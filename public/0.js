(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[0],{

/***/ "./node_modules/filepond-plugin-file-encode/dist/filepond-plugin-file-encode.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/filepond-plugin-file-encode/dist/filepond-plugin-file-encode.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * FilePondPluginFileEncode 2.1.9\n * Licensed under MIT, https://opensource.org/licenses/MIT/\n * Please visit https://pqina.nl/filepond/ for details.\n */\n\n/* eslint-disable */\n\n(function(global, factory) {\n   true\n    ? (module.exports = factory())\n    : undefined;\n})(this, function() {\n  'use strict';\n\n  var DataURIWorker = function DataURIWorker() {\n    // route messages\n    self.onmessage = function(e) {\n      convert(e.data.message, function(response) {\n        self.postMessage({ id: e.data.id, message: response });\n      });\n    };\n\n    // convert file to data uri\n    var convert = function convert(options, cb) {\n      var file = options.file;\n\n      var reader = new FileReader();\n      reader.onloadend = function() {\n        cb(reader.result.replace('data:', '').replace(/^.+,/, ''));\n      };\n      reader.readAsDataURL(file);\n    };\n  };\n\n  var plugin = function plugin(_ref) {\n    var addFilter = _ref.addFilter,\n      utils = _ref.utils;\n\n    // get quick reference to Type utils\n    var Type = utils.Type,\n      createWorker = utils.createWorker,\n      createRoute = utils.createRoute,\n      isFile = utils.isFile;\n\n    var encode = function encode(_ref2) {\n      var name = _ref2.name,\n        file = _ref2.file;\n      return new Promise(function(resolve) {\n        var worker = createWorker(DataURIWorker);\n        worker.post({ file: file }, function(data) {\n          resolve({ name: name, data: data });\n          worker.terminate();\n        });\n      });\n    };\n\n    // holds base64 strings till can be moved to item\n    var base64Cache = [];\n    addFilter('DID_CREATE_ITEM', function(item, _ref3) {\n      var query = _ref3.query;\n\n      if (!query('GET_ALLOW_FILE_ENCODE')) return;\n\n      item.extend('getFileEncodeBase64String', function() {\n        return base64Cache[item.id] && base64Cache[item.id].data;\n      });\n      item.extend('getFileEncodeDataURL', function() {\n        return 'data:'\n          .concat(item.fileType, ';base64,')\n          .concat(base64Cache[item.id].data);\n      });\n    });\n\n    addFilter('SHOULD_PREPARE_OUTPUT', function(shouldPrepareOutput, _ref4) {\n      var query = _ref4.query;\n      return new Promise(function(resolve) {\n        resolve(query('GET_ALLOW_FILE_ENCODE'));\n      });\n    });\n\n    addFilter('COMPLETE_PREPARE_OUTPUT', function(file, _ref5) {\n      var item = _ref5.item,\n        query = _ref5.query;\n      return new Promise(function(resolve) {\n        // if it's not a file or a list of files, continue\n        if (\n          !query('GET_ALLOW_FILE_ENCODE') ||\n          (!isFile(file) && !Array.isArray(file))\n        ) {\n          return resolve(file);\n        }\n\n        // store metadata settings for this cache\n        base64Cache[item.id] = {\n          metadata: item.getMetadata(),\n          data: null\n        };\n\n        // wait for all file items to be encoded\n        Promise.all(\n          (file instanceof Blob ? [{ name: null, file: file }] : file).map(\n            encode\n          )\n        ).then(function(dataItems) {\n          base64Cache[item.id].data =\n            file instanceof Blob ? dataItems[0].data : dataItems;\n          resolve(file);\n        });\n      });\n    });\n\n    // called for each view that is created right after the 'create' method\n    addFilter('CREATE_VIEW', function(viewAPI) {\n      // get reference to created view\n      var is = viewAPI.is,\n        view = viewAPI.view,\n        query = viewAPI.query;\n\n      // only hook up to item view\n      if (!is('file-wrapper') || !query('GET_ALLOW_FILE_ENCODE')) {\n        return;\n      }\n\n      view.registerWriter(\n        createRoute({\n          DID_PREPARE_OUTPUT: function DID_PREPARE_OUTPUT(_ref6) {\n            var root = _ref6.root,\n              action = _ref6.action;\n\n            // only do this if is not uploading async\n            if (query('IS_ASYNC')) {\n              return;\n            }\n\n            var item = query('GET_ITEM', action.id);\n            if (!item) return;\n\n            // extract base64 string\n            var cache = base64Cache[item.id];\n            var metadata = cache.metadata;\n            var data = cache.data;\n\n            // create JSON string from encoded data\n            var value = JSON.stringify({\n              id: item.id,\n              name: item.file.name,\n              type: item.file.type,\n              size: item.file.size,\n              metadata: metadata,\n              data: data\n            });\n\n            // for filepond < 4.13.0\n            if (root.ref.data) {\n              root.ref.data.value = value;\n            }\n            // newer versions\n            else {\n              root.dispatch('DID_DEFINE_VALUE', {\n                id: item.id,\n                value: value\n              });\n            }\n          },\n          DID_REMOVE_ITEM: function DID_REMOVE_ITEM(_ref7) {\n            var action = _ref7.action;\n            var item = query('GET_ITEM', action.id);\n            if (!item) return;\n            delete base64Cache[item.id];\n          }\n        })\n      );\n    });\n\n    return {\n      options: {\n        // Enable or disable file encoding\n        allowFileEncode: [true, Type.BOOLEAN]\n      }\n    };\n  };\n\n  // fire pluginloaded event if running in browser, this allows registering the plugin when using async script tags\n  var isBrowser =\n    typeof window !== 'undefined' && typeof window.document !== 'undefined';\n  if (isBrowser) {\n    document.dispatchEvent(\n      new CustomEvent('FilePond:pluginloaded', { detail: plugin })\n    );\n  }\n\n  return plugin;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmlsZXBvbmQtcGx1Z2luLWZpbGUtZW5jb2RlL2Rpc3QvZmlsZXBvbmQtcGx1Z2luLWZpbGUtZW5jb2RlLmpzPzc0ZTYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEVBQUUsS0FBNEQ7QUFDOUQ7QUFDQSxNQUFNLFNBRzhDO0FBQ3BELENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixtQ0FBbUM7QUFDN0QsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGFBQWE7QUFDbEMsbUJBQW1CLHlCQUF5QjtBQUM1QztBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9DQUFvQyx5QkFBeUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxpQkFBaUI7QUFDakU7QUFDQTs7QUFFQTtBQUNBLENBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmlsZXBvbmQtcGx1Z2luLWZpbGUtZW5jb2RlL2Rpc3QvZmlsZXBvbmQtcGx1Z2luLWZpbGUtZW5jb2RlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBGaWxlUG9uZFBsdWdpbkZpbGVFbmNvZGUgMi4xLjlcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCwgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQvXG4gKiBQbGVhc2UgdmlzaXQgaHR0cHM6Ly9wcWluYS5ubC9maWxlcG9uZC8gZm9yIGRldGFpbHMuXG4gKi9cblxuLyogZXNsaW50LWRpc2FibGUgKi9cblxuKGZ1bmN0aW9uKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICA/IChtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSlcbiAgICA6IHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZFxuICAgID8gZGVmaW5lKGZhY3RvcnkpXG4gICAgOiAoKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmKSxcbiAgICAgIChnbG9iYWwuRmlsZVBvbmRQbHVnaW5GaWxlRW5jb2RlID0gZmFjdG9yeSgpKSk7XG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBEYXRhVVJJV29ya2VyID0gZnVuY3Rpb24gRGF0YVVSSVdvcmtlcigpIHtcbiAgICAvLyByb3V0ZSBtZXNzYWdlc1xuICAgIHNlbGYub25tZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuICAgICAgY29udmVydChlLmRhdGEubWVzc2FnZSwgZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgc2VsZi5wb3N0TWVzc2FnZSh7IGlkOiBlLmRhdGEuaWQsIG1lc3NhZ2U6IHJlc3BvbnNlIH0pO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIGNvbnZlcnQgZmlsZSB0byBkYXRhIHVyaVxuICAgIHZhciBjb252ZXJ0ID0gZnVuY3Rpb24gY29udmVydChvcHRpb25zLCBjYikge1xuICAgICAgdmFyIGZpbGUgPSBvcHRpb25zLmZpbGU7XG5cbiAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgcmVhZGVyLm9ubG9hZGVuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjYihyZWFkZXIucmVzdWx0LnJlcGxhY2UoJ2RhdGE6JywgJycpLnJlcGxhY2UoL14uKywvLCAnJykpO1xuICAgICAgfTtcbiAgICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGZpbGUpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIHBsdWdpbiA9IGZ1bmN0aW9uIHBsdWdpbihfcmVmKSB7XG4gICAgdmFyIGFkZEZpbHRlciA9IF9yZWYuYWRkRmlsdGVyLFxuICAgICAgdXRpbHMgPSBfcmVmLnV0aWxzO1xuXG4gICAgLy8gZ2V0IHF1aWNrIHJlZmVyZW5jZSB0byBUeXBlIHV0aWxzXG4gICAgdmFyIFR5cGUgPSB1dGlscy5UeXBlLFxuICAgICAgY3JlYXRlV29ya2VyID0gdXRpbHMuY3JlYXRlV29ya2VyLFxuICAgICAgY3JlYXRlUm91dGUgPSB1dGlscy5jcmVhdGVSb3V0ZSxcbiAgICAgIGlzRmlsZSA9IHV0aWxzLmlzRmlsZTtcblxuICAgIHZhciBlbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUoX3JlZjIpIHtcbiAgICAgIHZhciBuYW1lID0gX3JlZjIubmFtZSxcbiAgICAgICAgZmlsZSA9IF9yZWYyLmZpbGU7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICB2YXIgd29ya2VyID0gY3JlYXRlV29ya2VyKERhdGFVUklXb3JrZXIpO1xuICAgICAgICB3b3JrZXIucG9zdCh7IGZpbGU6IGZpbGUgfSwgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgIHJlc29sdmUoeyBuYW1lOiBuYW1lLCBkYXRhOiBkYXRhIH0pO1xuICAgICAgICAgIHdvcmtlci50ZXJtaW5hdGUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gaG9sZHMgYmFzZTY0IHN0cmluZ3MgdGlsbCBjYW4gYmUgbW92ZWQgdG8gaXRlbVxuICAgIHZhciBiYXNlNjRDYWNoZSA9IFtdO1xuICAgIGFkZEZpbHRlcignRElEX0NSRUFURV9JVEVNJywgZnVuY3Rpb24oaXRlbSwgX3JlZjMpIHtcbiAgICAgIHZhciBxdWVyeSA9IF9yZWYzLnF1ZXJ5O1xuXG4gICAgICBpZiAoIXF1ZXJ5KCdHRVRfQUxMT1dfRklMRV9FTkNPREUnKSkgcmV0dXJuO1xuXG4gICAgICBpdGVtLmV4dGVuZCgnZ2V0RmlsZUVuY29kZUJhc2U2NFN0cmluZycsIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gYmFzZTY0Q2FjaGVbaXRlbS5pZF0gJiYgYmFzZTY0Q2FjaGVbaXRlbS5pZF0uZGF0YTtcbiAgICAgIH0pO1xuICAgICAgaXRlbS5leHRlbmQoJ2dldEZpbGVFbmNvZGVEYXRhVVJMJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAnZGF0YTonXG4gICAgICAgICAgLmNvbmNhdChpdGVtLmZpbGVUeXBlLCAnO2Jhc2U2NCwnKVxuICAgICAgICAgIC5jb25jYXQoYmFzZTY0Q2FjaGVbaXRlbS5pZF0uZGF0YSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGFkZEZpbHRlcignU0hPVUxEX1BSRVBBUkVfT1VUUFVUJywgZnVuY3Rpb24oc2hvdWxkUHJlcGFyZU91dHB1dCwgX3JlZjQpIHtcbiAgICAgIHZhciBxdWVyeSA9IF9yZWY0LnF1ZXJ5O1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgcmVzb2x2ZShxdWVyeSgnR0VUX0FMTE9XX0ZJTEVfRU5DT0RFJykpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBhZGRGaWx0ZXIoJ0NPTVBMRVRFX1BSRVBBUkVfT1VUUFVUJywgZnVuY3Rpb24oZmlsZSwgX3JlZjUpIHtcbiAgICAgIHZhciBpdGVtID0gX3JlZjUuaXRlbSxcbiAgICAgICAgcXVlcnkgPSBfcmVmNS5xdWVyeTtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgIC8vIGlmIGl0J3Mgbm90IGEgZmlsZSBvciBhIGxpc3Qgb2YgZmlsZXMsIGNvbnRpbnVlXG4gICAgICAgIGlmIChcbiAgICAgICAgICAhcXVlcnkoJ0dFVF9BTExPV19GSUxFX0VOQ09ERScpIHx8XG4gICAgICAgICAgKCFpc0ZpbGUoZmlsZSkgJiYgIUFycmF5LmlzQXJyYXkoZmlsZSkpXG4gICAgICAgICkge1xuICAgICAgICAgIHJldHVybiByZXNvbHZlKGZpbGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc3RvcmUgbWV0YWRhdGEgc2V0dGluZ3MgZm9yIHRoaXMgY2FjaGVcbiAgICAgICAgYmFzZTY0Q2FjaGVbaXRlbS5pZF0gPSB7XG4gICAgICAgICAgbWV0YWRhdGE6IGl0ZW0uZ2V0TWV0YWRhdGEoKSxcbiAgICAgICAgICBkYXRhOiBudWxsXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gd2FpdCBmb3IgYWxsIGZpbGUgaXRlbXMgdG8gYmUgZW5jb2RlZFxuICAgICAgICBQcm9taXNlLmFsbChcbiAgICAgICAgICAoZmlsZSBpbnN0YW5jZW9mIEJsb2IgPyBbeyBuYW1lOiBudWxsLCBmaWxlOiBmaWxlIH1dIDogZmlsZSkubWFwKFxuICAgICAgICAgICAgZW5jb2RlXG4gICAgICAgICAgKVxuICAgICAgICApLnRoZW4oZnVuY3Rpb24oZGF0YUl0ZW1zKSB7XG4gICAgICAgICAgYmFzZTY0Q2FjaGVbaXRlbS5pZF0uZGF0YSA9XG4gICAgICAgICAgICBmaWxlIGluc3RhbmNlb2YgQmxvYiA/IGRhdGFJdGVtc1swXS5kYXRhIDogZGF0YUl0ZW1zO1xuICAgICAgICAgIHJlc29sdmUoZmlsZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyBjYWxsZWQgZm9yIGVhY2ggdmlldyB0aGF0IGlzIGNyZWF0ZWQgcmlnaHQgYWZ0ZXIgdGhlICdjcmVhdGUnIG1ldGhvZFxuICAgIGFkZEZpbHRlcignQ1JFQVRFX1ZJRVcnLCBmdW5jdGlvbih2aWV3QVBJKSB7XG4gICAgICAvLyBnZXQgcmVmZXJlbmNlIHRvIGNyZWF0ZWQgdmlld1xuICAgICAgdmFyIGlzID0gdmlld0FQSS5pcyxcbiAgICAgICAgdmlldyA9IHZpZXdBUEkudmlldyxcbiAgICAgICAgcXVlcnkgPSB2aWV3QVBJLnF1ZXJ5O1xuXG4gICAgICAvLyBvbmx5IGhvb2sgdXAgdG8gaXRlbSB2aWV3XG4gICAgICBpZiAoIWlzKCdmaWxlLXdyYXBwZXInKSB8fCAhcXVlcnkoJ0dFVF9BTExPV19GSUxFX0VOQ09ERScpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmlldy5yZWdpc3RlcldyaXRlcihcbiAgICAgICAgY3JlYXRlUm91dGUoe1xuICAgICAgICAgIERJRF9QUkVQQVJFX09VVFBVVDogZnVuY3Rpb24gRElEX1BSRVBBUkVfT1VUUFVUKF9yZWY2KSB7XG4gICAgICAgICAgICB2YXIgcm9vdCA9IF9yZWY2LnJvb3QsXG4gICAgICAgICAgICAgIGFjdGlvbiA9IF9yZWY2LmFjdGlvbjtcblxuICAgICAgICAgICAgLy8gb25seSBkbyB0aGlzIGlmIGlzIG5vdCB1cGxvYWRpbmcgYXN5bmNcbiAgICAgICAgICAgIGlmIChxdWVyeSgnSVNfQVNZTkMnKSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpdGVtID0gcXVlcnkoJ0dFVF9JVEVNJywgYWN0aW9uLmlkKTtcbiAgICAgICAgICAgIGlmICghaXRlbSkgcmV0dXJuO1xuXG4gICAgICAgICAgICAvLyBleHRyYWN0IGJhc2U2NCBzdHJpbmdcbiAgICAgICAgICAgIHZhciBjYWNoZSA9IGJhc2U2NENhY2hlW2l0ZW0uaWRdO1xuICAgICAgICAgICAgdmFyIG1ldGFkYXRhID0gY2FjaGUubWV0YWRhdGE7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IGNhY2hlLmRhdGE7XG5cbiAgICAgICAgICAgIC8vIGNyZWF0ZSBKU09OIHN0cmluZyBmcm9tIGVuY29kZWQgZGF0YVxuICAgICAgICAgICAgdmFyIHZhbHVlID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICBpZDogaXRlbS5pZCxcbiAgICAgICAgICAgICAgbmFtZTogaXRlbS5maWxlLm5hbWUsXG4gICAgICAgICAgICAgIHR5cGU6IGl0ZW0uZmlsZS50eXBlLFxuICAgICAgICAgICAgICBzaXplOiBpdGVtLmZpbGUuc2l6ZSxcbiAgICAgICAgICAgICAgbWV0YWRhdGE6IG1ldGFkYXRhLFxuICAgICAgICAgICAgICBkYXRhOiBkYXRhXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gZm9yIGZpbGVwb25kIDwgNC4xMy4wXG4gICAgICAgICAgICBpZiAocm9vdC5yZWYuZGF0YSkge1xuICAgICAgICAgICAgICByb290LnJlZi5kYXRhLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBuZXdlciB2ZXJzaW9uc1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHJvb3QuZGlzcGF0Y2goJ0RJRF9ERUZJTkVfVkFMVUUnLCB7XG4gICAgICAgICAgICAgICAgaWQ6IGl0ZW0uaWQsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgRElEX1JFTU9WRV9JVEVNOiBmdW5jdGlvbiBESURfUkVNT1ZFX0lURU0oX3JlZjcpIHtcbiAgICAgICAgICAgIHZhciBhY3Rpb24gPSBfcmVmNy5hY3Rpb247XG4gICAgICAgICAgICB2YXIgaXRlbSA9IHF1ZXJ5KCdHRVRfSVRFTScsIGFjdGlvbi5pZCk7XG4gICAgICAgICAgICBpZiAoIWl0ZW0pIHJldHVybjtcbiAgICAgICAgICAgIGRlbGV0ZSBiYXNlNjRDYWNoZVtpdGVtLmlkXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgLy8gRW5hYmxlIG9yIGRpc2FibGUgZmlsZSBlbmNvZGluZ1xuICAgICAgICBhbGxvd0ZpbGVFbmNvZGU6IFt0cnVlLCBUeXBlLkJPT0xFQU5dXG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICAvLyBmaXJlIHBsdWdpbmxvYWRlZCBldmVudCBpZiBydW5uaW5nIGluIGJyb3dzZXIsIHRoaXMgYWxsb3dzIHJlZ2lzdGVyaW5nIHRoZSBwbHVnaW4gd2hlbiB1c2luZyBhc3luYyBzY3JpcHQgdGFnc1xuICB2YXIgaXNCcm93c2VyID1cbiAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcbiAgaWYgKGlzQnJvd3Nlcikge1xuICAgIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQoXG4gICAgICBuZXcgQ3VzdG9tRXZlbnQoJ0ZpbGVQb25kOnBsdWdpbmxvYWRlZCcsIHsgZGV0YWlsOiBwbHVnaW4gfSlcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIHBsdWdpbjtcbn0pO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/filepond-plugin-file-encode/dist/filepond-plugin-file-encode.js\n");

/***/ }),

/***/ "./node_modules/filepond-plugin-file-validate-size/dist/filepond-plugin-file-validate-size.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/filepond-plugin-file-validate-size/dist/filepond-plugin-file-validate-size.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * FilePondPluginFileValidateSize 2.2.1\n * Licensed under MIT, https://opensource.org/licenses/MIT/\n * Please visit https://pqina.nl/filepond/ for details.\n */\n\n/* eslint-disable */\n\n(function(global, factory) {\n   true\n    ? (module.exports = factory())\n    : undefined;\n})(this, function() {\n  'use strict';\n\n  var plugin = function plugin(_ref) {\n    var addFilter = _ref.addFilter,\n      utils = _ref.utils;\n    // get quick reference to Type utils\n    var Type = utils.Type,\n      replaceInString = utils.replaceInString,\n      toNaturalFileSize = utils.toNaturalFileSize;\n\n    // filtering if an item is allowed in hopper\n    addFilter('ALLOW_HOPPER_ITEM', function(file, _ref2) {\n      var query = _ref2.query;\n      if (!query('GET_ALLOW_FILE_SIZE_VALIDATION')) {\n        return true;\n      }\n\n      var sizeMax = query('GET_MAX_FILE_SIZE');\n      if (sizeMax !== null && file.size >= sizeMax) {\n        return false;\n      }\n\n      var sizeMin = query('GET_MIN_FILE_SIZE');\n      if (sizeMin !== null && file.size <= sizeMin) {\n        return false;\n      }\n\n      return true;\n    });\n\n    // called for each file that is loaded\n    // right before it is set to the item state\n    // should return a promise\n    addFilter('LOAD_FILE', function(file, _ref3) {\n      var query = _ref3.query;\n      return new Promise(function(resolve, reject) {\n        // if not allowed, all fine, exit\n        if (!query('GET_ALLOW_FILE_SIZE_VALIDATION')) {\n          return resolve(file);\n        }\n\n        // check if file should be filtered\n        var fileFilter = query('GET_FILE_VALIDATE_SIZE_FILTER');\n        if (fileFilter && !fileFilter(file)) {\n          return resolve(file);\n        }\n\n        // reject or resolve based on file size\n        var sizeMax = query('GET_MAX_FILE_SIZE');\n        if (sizeMax !== null && file.size >= sizeMax) {\n          reject({\n            status: {\n              main: query('GET_LABEL_MAX_FILE_SIZE_EXCEEDED'),\n              sub: replaceInString(query('GET_LABEL_MAX_FILE_SIZE'), {\n                filesize: toNaturalFileSize(sizeMax)\n              })\n            }\n          });\n\n          return;\n        }\n\n        // reject or resolve based on file size\n        var sizeMin = query('GET_MIN_FILE_SIZE');\n        if (sizeMin !== null && file.size <= sizeMin) {\n          reject({\n            status: {\n              main: query('GET_LABEL_MIN_FILE_SIZE_EXCEEDED'),\n              sub: replaceInString(query('GET_LABEL_MIN_FILE_SIZE'), {\n                filesize: toNaturalFileSize(sizeMin)\n              })\n            }\n          });\n\n          return;\n        }\n\n        // returns the current option value\n        var totalSizeMax = query('GET_MAX_TOTAL_FILE_SIZE');\n        if (totalSizeMax !== null) {\n          // get the current total file size\n          var currentTotalSize = query('GET_ACTIVE_ITEMS').reduce(function(\n            total,\n            item\n          ) {\n            return total + item.fileSize;\n          },\n          0);\n\n          // get the size of the new file\n          if (currentTotalSize > totalSizeMax) {\n            reject({\n              status: {\n                main: query('GET_LABEL_MAX_TOTAL_FILE_SIZE_EXCEEDED'),\n\n                sub: replaceInString(query('GET_LABEL_MAX_TOTAL_FILE_SIZE'), {\n                  filesize: toNaturalFileSize(totalSizeMax)\n                })\n              }\n            });\n\n            return;\n          }\n        }\n\n        // file is fine, let's pass it back\n        resolve(file);\n      });\n    });\n\n    return {\n      options: {\n        // Enable or disable file type validation\n        allowFileSizeValidation: [true, Type.BOOLEAN],\n\n        // Max individual file size in bytes\n        maxFileSize: [null, Type.INT],\n\n        // Min individual file size in bytes\n        minFileSize: [null, Type.INT],\n\n        // Max total file size in bytes\n        maxTotalFileSize: [null, Type.INT],\n\n        // Filter the files that need to be validated for size\n        fileValidateSizeFilter: [null, Type.FUNCTION],\n\n        // error labels\n        labelMinFileSizeExceeded: ['File is too small', Type.STRING],\n        labelMinFileSize: ['Minimum file size is {filesize}', Type.STRING],\n\n        labelMaxFileSizeExceeded: ['File is too large', Type.STRING],\n        labelMaxFileSize: ['Maximum file size is {filesize}', Type.STRING],\n\n        labelMaxTotalFileSizeExceeded: [\n          'Maximum total size exceeded',\n          Type.STRING\n        ],\n\n        labelMaxTotalFileSize: [\n          'Maximum total file size is {filesize}',\n          Type.STRING\n        ]\n      }\n    };\n  };\n\n  // fire pluginloaded event if running in browser, this allows registering the plugin when using async script tags\n  var isBrowser =\n    typeof window !== 'undefined' && typeof window.document !== 'undefined';\n  if (isBrowser) {\n    document.dispatchEvent(\n      new CustomEvent('FilePond:pluginloaded', { detail: plugin })\n    );\n  }\n\n  return plugin;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmlsZXBvbmQtcGx1Z2luLWZpbGUtdmFsaWRhdGUtc2l6ZS9kaXN0L2ZpbGVwb25kLXBsdWdpbi1maWxlLXZhbGlkYXRlLXNpemUuanM/M2I5NiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsRUFBRSxLQUE0RDtBQUM5RDtBQUNBLE1BQU0sU0FHb0Q7QUFDMUQsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsV0FBVzs7QUFFWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxXQUFXOztBQUVYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrREFBa0QsU0FBUzs7QUFFM0Q7QUFDQSxrREFBa0QsU0FBUzs7QUFFM0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsaUJBQWlCO0FBQ2pFO0FBQ0E7O0FBRUE7QUFDQSxDQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2ZpbGVwb25kLXBsdWdpbi1maWxlLXZhbGlkYXRlLXNpemUvZGlzdC9maWxlcG9uZC1wbHVnaW4tZmlsZS12YWxpZGF0ZS1zaXplLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBGaWxlUG9uZFBsdWdpbkZpbGVWYWxpZGF0ZVNpemUgMi4yLjFcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCwgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQvXG4gKiBQbGVhc2UgdmlzaXQgaHR0cHM6Ly9wcWluYS5ubC9maWxlcG9uZC8gZm9yIGRldGFpbHMuXG4gKi9cblxuLyogZXNsaW50LWRpc2FibGUgKi9cblxuKGZ1bmN0aW9uKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICA/IChtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSlcbiAgICA6IHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZFxuICAgID8gZGVmaW5lKGZhY3RvcnkpXG4gICAgOiAoKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmKSxcbiAgICAgIChnbG9iYWwuRmlsZVBvbmRQbHVnaW5GaWxlVmFsaWRhdGVTaXplID0gZmFjdG9yeSgpKSk7XG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBwbHVnaW4gPSBmdW5jdGlvbiBwbHVnaW4oX3JlZikge1xuICAgIHZhciBhZGRGaWx0ZXIgPSBfcmVmLmFkZEZpbHRlcixcbiAgICAgIHV0aWxzID0gX3JlZi51dGlscztcbiAgICAvLyBnZXQgcXVpY2sgcmVmZXJlbmNlIHRvIFR5cGUgdXRpbHNcbiAgICB2YXIgVHlwZSA9IHV0aWxzLlR5cGUsXG4gICAgICByZXBsYWNlSW5TdHJpbmcgPSB1dGlscy5yZXBsYWNlSW5TdHJpbmcsXG4gICAgICB0b05hdHVyYWxGaWxlU2l6ZSA9IHV0aWxzLnRvTmF0dXJhbEZpbGVTaXplO1xuXG4gICAgLy8gZmlsdGVyaW5nIGlmIGFuIGl0ZW0gaXMgYWxsb3dlZCBpbiBob3BwZXJcbiAgICBhZGRGaWx0ZXIoJ0FMTE9XX0hPUFBFUl9JVEVNJywgZnVuY3Rpb24oZmlsZSwgX3JlZjIpIHtcbiAgICAgIHZhciBxdWVyeSA9IF9yZWYyLnF1ZXJ5O1xuICAgICAgaWYgKCFxdWVyeSgnR0VUX0FMTE9XX0ZJTEVfU0laRV9WQUxJREFUSU9OJykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBzaXplTWF4ID0gcXVlcnkoJ0dFVF9NQVhfRklMRV9TSVpFJyk7XG4gICAgICBpZiAoc2l6ZU1heCAhPT0gbnVsbCAmJiBmaWxlLnNpemUgPj0gc2l6ZU1heCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBzaXplTWluID0gcXVlcnkoJ0dFVF9NSU5fRklMRV9TSVpFJyk7XG4gICAgICBpZiAoc2l6ZU1pbiAhPT0gbnVsbCAmJiBmaWxlLnNpemUgPD0gc2l6ZU1pbikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuXG4gICAgLy8gY2FsbGVkIGZvciBlYWNoIGZpbGUgdGhhdCBpcyBsb2FkZWRcbiAgICAvLyByaWdodCBiZWZvcmUgaXQgaXMgc2V0IHRvIHRoZSBpdGVtIHN0YXRlXG4gICAgLy8gc2hvdWxkIHJldHVybiBhIHByb21pc2VcbiAgICBhZGRGaWx0ZXIoJ0xPQURfRklMRScsIGZ1bmN0aW9uKGZpbGUsIF9yZWYzKSB7XG4gICAgICB2YXIgcXVlcnkgPSBfcmVmMy5xdWVyeTtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgLy8gaWYgbm90IGFsbG93ZWQsIGFsbCBmaW5lLCBleGl0XG4gICAgICAgIGlmICghcXVlcnkoJ0dFVF9BTExPV19GSUxFX1NJWkVfVkFMSURBVElPTicpKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUoZmlsZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGVjayBpZiBmaWxlIHNob3VsZCBiZSBmaWx0ZXJlZFxuICAgICAgICB2YXIgZmlsZUZpbHRlciA9IHF1ZXJ5KCdHRVRfRklMRV9WQUxJREFURV9TSVpFX0ZJTFRFUicpO1xuICAgICAgICBpZiAoZmlsZUZpbHRlciAmJiAhZmlsZUZpbHRlcihmaWxlKSkge1xuICAgICAgICAgIHJldHVybiByZXNvbHZlKGZpbGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVqZWN0IG9yIHJlc29sdmUgYmFzZWQgb24gZmlsZSBzaXplXG4gICAgICAgIHZhciBzaXplTWF4ID0gcXVlcnkoJ0dFVF9NQVhfRklMRV9TSVpFJyk7XG4gICAgICAgIGlmIChzaXplTWF4ICE9PSBudWxsICYmIGZpbGUuc2l6ZSA+PSBzaXplTWF4KSB7XG4gICAgICAgICAgcmVqZWN0KHtcbiAgICAgICAgICAgIHN0YXR1czoge1xuICAgICAgICAgICAgICBtYWluOiBxdWVyeSgnR0VUX0xBQkVMX01BWF9GSUxFX1NJWkVfRVhDRUVERUQnKSxcbiAgICAgICAgICAgICAgc3ViOiByZXBsYWNlSW5TdHJpbmcocXVlcnkoJ0dFVF9MQUJFTF9NQVhfRklMRV9TSVpFJyksIHtcbiAgICAgICAgICAgICAgICBmaWxlc2l6ZTogdG9OYXR1cmFsRmlsZVNpemUoc2l6ZU1heClcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlamVjdCBvciByZXNvbHZlIGJhc2VkIG9uIGZpbGUgc2l6ZVxuICAgICAgICB2YXIgc2l6ZU1pbiA9IHF1ZXJ5KCdHRVRfTUlOX0ZJTEVfU0laRScpO1xuICAgICAgICBpZiAoc2l6ZU1pbiAhPT0gbnVsbCAmJiBmaWxlLnNpemUgPD0gc2l6ZU1pbikge1xuICAgICAgICAgIHJlamVjdCh7XG4gICAgICAgICAgICBzdGF0dXM6IHtcbiAgICAgICAgICAgICAgbWFpbjogcXVlcnkoJ0dFVF9MQUJFTF9NSU5fRklMRV9TSVpFX0VYQ0VFREVEJyksXG4gICAgICAgICAgICAgIHN1YjogcmVwbGFjZUluU3RyaW5nKHF1ZXJ5KCdHRVRfTEFCRUxfTUlOX0ZJTEVfU0laRScpLCB7XG4gICAgICAgICAgICAgICAgZmlsZXNpemU6IHRvTmF0dXJhbEZpbGVTaXplKHNpemVNaW4pXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXR1cm5zIHRoZSBjdXJyZW50IG9wdGlvbiB2YWx1ZVxuICAgICAgICB2YXIgdG90YWxTaXplTWF4ID0gcXVlcnkoJ0dFVF9NQVhfVE9UQUxfRklMRV9TSVpFJyk7XG4gICAgICAgIGlmICh0b3RhbFNpemVNYXggIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBnZXQgdGhlIGN1cnJlbnQgdG90YWwgZmlsZSBzaXplXG4gICAgICAgICAgdmFyIGN1cnJlbnRUb3RhbFNpemUgPSBxdWVyeSgnR0VUX0FDVElWRV9JVEVNUycpLnJlZHVjZShmdW5jdGlvbihcbiAgICAgICAgICAgIHRvdGFsLFxuICAgICAgICAgICAgaXRlbVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIHRvdGFsICsgaXRlbS5maWxlU2l6ZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIDApO1xuXG4gICAgICAgICAgLy8gZ2V0IHRoZSBzaXplIG9mIHRoZSBuZXcgZmlsZVxuICAgICAgICAgIGlmIChjdXJyZW50VG90YWxTaXplID4gdG90YWxTaXplTWF4KSB7XG4gICAgICAgICAgICByZWplY3Qoe1xuICAgICAgICAgICAgICBzdGF0dXM6IHtcbiAgICAgICAgICAgICAgICBtYWluOiBxdWVyeSgnR0VUX0xBQkVMX01BWF9UT1RBTF9GSUxFX1NJWkVfRVhDRUVERUQnKSxcblxuICAgICAgICAgICAgICAgIHN1YjogcmVwbGFjZUluU3RyaW5nKHF1ZXJ5KCdHRVRfTEFCRUxfTUFYX1RPVEFMX0ZJTEVfU0laRScpLCB7XG4gICAgICAgICAgICAgICAgICBmaWxlc2l6ZTogdG9OYXR1cmFsRmlsZVNpemUodG90YWxTaXplTWF4KVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmlsZSBpcyBmaW5lLCBsZXQncyBwYXNzIGl0IGJhY2tcbiAgICAgICAgcmVzb2x2ZShmaWxlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgLy8gRW5hYmxlIG9yIGRpc2FibGUgZmlsZSB0eXBlIHZhbGlkYXRpb25cbiAgICAgICAgYWxsb3dGaWxlU2l6ZVZhbGlkYXRpb246IFt0cnVlLCBUeXBlLkJPT0xFQU5dLFxuXG4gICAgICAgIC8vIE1heCBpbmRpdmlkdWFsIGZpbGUgc2l6ZSBpbiBieXRlc1xuICAgICAgICBtYXhGaWxlU2l6ZTogW251bGwsIFR5cGUuSU5UXSxcblxuICAgICAgICAvLyBNaW4gaW5kaXZpZHVhbCBmaWxlIHNpemUgaW4gYnl0ZXNcbiAgICAgICAgbWluRmlsZVNpemU6IFtudWxsLCBUeXBlLklOVF0sXG5cbiAgICAgICAgLy8gTWF4IHRvdGFsIGZpbGUgc2l6ZSBpbiBieXRlc1xuICAgICAgICBtYXhUb3RhbEZpbGVTaXplOiBbbnVsbCwgVHlwZS5JTlRdLFxuXG4gICAgICAgIC8vIEZpbHRlciB0aGUgZmlsZXMgdGhhdCBuZWVkIHRvIGJlIHZhbGlkYXRlZCBmb3Igc2l6ZVxuICAgICAgICBmaWxlVmFsaWRhdGVTaXplRmlsdGVyOiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG5cbiAgICAgICAgLy8gZXJyb3IgbGFiZWxzXG4gICAgICAgIGxhYmVsTWluRmlsZVNpemVFeGNlZWRlZDogWydGaWxlIGlzIHRvbyBzbWFsbCcsIFR5cGUuU1RSSU5HXSxcbiAgICAgICAgbGFiZWxNaW5GaWxlU2l6ZTogWydNaW5pbXVtIGZpbGUgc2l6ZSBpcyB7ZmlsZXNpemV9JywgVHlwZS5TVFJJTkddLFxuXG4gICAgICAgIGxhYmVsTWF4RmlsZVNpemVFeGNlZWRlZDogWydGaWxlIGlzIHRvbyBsYXJnZScsIFR5cGUuU1RSSU5HXSxcbiAgICAgICAgbGFiZWxNYXhGaWxlU2l6ZTogWydNYXhpbXVtIGZpbGUgc2l6ZSBpcyB7ZmlsZXNpemV9JywgVHlwZS5TVFJJTkddLFxuXG4gICAgICAgIGxhYmVsTWF4VG90YWxGaWxlU2l6ZUV4Y2VlZGVkOiBbXG4gICAgICAgICAgJ01heGltdW0gdG90YWwgc2l6ZSBleGNlZWRlZCcsXG4gICAgICAgICAgVHlwZS5TVFJJTkdcbiAgICAgICAgXSxcblxuICAgICAgICBsYWJlbE1heFRvdGFsRmlsZVNpemU6IFtcbiAgICAgICAgICAnTWF4aW11bSB0b3RhbCBmaWxlIHNpemUgaXMge2ZpbGVzaXplfScsXG4gICAgICAgICAgVHlwZS5TVFJJTkdcbiAgICAgICAgXVxuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgLy8gZmlyZSBwbHVnaW5sb2FkZWQgZXZlbnQgaWYgcnVubmluZyBpbiBicm93c2VyLCB0aGlzIGFsbG93cyByZWdpc3RlcmluZyB0aGUgcGx1Z2luIHdoZW4gdXNpbmcgYXN5bmMgc2NyaXB0IHRhZ3NcbiAgdmFyIGlzQnJvd3NlciA9XG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG4gIGlmIChpc0Jyb3dzZXIpIHtcbiAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KFxuICAgICAgbmV3IEN1c3RvbUV2ZW50KCdGaWxlUG9uZDpwbHVnaW5sb2FkZWQnLCB7IGRldGFpbDogcGx1Z2luIH0pXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBwbHVnaW47XG59KTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/filepond-plugin-file-validate-size/dist/filepond-plugin-file-validate-size.js\n");

/***/ }),

/***/ "./node_modules/filepond-plugin-image-exif-orientation/dist/filepond-plugin-image-exif-orientation.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/filepond-plugin-image-exif-orientation/dist/filepond-plugin-image-exif-orientation.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * FilePondPluginImageExifOrientation 1.0.9\n * Licensed under MIT, https://opensource.org/licenses/MIT/\n * Please visit https://pqina.nl/filepond/ for details.\n */\n\n/* eslint-disable */\n\n(function(global, factory) {\n   true\n    ? (module.exports = factory())\n    : undefined;\n})(this, function() {\n  'use strict';\n\n  // test if file is of type image\n  var isJPEG = function isJPEG(file) {\n    return /^image\\/jpeg/.test(file.type);\n  };\n\n  var Marker = {\n    JPEG: 0xffd8,\n    APP1: 0xffe1,\n    EXIF: 0x45786966,\n    TIFF: 0x4949,\n    Orientation: 0x0112,\n    Unknown: 0xff00\n  };\n\n  var getUint16 = function getUint16(view, offset) {\n    var little =\n      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    return view.getUint16(offset, little);\n  };\n  var getUint32 = function getUint32(view, offset) {\n    var little =\n      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    return view.getUint32(offset, little);\n  };\n\n  var getImageOrientation = function getImageOrientation(file) {\n    return new Promise(function(resolve, reject) {\n      var reader = new FileReader();\n      reader.onload = function(e) {\n        var view = new DataView(e.target.result);\n\n        // Every JPEG file starts from binary value '0xFFD8'\n        if (getUint16(view, 0) !== Marker.JPEG) {\n          // This aint no JPEG\n          resolve(-1);\n          return;\n        }\n\n        var length = view.byteLength;\n        var offset = 2;\n\n        while (offset < length) {\n          var marker = getUint16(view, offset);\n          offset += 2;\n\n          // There's our APP1 Marker\n          if (marker === Marker.APP1) {\n            if (getUint32(view, (offset += 2)) !== Marker.EXIF) {\n              // no EXIF info defined\n              break;\n            }\n\n            // Get TIFF Header\n            var little = getUint16(view, (offset += 6)) === Marker.TIFF;\n            offset += getUint32(view, offset + 4, little);\n\n            var tags = getUint16(view, offset, little);\n            offset += 2;\n\n            for (var i = 0; i < tags; i++) {\n              // found the orientation tag\n              if (\n                getUint16(view, offset + i * 12, little) === Marker.Orientation\n              ) {\n                resolve(getUint16(view, offset + i * 12 + 8, little));\n\n                return;\n              }\n            }\n          } else if ((marker & Marker.Unknown) !== Marker.Unknown) {\n            // Invalid\n            break;\n          } else {\n            offset += getUint16(view, offset);\n          }\n        }\n\n        // Nothing found\n        resolve(-1);\n      };\n\n      // we don't need to read the entire file to get the orientation\n      reader.readAsArrayBuffer(file.slice(0, 64 * 1024));\n    });\n  };\n\n  var IS_BROWSER = (function() {\n    return (\n      typeof window !== 'undefined' && typeof window.document !== 'undefined'\n    );\n  })();\n  var isBrowser = function isBrowser() {\n    return IS_BROWSER;\n  };\n\n  // 2x1 pixel image 90CW rotated with orientation header\n  var testSrc =\n    'data:image/jpg;base64,/9j/4AAQSkZJRgABAQEASABIAAD/4QA6RXhpZgAATU0AKgAAAAgAAwESAAMAAAABAAYAAAEoAAMAAAABAAIAAAITAAMAAAABAAEAAAAAAAD/2wBDAP//////////////////////////////////////////////////////////////////////////////////////wAALCAABAAIBASIA/8QAJgABAAAAAAAAAAAAAAAAAAAAAxABAAAAAAAAAAAAAAAAAAAAAP/aAAgBAQAAPwBH/9k=';\n\n  // should correct orientation if is presented in landscape, in which case the browser doesn't autocorrect\n  var shouldCorrect = undefined;\n  var testImage = isBrowser() ? new Image() : {};\n  testImage.onload = function() {\n    return (shouldCorrect = testImage.naturalWidth > testImage.naturalHeight);\n  };\n  testImage.src = testSrc;\n\n  var shouldCorrectImageExifOrientation = function shouldCorrectImageExifOrientation() {\n    return shouldCorrect;\n  };\n\n  /**\n   * Read Image Orientation Plugin\n   */\n  var plugin = function plugin(_ref) {\n    var addFilter = _ref.addFilter,\n      utils = _ref.utils;\n    var Type = utils.Type,\n      isFile = utils.isFile;\n\n    // subscribe to file load and append required info\n    addFilter('DID_LOAD_ITEM', function(item, _ref2) {\n      var query = _ref2.query;\n      return new Promise(function(resolve, reject) {\n        // get file reference\n        var file = item.file;\n\n        // if this is not a jpeg image we are not interested\n        if (\n          !isFile(file) ||\n          !isJPEG(file) ||\n          !query('GET_ALLOW_IMAGE_EXIF_ORIENTATION') ||\n          !shouldCorrectImageExifOrientation()\n        ) {\n          // continue with the unaltered dataset\n          return resolve(item);\n        }\n\n        // get orientation from exif data\n        getImageOrientation(file).then(function(orientation) {\n          item.setMetadata('exif', { orientation: orientation });\n          resolve(item);\n        });\n      });\n    });\n\n    // Expose plugin options\n    return {\n      options: {\n        // Enable or disable image orientation reading\n        allowImageExifOrientation: [true, Type.BOOLEAN]\n      }\n    };\n  };\n\n  // fire pluginloaded event if running in browser, this allows registering the plugin when using async script tags\n  var isBrowser$1 =\n    typeof window !== 'undefined' && typeof window.document !== 'undefined';\n  if (isBrowser$1) {\n    document.dispatchEvent(\n      new CustomEvent('FilePond:pluginloaded', { detail: plugin })\n    );\n  }\n\n  return plugin;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmlsZXBvbmQtcGx1Z2luLWltYWdlLWV4aWYtb3JpZW50YXRpb24vZGlzdC9maWxlcG9uZC1wbHVnaW4taW1hZ2UtZXhpZi1vcmllbnRhdGlvbi5qcz84MmQzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxFQUFFLEtBQTREO0FBQzlEO0FBQ0EsTUFBTSxTQUd3RDtBQUM5RCxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMkJBQTJCLFVBQVU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0NBQW9DLDJCQUEyQjtBQUMvRDtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsaUJBQWlCO0FBQ2pFO0FBQ0E7O0FBRUE7QUFDQSxDQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2ZpbGVwb25kLXBsdWdpbi1pbWFnZS1leGlmLW9yaWVudGF0aW9uL2Rpc3QvZmlsZXBvbmQtcGx1Z2luLWltYWdlLWV4aWYtb3JpZW50YXRpb24uanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEZpbGVQb25kUGx1Z2luSW1hZ2VFeGlmT3JpZW50YXRpb24gMS4wLjlcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCwgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQvXG4gKiBQbGVhc2UgdmlzaXQgaHR0cHM6Ly9wcWluYS5ubC9maWxlcG9uZC8gZm9yIGRldGFpbHMuXG4gKi9cblxuLyogZXNsaW50LWRpc2FibGUgKi9cblxuKGZ1bmN0aW9uKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICA/IChtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSlcbiAgICA6IHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZFxuICAgID8gZGVmaW5lKGZhY3RvcnkpXG4gICAgOiAoKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmKSxcbiAgICAgIChnbG9iYWwuRmlsZVBvbmRQbHVnaW5JbWFnZUV4aWZPcmllbnRhdGlvbiA9IGZhY3RvcnkoKSkpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyB0ZXN0IGlmIGZpbGUgaXMgb2YgdHlwZSBpbWFnZVxuICB2YXIgaXNKUEVHID0gZnVuY3Rpb24gaXNKUEVHKGZpbGUpIHtcbiAgICByZXR1cm4gL15pbWFnZVxcL2pwZWcvLnRlc3QoZmlsZS50eXBlKTtcbiAgfTtcblxuICB2YXIgTWFya2VyID0ge1xuICAgIEpQRUc6IDB4ZmZkOCxcbiAgICBBUFAxOiAweGZmZTEsXG4gICAgRVhJRjogMHg0NTc4Njk2NixcbiAgICBUSUZGOiAweDQ5NDksXG4gICAgT3JpZW50YXRpb246IDB4MDExMixcbiAgICBVbmtub3duOiAweGZmMDBcbiAgfTtcblxuICB2YXIgZ2V0VWludDE2ID0gZnVuY3Rpb24gZ2V0VWludDE2KHZpZXcsIG9mZnNldCkge1xuICAgIHZhciBsaXR0bGUgPVxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgICByZXR1cm4gdmlldy5nZXRVaW50MTYob2Zmc2V0LCBsaXR0bGUpO1xuICB9O1xuICB2YXIgZ2V0VWludDMyID0gZnVuY3Rpb24gZ2V0VWludDMyKHZpZXcsIG9mZnNldCkge1xuICAgIHZhciBsaXR0bGUgPVxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgICByZXR1cm4gdmlldy5nZXRVaW50MzIob2Zmc2V0LCBsaXR0bGUpO1xuICB9O1xuXG4gIHZhciBnZXRJbWFnZU9yaWVudGF0aW9uID0gZnVuY3Rpb24gZ2V0SW1hZ2VPcmllbnRhdGlvbihmaWxlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgdmlldyA9IG5ldyBEYXRhVmlldyhlLnRhcmdldC5yZXN1bHQpO1xuXG4gICAgICAgIC8vIEV2ZXJ5IEpQRUcgZmlsZSBzdGFydHMgZnJvbSBiaW5hcnkgdmFsdWUgJzB4RkZEOCdcbiAgICAgICAgaWYgKGdldFVpbnQxNih2aWV3LCAwKSAhPT0gTWFya2VyLkpQRUcpIHtcbiAgICAgICAgICAvLyBUaGlzIGFpbnQgbm8gSlBFR1xuICAgICAgICAgIHJlc29sdmUoLTEpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsZW5ndGggPSB2aWV3LmJ5dGVMZW5ndGg7XG4gICAgICAgIHZhciBvZmZzZXQgPSAyO1xuXG4gICAgICAgIHdoaWxlIChvZmZzZXQgPCBsZW5ndGgpIHtcbiAgICAgICAgICB2YXIgbWFya2VyID0gZ2V0VWludDE2KHZpZXcsIG9mZnNldCk7XG4gICAgICAgICAgb2Zmc2V0ICs9IDI7XG5cbiAgICAgICAgICAvLyBUaGVyZSdzIG91ciBBUFAxIE1hcmtlclxuICAgICAgICAgIGlmIChtYXJrZXIgPT09IE1hcmtlci5BUFAxKSB7XG4gICAgICAgICAgICBpZiAoZ2V0VWludDMyKHZpZXcsIChvZmZzZXQgKz0gMikpICE9PSBNYXJrZXIuRVhJRikge1xuICAgICAgICAgICAgICAvLyBubyBFWElGIGluZm8gZGVmaW5lZFxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gR2V0IFRJRkYgSGVhZGVyXG4gICAgICAgICAgICB2YXIgbGl0dGxlID0gZ2V0VWludDE2KHZpZXcsIChvZmZzZXQgKz0gNikpID09PSBNYXJrZXIuVElGRjtcbiAgICAgICAgICAgIG9mZnNldCArPSBnZXRVaW50MzIodmlldywgb2Zmc2V0ICsgNCwgbGl0dGxlKTtcblxuICAgICAgICAgICAgdmFyIHRhZ3MgPSBnZXRVaW50MTYodmlldywgb2Zmc2V0LCBsaXR0bGUpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IDI7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGFnczsgaSsrKSB7XG4gICAgICAgICAgICAgIC8vIGZvdW5kIHRoZSBvcmllbnRhdGlvbiB0YWdcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGdldFVpbnQxNih2aWV3LCBvZmZzZXQgKyBpICogMTIsIGxpdHRsZSkgPT09IE1hcmtlci5PcmllbnRhdGlvblxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKGdldFVpbnQxNih2aWV3LCBvZmZzZXQgKyBpICogMTIgKyA4LCBsaXR0bGUpKTtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoKG1hcmtlciAmIE1hcmtlci5Vbmtub3duKSAhPT0gTWFya2VyLlVua25vd24pIHtcbiAgICAgICAgICAgIC8vIEludmFsaWRcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvZmZzZXQgKz0gZ2V0VWludDE2KHZpZXcsIG9mZnNldCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gTm90aGluZyBmb3VuZFxuICAgICAgICByZXNvbHZlKC0xKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIHdlIGRvbid0IG5lZWQgdG8gcmVhZCB0aGUgZW50aXJlIGZpbGUgdG8gZ2V0IHRoZSBvcmllbnRhdGlvblxuICAgICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGZpbGUuc2xpY2UoMCwgNjQgKiAxMDI0KSk7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIElTX0JST1dTRVIgPSAoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnXG4gICAgKTtcbiAgfSkoKTtcbiAgdmFyIGlzQnJvd3NlciA9IGZ1bmN0aW9uIGlzQnJvd3NlcigpIHtcbiAgICByZXR1cm4gSVNfQlJPV1NFUjtcbiAgfTtcblxuICAvLyAyeDEgcGl4ZWwgaW1hZ2UgOTBDVyByb3RhdGVkIHdpdGggb3JpZW50YXRpb24gaGVhZGVyXG4gIHZhciB0ZXN0U3JjID1cbiAgICAnZGF0YTppbWFnZS9qcGc7YmFzZTY0LC85ai80QUFRU2taSlJnQUJBUUVBU0FCSUFBRC80UUE2UlhocFpnQUFUVTBBS2dBQUFBZ0FBd0VTQUFNQUFBQUJBQVlBQUFFb0FBTUFBQUFCQUFJQUFBSVRBQU1BQUFBQkFBRUFBQUFBQUFELzJ3QkRBUC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vd0FBTENBQUJBQUlCQVNJQS84UUFKZ0FCQUFBQUFBQUFBQUFBQUFBQUFBQUFBeEFCQUFBQUFBQUFBQUFBQUFBQUFBQUFBUC9hQUFnQkFRQUFQd0JILzlrPSc7XG5cbiAgLy8gc2hvdWxkIGNvcnJlY3Qgb3JpZW50YXRpb24gaWYgaXMgcHJlc2VudGVkIGluIGxhbmRzY2FwZSwgaW4gd2hpY2ggY2FzZSB0aGUgYnJvd3NlciBkb2Vzbid0IGF1dG9jb3JyZWN0XG4gIHZhciBzaG91bGRDb3JyZWN0ID0gdW5kZWZpbmVkO1xuICB2YXIgdGVzdEltYWdlID0gaXNCcm93c2VyKCkgPyBuZXcgSW1hZ2UoKSA6IHt9O1xuICB0ZXN0SW1hZ2Uub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIChzaG91bGRDb3JyZWN0ID0gdGVzdEltYWdlLm5hdHVyYWxXaWR0aCA+IHRlc3RJbWFnZS5uYXR1cmFsSGVpZ2h0KTtcbiAgfTtcbiAgdGVzdEltYWdlLnNyYyA9IHRlc3RTcmM7XG5cbiAgdmFyIHNob3VsZENvcnJlY3RJbWFnZUV4aWZPcmllbnRhdGlvbiA9IGZ1bmN0aW9uIHNob3VsZENvcnJlY3RJbWFnZUV4aWZPcmllbnRhdGlvbigpIHtcbiAgICByZXR1cm4gc2hvdWxkQ29ycmVjdDtcbiAgfTtcblxuICAvKipcbiAgICogUmVhZCBJbWFnZSBPcmllbnRhdGlvbiBQbHVnaW5cbiAgICovXG4gIHZhciBwbHVnaW4gPSBmdW5jdGlvbiBwbHVnaW4oX3JlZikge1xuICAgIHZhciBhZGRGaWx0ZXIgPSBfcmVmLmFkZEZpbHRlcixcbiAgICAgIHV0aWxzID0gX3JlZi51dGlscztcbiAgICB2YXIgVHlwZSA9IHV0aWxzLlR5cGUsXG4gICAgICBpc0ZpbGUgPSB1dGlscy5pc0ZpbGU7XG5cbiAgICAvLyBzdWJzY3JpYmUgdG8gZmlsZSBsb2FkIGFuZCBhcHBlbmQgcmVxdWlyZWQgaW5mb1xuICAgIGFkZEZpbHRlcignRElEX0xPQURfSVRFTScsIGZ1bmN0aW9uKGl0ZW0sIF9yZWYyKSB7XG4gICAgICB2YXIgcXVlcnkgPSBfcmVmMi5xdWVyeTtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgLy8gZ2V0IGZpbGUgcmVmZXJlbmNlXG4gICAgICAgIHZhciBmaWxlID0gaXRlbS5maWxlO1xuXG4gICAgICAgIC8vIGlmIHRoaXMgaXMgbm90IGEganBlZyBpbWFnZSB3ZSBhcmUgbm90IGludGVyZXN0ZWRcbiAgICAgICAgaWYgKFxuICAgICAgICAgICFpc0ZpbGUoZmlsZSkgfHxcbiAgICAgICAgICAhaXNKUEVHKGZpbGUpIHx8XG4gICAgICAgICAgIXF1ZXJ5KCdHRVRfQUxMT1dfSU1BR0VfRVhJRl9PUklFTlRBVElPTicpIHx8XG4gICAgICAgICAgIXNob3VsZENvcnJlY3RJbWFnZUV4aWZPcmllbnRhdGlvbigpXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIGNvbnRpbnVlIHdpdGggdGhlIHVuYWx0ZXJlZCBkYXRhc2V0XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUoaXRlbSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnZXQgb3JpZW50YXRpb24gZnJvbSBleGlmIGRhdGFcbiAgICAgICAgZ2V0SW1hZ2VPcmllbnRhdGlvbihmaWxlKS50aGVuKGZ1bmN0aW9uKG9yaWVudGF0aW9uKSB7XG4gICAgICAgICAgaXRlbS5zZXRNZXRhZGF0YSgnZXhpZicsIHsgb3JpZW50YXRpb246IG9yaWVudGF0aW9uIH0pO1xuICAgICAgICAgIHJlc29sdmUoaXRlbSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyBFeHBvc2UgcGx1Z2luIG9wdGlvbnNcbiAgICByZXR1cm4ge1xuICAgICAgb3B0aW9uczoge1xuICAgICAgICAvLyBFbmFibGUgb3IgZGlzYWJsZSBpbWFnZSBvcmllbnRhdGlvbiByZWFkaW5nXG4gICAgICAgIGFsbG93SW1hZ2VFeGlmT3JpZW50YXRpb246IFt0cnVlLCBUeXBlLkJPT0xFQU5dXG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICAvLyBmaXJlIHBsdWdpbmxvYWRlZCBldmVudCBpZiBydW5uaW5nIGluIGJyb3dzZXIsIHRoaXMgYWxsb3dzIHJlZ2lzdGVyaW5nIHRoZSBwbHVnaW4gd2hlbiB1c2luZyBhc3luYyBzY3JpcHQgdGFnc1xuICB2YXIgaXNCcm93c2VyJDEgPVxuICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnO1xuICBpZiAoaXNCcm93c2VyJDEpIHtcbiAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KFxuICAgICAgbmV3IEN1c3RvbUV2ZW50KCdGaWxlUG9uZDpwbHVnaW5sb2FkZWQnLCB7IGRldGFpbDogcGx1Z2luIH0pXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBwbHVnaW47XG59KTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/filepond-plugin-image-exif-orientation/dist/filepond-plugin-image-exif-orientation.js\n");

/***/ }),

/***/ "./node_modules/filepond-plugin-image-preview/dist/filepond-plugin-image-preview.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/filepond-plugin-image-preview/dist/filepond-plugin-image-preview.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * FilePondPluginImagePreview 4.6.4\n * Licensed under MIT, https://opensource.org/licenses/MIT/\n * Please visit https://pqina.nl/filepond/ for details.\n */\n\n/* eslint-disable */\n\n(function(global, factory) {\n   true\n    ? (module.exports = factory())\n    : undefined;\n})(this, function() {\n  'use strict';\n\n  // test if file is of type image and can be viewed in canvas\n  var isPreviewableImage = function isPreviewableImage(file) {\n    return /^image/.test(file.type);\n  };\n\n  function _typeof(obj) {\n    if (typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol') {\n      _typeof = function(obj) {\n        return typeof obj;\n      };\n    } else {\n      _typeof = function(obj) {\n        return obj &&\n          typeof Symbol === 'function' &&\n          obj.constructor === Symbol &&\n          obj !== Symbol.prototype\n          ? 'symbol'\n          : typeof obj;\n      };\n    }\n\n    return _typeof(obj);\n  }\n\n  var REACT_ELEMENT_TYPE;\n\n  function _jsx(type, props, key, children) {\n    if (!REACT_ELEMENT_TYPE) {\n      REACT_ELEMENT_TYPE =\n        (typeof Symbol === 'function' &&\n          Symbol.for &&\n          Symbol.for('react.element')) ||\n        0xeac7;\n    }\n\n    var defaultProps = type && type.defaultProps;\n    var childrenLength = arguments.length - 3;\n\n    if (!props && childrenLength !== 0) {\n      props = {\n        children: void 0\n      };\n    }\n\n    if (props && defaultProps) {\n      for (var propName in defaultProps) {\n        if (props[propName] === void 0) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    } else if (!props) {\n      props = defaultProps || {};\n    }\n\n    if (childrenLength === 1) {\n      props.children = children;\n    } else if (childrenLength > 1) {\n      var childArray = new Array(childrenLength);\n\n      for (var i = 0; i < childrenLength; i++) {\n        childArray[i] = arguments[i + 3];\n      }\n\n      props.children = childArray;\n    }\n\n    return {\n      $$typeof: REACT_ELEMENT_TYPE,\n      type: type,\n      key: key === undefined ? null : '' + key,\n      ref: null,\n      props: props,\n      _owner: null\n    };\n  }\n\n  function _asyncIterator(iterable) {\n    var method;\n\n    if (typeof Symbol === 'function') {\n      if (Symbol.asyncIterator) {\n        method = iterable[Symbol.asyncIterator];\n        if (method != null) return method.call(iterable);\n      }\n\n      if (Symbol.iterator) {\n        method = iterable[Symbol.iterator];\n        if (method != null) return method.call(iterable);\n      }\n    }\n\n    throw new TypeError('Object is not async iterable');\n  }\n\n  function _AwaitValue(value) {\n    this.wrapped = value;\n  }\n\n  function _AsyncGenerator(gen) {\n    var front, back;\n\n    function send(key, arg) {\n      return new Promise(function(resolve, reject) {\n        var request = {\n          key: key,\n          arg: arg,\n          resolve: resolve,\n          reject: reject,\n          next: null\n        };\n\n        if (back) {\n          back = back.next = request;\n        } else {\n          front = back = request;\n          resume(key, arg);\n        }\n      });\n    }\n\n    function resume(key, arg) {\n      try {\n        var result = gen[key](arg);\n        var value = result.value;\n        var wrappedAwait = value instanceof _AwaitValue;\n        Promise.resolve(wrappedAwait ? value.wrapped : value).then(\n          function(arg) {\n            if (wrappedAwait) {\n              resume('next', arg);\n              return;\n            }\n\n            settle(result.done ? 'return' : 'normal', arg);\n          },\n          function(err) {\n            resume('throw', err);\n          }\n        );\n      } catch (err) {\n        settle('throw', err);\n      }\n    }\n\n    function settle(type, value) {\n      switch (type) {\n        case 'return':\n          front.resolve({\n            value: value,\n            done: true\n          });\n          break;\n\n        case 'throw':\n          front.reject(value);\n          break;\n\n        default:\n          front.resolve({\n            value: value,\n            done: false\n          });\n          break;\n      }\n\n      front = front.next;\n\n      if (front) {\n        resume(front.key, front.arg);\n      } else {\n        back = null;\n      }\n    }\n\n    this._invoke = send;\n\n    if (typeof gen.return !== 'function') {\n      this.return = undefined;\n    }\n  }\n\n  if (typeof Symbol === 'function' && Symbol.asyncIterator) {\n    _AsyncGenerator.prototype[Symbol.asyncIterator] = function() {\n      return this;\n    };\n  }\n\n  _AsyncGenerator.prototype.next = function(arg) {\n    return this._invoke('next', arg);\n  };\n\n  _AsyncGenerator.prototype.throw = function(arg) {\n    return this._invoke('throw', arg);\n  };\n\n  _AsyncGenerator.prototype.return = function(arg) {\n    return this._invoke('return', arg);\n  };\n\n  function _wrapAsyncGenerator(fn) {\n    return function() {\n      return new _AsyncGenerator(fn.apply(this, arguments));\n    };\n  }\n\n  function _awaitAsyncGenerator(value) {\n    return new _AwaitValue(value);\n  }\n\n  function _asyncGeneratorDelegate(inner, awaitWrap) {\n    var iter = {},\n      waiting = false;\n\n    function pump(key, value) {\n      waiting = true;\n      value = new Promise(function(resolve) {\n        resolve(inner[key](value));\n      });\n      return {\n        done: false,\n        value: awaitWrap(value)\n      };\n    }\n\n    if (typeof Symbol === 'function' && Symbol.iterator) {\n      iter[Symbol.iterator] = function() {\n        return this;\n      };\n    }\n\n    iter.next = function(value) {\n      if (waiting) {\n        waiting = false;\n        return value;\n      }\n\n      return pump('next', value);\n    };\n\n    if (typeof inner.throw === 'function') {\n      iter.throw = function(value) {\n        if (waiting) {\n          waiting = false;\n          throw value;\n        }\n\n        return pump('throw', value);\n      };\n    }\n\n    if (typeof inner.return === 'function') {\n      iter.return = function(value) {\n        return pump('return', value);\n      };\n    }\n\n    return iter;\n  }\n\n  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n      var info = gen[key](arg);\n      var value = info.value;\n    } catch (error) {\n      reject(error);\n      return;\n    }\n\n    if (info.done) {\n      resolve(value);\n    } else {\n      Promise.resolve(value).then(_next, _throw);\n    }\n  }\n\n  function _asyncToGenerator(fn) {\n    return function() {\n      var self = this,\n        args = arguments;\n      return new Promise(function(resolve, reject) {\n        var gen = fn.apply(self, args);\n\n        function _next(value) {\n          asyncGeneratorStep(\n            gen,\n            resolve,\n            reject,\n            _next,\n            _throw,\n            'next',\n            value\n          );\n        }\n\n        function _throw(err) {\n          asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'throw', err);\n        }\n\n        _next(undefined);\n      });\n    };\n  }\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError('Cannot call a class as a function');\n    }\n  }\n\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if ('value' in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n  }\n\n  function _defineEnumerableProperties(obj, descs) {\n    for (var key in descs) {\n      var desc = descs[key];\n      desc.configurable = desc.enumerable = true;\n      if ('value' in desc) desc.writable = true;\n      Object.defineProperty(obj, key, desc);\n    }\n\n    if (Object.getOwnPropertySymbols) {\n      var objectSymbols = Object.getOwnPropertySymbols(descs);\n\n      for (var i = 0; i < objectSymbols.length; i++) {\n        var sym = objectSymbols[i];\n        var desc = descs[sym];\n        desc.configurable = desc.enumerable = true;\n        if ('value' in desc) desc.writable = true;\n        Object.defineProperty(obj, sym, desc);\n      }\n    }\n\n    return obj;\n  }\n\n  function _defaults(obj, defaults) {\n    var keys = Object.getOwnPropertyNames(defaults);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      var value = Object.getOwnPropertyDescriptor(defaults, key);\n\n      if (value && value.configurable && obj[key] === undefined) {\n        Object.defineProperty(obj, key, value);\n      }\n    }\n\n    return obj;\n  }\n\n  function _defineProperty(obj, key, value) {\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  function _extends() {\n    _extends =\n      Object.assign ||\n      function(target) {\n        for (var i = 1; i < arguments.length; i++) {\n          var source = arguments[i];\n\n          for (var key in source) {\n            if (Object.prototype.hasOwnProperty.call(source, key)) {\n              target[key] = source[key];\n            }\n          }\n        }\n\n        return target;\n      };\n\n    return _extends.apply(this, arguments);\n  }\n\n  function _objectSpread(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i] != null ? arguments[i] : {};\n      var ownKeys = Object.keys(source);\n\n      if (typeof Object.getOwnPropertySymbols === 'function') {\n        ownKeys = ownKeys.concat(\n          Object.getOwnPropertySymbols(source).filter(function(sym) {\n            return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n          })\n        );\n      }\n\n      ownKeys.forEach(function(key) {\n        _defineProperty(target, key, source[key]);\n      });\n    }\n\n    return target;\n  }\n\n  function _inherits(subClass, superClass) {\n    if (typeof superClass !== 'function' && superClass !== null) {\n      throw new TypeError('Super expression must either be null or a function');\n    }\n\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n      constructor: {\n        value: subClass,\n        writable: true,\n        configurable: true\n      }\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n  }\n\n  function _inheritsLoose(subClass, superClass) {\n    subClass.prototype = Object.create(superClass.prototype);\n    subClass.prototype.constructor = subClass;\n    subClass.__proto__ = superClass;\n  }\n\n  function _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf\n      ? Object.getPrototypeOf\n      : function _getPrototypeOf(o) {\n          return o.__proto__ || Object.getPrototypeOf(o);\n        };\n    return _getPrototypeOf(o);\n  }\n\n  function _setPrototypeOf(o, p) {\n    _setPrototypeOf =\n      Object.setPrototypeOf ||\n      function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n      };\n\n    return _setPrototypeOf(o, p);\n  }\n\n  function isNativeReflectConstruct() {\n    if (typeof Reflect === 'undefined' || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === 'function') return true;\n\n    try {\n      Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  function _construct(Parent, args, Class) {\n    if (isNativeReflectConstruct()) {\n      _construct = Reflect.construct;\n    } else {\n      _construct = function _construct(Parent, args, Class) {\n        var a = [null];\n        a.push.apply(a, args);\n        var Constructor = Function.bind.apply(Parent, a);\n        var instance = new Constructor();\n        if (Class) _setPrototypeOf(instance, Class.prototype);\n        return instance;\n      };\n    }\n\n    return _construct.apply(null, arguments);\n  }\n\n  function _isNativeFunction(fn) {\n    return Function.toString.call(fn).indexOf('[native code]') !== -1;\n  }\n\n  function _wrapNativeSuper(Class) {\n    var _cache = typeof Map === 'function' ? new Map() : undefined;\n\n    _wrapNativeSuper = function _wrapNativeSuper(Class) {\n      if (Class === null || !_isNativeFunction(Class)) return Class;\n\n      if (typeof Class !== 'function') {\n        throw new TypeError(\n          'Super expression must either be null or a function'\n        );\n      }\n\n      if (typeof _cache !== 'undefined') {\n        if (_cache.has(Class)) return _cache.get(Class);\n\n        _cache.set(Class, Wrapper);\n      }\n\n      function Wrapper() {\n        return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n      }\n\n      Wrapper.prototype = Object.create(Class.prototype, {\n        constructor: {\n          value: Wrapper,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      });\n      return _setPrototypeOf(Wrapper, Class);\n    };\n\n    return _wrapNativeSuper(Class);\n  }\n\n  function _instanceof(left, right) {\n    if (\n      right != null &&\n      typeof Symbol !== 'undefined' &&\n      right[Symbol.hasInstance]\n    ) {\n      return right[Symbol.hasInstance](left);\n    } else {\n      return left instanceof right;\n    }\n  }\n\n  function _interopRequireDefault(obj) {\n    return obj && obj.__esModule\n      ? obj\n      : {\n          default: obj\n        };\n  }\n\n  function _interopRequireWildcard(obj) {\n    if (obj && obj.__esModule) {\n      return obj;\n    } else {\n      var newObj = {};\n\n      if (obj != null) {\n        for (var key in obj) {\n          if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc =\n              Object.defineProperty && Object.getOwnPropertyDescriptor\n                ? Object.getOwnPropertyDescriptor(obj, key)\n                : {};\n\n            if (desc.get || desc.set) {\n              Object.defineProperty(newObj, key, desc);\n            } else {\n              newObj[key] = obj[key];\n            }\n          }\n        }\n      }\n\n      newObj.default = obj;\n      return newObj;\n    }\n  }\n\n  function _newArrowCheck(innerThis, boundThis) {\n    if (innerThis !== boundThis) {\n      throw new TypeError('Cannot instantiate an arrow function');\n    }\n  }\n\n  function _objectDestructuringEmpty(obj) {\n    if (obj == null) throw new TypeError('Cannot destructure undefined');\n  }\n\n  function _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n\n    for (i = 0; i < sourceKeys.length; i++) {\n      key = sourceKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      target[key] = source[key];\n    }\n\n    return target;\n  }\n\n  function _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n\n    var key, i;\n\n    if (Object.getOwnPropertySymbols) {\n      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n      for (i = 0; i < sourceSymbolKeys.length; i++) {\n        key = sourceSymbolKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n        target[key] = source[key];\n      }\n    }\n\n    return target;\n  }\n\n  function _assertThisInitialized(self) {\n    if (self === void 0) {\n      throw new ReferenceError(\n        \"this hasn't been initialised - super() hasn't been called\"\n      );\n    }\n\n    return self;\n  }\n\n  function _possibleConstructorReturn(self, call) {\n    if (call && (typeof call === 'object' || typeof call === 'function')) {\n      return call;\n    }\n\n    return _assertThisInitialized(self);\n  }\n\n  function _superPropBase(object, property) {\n    while (!Object.prototype.hasOwnProperty.call(object, property)) {\n      object = _getPrototypeOf(object);\n      if (object === null) break;\n    }\n\n    return object;\n  }\n\n  function _get(target, property, receiver) {\n    if (typeof Reflect !== 'undefined' && Reflect.get) {\n      _get = Reflect.get;\n    } else {\n      _get = function _get(target, property, receiver) {\n        var base = _superPropBase(target, property);\n\n        if (!base) return;\n        var desc = Object.getOwnPropertyDescriptor(base, property);\n\n        if (desc.get) {\n          return desc.get.call(receiver);\n        }\n\n        return desc.value;\n      };\n    }\n\n    return _get(target, property, receiver || target);\n  }\n\n  function set(target, property, value, receiver) {\n    if (typeof Reflect !== 'undefined' && Reflect.set) {\n      set = Reflect.set;\n    } else {\n      set = function set(target, property, value, receiver) {\n        var base = _superPropBase(target, property);\n\n        var desc;\n\n        if (base) {\n          desc = Object.getOwnPropertyDescriptor(base, property);\n\n          if (desc.set) {\n            desc.set.call(receiver, value);\n            return true;\n          } else if (!desc.writable) {\n            return false;\n          }\n        }\n\n        desc = Object.getOwnPropertyDescriptor(receiver, property);\n\n        if (desc) {\n          if (!desc.writable) {\n            return false;\n          }\n\n          desc.value = value;\n          Object.defineProperty(receiver, property, desc);\n        } else {\n          _defineProperty(receiver, property, value);\n        }\n\n        return true;\n      };\n    }\n\n    return set(target, property, value, receiver);\n  }\n\n  function _set(target, property, value, receiver, isStrict) {\n    var s = set(target, property, value, receiver || target);\n\n    if (!s && isStrict) {\n      throw new Error('failed to set property');\n    }\n\n    return value;\n  }\n\n  function _taggedTemplateLiteral(strings, raw) {\n    if (!raw) {\n      raw = strings.slice(0);\n    }\n\n    return Object.freeze(\n      Object.defineProperties(strings, {\n        raw: {\n          value: Object.freeze(raw)\n        }\n      })\n    );\n  }\n\n  function _taggedTemplateLiteralLoose(strings, raw) {\n    if (!raw) {\n      raw = strings.slice(0);\n    }\n\n    strings.raw = raw;\n    return strings;\n  }\n\n  function _temporalRef(val, name) {\n    if (val === _temporalUndefined) {\n      throw new ReferenceError(name + ' is not defined - temporal dead zone');\n    } else {\n      return val;\n    }\n  }\n\n  function _readOnlyError(name) {\n    throw new Error('\"' + name + '\" is read-only');\n  }\n\n  function _classNameTDZError(name) {\n    throw new Error(\n      'Class \"' + name + '\" cannot be referenced in computed property keys.'\n    );\n  }\n\n  var _temporalUndefined = {};\n\n  function _slicedToArray(arr, i) {\n    return (\n      _arrayWithHoles(arr) ||\n      _iterableToArrayLimit(arr, i) ||\n      _nonIterableRest()\n    );\n  }\n\n  function _slicedToArrayLoose(arr, i) {\n    return (\n      _arrayWithHoles(arr) ||\n      _iterableToArrayLimitLoose(arr, i) ||\n      _nonIterableRest()\n    );\n  }\n\n  function _toArray(arr) {\n    return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest();\n  }\n\n  function _toConsumableArray(arr) {\n    return (\n      _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread()\n    );\n  }\n\n  function _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) {\n      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++)\n        arr2[i] = arr[i];\n\n      return arr2;\n    }\n  }\n\n  function _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n  }\n\n  function _iterableToArray(iter) {\n    if (\n      Symbol.iterator in Object(iter) ||\n      Object.prototype.toString.call(iter) === '[object Arguments]'\n    )\n      return Array.from(iter);\n  }\n\n  function _iterableToArrayLimit(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (\n        var _i = arr[Symbol.iterator](), _s;\n        !(_n = (_s = _i.next()).done);\n        _n = true\n      ) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i['return'] != null) _i['return']();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  function _iterableToArrayLimitLoose(arr, i) {\n    var _arr = [];\n\n    for (\n      var _iterator = arr[Symbol.iterator](), _step;\n      !(_step = _iterator.next()).done;\n\n    ) {\n      _arr.push(_step.value);\n\n      if (i && _arr.length === i) break;\n    }\n\n    return _arr;\n  }\n\n  function _nonIterableSpread() {\n    throw new TypeError('Invalid attempt to spread non-iterable instance');\n  }\n\n  function _nonIterableRest() {\n    throw new TypeError('Invalid attempt to destructure non-iterable instance');\n  }\n\n  function _skipFirstGeneratorNext(fn) {\n    return function() {\n      var it = fn.apply(this, arguments);\n      it.next();\n      return it;\n    };\n  }\n\n  function _toPrimitive(input, hint) {\n    if (typeof input !== 'object' || input === null) return input;\n    var prim = input[Symbol.toPrimitive];\n\n    if (prim !== undefined) {\n      var res = prim.call(input, hint || 'default');\n      if (typeof res !== 'object') return res;\n      throw new TypeError('@@toPrimitive must return a primitive value.');\n    }\n\n    return (hint === 'string' ? String : Number)(input);\n  }\n\n  function _toPropertyKey(arg) {\n    var key = _toPrimitive(arg, 'string');\n\n    return typeof key === 'symbol' ? key : String(key);\n  }\n\n  function _initializerWarningHelper(descriptor, context) {\n    throw new Error(\n      'Decorating class property failed. Please ensure that ' +\n        'proposal-class-properties is enabled and set to use loose mode. ' +\n        'To use proposal-class-properties in spec mode with decorators, wait for ' +\n        'the next major version of decorators in stage 2.'\n    );\n  }\n\n  function _initializerDefineProperty(target, property, descriptor, context) {\n    if (!descriptor) return;\n    Object.defineProperty(target, property, {\n      enumerable: descriptor.enumerable,\n      configurable: descriptor.configurable,\n      writable: descriptor.writable,\n      value: descriptor.initializer\n        ? descriptor.initializer.call(context)\n        : void 0\n    });\n  }\n\n  function _applyDecoratedDescriptor(\n    target,\n    property,\n    decorators,\n    descriptor,\n    context\n  ) {\n    var desc = {};\n    Object.keys(descriptor).forEach(function(key) {\n      desc[key] = descriptor[key];\n    });\n    desc.enumerable = !!desc.enumerable;\n    desc.configurable = !!desc.configurable;\n\n    if ('value' in desc || desc.initializer) {\n      desc.writable = true;\n    }\n\n    desc = decorators\n      .slice()\n      .reverse()\n      .reduce(function(desc, decorator) {\n        return decorator(target, property, desc) || desc;\n      }, desc);\n\n    if (context && desc.initializer !== void 0) {\n      desc.value = desc.initializer ? desc.initializer.call(context) : void 0;\n      desc.initializer = undefined;\n    }\n\n    if (desc.initializer === void 0) {\n      Object.defineProperty(target, property, desc);\n      desc = null;\n    }\n\n    return desc;\n  }\n\n  var id = 0;\n\n  function _classPrivateFieldLooseKey(name) {\n    return '__private_' + id++ + '_' + name;\n  }\n\n  function _classPrivateFieldLooseBase(receiver, privateKey) {\n    if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {\n      throw new TypeError('attempted to use private field on non-instance');\n    }\n\n    return receiver;\n  }\n\n  function _classPrivateFieldGet(receiver, privateMap) {\n    if (!privateMap.has(receiver)) {\n      throw new TypeError('attempted to get private field on non-instance');\n    }\n\n    var descriptor = privateMap.get(receiver);\n\n    if (descriptor.get) {\n      return descriptor.get.call(receiver);\n    }\n\n    return descriptor.value;\n  }\n\n  function _classPrivateFieldSet(receiver, privateMap, value) {\n    if (!privateMap.has(receiver)) {\n      throw new TypeError('attempted to set private field on non-instance');\n    }\n\n    var descriptor = privateMap.get(receiver);\n\n    if (descriptor.set) {\n      descriptor.set.call(receiver, value);\n    } else {\n      if (!descriptor.writable) {\n        throw new TypeError('attempted to set read only private field');\n      }\n\n      descriptor.value = value;\n    }\n\n    return value;\n  }\n\n  function _classStaticPrivateFieldSpecGet(\n    receiver,\n    classConstructor,\n    descriptor\n  ) {\n    if (receiver !== classConstructor) {\n      throw new TypeError('Private static access of wrong provenance');\n    }\n\n    return descriptor.value;\n  }\n\n  function _classStaticPrivateFieldSpecSet(\n    receiver,\n    classConstructor,\n    descriptor,\n    value\n  ) {\n    if (receiver !== classConstructor) {\n      throw new TypeError('Private static access of wrong provenance');\n    }\n\n    if (!descriptor.writable) {\n      throw new TypeError('attempted to set read only private field');\n    }\n\n    descriptor.value = value;\n    return value;\n  }\n\n  function _classStaticPrivateMethodGet(receiver, classConstructor, method) {\n    if (receiver !== classConstructor) {\n      throw new TypeError('Private static access of wrong provenance');\n    }\n\n    return method;\n  }\n\n  function _classStaticPrivateMethodSet() {\n    throw new TypeError('attempted to set read only static private field');\n  }\n\n  function _decorate(decorators, factory, superClass, mixins) {\n    var api = _getDecoratorsApi();\n\n    if (mixins) {\n      for (var i = 0; i < mixins.length; i++) {\n        api = mixins[i](api);\n      }\n    }\n\n    var r = factory(function initialize(O) {\n      api.initializeInstanceElements(O, decorated.elements);\n    }, superClass);\n    var decorated = api.decorateClass(\n      _coalesceClassElements(r.d.map(_createElementDescriptor)),\n      decorators\n    );\n    api.initializeClassElements(r.F, decorated.elements);\n    return api.runClassFinishers(r.F, decorated.finishers);\n  }\n\n  function _getDecoratorsApi() {\n    _getDecoratorsApi = function() {\n      return api;\n    };\n\n    var api = {\n      elementsDefinitionOrder: [['method'], ['field']],\n      initializeInstanceElements: function(O, elements) {\n        ['method', 'field'].forEach(function(kind) {\n          elements.forEach(function(element) {\n            if (element.kind === kind && element.placement === 'own') {\n              this.defineClassElement(O, element);\n            }\n          }, this);\n        }, this);\n      },\n      initializeClassElements: function(F, elements) {\n        var proto = F.prototype;\n        ['method', 'field'].forEach(function(kind) {\n          elements.forEach(function(element) {\n            var placement = element.placement;\n\n            if (\n              element.kind === kind &&\n              (placement === 'static' || placement === 'prototype')\n            ) {\n              var receiver = placement === 'static' ? F : proto;\n              this.defineClassElement(receiver, element);\n            }\n          }, this);\n        }, this);\n      },\n      defineClassElement: function(receiver, element) {\n        var descriptor = element.descriptor;\n\n        if (element.kind === 'field') {\n          var initializer = element.initializer;\n          descriptor = {\n            enumerable: descriptor.enumerable,\n            writable: descriptor.writable,\n            configurable: descriptor.configurable,\n            value: initializer === void 0 ? void 0 : initializer.call(receiver)\n          };\n        }\n\n        Object.defineProperty(receiver, element.key, descriptor);\n      },\n      decorateClass: function(elements, decorators) {\n        var newElements = [];\n        var finishers = [];\n        var placements = {\n          static: [],\n          prototype: [],\n          own: []\n        };\n        elements.forEach(function(element) {\n          this.addElementPlacement(element, placements);\n        }, this);\n        elements.forEach(function(element) {\n          if (!_hasDecorators(element)) return newElements.push(element);\n          var elementFinishersExtras = this.decorateElement(\n            element,\n            placements\n          );\n          newElements.push(elementFinishersExtras.element);\n          newElements.push.apply(newElements, elementFinishersExtras.extras);\n          finishers.push.apply(finishers, elementFinishersExtras.finishers);\n        }, this);\n\n        if (!decorators) {\n          return {\n            elements: newElements,\n            finishers: finishers\n          };\n        }\n\n        var result = this.decorateConstructor(newElements, decorators);\n        finishers.push.apply(finishers, result.finishers);\n        result.finishers = finishers;\n        return result;\n      },\n      addElementPlacement: function(element, placements, silent) {\n        var keys = placements[element.placement];\n\n        if (!silent && keys.indexOf(element.key) !== -1) {\n          throw new TypeError('Duplicated element (' + element.key + ')');\n        }\n\n        keys.push(element.key);\n      },\n      decorateElement: function(element, placements) {\n        var extras = [];\n        var finishers = [];\n\n        for (\n          var decorators = element.decorators, i = decorators.length - 1;\n          i >= 0;\n          i--\n        ) {\n          var keys = placements[element.placement];\n          keys.splice(keys.indexOf(element.key), 1);\n          var elementObject = this.fromElementDescriptor(element);\n          var elementFinisherExtras = this.toElementFinisherExtras(\n            (0, decorators[i])(elementObject) || elementObject\n          );\n          element = elementFinisherExtras.element;\n          this.addElementPlacement(element, placements);\n\n          if (elementFinisherExtras.finisher) {\n            finishers.push(elementFinisherExtras.finisher);\n          }\n\n          var newExtras = elementFinisherExtras.extras;\n\n          if (newExtras) {\n            for (var j = 0; j < newExtras.length; j++) {\n              this.addElementPlacement(newExtras[j], placements);\n            }\n\n            extras.push.apply(extras, newExtras);\n          }\n        }\n\n        return {\n          element: element,\n          finishers: finishers,\n          extras: extras\n        };\n      },\n      decorateConstructor: function(elements, decorators) {\n        var finishers = [];\n\n        for (var i = decorators.length - 1; i >= 0; i--) {\n          var obj = this.fromClassDescriptor(elements);\n          var elementsAndFinisher = this.toClassDescriptor(\n            (0, decorators[i])(obj) || obj\n          );\n\n          if (elementsAndFinisher.finisher !== undefined) {\n            finishers.push(elementsAndFinisher.finisher);\n          }\n\n          if (elementsAndFinisher.elements !== undefined) {\n            elements = elementsAndFinisher.elements;\n\n            for (var j = 0; j < elements.length - 1; j++) {\n              for (var k = j + 1; k < elements.length; k++) {\n                if (\n                  elements[j].key === elements[k].key &&\n                  elements[j].placement === elements[k].placement\n                ) {\n                  throw new TypeError(\n                    'Duplicated element (' + elements[j].key + ')'\n                  );\n                }\n              }\n            }\n          }\n        }\n\n        return {\n          elements: elements,\n          finishers: finishers\n        };\n      },\n      fromElementDescriptor: function(element) {\n        var obj = {\n          kind: element.kind,\n          key: element.key,\n          placement: element.placement,\n          descriptor: element.descriptor\n        };\n        var desc = {\n          value: 'Descriptor',\n          configurable: true\n        };\n        Object.defineProperty(obj, Symbol.toStringTag, desc);\n        if (element.kind === 'field') obj.initializer = element.initializer;\n        return obj;\n      },\n      toElementDescriptors: function(elementObjects) {\n        if (elementObjects === undefined) return;\n        return _toArray(elementObjects).map(function(elementObject) {\n          var element = this.toElementDescriptor(elementObject);\n          this.disallowProperty(\n            elementObject,\n            'finisher',\n            'An element descriptor'\n          );\n          this.disallowProperty(\n            elementObject,\n            'extras',\n            'An element descriptor'\n          );\n          return element;\n        }, this);\n      },\n      toElementDescriptor: function(elementObject) {\n        var kind = String(elementObject.kind);\n\n        if (kind !== 'method' && kind !== 'field') {\n          throw new TypeError(\n            'An element descriptor\\'s .kind property must be either \"method\" or' +\n              ' \"field\", but a decorator created an element descriptor with' +\n              ' .kind \"' +\n              kind +\n              '\"'\n          );\n        }\n\n        var key = _toPropertyKey(elementObject.key);\n\n        var placement = String(elementObject.placement);\n\n        if (\n          placement !== 'static' &&\n          placement !== 'prototype' &&\n          placement !== 'own'\n        ) {\n          throw new TypeError(\n            'An element descriptor\\'s .placement property must be one of \"static\",' +\n              ' \"prototype\" or \"own\", but a decorator created an element descriptor' +\n              ' with .placement \"' +\n              placement +\n              '\"'\n          );\n        }\n\n        var descriptor = elementObject.descriptor;\n        this.disallowProperty(\n          elementObject,\n          'elements',\n          'An element descriptor'\n        );\n        var element = {\n          kind: kind,\n          key: key,\n          placement: placement,\n          descriptor: Object.assign({}, descriptor)\n        };\n\n        if (kind !== 'field') {\n          this.disallowProperty(\n            elementObject,\n            'initializer',\n            'A method descriptor'\n          );\n        } else {\n          this.disallowProperty(\n            descriptor,\n            'get',\n            'The property descriptor of a field descriptor'\n          );\n          this.disallowProperty(\n            descriptor,\n            'set',\n            'The property descriptor of a field descriptor'\n          );\n          this.disallowProperty(\n            descriptor,\n            'value',\n            'The property descriptor of a field descriptor'\n          );\n          element.initializer = elementObject.initializer;\n        }\n\n        return element;\n      },\n      toElementFinisherExtras: function(elementObject) {\n        var element = this.toElementDescriptor(elementObject);\n\n        var finisher = _optionalCallableProperty(elementObject, 'finisher');\n\n        var extras = this.toElementDescriptors(elementObject.extras);\n        return {\n          element: element,\n          finisher: finisher,\n          extras: extras\n        };\n      },\n      fromClassDescriptor: function(elements) {\n        var obj = {\n          kind: 'class',\n          elements: elements.map(this.fromElementDescriptor, this)\n        };\n        var desc = {\n          value: 'Descriptor',\n          configurable: true\n        };\n        Object.defineProperty(obj, Symbol.toStringTag, desc);\n        return obj;\n      },\n      toClassDescriptor: function(obj) {\n        var kind = String(obj.kind);\n\n        if (kind !== 'class') {\n          throw new TypeError(\n            'A class descriptor\\'s .kind property must be \"class\", but a decorator' +\n              ' created a class descriptor with .kind \"' +\n              kind +\n              '\"'\n          );\n        }\n\n        this.disallowProperty(obj, 'key', 'A class descriptor');\n        this.disallowProperty(obj, 'placement', 'A class descriptor');\n        this.disallowProperty(obj, 'descriptor', 'A class descriptor');\n        this.disallowProperty(obj, 'initializer', 'A class descriptor');\n        this.disallowProperty(obj, 'extras', 'A class descriptor');\n\n        var finisher = _optionalCallableProperty(obj, 'finisher');\n\n        var elements = this.toElementDescriptors(obj.elements);\n        return {\n          elements: elements,\n          finisher: finisher\n        };\n      },\n      runClassFinishers: function(constructor, finishers) {\n        for (var i = 0; i < finishers.length; i++) {\n          var newConstructor = (0, finishers[i])(constructor);\n\n          if (newConstructor !== undefined) {\n            if (typeof newConstructor !== 'function') {\n              throw new TypeError('Finishers must return a constructor.');\n            }\n\n            constructor = newConstructor;\n          }\n        }\n\n        return constructor;\n      },\n      disallowProperty: function(obj, name, objectType) {\n        if (obj[name] !== undefined) {\n          throw new TypeError(\n            objectType + \" can't have a .\" + name + ' property.'\n          );\n        }\n      }\n    };\n    return api;\n  }\n\n  function _createElementDescriptor(def) {\n    var key = _toPropertyKey(def.key);\n\n    var descriptor;\n\n    if (def.kind === 'method') {\n      descriptor = {\n        value: def.value,\n        writable: true,\n        configurable: true,\n        enumerable: false\n      };\n    } else if (def.kind === 'get') {\n      descriptor = {\n        get: def.value,\n        configurable: true,\n        enumerable: false\n      };\n    } else if (def.kind === 'set') {\n      descriptor = {\n        set: def.value,\n        configurable: true,\n        enumerable: false\n      };\n    } else if (def.kind === 'field') {\n      descriptor = {\n        configurable: true,\n        writable: true,\n        enumerable: true\n      };\n    }\n\n    var element = {\n      kind: def.kind === 'field' ? 'field' : 'method',\n      key: key,\n      placement: def.static\n        ? 'static'\n        : def.kind === 'field'\n        ? 'own'\n        : 'prototype',\n      descriptor: descriptor\n    };\n    if (def.decorators) element.decorators = def.decorators;\n    if (def.kind === 'field') element.initializer = def.value;\n    return element;\n  }\n\n  function _coalesceGetterSetter(element, other) {\n    if (element.descriptor.get !== undefined) {\n      other.descriptor.get = element.descriptor.get;\n    } else {\n      other.descriptor.set = element.descriptor.set;\n    }\n  }\n\n  function _coalesceClassElements(elements) {\n    var newElements = [];\n\n    var isSameElement = function(other) {\n      return (\n        other.kind === 'method' &&\n        other.key === element.key &&\n        other.placement === element.placement\n      );\n    };\n\n    for (var i = 0; i < elements.length; i++) {\n      var element = elements[i];\n      var other;\n\n      if (\n        element.kind === 'method' &&\n        (other = newElements.find(isSameElement))\n      ) {\n        if (\n          _isDataDescriptor(element.descriptor) ||\n          _isDataDescriptor(other.descriptor)\n        ) {\n          if (_hasDecorators(element) || _hasDecorators(other)) {\n            throw new ReferenceError(\n              'Duplicated methods (' + element.key + \") can't be decorated.\"\n            );\n          }\n\n          other.descriptor = element.descriptor;\n        } else {\n          if (_hasDecorators(element)) {\n            if (_hasDecorators(other)) {\n              throw new ReferenceError(\n                \"Decorators can't be placed on different accessors with for \" +\n                  'the same property (' +\n                  element.key +\n                  ').'\n              );\n            }\n\n            other.decorators = element.decorators;\n          }\n\n          _coalesceGetterSetter(element, other);\n        }\n      } else {\n        newElements.push(element);\n      }\n    }\n\n    return newElements;\n  }\n\n  function _hasDecorators(element) {\n    return element.decorators && element.decorators.length;\n  }\n\n  function _isDataDescriptor(desc) {\n    return (\n      desc !== undefined &&\n      !(desc.value === undefined && desc.writable === undefined)\n    );\n  }\n\n  function _optionalCallableProperty(obj, name) {\n    var value = obj[name];\n\n    if (value !== undefined && typeof value !== 'function') {\n      throw new TypeError(\"Expected '\" + name + \"' to be a function\");\n    }\n\n    return value;\n  }\n\n  function _classPrivateMethodGet(receiver, privateSet, fn) {\n    if (!privateSet.has(receiver)) {\n      throw new TypeError('attempted to get private field on non-instance');\n    }\n\n    return fn;\n  }\n\n  function _classPrivateMethodSet() {\n    throw new TypeError('attempted to reassign private method');\n  }\n\n  function _wrapRegExp(re, groups) {\n    _wrapRegExp = function(re, groups) {\n      return new BabelRegExp(re, groups);\n    };\n\n    var _RegExp = _wrapNativeSuper(RegExp);\n\n    var _super = RegExp.prototype;\n\n    var _groups = new WeakMap();\n\n    function BabelRegExp(re, groups) {\n      var _this = _RegExp.call(this, re);\n\n      _groups.set(_this, groups);\n\n      return _this;\n    }\n\n    _inherits(BabelRegExp, _RegExp);\n\n    BabelRegExp.prototype.exec = function(str) {\n      var result = _super.exec.call(this, str);\n\n      if (result) result.groups = buildGroups(result, this);\n      return result;\n    };\n\n    BabelRegExp.prototype[Symbol.replace] = function(str, substitution) {\n      if (typeof substitution === 'string') {\n        var groups = _groups.get(this);\n\n        return _super[Symbol.replace].call(\n          this,\n          str,\n          substitution.replace(/\\$<([^>]+)>/g, function(_, name) {\n            return '$' + groups[name];\n          })\n        );\n      } else if (typeof substitution === 'function') {\n        var _this = this;\n\n        return _super[Symbol.replace].call(this, str, function() {\n          var args = [];\n          args.push.apply(args, arguments);\n\n          if (typeof args[args.length - 1] !== 'object') {\n            args.push(buildGroups(args, _this));\n          }\n\n          return substitution.apply(this, args);\n        });\n      } else {\n        return _super[Symbol.replace].call(this, str, substitution);\n      }\n    };\n\n    function buildGroups(result, re) {\n      var g = _groups.get(re);\n\n      return Object.keys(g).reduce(function(groups, name) {\n        groups[name] = result[g[name]];\n        return groups;\n      }, Object.create(null));\n    }\n\n    return _wrapRegExp.apply(this, arguments);\n  }\n\n  var vectorMultiply = function vectorMultiply(v, amount) {\n    return createVector(v.x * amount, v.y * amount);\n  };\n\n  var vectorAdd = function vectorAdd(a, b) {\n    return createVector(a.x + b.x, a.y + b.y);\n  };\n\n  var vectorNormalize = function vectorNormalize(v) {\n    var l = Math.sqrt(v.x * v.x + v.y * v.y);\n    if (l === 0) {\n      return {\n        x: 0,\n        y: 0\n      };\n    }\n    return createVector(v.x / l, v.y / l);\n  };\n\n  var vectorRotate = function vectorRotate(v, radians, origin) {\n    var cos = Math.cos(radians);\n    var sin = Math.sin(radians);\n    var t = createVector(v.x - origin.x, v.y - origin.y);\n    return createVector(\n      origin.x + cos * t.x - sin * t.y,\n      origin.y + sin * t.x + cos * t.y\n    );\n  };\n\n  var createVector = function createVector() {\n    var x =\n      arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var y =\n      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    return { x: x, y: y };\n  };\n\n  var getMarkupValue = function getMarkupValue(value, size) {\n    var scalar =\n      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    var axis = arguments.length > 3 ? arguments[3] : undefined;\n    if (typeof value === 'string') {\n      return parseFloat(value) * scalar;\n    }\n    if (typeof value === 'number') {\n      return value * (axis ? size[axis] : Math.min(size.width, size.height));\n    }\n    return;\n  };\n\n  var getMarkupStyles = function getMarkupStyles(markup, size, scale) {\n    var lineStyle = markup.borderStyle || markup.lineStyle || 'solid';\n    var fill = markup.backgroundColor || markup.fontColor || 'transparent';\n    var stroke = markup.borderColor || markup.lineColor || 'transparent';\n    var strokeWidth = getMarkupValue(\n      markup.borderWidth || markup.lineWidth,\n      size,\n      scale\n    );\n    var lineCap = markup.lineCap || 'round';\n    var lineJoin = markup.lineJoin || 'round';\n    var dashes =\n      typeof lineStyle === 'string'\n        ? ''\n        : lineStyle\n            .map(function(v) {\n              return getMarkupValue(v, size, scale);\n            })\n            .join(',');\n    var opacity = markup.opacity || 1;\n    return {\n      'stroke-linecap': lineCap,\n      'stroke-linejoin': lineJoin,\n      'stroke-width': strokeWidth || 0,\n      'stroke-dasharray': dashes,\n      stroke: stroke,\n      fill: fill,\n      opacity: opacity\n    };\n  };\n\n  var isDefined = function isDefined(value) {\n    return value != null;\n  };\n\n  var getMarkupRect = function getMarkupRect(rect, size) {\n    var scalar =\n      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n\n    var left =\n      getMarkupValue(rect.x, size, scalar, 'width') ||\n      getMarkupValue(rect.left, size, scalar, 'width');\n    var top =\n      getMarkupValue(rect.y, size, scalar, 'height') ||\n      getMarkupValue(rect.top, size, scalar, 'height');\n    var width = getMarkupValue(rect.width, size, scalar, 'width');\n    var height = getMarkupValue(rect.height, size, scalar, 'height');\n    var right = getMarkupValue(rect.right, size, scalar, 'width');\n    var bottom = getMarkupValue(rect.bottom, size, scalar, 'height');\n\n    if (!isDefined(top)) {\n      if (isDefined(height) && isDefined(bottom)) {\n        top = size.height - height - bottom;\n      } else {\n        top = bottom;\n      }\n    }\n\n    if (!isDefined(left)) {\n      if (isDefined(width) && isDefined(right)) {\n        left = size.width - width - right;\n      } else {\n        left = right;\n      }\n    }\n\n    if (!isDefined(width)) {\n      if (isDefined(left) && isDefined(right)) {\n        width = size.width - left - right;\n      } else {\n        width = 0;\n      }\n    }\n\n    if (!isDefined(height)) {\n      if (isDefined(top) && isDefined(bottom)) {\n        height = size.height - top - bottom;\n      } else {\n        height = 0;\n      }\n    }\n\n    return {\n      x: left || 0,\n      y: top || 0,\n      width: width || 0,\n      height: height || 0\n    };\n  };\n\n  var pointsToPathShape = function pointsToPathShape(points) {\n    return points\n      .map(function(point, index) {\n        return ''\n          .concat(index === 0 ? 'M' : 'L', ' ')\n          .concat(point.x, ' ')\n          .concat(point.y);\n      })\n      .join(' ');\n  };\n\n  var setAttributes = function setAttributes(element, attr) {\n    return Object.keys(attr).forEach(function(key) {\n      return element.setAttribute(key, attr[key]);\n    });\n  };\n\n  var ns = 'http://www.w3.org/2000/svg';\n  var svg = function svg(tag, attr) {\n    var element = document.createElementNS(ns, tag);\n    if (attr) {\n      setAttributes(element, attr);\n    }\n    return element;\n  };\n\n  var updateRect = function updateRect(element) {\n    return setAttributes(\n      element,\n      Object.assign({}, element.rect, element.styles)\n    );\n  };\n\n  var updateEllipse = function updateEllipse(element) {\n    var cx = element.rect.x + element.rect.width * 0.5;\n    var cy = element.rect.y + element.rect.height * 0.5;\n    var rx = element.rect.width * 0.5;\n    var ry = element.rect.height * 0.5;\n    return setAttributes(\n      element,\n      Object.assign(\n        {\n          cx: cx,\n          cy: cy,\n          rx: rx,\n          ry: ry\n        },\n        element.styles\n      )\n    );\n  };\n\n  var IMAGE_FIT_STYLE = {\n    contain: 'xMidYMid meet',\n    cover: 'xMidYMid slice'\n  };\n\n  var updateImage = function updateImage(element, markup) {\n    setAttributes(\n      element,\n      Object.assign({}, element.rect, element.styles, {\n        preserveAspectRatio: IMAGE_FIT_STYLE[markup.fit] || 'none'\n      })\n    );\n  };\n\n  var TEXT_ANCHOR = {\n    left: 'start',\n    center: 'middle',\n    right: 'end'\n  };\n\n  var updateText = function updateText(element, markup, size, scale) {\n    var fontSize = getMarkupValue(markup.fontSize, size, scale);\n    var fontFamily = markup.fontFamily || 'sans-serif';\n    var fontWeight = markup.fontWeight || 'normal';\n    var textAlign = TEXT_ANCHOR[markup.textAlign] || 'start';\n\n    setAttributes(\n      element,\n      Object.assign({}, element.rect, element.styles, {\n        'stroke-width': 0,\n        'font-weight': fontWeight,\n        'font-size': fontSize,\n        'font-family': fontFamily,\n        'text-anchor': textAlign\n      })\n    );\n\n    // update text\n    if (element.text !== markup.text) {\n      element.text = markup.text;\n      element.textContent = markup.text.length ? markup.text : ' ';\n    }\n  };\n\n  var updateLine = function updateLine(element, markup, size, scale) {\n    setAttributes(\n      element,\n      Object.assign({}, element.rect, element.styles, {\n        fill: 'none'\n      })\n    );\n\n    var line = element.childNodes[0];\n    var begin = element.childNodes[1];\n    var end = element.childNodes[2];\n\n    var origin = element.rect;\n\n    var target = {\n      x: element.rect.x + element.rect.width,\n      y: element.rect.y + element.rect.height\n    };\n\n    setAttributes(line, {\n      x1: origin.x,\n      y1: origin.y,\n      x2: target.x,\n      y2: target.y\n    });\n\n    if (!markup.lineDecoration) return;\n\n    begin.style.display = 'none';\n    end.style.display = 'none';\n\n    var v = vectorNormalize({\n      x: target.x - origin.x,\n      y: target.y - origin.y\n    });\n\n    var l = getMarkupValue(0.05, size, scale);\n\n    if (markup.lineDecoration.indexOf('arrow-begin') !== -1) {\n      var arrowBeginRotationPoint = vectorMultiply(v, l);\n      var arrowBeginCenter = vectorAdd(origin, arrowBeginRotationPoint);\n      var arrowBeginA = vectorRotate(origin, 2, arrowBeginCenter);\n      var arrowBeginB = vectorRotate(origin, -2, arrowBeginCenter);\n\n      setAttributes(begin, {\n        style: 'display:block;',\n        d: 'M'\n          .concat(arrowBeginA.x, ',')\n          .concat(arrowBeginA.y, ' L')\n          .concat(origin.x, ',')\n          .concat(origin.y, ' L')\n          .concat(arrowBeginB.x, ',')\n          .concat(arrowBeginB.y)\n      });\n    }\n\n    if (markup.lineDecoration.indexOf('arrow-end') !== -1) {\n      var arrowEndRotationPoint = vectorMultiply(v, -l);\n      var arrowEndCenter = vectorAdd(target, arrowEndRotationPoint);\n      var arrowEndA = vectorRotate(target, 2, arrowEndCenter);\n      var arrowEndB = vectorRotate(target, -2, arrowEndCenter);\n\n      setAttributes(end, {\n        style: 'display:block;',\n        d: 'M'\n          .concat(arrowEndA.x, ',')\n          .concat(arrowEndA.y, ' L')\n          .concat(target.x, ',')\n          .concat(target.y, ' L')\n          .concat(arrowEndB.x, ',')\n          .concat(arrowEndB.y)\n      });\n    }\n  };\n\n  var updatePath = function updatePath(element, markup, size, scale) {\n    setAttributes(\n      element,\n      Object.assign({}, element.styles, {\n        fill: 'none',\n        d: pointsToPathShape(\n          markup.points.map(function(point) {\n            return {\n              x: getMarkupValue(point.x, size, scale, 'width'),\n              y: getMarkupValue(point.y, size, scale, 'height')\n            };\n          })\n        )\n      })\n    );\n  };\n\n  var createShape = function createShape(node) {\n    return function(markup) {\n      return svg(node, { id: markup.id });\n    };\n  };\n\n  var createImage = function createImage(markup) {\n    var shape = svg('image', {\n      id: markup.id,\n      'stroke-linecap': 'round',\n      'stroke-linejoin': 'round',\n      opacity: '0'\n    });\n\n    shape.onload = function() {\n      shape.setAttribute('opacity', markup.opacity || 1);\n    };\n    shape.setAttributeNS(\n      'http://www.w3.org/1999/xlink',\n      'xlink:href',\n      markup.src\n    );\n    return shape;\n  };\n\n  var createLine = function createLine(markup) {\n    var shape = svg('g', {\n      id: markup.id,\n      'stroke-linecap': 'round',\n      'stroke-linejoin': 'round'\n    });\n\n    var line = svg('line');\n    shape.appendChild(line);\n\n    var begin = svg('path');\n    shape.appendChild(begin);\n\n    var end = svg('path');\n    shape.appendChild(end);\n\n    return shape;\n  };\n\n  var CREATE_TYPE_ROUTES = {\n    image: createImage,\n    rect: createShape('rect'),\n    ellipse: createShape('ellipse'),\n    text: createShape('text'),\n    path: createShape('path'),\n    line: createLine\n  };\n\n  var UPDATE_TYPE_ROUTES = {\n    rect: updateRect,\n    ellipse: updateEllipse,\n    image: updateImage,\n    text: updateText,\n    path: updatePath,\n    line: updateLine\n  };\n\n  var createMarkupByType = function createMarkupByType(type, markup) {\n    return CREATE_TYPE_ROUTES[type](markup);\n  };\n\n  var updateMarkupByType = function updateMarkupByType(\n    element,\n    type,\n    markup,\n    size,\n    scale\n  ) {\n    if (type !== 'path') {\n      element.rect = getMarkupRect(markup, size, scale);\n    }\n    element.styles = getMarkupStyles(markup, size, scale);\n    UPDATE_TYPE_ROUTES[type](element, markup, size, scale);\n  };\n\n  var MARKUP_RECT = [\n    'x',\n    'y',\n    'left',\n    'top',\n    'right',\n    'bottom',\n    'width',\n    'height'\n  ];\n\n  var toOptionalFraction = function toOptionalFraction(value) {\n    return typeof value === 'string' && /%/.test(value)\n      ? parseFloat(value) / 100\n      : value;\n  };\n\n  // adds default markup properties, clones markup\n  var prepareMarkup = function prepareMarkup(markup) {\n    var _markup = _slicedToArray(markup, 2),\n      type = _markup[0],\n      props = _markup[1];\n\n    var rect = props.points\n      ? {}\n      : MARKUP_RECT.reduce(function(prev, curr) {\n          prev[curr] = toOptionalFraction(props[curr]);\n          return prev;\n        }, {});\n\n    return [\n      type,\n      Object.assign(\n        {\n          zIndex: 0\n        },\n        props,\n        rect\n      )\n    ];\n  };\n\n  var sortMarkupByZIndex = function sortMarkupByZIndex(a, b) {\n    if (a[1].zIndex > b[1].zIndex) {\n      return 1;\n    }\n    if (a[1].zIndex < b[1].zIndex) {\n      return -1;\n    }\n    return 0;\n  };\n\n  var createMarkupView = function createMarkupView(_) {\n    return _.utils.createView({\n      name: 'image-preview-markup',\n      tag: 'svg',\n      ignoreRect: true,\n      mixins: {\n        apis: ['width', 'height', 'crop', 'markup', 'resize', 'dirty']\n      },\n\n      write: function write(_ref) {\n        var root = _ref.root,\n          props = _ref.props;\n\n        if (!props.dirty) return;\n        var crop = props.crop,\n          resize = props.resize,\n          markup = props.markup;\n\n        var viewWidth = props.width;\n        var viewHeight = props.height;\n\n        var cropWidth = crop.width;\n        var cropHeight = crop.height;\n\n        if (resize) {\n          var _size = resize.size;\n\n          var outputWidth = _size && _size.width;\n          var outputHeight = _size && _size.height;\n          var outputFit = resize.mode;\n          var outputUpscale = resize.upscale;\n\n          if (outputWidth && !outputHeight) outputHeight = outputWidth;\n          if (outputHeight && !outputWidth) outputWidth = outputHeight;\n\n          var shouldUpscale =\n            cropWidth < outputWidth && cropHeight < outputHeight;\n\n          if (!shouldUpscale || (shouldUpscale && outputUpscale)) {\n            var scalarWidth = outputWidth / cropWidth;\n            var scalarHeight = outputHeight / cropHeight;\n\n            if (outputFit === 'force') {\n              cropWidth = outputWidth;\n              cropHeight = outputHeight;\n            } else {\n              var scalar;\n              if (outputFit === 'cover') {\n                scalar = Math.max(scalarWidth, scalarHeight);\n              } else if (outputFit === 'contain') {\n                scalar = Math.min(scalarWidth, scalarHeight);\n              }\n              cropWidth = cropWidth * scalar;\n              cropHeight = cropHeight * scalar;\n            }\n          }\n        }\n\n        var size = {\n          width: viewWidth,\n          height: viewHeight\n        };\n\n        root.element.setAttribute('width', size.width);\n        root.element.setAttribute('height', size.height);\n\n        var scale = Math.min(viewWidth / cropWidth, viewHeight / cropHeight);\n\n        // clear\n        root.element.innerHTML = '';\n\n        // get filter\n        var markupFilter = root.query('GET_IMAGE_PREVIEW_MARKUP_FILTER');\n\n        // draw new\n        markup\n          .filter(markupFilter)\n          .map(prepareMarkup)\n          .sort(sortMarkupByZIndex)\n          .forEach(function(markup) {\n            var _markup = _slicedToArray(markup, 2),\n              type = _markup[0],\n              settings = _markup[1];\n\n            // create\n            var element = createMarkupByType(type, settings);\n\n            // update\n            updateMarkupByType(element, type, settings, size, scale);\n\n            // add\n            root.element.appendChild(element);\n          });\n      }\n    });\n  };\n\n  var createVector$1 = function createVector(x, y) {\n    return { x: x, y: y };\n  };\n\n  var vectorDot = function vectorDot(a, b) {\n    return a.x * b.x + a.y * b.y;\n  };\n\n  var vectorSubtract = function vectorSubtract(a, b) {\n    return createVector$1(a.x - b.x, a.y - b.y);\n  };\n\n  var vectorDistanceSquared = function vectorDistanceSquared(a, b) {\n    return vectorDot(vectorSubtract(a, b), vectorSubtract(a, b));\n  };\n\n  var vectorDistance = function vectorDistance(a, b) {\n    return Math.sqrt(vectorDistanceSquared(a, b));\n  };\n\n  var getOffsetPointOnEdge = function getOffsetPointOnEdge(length, rotation) {\n    var a = length;\n\n    var A = 1.5707963267948966;\n    var B = rotation;\n    var C = 1.5707963267948966 - rotation;\n\n    var sinA = Math.sin(A);\n    var sinB = Math.sin(B);\n    var sinC = Math.sin(C);\n    var cosC = Math.cos(C);\n    var ratio = a / sinA;\n    var b = ratio * sinB;\n    var c = ratio * sinC;\n\n    return createVector$1(cosC * b, cosC * c);\n  };\n\n  var getRotatedRectSize = function getRotatedRectSize(rect, rotation) {\n    var w = rect.width;\n    var h = rect.height;\n\n    var hor = getOffsetPointOnEdge(w, rotation);\n    var ver = getOffsetPointOnEdge(h, rotation);\n\n    var tl = createVector$1(rect.x + Math.abs(hor.x), rect.y - Math.abs(hor.y));\n\n    var tr = createVector$1(\n      rect.x + rect.width + Math.abs(ver.y),\n      rect.y + Math.abs(ver.x)\n    );\n\n    var bl = createVector$1(\n      rect.x - Math.abs(ver.y),\n      rect.y + rect.height - Math.abs(ver.x)\n    );\n\n    return {\n      width: vectorDistance(tl, tr),\n      height: vectorDistance(tl, bl)\n    };\n  };\n\n  var calculateCanvasSize = function calculateCanvasSize(\n    image,\n    canvasAspectRatio\n  ) {\n    var zoom =\n      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n\n    var imageAspectRatio = image.height / image.width;\n\n    // determine actual pixels on x and y axis\n    var canvasWidth = 1;\n    var canvasHeight = canvasAspectRatio;\n    var imgWidth = 1;\n    var imgHeight = imageAspectRatio;\n    if (imgHeight > canvasHeight) {\n      imgHeight = canvasHeight;\n      imgWidth = imgHeight / imageAspectRatio;\n    }\n\n    var scalar = Math.max(canvasWidth / imgWidth, canvasHeight / imgHeight);\n    var width = image.width / (zoom * scalar * imgWidth);\n    var height = width * canvasAspectRatio;\n\n    return {\n      width: width,\n      height: height\n    };\n  };\n\n  var getImageRectZoomFactor = function getImageRectZoomFactor(\n    imageRect,\n    cropRect,\n    rotation,\n    center\n  ) {\n    // calculate available space round image center position\n    var cx = center.x > 0.5 ? 1 - center.x : center.x;\n    var cy = center.y > 0.5 ? 1 - center.y : center.y;\n    var imageWidth = cx * 2 * imageRect.width;\n    var imageHeight = cy * 2 * imageRect.height;\n\n    // calculate rotated crop rectangle size\n    var rotatedCropSize = getRotatedRectSize(cropRect, rotation);\n\n    // calculate scalar required to fit image\n    return Math.max(\n      rotatedCropSize.width / imageWidth,\n      rotatedCropSize.height / imageHeight\n    );\n  };\n\n  var getCenteredCropRect = function getCenteredCropRect(\n    container,\n    aspectRatio\n  ) {\n    var width = container.width;\n    var height = width * aspectRatio;\n    if (height > container.height) {\n      height = container.height;\n      width = height / aspectRatio;\n    }\n    var x = (container.width - width) * 0.5;\n    var y = (container.height - height) * 0.5;\n\n    return {\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    };\n  };\n\n  var getCurrentCropSize = function getCurrentCropSize(imageSize) {\n    var crop =\n      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var zoom = crop.zoom,\n      rotation = crop.rotation,\n      center = crop.center,\n      aspectRatio = crop.aspectRatio;\n\n    if (!aspectRatio) aspectRatio = imageSize.height / imageSize.width;\n\n    var canvasSize = calculateCanvasSize(imageSize, aspectRatio, zoom);\n\n    var canvasCenter = {\n      x: canvasSize.width * 0.5,\n      y: canvasSize.height * 0.5\n    };\n\n    var stage = {\n      x: 0,\n      y: 0,\n      width: canvasSize.width,\n      height: canvasSize.height,\n      center: canvasCenter\n    };\n\n    var shouldLimit = typeof crop.scaleToFit === 'undefined' || crop.scaleToFit;\n\n    var stageZoomFactor = getImageRectZoomFactor(\n      imageSize,\n      getCenteredCropRect(stage, aspectRatio),\n      rotation,\n      shouldLimit ? center : { x: 0.5, y: 0.5 }\n    );\n\n    var scale = zoom * stageZoomFactor;\n\n    // start drawing\n    return {\n      widthFloat: canvasSize.width / scale,\n      heightFloat: canvasSize.height / scale,\n      width: Math.round(canvasSize.width / scale),\n      height: Math.round(canvasSize.height / scale)\n    };\n  };\n\n  var IMAGE_SCALE_SPRING_PROPS = {\n    type: 'spring',\n    stiffness: 0.5,\n    damping: 0.45,\n    mass: 10\n  };\n\n  // does horizontal and vertical flipping\n  var createBitmapView = function createBitmapView(_) {\n    return _.utils.createView({\n      name: 'image-bitmap',\n      ignoreRect: true,\n      mixins: { styles: ['scaleX', 'scaleY'] },\n      create: function create(_ref) {\n        var root = _ref.root,\n          props = _ref.props;\n        root.appendChild(props.image);\n      }\n    });\n  };\n\n  // shifts and rotates image\n  var createImageCanvasWrapper = function createImageCanvasWrapper(_) {\n    return _.utils.createView({\n      name: 'image-canvas-wrapper',\n      tag: 'div',\n      ignoreRect: true,\n      mixins: {\n        apis: ['crop', 'width', 'height'],\n\n        styles: [\n          'originX',\n          'originY',\n          'translateX',\n          'translateY',\n          'scaleX',\n          'scaleY',\n          'rotateZ'\n        ],\n\n        animations: {\n          originX: IMAGE_SCALE_SPRING_PROPS,\n          originY: IMAGE_SCALE_SPRING_PROPS,\n          scaleX: IMAGE_SCALE_SPRING_PROPS,\n          scaleY: IMAGE_SCALE_SPRING_PROPS,\n          translateX: IMAGE_SCALE_SPRING_PROPS,\n          translateY: IMAGE_SCALE_SPRING_PROPS,\n          rotateZ: IMAGE_SCALE_SPRING_PROPS\n        }\n      },\n\n      create: function create(_ref2) {\n        var root = _ref2.root,\n          props = _ref2.props;\n        props.width = props.image.width;\n        props.height = props.image.height;\n        root.ref.bitmap = root.appendChildView(\n          root.createChildView(createBitmapView(_), { image: props.image })\n        );\n      },\n      write: function write(_ref3) {\n        var root = _ref3.root,\n          props = _ref3.props;\n        var flip = props.crop.flip;\n        var bitmap = root.ref.bitmap;\n        bitmap.scaleX = flip.horizontal ? -1 : 1;\n        bitmap.scaleY = flip.vertical ? -1 : 1;\n      }\n    });\n  };\n\n  // clips canvas to correct aspect ratio\n  var createClipView = function createClipView(_) {\n    return _.utils.createView({\n      name: 'image-clip',\n      tag: 'div',\n      ignoreRect: true,\n      mixins: {\n        apis: [\n          'crop',\n          'markup',\n          'resize',\n          'width',\n          'height',\n          'dirty',\n          'background'\n        ],\n\n        styles: ['width', 'height', 'opacity'],\n        animations: {\n          opacity: { type: 'tween', duration: 250 }\n        }\n      },\n\n      didWriteView: function didWriteView(_ref4) {\n        var root = _ref4.root,\n          props = _ref4.props;\n        if (!props.background) return;\n        root.element.style.backgroundColor = props.background;\n      },\n      create: function create(_ref5) {\n        var root = _ref5.root,\n          props = _ref5.props;\n\n        root.ref.image = root.appendChildView(\n          root.createChildView(\n            createImageCanvasWrapper(_),\n            Object.assign({}, props)\n          )\n        );\n\n        root.ref.createMarkup = function() {\n          if (root.ref.markup) return;\n          root.ref.markup = root.appendChildView(\n            root.createChildView(createMarkupView(_), Object.assign({}, props))\n          );\n        };\n\n        root.ref.destroyMarkup = function() {\n          if (!root.ref.markup) return;\n          root.removeChildView(root.ref.markup);\n          root.ref.markup = null;\n        };\n\n        // set up transparency grid\n        var transparencyIndicator = root.query(\n          'GET_IMAGE_PREVIEW_TRANSPARENCY_INDICATOR'\n        );\n        if (transparencyIndicator === null) return;\n\n        // grid pattern\n        if (transparencyIndicator === 'grid') {\n          root.element.dataset.transparencyIndicator = transparencyIndicator;\n        }\n        // basic color\n        else {\n          root.element.dataset.transparencyIndicator = 'color';\n        }\n      },\n      write: function write(_ref6) {\n        var root = _ref6.root,\n          props = _ref6.props,\n          shouldOptimize = _ref6.shouldOptimize;\n        var crop = props.crop,\n          markup = props.markup,\n          resize = props.resize,\n          dirty = props.dirty,\n          width = props.width,\n          height = props.height;\n\n        root.ref.image.crop = crop;\n\n        var stage = {\n          x: 0,\n          y: 0,\n          width: width,\n          height: height,\n          center: {\n            x: width * 0.5,\n            y: height * 0.5\n          }\n        };\n\n        var image = {\n          width: root.ref.image.width,\n          height: root.ref.image.height\n        };\n\n        var origin = {\n          x: crop.center.x * image.width,\n          y: crop.center.y * image.height\n        };\n\n        var translation = {\n          x: stage.center.x - image.width * crop.center.x,\n          y: stage.center.y - image.height * crop.center.y\n        };\n\n        var rotation = Math.PI * 2 + (crop.rotation % (Math.PI * 2));\n\n        var cropAspectRatio = crop.aspectRatio || image.height / image.width;\n\n        var shouldLimit =\n          typeof crop.scaleToFit === 'undefined' || crop.scaleToFit;\n\n        var stageZoomFactor = getImageRectZoomFactor(\n          image,\n          getCenteredCropRect(stage, cropAspectRatio),\n\n          rotation,\n          shouldLimit ? crop.center : { x: 0.5, y: 0.5 }\n        );\n\n        var scale = crop.zoom * stageZoomFactor;\n\n        // update markup view\n        if (markup && markup.length) {\n          root.ref.createMarkup();\n          root.ref.markup.width = width;\n          root.ref.markup.height = height;\n          root.ref.markup.resize = resize;\n          root.ref.markup.dirty = dirty;\n          root.ref.markup.markup = markup;\n          root.ref.markup.crop = getCurrentCropSize(image, crop);\n        } else if (root.ref.markup) {\n          root.ref.destroyMarkup();\n        }\n\n        // update image view\n        var imageView = root.ref.image;\n\n        // don't update clip layout\n        if (shouldOptimize) {\n          imageView.originX = null;\n          imageView.originY = null;\n          imageView.translateX = null;\n          imageView.translateY = null;\n          imageView.rotateZ = null;\n          imageView.scaleX = null;\n          imageView.scaleY = null;\n          return;\n        }\n\n        imageView.originX = origin.x;\n        imageView.originY = origin.y;\n        imageView.translateX = translation.x;\n        imageView.translateY = translation.y;\n        imageView.rotateZ = rotation;\n        imageView.scaleX = scale;\n        imageView.scaleY = scale;\n      }\n    });\n  };\n\n  var createImageView = function createImageView(_) {\n    return _.utils.createView({\n      name: 'image-preview',\n      tag: 'div',\n      ignoreRect: true,\n      mixins: {\n        apis: ['image', 'crop', 'markup', 'resize', 'dirty', 'background'],\n\n        styles: ['translateY', 'scaleX', 'scaleY', 'opacity'],\n\n        animations: {\n          scaleX: IMAGE_SCALE_SPRING_PROPS,\n          scaleY: IMAGE_SCALE_SPRING_PROPS,\n          translateY: IMAGE_SCALE_SPRING_PROPS,\n          opacity: { type: 'tween', duration: 400 }\n        }\n      },\n\n      create: function create(_ref7) {\n        var root = _ref7.root,\n          props = _ref7.props;\n        root.ref.clip = root.appendChildView(\n          root.createChildView(createClipView(_), {\n            id: props.id,\n            image: props.image,\n            crop: props.crop,\n            markup: props.markup,\n            resize: props.resize,\n            dirty: props.dirty,\n            background: props.background\n          })\n        );\n      },\n      write: function write(_ref8) {\n        var root = _ref8.root,\n          props = _ref8.props,\n          shouldOptimize = _ref8.shouldOptimize;\n        var clip = root.ref.clip;\n        var image = props.image,\n          crop = props.crop,\n          markup = props.markup,\n          resize = props.resize,\n          dirty = props.dirty;\n\n        clip.crop = crop;\n        clip.markup = markup;\n        clip.resize = resize;\n        clip.dirty = dirty;\n\n        // don't update clip layout\n        clip.opacity = shouldOptimize ? 0 : 1;\n\n        // don't re-render if optimizing or hidden (width will be zero resulting in weird animations)\n        if (shouldOptimize || root.rect.element.hidden) return;\n\n        // calculate scaled preview image size\n        var imageAspectRatio = image.height / image.width;\n        var aspectRatio = crop.aspectRatio || imageAspectRatio;\n\n        // calculate container size\n        var containerWidth = root.rect.inner.width;\n        var containerHeight = root.rect.inner.height;\n\n        var fixedPreviewHeight = root.query('GET_IMAGE_PREVIEW_HEIGHT');\n        var minPreviewHeight = root.query('GET_IMAGE_PREVIEW_MIN_HEIGHT');\n        var maxPreviewHeight = root.query('GET_IMAGE_PREVIEW_MAX_HEIGHT');\n\n        var panelAspectRatio = root.query('GET_PANEL_ASPECT_RATIO');\n        var allowMultiple = root.query('GET_ALLOW_MULTIPLE');\n\n        if (panelAspectRatio && !allowMultiple) {\n          fixedPreviewHeight = containerWidth * panelAspectRatio;\n          aspectRatio = panelAspectRatio;\n        }\n\n        // determine clip width and height\n        var clipHeight =\n          fixedPreviewHeight !== null\n            ? fixedPreviewHeight\n            : Math.max(\n                minPreviewHeight,\n                Math.min(containerWidth * aspectRatio, maxPreviewHeight)\n              );\n\n        var clipWidth = clipHeight / aspectRatio;\n        if (clipWidth > containerWidth) {\n          clipWidth = containerWidth;\n          clipHeight = clipWidth * aspectRatio;\n        }\n\n        if (clipHeight > containerHeight) {\n          clipHeight = containerHeight;\n          clipWidth = containerHeight / aspectRatio;\n        }\n\n        clip.width = clipWidth;\n        clip.height = clipHeight;\n      }\n    });\n  };\n\n  var SVG_MASK =\n    '<svg width=\"500\" height=\"200\" viewBox=\"0 0 500 200\" preserveAspectRatio=\"none\">\\n    <defs>\\n        <radialGradient id=\"gradient-__UID__\" cx=\".5\" cy=\"1.25\" r=\"1.15\">\\n            <stop offset=\\'50%\\' stop-color=\\'#000000\\'/>\\n            <stop offset=\\'56%\\' stop-color=\\'#0a0a0a\\'/>\\n            <stop offset=\\'63%\\' stop-color=\\'#262626\\'/>\\n            <stop offset=\\'69%\\' stop-color=\\'#4f4f4f\\'/>\\n            <stop offset=\\'75%\\' stop-color=\\'#808080\\'/>\\n            <stop offset=\\'81%\\' stop-color=\\'#b1b1b1\\'/>\\n            <stop offset=\\'88%\\' stop-color=\\'#dadada\\'/>\\n            <stop offset=\\'94%\\' stop-color=\\'#f6f6f6\\'/>\\n            <stop offset=\\'100%\\' stop-color=\\'#ffffff\\'/>\\n        </radialGradient>\\n        <mask id=\"mask-__UID__\">\\n            <rect x=\"0\" y=\"0\" width=\"500\" height=\"200\" fill=\"url(#gradient-__UID__)\"></rect>\\n        </mask>\\n    </defs>\\n    <rect x=\"0\" width=\"500\" height=\"200\" fill=\"currentColor\" mask=\"url(#mask-__UID__)\"></rect>\\n</svg>';\n\n  var checkedMyBases = false;\n  var SVGMaskUniqueId = 0;\n\n  var createImageOverlayView = function createImageOverlayView(fpAPI) {\n    return fpAPI.utils.createView({\n      name: 'image-preview-overlay',\n      tag: 'div',\n      ignoreRect: true,\n      create: function create(_ref) {\n        var root = _ref.root,\n          props = _ref.props;\n\n        if (!checkedMyBases && document.querySelector('base')) {\n          SVG_MASK = SVG_MASK.replace(\n            /url\\(\\#/g,\n            'url(' +\n              window.location.href.replace(window.location.hash, '') +\n              '#'\n          );\n          checkedMyBases = true;\n        }\n\n        SVGMaskUniqueId++;\n        root.element.classList.add(\n          'filepond--image-preview-overlay-'.concat(props.status)\n        );\n        root.element.innerHTML = SVG_MASK.replace(/__UID__/g, SVGMaskUniqueId);\n      },\n      mixins: {\n        styles: ['opacity'],\n        animations: {\n          opacity: { type: 'spring', mass: 25 }\n        }\n      }\n    });\n  };\n\n  /**\n   * Bitmap Worker\n   */\n  var BitmapWorker = function BitmapWorker() {\n    self.onmessage = function(e) {\n      createImageBitmap(e.data.message.file).then(function(bitmap) {\n        self.postMessage({ id: e.data.id, message: bitmap }, [bitmap]);\n      });\n    };\n  };\n\n  /**\n   * ColorMatrix Worker\n   */\n  var ColorMatrixWorker = function ColorMatrixWorker() {\n    self.onmessage = function(e) {\n      var imageData = e.data.message.imageData;\n      var matrix = e.data.message.colorMatrix;\n\n      var data = imageData.data;\n      var l = data.length;\n\n      var m11 = matrix[0];\n      var m12 = matrix[1];\n      var m13 = matrix[2];\n      var m14 = matrix[3];\n      var m15 = matrix[4];\n\n      var m21 = matrix[5];\n      var m22 = matrix[6];\n      var m23 = matrix[7];\n      var m24 = matrix[8];\n      var m25 = matrix[9];\n\n      var m31 = matrix[10];\n      var m32 = matrix[11];\n      var m33 = matrix[12];\n      var m34 = matrix[13];\n      var m35 = matrix[14];\n\n      var m41 = matrix[15];\n      var m42 = matrix[16];\n      var m43 = matrix[17];\n      var m44 = matrix[18];\n      var m45 = matrix[19];\n\n      var index = 0,\n        r = 0.0,\n        g = 0.0,\n        b = 0.0,\n        a = 0.0;\n\n      for (; index < l; index += 4) {\n        r = data[index] / 255;\n        g = data[index + 1] / 255;\n        b = data[index + 2] / 255;\n        a = data[index + 3] / 255;\n        data[index] = Math.max(\n          0,\n          Math.min((r * m11 + g * m12 + b * m13 + a * m14 + m15) * 255, 255)\n        );\n        data[index + 1] = Math.max(\n          0,\n          Math.min((r * m21 + g * m22 + b * m23 + a * m24 + m25) * 255, 255)\n        );\n        data[index + 2] = Math.max(\n          0,\n          Math.min((r * m31 + g * m32 + b * m33 + a * m34 + m35) * 255, 255)\n        );\n        data[index + 3] = Math.max(\n          0,\n          Math.min((r * m41 + g * m42 + b * m43 + a * m44 + m45) * 255, 255)\n        );\n      }\n\n      self.postMessage({ id: e.data.id, message: imageData }, [\n        imageData.data.buffer\n      ]);\n    };\n  };\n\n  var getImageSize = function getImageSize(url, cb) {\n    var image = new Image();\n    image.onload = function() {\n      var width = image.naturalWidth;\n      var height = image.naturalHeight;\n      image = null;\n      cb(width, height);\n    };\n    image.src = url;\n  };\n\n  var transforms = {\n    1: function _() {\n      return [1, 0, 0, 1, 0, 0];\n    },\n    2: function _(width) {\n      return [-1, 0, 0, 1, width, 0];\n    },\n    3: function _(width, height) {\n      return [-1, 0, 0, -1, width, height];\n    },\n    4: function _(width, height) {\n      return [1, 0, 0, -1, 0, height];\n    },\n    5: function _() {\n      return [0, 1, 1, 0, 0, 0];\n    },\n    6: function _(width, height) {\n      return [0, 1, -1, 0, height, 0];\n    },\n    7: function _(width, height) {\n      return [0, -1, -1, 0, height, width];\n    },\n    8: function _(width) {\n      return [0, -1, 1, 0, 0, width];\n    }\n  };\n\n  var fixImageOrientation = function fixImageOrientation(\n    ctx,\n    width,\n    height,\n    orientation\n  ) {\n    // no orientation supplied\n    if (orientation === -1) {\n      return;\n    }\n\n    ctx.transform.apply(ctx, transforms[orientation](width, height));\n  };\n\n  // draws the preview image to canvas\n  var createPreviewImage = function createPreviewImage(\n    data,\n    width,\n    height,\n    orientation\n  ) {\n    // can't draw on half pixels\n    width = Math.round(width);\n    height = Math.round(height);\n\n    // draw image\n    var canvas = document.createElement('canvas');\n    canvas.width = width;\n    canvas.height = height;\n    var ctx = canvas.getContext('2d');\n\n    // if is rotated incorrectly swap width and height\n    if (orientation >= 5 && orientation <= 8) {\n      var _ref = [height, width];\n      width = _ref[0];\n      height = _ref[1];\n    }\n\n    // correct image orientation\n    fixImageOrientation(ctx, width, height, orientation);\n\n    // draw the image\n    ctx.drawImage(data, 0, 0, width, height);\n\n    return canvas;\n  };\n\n  var isBitmap = function isBitmap(file) {\n    return /^image/.test(file.type) && !/svg/.test(file.type);\n  };\n\n  var MAX_WIDTH = 10;\n  var MAX_HEIGHT = 10;\n\n  var calculateAverageColor = function calculateAverageColor(image) {\n    var scalar = Math.min(MAX_WIDTH / image.width, MAX_HEIGHT / image.height);\n\n    var canvas = document.createElement('canvas');\n    var ctx = canvas.getContext('2d');\n    var width = (canvas.width = Math.ceil(image.width * scalar));\n    var height = (canvas.height = Math.ceil(image.height * scalar));\n    ctx.drawImage(image, 0, 0, width, height);\n    var data = null;\n    try {\n      data = ctx.getImageData(0, 0, width, height).data;\n    } catch (e) {\n      return null;\n    }\n    var l = data.length;\n\n    var r = 0;\n    var g = 0;\n    var b = 0;\n    var i = 0;\n\n    for (; i < l; i += 4) {\n      r += data[i] * data[i];\n      g += data[i + 1] * data[i + 1];\n      b += data[i + 2] * data[i + 2];\n    }\n\n    r = averageColor(r, l);\n    g = averageColor(g, l);\n    b = averageColor(b, l);\n\n    return { r: r, g: g, b: b };\n  };\n\n  var averageColor = function averageColor(c, l) {\n    return Math.floor(Math.sqrt(c / (l / 4)));\n  };\n\n  var cloneCanvas = function cloneCanvas(origin, target) {\n    target = target || document.createElement('canvas');\n    target.width = origin.width;\n    target.height = origin.height;\n    var ctx = target.getContext('2d');\n    ctx.drawImage(origin, 0, 0);\n    return target;\n  };\n\n  var cloneImageData = function cloneImageData(imageData) {\n    var id;\n    try {\n      id = new ImageData(imageData.width, imageData.height);\n    } catch (e) {\n      var canvas = document.createElement('canvas');\n      var ctx = canvas.getContext('2d');\n      id = ctx.createImageData(imageData.width, imageData.height);\n    }\n    id.data.set(new Uint8ClampedArray(imageData.data));\n    return id;\n  };\n\n  var loadImage = function loadImage(url) {\n    return new Promise(function(resolve, reject) {\n      var img = new Image();\n      img.crossOrigin = 'Anonymous';\n      img.onload = function() {\n        resolve(img);\n      };\n      img.onerror = function(e) {\n        reject(e);\n      };\n      img.src = url;\n    });\n  };\n\n  var createImageWrapperView = function createImageWrapperView(_) {\n    // create overlay view\n    var OverlayView = createImageOverlayView(_);\n\n    var ImageView = createImageView(_);\n    var createWorker = _.utils.createWorker;\n\n    var applyFilter = function applyFilter(root, filter, target) {\n      return new Promise(function(resolve) {\n        // will store image data for future filter updates\n        if (!root.ref.imageData) {\n          root.ref.imageData = target\n            .getContext('2d')\n            .getImageData(0, 0, target.width, target.height);\n        }\n\n        // get image data reference\n        var imageData = cloneImageData(root.ref.imageData);\n\n        if (!filter || filter.length !== 20) {\n          target.getContext('2d').putImageData(imageData, 0, 0);\n          return resolve();\n        }\n\n        var worker = createWorker(ColorMatrixWorker);\n        worker.post(\n          {\n            imageData: imageData,\n            colorMatrix: filter\n          },\n\n          function(response) {\n            // apply filtered colors\n            target.getContext('2d').putImageData(response, 0, 0);\n\n            // stop worker\n            worker.terminate();\n\n            // done!\n            resolve();\n          },\n          [imageData.data.buffer]\n        );\n      });\n    };\n\n    var removeImageView = function removeImageView(root, imageView) {\n      root.removeChildView(imageView);\n      imageView.image.width = 1;\n      imageView.image.height = 1;\n      imageView._destroy();\n    };\n\n    // remove an image\n    var shiftImage = function shiftImage(_ref) {\n      var root = _ref.root;\n      var imageView = root.ref.images.shift();\n      imageView.opacity = 0;\n      imageView.translateY = -15;\n      root.ref.imageViewBin.push(imageView);\n      return imageView;\n    };\n\n    // add new image\n    var pushImage = function pushImage(_ref2) {\n      var root = _ref2.root,\n        props = _ref2.props,\n        image = _ref2.image;\n\n      var id = props.id;\n      var item = root.query('GET_ITEM', { id: id });\n      if (!item) return;\n\n      var crop = item.getMetadata('crop') || {\n        center: {\n          x: 0.5,\n          y: 0.5\n        },\n\n        flip: {\n          horizontal: false,\n          vertical: false\n        },\n\n        zoom: 1,\n        rotation: 0,\n        aspectRatio: null\n      };\n\n      var background = root.query(\n        'GET_IMAGE_TRANSFORM_CANVAS_BACKGROUND_COLOR'\n      );\n\n      var markup;\n      var resize;\n      var dirty = false;\n      if (root.query('GET_IMAGE_PREVIEW_MARKUP_SHOW')) {\n        markup = item.getMetadata('markup') || [];\n        resize = item.getMetadata('resize');\n        dirty = true;\n      }\n\n      // append image presenter\n      var imageView = root.appendChildView(\n        root.createChildView(ImageView, {\n          id: id,\n          image: image,\n          crop: crop,\n          resize: resize,\n          markup: markup,\n          dirty: dirty,\n          background: background,\n          opacity: 0,\n          scaleX: 1.15,\n          scaleY: 1.15,\n          translateY: 15\n        }),\n\n        root.childViews.length\n      );\n\n      root.ref.images.push(imageView);\n\n      // reveal the preview image\n      imageView.opacity = 1;\n      imageView.scaleX = 1;\n      imageView.scaleY = 1;\n      imageView.translateY = 0;\n\n      // the preview is now ready to be drawn\n      setTimeout(function() {\n        root.dispatch('DID_IMAGE_PREVIEW_SHOW', { id: id });\n      }, 250);\n    };\n\n    var updateImage = function updateImage(_ref3) {\n      var root = _ref3.root,\n        props = _ref3.props;\n      var item = root.query('GET_ITEM', { id: props.id });\n      if (!item) return;\n      var imageView = root.ref.images[root.ref.images.length - 1];\n      imageView.crop = item.getMetadata('crop');\n      imageView.background = root.query(\n        'GET_IMAGE_TRANSFORM_CANVAS_BACKGROUND_COLOR'\n      );\n      if (root.query('GET_IMAGE_PREVIEW_MARKUP_SHOW')) {\n        imageView.dirty = true;\n        imageView.resize = item.getMetadata('resize');\n        imageView.markup = item.getMetadata('markup');\n      }\n    };\n\n    // replace image preview\n    var didUpdateItemMetadata = function didUpdateItemMetadata(_ref4) {\n      var root = _ref4.root,\n        props = _ref4.props,\n        action = _ref4.action;\n\n      // only filter and crop trigger redraw\n      if (!/crop|filter|markup|resize/.test(action.change.key)) return;\n\n      // no images to update, exit\n      if (!root.ref.images.length) return;\n\n      // no item found, exit\n      var item = root.query('GET_ITEM', { id: props.id });\n      if (!item) return;\n\n      // for now, update existing image when filtering\n      if (/filter/.test(action.change.key)) {\n        var imageView = root.ref.images[root.ref.images.length - 1];\n        applyFilter(root, action.change.value, imageView.image);\n        return;\n      }\n\n      if (/crop|markup|resize/.test(action.change.key)) {\n        var crop = item.getMetadata('crop');\n        var image = root.ref.images[root.ref.images.length - 1];\n\n        // if aspect ratio has changed, we need to create a new image\n        if (Math.abs(crop.aspectRatio - image.crop.aspectRatio) > 0.00001) {\n          var _imageView = shiftImage({ root: root });\n          pushImage({\n            root: root,\n            props: props,\n            image: cloneCanvas(_imageView.image)\n          });\n        }\n        // if not, we can update the current image\n        else {\n          updateImage({ root: root, props: props });\n        }\n      }\n    };\n\n    var canCreateImageBitmap = function canCreateImageBitmap(file) {\n      // Firefox versions before 58 will freeze when running createImageBitmap\n      // in a Web Worker so we detect those versions and return false for support\n      var userAgent = window.navigator.userAgent;\n      var isFirefox = userAgent.match(/Firefox\\/([0-9]+)\\./);\n      var firefoxVersion = isFirefox ? parseInt(isFirefox[1]) : null;\n      if (firefoxVersion <= 58) return false;\n\n      return 'createImageBitmap' in window && isBitmap(file);\n    };\n\n    /**\n     * Write handler for when preview container has been created\n     */\n    var didCreatePreviewContainer = function didCreatePreviewContainer(_ref5) {\n      var root = _ref5.root,\n        props = _ref5.props;\n      var id = props.id;\n\n      // we need to get the file data to determine the eventual image size\n      var item = root.query('GET_ITEM', id);\n      if (!item) return;\n\n      // get url to file (we'll revoke it later on when done)\n      var fileURL = URL.createObjectURL(item.file);\n\n      // determine image size of this item\n      getImageSize(fileURL, function(width, height) {\n        // we can now scale the panel to the final size\n        root.dispatch('DID_IMAGE_PREVIEW_CALCULATE_SIZE', {\n          id: id,\n          width: width,\n          height: height\n        });\n      });\n    };\n\n    var drawPreview = function drawPreview(_ref6) {\n      var root = _ref6.root,\n        props = _ref6.props;\n      var id = props.id;\n\n      // we need to get the file data to determine the eventual image size\n      var item = root.query('GET_ITEM', id);\n      if (!item) return;\n\n      // get url to file (we'll revoke it later on when done)\n      var fileURL = URL.createObjectURL(item.file);\n\n      // fallback\n      var loadPreviewFallback = function loadPreviewFallback() {\n        // let's scale the image in the main thread :(\n        loadImage(fileURL).then(previewImageLoaded);\n      };\n\n      // image is now ready\n      var previewImageLoaded = function previewImageLoaded(imageData) {\n        // the file url is no longer needed\n        URL.revokeObjectURL(fileURL);\n\n        // draw the scaled down version here and use that as source so bitmapdata can be closed\n        // orientation info\n        var exif = item.getMetadata('exif') || {};\n        var orientation = exif.orientation || -1;\n\n        // get width and height from action, and swap if orientation is incorrect\n        var width = imageData.width,\n          height = imageData.height;\n        if (orientation >= 5 && orientation <= 8) {\n          var _ref7 = [height, width];\n          width = _ref7[0];\n          height = _ref7[1];\n        }\n\n        // scale canvas based on pixel density\n        // we multiply by .75 as that creates smaller but still clear images on screens with high res displays\n        var pixelDensityFactor = Math.max(1, window.devicePixelRatio * 0.75);\n\n        // we want as much pixels to work with as possible,\n        // this multiplies the minimum image resolution,\n        // so when zooming in it doesn't get too blurry\n        var zoomFactor = root.query('GET_IMAGE_PREVIEW_ZOOM_FACTOR');\n\n        // imaeg scale factor\n        var scaleFactor = zoomFactor * pixelDensityFactor;\n\n        // calculate scaled preview image size\n        var previewImageRatio = height / width;\n\n        // calculate image preview height and width\n        var previewContainerWidth = root.rect.element.width;\n        var previewContainerHeight = root.rect.element.height;\n\n        var imageWidth = previewContainerWidth;\n        var imageHeight = imageWidth * previewImageRatio;\n\n        if (previewImageRatio > 1) {\n          imageWidth = Math.min(width, previewContainerWidth * scaleFactor);\n          imageHeight = imageWidth * previewImageRatio;\n        } else {\n          imageHeight = Math.min(height, previewContainerHeight * scaleFactor);\n          imageWidth = imageHeight / previewImageRatio;\n        }\n\n        // transfer to image tag so no canvas memory wasted on iOS\n        var previewImage = createPreviewImage(\n          imageData,\n          imageWidth,\n          imageHeight,\n          orientation\n        );\n\n        // done\n        var done = function done() {\n          // calculate average image color, disabled for now\n          var averageColor = root.query(\n            'GET_IMAGE_PREVIEW_CALCULATE_AVERAGE_IMAGE_COLOR'\n          )\n            ? calculateAverageColor(data)\n            : null;\n          item.setMetadata('color', averageColor, true);\n\n          // data has been transferred to canvas ( if was ImageBitmap )\n          if ('close' in imageData) {\n            imageData.close();\n          }\n\n          // show the overlay\n          root.ref.overlayShadow.opacity = 1;\n\n          // create the first image\n          pushImage({ root: root, props: props, image: previewImage });\n        };\n\n        // apply filter\n        var filter = item.getMetadata('filter');\n        if (filter) {\n          applyFilter(root, filter, previewImage).then(done);\n        } else {\n          done();\n        }\n      };\n\n      // if we support scaling using createImageBitmap we use a worker\n      if (canCreateImageBitmap(item.file)) {\n        // let's scale the image in a worker\n        var worker = createWorker(BitmapWorker);\n\n        worker.post(\n          {\n            file: item.file\n          },\n\n          function(imageBitmap) {\n            // destroy worker\n            worker.terminate();\n\n            // no bitmap returned, must be something wrong,\n            // try the oldschool way\n            if (!imageBitmap) {\n              loadPreviewFallback();\n              return;\n            }\n\n            // yay we got our bitmap, let's continue showing the preview\n            previewImageLoaded(imageBitmap);\n          }\n        );\n      } else {\n        // create fallback preview\n        loadPreviewFallback();\n      }\n    };\n\n    /**\n     * Write handler for when the preview image is ready to be animated\n     */\n    var didDrawPreview = function didDrawPreview(_ref8) {\n      var root = _ref8.root;\n      // get last added image\n      var image = root.ref.images[root.ref.images.length - 1];\n      image.translateY = 0;\n      image.scaleX = 1.0;\n      image.scaleY = 1.0;\n      image.opacity = 1;\n    };\n\n    /**\n     * Write handler for when the preview has been loaded\n     */\n    var restoreOverlay = function restoreOverlay(_ref9) {\n      var root = _ref9.root;\n      root.ref.overlayShadow.opacity = 1;\n      root.ref.overlayError.opacity = 0;\n      root.ref.overlaySuccess.opacity = 0;\n    };\n\n    var didThrowError = function didThrowError(_ref10) {\n      var root = _ref10.root;\n      root.ref.overlayShadow.opacity = 0.25;\n      root.ref.overlayError.opacity = 1;\n    };\n\n    var didCompleteProcessing = function didCompleteProcessing(_ref11) {\n      var root = _ref11.root;\n      root.ref.overlayShadow.opacity = 0.25;\n      root.ref.overlaySuccess.opacity = 1;\n    };\n\n    /**\n     * Constructor\n     */\n    var create = function create(_ref12) {\n      var root = _ref12.root;\n\n      // image view\n      root.ref.images = [];\n\n      // the preview image data (we need this to filter the image)\n      root.ref.imageData = null;\n\n      // image bin\n      root.ref.imageViewBin = [];\n\n      // image overlays\n      root.ref.overlayShadow = root.appendChildView(\n        root.createChildView(OverlayView, {\n          opacity: 0,\n          status: 'idle'\n        })\n      );\n\n      root.ref.overlaySuccess = root.appendChildView(\n        root.createChildView(OverlayView, {\n          opacity: 0,\n          status: 'success'\n        })\n      );\n\n      root.ref.overlayError = root.appendChildView(\n        root.createChildView(OverlayView, {\n          opacity: 0,\n          status: 'failure'\n        })\n      );\n    };\n\n    return _.utils.createView({\n      name: 'image-preview-wrapper',\n      create: create,\n      styles: ['height'],\n\n      apis: ['height'],\n\n      destroy: function destroy(_ref13) {\n        var root = _ref13.root;\n        // we resize the image so memory on iOS 12 is released more quickly (it seems)\n        root.ref.images.forEach(function(imageView) {\n          imageView.image.width = 1;\n          imageView.image.height = 1;\n        });\n      },\n      didWriteView: function didWriteView(_ref14) {\n        var root = _ref14.root;\n        root.ref.images.forEach(function(imageView) {\n          imageView.dirty = false;\n        });\n      },\n      write: _.utils.createRoute(\n        {\n          // image preview stated\n          DID_IMAGE_PREVIEW_DRAW: didDrawPreview,\n          DID_IMAGE_PREVIEW_CONTAINER_CREATE: didCreatePreviewContainer,\n          DID_FINISH_CALCULATE_PREVIEWSIZE: drawPreview,\n          DID_UPDATE_ITEM_METADATA: didUpdateItemMetadata,\n\n          // file states\n          DID_THROW_ITEM_LOAD_ERROR: didThrowError,\n          DID_THROW_ITEM_PROCESSING_ERROR: didThrowError,\n          DID_THROW_ITEM_INVALID: didThrowError,\n          DID_COMPLETE_ITEM_PROCESSING: didCompleteProcessing,\n          DID_START_ITEM_PROCESSING: restoreOverlay,\n          DID_REVERT_ITEM_PROCESSING: restoreOverlay\n        },\n        function(_ref15) {\n          var root = _ref15.root;\n\n          // views on death row\n          var viewsToRemove = root.ref.imageViewBin.filter(function(imageView) {\n            return imageView.opacity === 0;\n          });\n\n          // views to retain\n          root.ref.imageViewBin = root.ref.imageViewBin.filter(function(\n            imageView\n          ) {\n            return imageView.opacity > 0;\n          });\n\n          // remove these views\n          viewsToRemove.forEach(function(imageView) {\n            return removeImageView(root, imageView);\n          });\n          viewsToRemove.length = 0;\n        }\n      )\n    });\n  };\n\n  /**\n   * Image Preview Plugin\n   */\n  var plugin = function plugin(fpAPI) {\n    var addFilter = fpAPI.addFilter,\n      utils = fpAPI.utils;\n    var Type = utils.Type,\n      createRoute = utils.createRoute,\n      isFile = utils.isFile;\n\n    // imagePreviewView\n    var imagePreviewView = createImageWrapperView(fpAPI);\n\n    // called for each view that is created right after the 'create' method\n    addFilter('CREATE_VIEW', function(viewAPI) {\n      // get reference to created view\n      var is = viewAPI.is,\n        view = viewAPI.view,\n        query = viewAPI.query;\n\n      // only hook up to item view and only if is enabled for this cropper\n      if (!is('file') || !query('GET_ALLOW_IMAGE_PREVIEW')) return;\n\n      // create the image preview plugin, but only do so if the item is an image\n      var didLoadItem = function didLoadItem(_ref) {\n        var root = _ref.root,\n          props = _ref.props;\n        var id = props.id;\n        var item = query('GET_ITEM', id);\n\n        // item could theoretically have been removed in the mean time\n        if (!item || !isFile(item.file) || item.archived) return;\n\n        // get the file object\n        var file = item.file;\n\n        // exit if this is not an image\n        if (!isPreviewableImage(file)) return;\n\n        // test if is filtered\n        if (!query('GET_IMAGE_PREVIEW_FILTER_ITEM')(item)) return;\n\n        // exit if image size is too high and no createImageBitmap support\n        // this would simply bring the browser to its knees and that is not what we want\n        var supportsCreateImageBitmap = 'createImageBitmap' in (window || {});\n        var maxPreviewFileSize = query('GET_IMAGE_PREVIEW_MAX_FILE_SIZE');\n        if (\n          !supportsCreateImageBitmap &&\n          maxPreviewFileSize &&\n          file.size > maxPreviewFileSize\n        )\n          return;\n\n        // set preview view\n        root.ref.imagePreview = view.appendChildView(\n          view.createChildView(imagePreviewView, { id: id })\n        );\n\n        // update height if is fixed\n        var fixedPreviewHeight = root.query('GET_IMAGE_PREVIEW_HEIGHT');\n        if (fixedPreviewHeight) {\n          root.dispatch('DID_UPDATE_PANEL_HEIGHT', {\n            id: item.id,\n            height: fixedPreviewHeight\n          });\n        }\n\n        // now ready\n        var queue =\n          !supportsCreateImageBitmap &&\n          file.size > query('GET_IMAGE_PREVIEW_MAX_INSTANT_PREVIEW_FILE_SIZE');\n        root.dispatch('DID_IMAGE_PREVIEW_CONTAINER_CREATE', { id: id }, queue);\n      };\n\n      var rescaleItem = function rescaleItem(root, props) {\n        if (!root.ref.imagePreview) return;\n        var id = props.id;\n\n        // get item\n        var item = root.query('GET_ITEM', { id: id });\n        if (!item) return;\n\n        // if is fixed height or panel has aspect ratio, exit here, height has already been defined\n        var panelAspectRatio = root.query('GET_PANEL_ASPECT_RATIO');\n        var itemPanelAspectRatio = root.query('GET_ITEM_PANEL_ASPECT_RATIO');\n        var fixedHeight = root.query('GET_IMAGE_PREVIEW_HEIGHT');\n        if (panelAspectRatio || itemPanelAspectRatio || fixedHeight) return;\n\n        // no data!\n        var _root$ref = root.ref,\n          imageWidth = _root$ref.imageWidth,\n          imageHeight = _root$ref.imageHeight;\n        if (!imageWidth || !imageHeight) return;\n\n        // get height min and max\n        var minPreviewHeight = root.query('GET_IMAGE_PREVIEW_MIN_HEIGHT');\n        var maxPreviewHeight = root.query('GET_IMAGE_PREVIEW_MAX_HEIGHT');\n\n        // orientation info\n        var exif = item.getMetadata('exif') || {};\n        var orientation = exif.orientation || -1;\n\n        // get width and height from action, and swap of orientation is incorrect\n        if (orientation >= 5 && orientation <= 8) {\n          var _ref2 = [imageHeight, imageWidth];\n          imageWidth = _ref2[0];\n          imageHeight = _ref2[1];\n        }\n\n        // scale up width and height when we're dealing with an SVG\n        if (!isBitmap(item.file) || root.query('GET_IMAGE_PREVIEW_UPSCALE')) {\n          var scalar = 2048 / imageWidth;\n          imageWidth *= scalar;\n          imageHeight *= scalar;\n        }\n\n        // image aspect ratio\n        var imageAspectRatio = imageHeight / imageWidth;\n\n        // we need the item to get to the crop size\n        var previewAspectRatio =\n          (item.getMetadata('crop') || {}).aspectRatio || imageAspectRatio;\n\n        // preview height range\n        var previewHeightMax = Math.max(\n          minPreviewHeight,\n          Math.min(imageHeight, maxPreviewHeight)\n        );\n        var itemWidth = root.rect.element.width;\n        var previewHeight = Math.min(\n          itemWidth * previewAspectRatio,\n          previewHeightMax\n        );\n\n        // request update to panel height\n        root.dispatch('DID_UPDATE_PANEL_HEIGHT', {\n          id: item.id,\n          height: previewHeight\n        });\n      };\n\n      var didResizeView = function didResizeView(_ref3) {\n        var root = _ref3.root;\n        // actions in next write operation\n        root.ref.shouldRescale = true;\n      };\n\n      var didUpdateItemMetadata = function didUpdateItemMetadata(_ref4) {\n        var root = _ref4.root,\n          action = _ref4.action;\n\n        if (action.change.key !== 'crop') return;\n\n        // actions in next write operation\n        root.ref.shouldRescale = true;\n      };\n\n      var didCalculatePreviewSize = function didCalculatePreviewSize(_ref5) {\n        var root = _ref5.root,\n          action = _ref5.action;\n\n        // remember dimensions\n        root.ref.imageWidth = action.width;\n        root.ref.imageHeight = action.height;\n\n        // actions in next write operation\n        root.ref.shouldRescale = true;\n        root.ref.shouldDrawPreview = true;\n\n        // as image load could take a while and fire when draw loop is resting we need to give it a kick\n        root.dispatch('KICK');\n      };\n\n      // start writing\n      view.registerWriter(\n        createRoute(\n          {\n            DID_RESIZE_ROOT: didResizeView,\n            DID_STOP_RESIZE: didResizeView,\n            DID_LOAD_ITEM: didLoadItem,\n            DID_IMAGE_PREVIEW_CALCULATE_SIZE: didCalculatePreviewSize,\n            DID_UPDATE_ITEM_METADATA: didUpdateItemMetadata\n          },\n          function(_ref6) {\n            var root = _ref6.root,\n              props = _ref6.props;\n\n            // no preview view attached\n            if (!root.ref.imagePreview) return;\n\n            // don't do anything while hidden\n            if (root.rect.element.hidden) return;\n\n            // resize the item panel\n            if (root.ref.shouldRescale) {\n              rescaleItem(root, props);\n              root.ref.shouldRescale = false;\n            }\n\n            if (root.ref.shouldDrawPreview) {\n              // queue till next frame so we're sure the height has been applied this forces the draw image call inside the wrapper view to use the correct height\n              requestAnimationFrame(function() {\n                root.dispatch('DID_FINISH_CALCULATE_PREVIEWSIZE', {\n                  id: props.id\n                });\n              });\n              root.ref.shouldDrawPreview = false;\n            }\n          }\n        )\n      );\n    });\n\n    // expose plugin\n    return {\n      options: {\n        // Enable or disable image preview\n        allowImagePreview: [true, Type.BOOLEAN],\n\n        // filters file items to determine which are shown as preview\n        imagePreviewFilterItem: [\n          function() {\n            return true;\n          },\n          Type.FUNCTION\n        ],\n\n        // Fixed preview height\n        imagePreviewHeight: [null, Type.INT],\n\n        // Min image height\n        imagePreviewMinHeight: [44, Type.INT],\n\n        // Max image height\n        imagePreviewMaxHeight: [256, Type.INT],\n\n        // Max size of preview file for when createImageBitmap is not supported\n        imagePreviewMaxFileSize: [null, Type.INT],\n\n        // The amount of extra pixels added to the image preview to allow comfortable zooming\n        imagePreviewZoomFactor: [2, Type.INT],\n\n        // Should we upscale small images to fit the max bounding box of the preview area\n        imagePreviewUpscale: [false, Type.BOOLEAN],\n\n        // Max size of preview file that we allow to try to instant preview if createImageBitmap is not supported, else image is queued for loading\n        imagePreviewMaxInstantPreviewFileSize: [1000000, Type.INT],\n\n        // Style of the transparancy indicator used behind images\n        imagePreviewTransparencyIndicator: [null, Type.STRING],\n\n        // Enables or disables reading average image color\n        imagePreviewCalculateAverageImageColor: [false, Type.BOOLEAN],\n\n        // Enables or disables the previewing of markup\n        imagePreviewMarkupShow: [true, Type.BOOLEAN],\n\n        // Allows filtering of markup to only show certain shapes\n        imagePreviewMarkupFilter: [\n          function() {\n            return true;\n          },\n          Type.FUNCTION\n        ]\n      }\n    };\n  };\n\n  // fire pluginloaded event if running in browser, this allows registering the plugin when using async script tags\n  var isBrowser =\n    typeof window !== 'undefined' && typeof window.document !== 'undefined';\n  if (isBrowser) {\n    document.dispatchEvent(\n      new CustomEvent('FilePond:pluginloaded', { detail: plugin })\n    );\n  }\n\n  return plugin;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmlsZXBvbmQtcGx1Z2luLWltYWdlLXByZXZpZXcvZGlzdC9maWxlcG9uZC1wbHVnaW4taW1hZ2UtcHJldmlldy5qcz8yY2ZjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxFQUFFLEtBQTREO0FBQzlEO0FBQ0EsTUFBTSxTQUdnRDtBQUN0RCxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBLHFCQUFxQixvQkFBb0I7QUFDekM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEscUJBQXFCLDBCQUEwQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsdUJBQXVCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQiw2QkFBNkI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbURBQW1ELGdCQUFnQjtBQUNuRTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixtQkFBbUI7QUFDeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsMkJBQTJCLHNCQUFzQjtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsMkNBQTJDLFFBQVE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMkJBQTJCLHlCQUF5QjtBQUNwRCxpQ0FBaUMscUJBQXFCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixxQkFBcUI7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBSTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsK0JBQStCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQscUJBQXFCO0FBQzFFO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUM7QUFDdkM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixpQ0FBaUM7QUFDM0QsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0Isb0NBQW9DO0FBQzVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxPQUFPO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlDQUF5QyxTQUFTO0FBQ2xEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaURBQWlELFNBQVM7QUFDMUQsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxlQUFlO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHlDQUF5QyxlQUFlO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVDQUF1QyxhQUFhO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwyQkFBMkI7QUFDbEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsZ0RBQWdEO0FBQ3JFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0RBQWtELFNBQVM7QUFDM0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELFNBQVM7QUFDdEU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDLFNBQVM7QUFDcEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5Q0FBeUM7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsaUJBQWlCO0FBQ2pFO0FBQ0E7O0FBRUE7QUFDQSxDQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2ZpbGVwb25kLXBsdWdpbi1pbWFnZS1wcmV2aWV3L2Rpc3QvZmlsZXBvbmQtcGx1Z2luLWltYWdlLXByZXZpZXcuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEZpbGVQb25kUGx1Z2luSW1hZ2VQcmV2aWV3IDQuNi40XG4gKiBMaWNlbnNlZCB1bmRlciBNSVQsIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUL1xuICogUGxlYXNlIHZpc2l0IGh0dHBzOi8vcHFpbmEubmwvZmlsZXBvbmQvIGZvciBkZXRhaWxzLlxuICovXG5cbi8qIGVzbGludC1kaXNhYmxlICovXG5cbihmdW5jdGlvbihnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXG4gICAgPyAobW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkpXG4gICAgOiB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWRcbiAgICA/IGRlZmluZShmYWN0b3J5KVxuICAgIDogKChnbG9iYWwgPSBnbG9iYWwgfHwgc2VsZiksXG4gICAgICAoZ2xvYmFsLkZpbGVQb25kUGx1Z2luSW1hZ2VQcmV2aWV3ID0gZmFjdG9yeSgpKSk7XG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIHRlc3QgaWYgZmlsZSBpcyBvZiB0eXBlIGltYWdlIGFuZCBjYW4gYmUgdmlld2VkIGluIGNhbnZhc1xuICB2YXIgaXNQcmV2aWV3YWJsZUltYWdlID0gZnVuY3Rpb24gaXNQcmV2aWV3YWJsZUltYWdlKGZpbGUpIHtcbiAgICByZXR1cm4gL15pbWFnZS8udGVzdChmaWxlLnR5cGUpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgIF90eXBlb2YgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBfdHlwZW9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogJiZcbiAgICAgICAgICB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiZcbiAgICAgICAgICBvYmogIT09IFN5bWJvbC5wcm90b3R5cGVcbiAgICAgICAgICA/ICdzeW1ib2wnXG4gICAgICAgICAgOiB0eXBlb2Ygb2JqO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3R5cGVvZihvYmopO1xuICB9XG5cbiAgdmFyIFJFQUNUX0VMRU1FTlRfVFlQRTtcblxuICBmdW5jdGlvbiBfanN4KHR5cGUsIHByb3BzLCBrZXksIGNoaWxkcmVuKSB7XG4gICAgaWYgKCFSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgIFJFQUNUX0VMRU1FTlRfVFlQRSA9XG4gICAgICAgICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgU3ltYm9sLmZvciAmJlxuICAgICAgICAgIFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSkgfHxcbiAgICAgICAgMHhlYWM3O1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzO1xuICAgIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAzO1xuXG4gICAgaWYgKCFwcm9wcyAmJiBjaGlsZHJlbkxlbmd0aCAhPT0gMCkge1xuICAgICAgcHJvcHMgPSB7XG4gICAgICAgIGNoaWxkcmVuOiB2b2lkIDBcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHByb3BzICYmIGRlZmF1bHRQcm9wcykge1xuICAgICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHZvaWQgMCkge1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFwcm9wcykge1xuICAgICAgcHJvcHMgPSBkZWZhdWx0UHJvcHMgfHwge307XG4gICAgfVxuXG4gICAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgICB2YXIgY2hpbGRBcnJheSA9IG5ldyBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAzXTtcbiAgICAgIH1cblxuICAgICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgICAgdHlwZTogdHlwZSxcbiAgICAgIGtleToga2V5ID09PSB1bmRlZmluZWQgPyBudWxsIDogJycgKyBrZXksXG4gICAgICByZWY6IG51bGwsXG4gICAgICBwcm9wczogcHJvcHMsXG4gICAgICBfb3duZXI6IG51bGxcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gX2FzeW5jSXRlcmF0b3IoaXRlcmFibGUpIHtcbiAgICB2YXIgbWV0aG9kO1xuXG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChTeW1ib2wuYXN5bmNJdGVyYXRvcikge1xuICAgICAgICBtZXRob2QgPSBpdGVyYWJsZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl07XG4gICAgICAgIGlmIChtZXRob2QgIT0gbnVsbCkgcmV0dXJuIG1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKFN5bWJvbC5pdGVyYXRvcikge1xuICAgICAgICBtZXRob2QgPSBpdGVyYWJsZVtTeW1ib2wuaXRlcmF0b3JdO1xuICAgICAgICBpZiAobWV0aG9kICE9IG51bGwpIHJldHVybiBtZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0IGlzIG5vdCBhc3luYyBpdGVyYWJsZScpO1xuICB9XG5cbiAgZnVuY3Rpb24gX0F3YWl0VmFsdWUodmFsdWUpIHtcbiAgICB0aGlzLndyYXBwZWQgPSB2YWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9Bc3luY0dlbmVyYXRvcihnZW4pIHtcbiAgICB2YXIgZnJvbnQsIGJhY2s7XG5cbiAgICBmdW5jdGlvbiBzZW5kKGtleSwgYXJnKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciByZXF1ZXN0ID0ge1xuICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgIGFyZzogYXJnLFxuICAgICAgICAgIHJlc29sdmU6IHJlc29sdmUsXG4gICAgICAgICAgcmVqZWN0OiByZWplY3QsXG4gICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChiYWNrKSB7XG4gICAgICAgICAgYmFjayA9IGJhY2submV4dCA9IHJlcXVlc3Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZnJvbnQgPSBiYWNrID0gcmVxdWVzdDtcbiAgICAgICAgICByZXN1bWUoa2V5LCBhcmcpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXN1bWUoa2V5LCBhcmcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBnZW5ba2V5XShhcmcpO1xuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIHZhciB3cmFwcGVkQXdhaXQgPSB2YWx1ZSBpbnN0YW5jZW9mIF9Bd2FpdFZhbHVlO1xuICAgICAgICBQcm9taXNlLnJlc29sdmUod3JhcHBlZEF3YWl0ID8gdmFsdWUud3JhcHBlZCA6IHZhbHVlKS50aGVuKFxuICAgICAgICAgIGZ1bmN0aW9uKGFyZykge1xuICAgICAgICAgICAgaWYgKHdyYXBwZWRBd2FpdCkge1xuICAgICAgICAgICAgICByZXN1bWUoJ25leHQnLCBhcmcpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNldHRsZShyZXN1bHQuZG9uZSA/ICdyZXR1cm4nIDogJ25vcm1hbCcsIGFyZyk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIHJlc3VtZSgndGhyb3cnLCBlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBzZXR0bGUoJ3Rocm93JywgZXJyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXR0bGUodHlwZSwgdmFsdWUpIHtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdyZXR1cm4nOlxuICAgICAgICAgIGZyb250LnJlc29sdmUoe1xuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3Rocm93JzpcbiAgICAgICAgICBmcm9udC5yZWplY3QodmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgZnJvbnQucmVzb2x2ZSh7XG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBmcm9udCA9IGZyb250Lm5leHQ7XG5cbiAgICAgIGlmIChmcm9udCkge1xuICAgICAgICByZXN1bWUoZnJvbnQua2V5LCBmcm9udC5hcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmFjayA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5faW52b2tlID0gc2VuZDtcblxuICAgIGlmICh0eXBlb2YgZ2VuLnJldHVybiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5yZXR1cm4gPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHtcbiAgICBfQXN5bmNHZW5lcmF0b3IucHJvdG90eXBlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgfVxuXG4gIF9Bc3luY0dlbmVyYXRvci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB0aGlzLl9pbnZva2UoJ25leHQnLCBhcmcpO1xuICB9O1xuXG4gIF9Bc3luY0dlbmVyYXRvci5wcm90b3R5cGUudGhyb3cgPSBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdGhpcy5faW52b2tlKCd0aHJvdycsIGFyZyk7XG4gIH07XG5cbiAgX0FzeW5jR2VuZXJhdG9yLnByb3RvdHlwZS5yZXR1cm4gPSBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdGhpcy5faW52b2tlKCdyZXR1cm4nLCBhcmcpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIF93cmFwQXN5bmNHZW5lcmF0b3IoZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IF9Bc3luY0dlbmVyYXRvcihmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gX2F3YWl0QXN5bmNHZW5lcmF0b3IodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IF9Bd2FpdFZhbHVlKHZhbHVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9hc3luY0dlbmVyYXRvckRlbGVnYXRlKGlubmVyLCBhd2FpdFdyYXApIHtcbiAgICB2YXIgaXRlciA9IHt9LFxuICAgICAgd2FpdGluZyA9IGZhbHNlO1xuXG4gICAgZnVuY3Rpb24gcHVtcChrZXksIHZhbHVlKSB7XG4gICAgICB3YWl0aW5nID0gdHJ1ZTtcbiAgICAgIHZhbHVlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICByZXNvbHZlKGlubmVyW2tleV0odmFsdWUpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBhd2FpdFdyYXAodmFsdWUpXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcikge1xuICAgICAgaXRlcltTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBpdGVyLm5leHQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKHdhaXRpbmcpIHtcbiAgICAgICAgd2FpdGluZyA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwdW1wKCduZXh0JywgdmFsdWUpO1xuICAgIH07XG5cbiAgICBpZiAodHlwZW9mIGlubmVyLnRocm93ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpdGVyLnRocm93ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKHdhaXRpbmcpIHtcbiAgICAgICAgICB3YWl0aW5nID0gZmFsc2U7XG4gICAgICAgICAgdGhyb3cgdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcHVtcCgndGhyb3cnLCB2YWx1ZSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5uZXIucmV0dXJuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpdGVyLnJldHVybiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBwdW1wKCdyZXR1cm4nLCB2YWx1ZSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBpdGVyO1xuICB9XG5cbiAgZnVuY3Rpb24gYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBrZXksIGFyZykge1xuICAgIHRyeSB7XG4gICAgICB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7XG4gICAgICB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTtcblxuICAgICAgICBmdW5jdGlvbiBfbmV4dCh2YWx1ZSkge1xuICAgICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChcbiAgICAgICAgICAgIGdlbixcbiAgICAgICAgICAgIHJlc29sdmUsXG4gICAgICAgICAgICByZWplY3QsXG4gICAgICAgICAgICBfbmV4dCxcbiAgICAgICAgICAgIF90aHJvdyxcbiAgICAgICAgICAgICduZXh0JyxcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIF90aHJvdyhlcnIpIHtcbiAgICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csICd0aHJvdycsIGVycik7XG4gICAgICAgIH1cblxuICAgICAgICBfbmV4dCh1bmRlZmluZWQpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9kZWZpbmVFbnVtZXJhYmxlUHJvcGVydGllcyhvYmosIGRlc2NzKSB7XG4gICAgZm9yICh2YXIga2V5IGluIGRlc2NzKSB7XG4gICAgICB2YXIgZGVzYyA9IGRlc2NzW2tleV07XG4gICAgICBkZXNjLmNvbmZpZ3VyYWJsZSA9IGRlc2MuZW51bWVyYWJsZSA9IHRydWU7XG4gICAgICBpZiAoJ3ZhbHVlJyBpbiBkZXNjKSBkZXNjLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgZGVzYyk7XG4gICAgfVxuXG4gICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICAgIHZhciBvYmplY3RTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhkZXNjcyk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0U3ltYm9scy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc3ltID0gb2JqZWN0U3ltYm9sc1tpXTtcbiAgICAgICAgdmFyIGRlc2MgPSBkZXNjc1tzeW1dO1xuICAgICAgICBkZXNjLmNvbmZpZ3VyYWJsZSA9IGRlc2MuZW51bWVyYWJsZSA9IHRydWU7XG4gICAgICAgIGlmICgndmFsdWUnIGluIGRlc2MpIGRlc2Mud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBzeW0sIGRlc2MpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICBmdW5jdGlvbiBfZGVmYXVsdHMob2JqLCBkZWZhdWx0cykge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZGVmYXVsdHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgIHZhciB2YWx1ZSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZGVmYXVsdHMsIGtleSk7XG5cbiAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS5jb25maWd1cmFibGUgJiYgb2JqW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gICAgX2V4dGVuZHMgPVxuICAgICAgT2JqZWN0LmFzc2lnbiB8fFxuICAgICAgZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgIH07XG5cbiAgICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuICAgICAgdmFyIG93bktleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuXG4gICAgICBpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb3duS2V5cyA9IG93bktleXMuY29uY2F0KFxuICAgICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKS5maWx0ZXIoZnVuY3Rpb24oc3ltKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIHN5bSkuZW51bWVyYWJsZTtcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBvd25LZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICAgIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbicpO1xuICAgIH1cblxuICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG4gIH1cblxuICBmdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO1xuICAgIHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzO1xuICAgIHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG4gIH1cblxuICBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZlxuICAgICAgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2ZcbiAgICAgIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICAgICAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICAgICAgICB9O1xuICAgIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH1cblxuICBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIF9zZXRQcm90b3R5cGVPZiA9XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgIGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgICAgIG8uX19wcm90b19fID0gcDtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgICB9O1xuXG4gICAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09ICd1bmRlZmluZWQnIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiBQcm94eSA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHRydWU7XG5cbiAgICB0cnkge1xuICAgICAgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24oKSB7fSkpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykge1xuICAgIGlmIChpc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSkge1xuICAgICAgX2NvbnN0cnVjdCA9IFJlZmxlY3QuY29uc3RydWN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBfY29uc3RydWN0ID0gZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7XG4gICAgICAgIHZhciBhID0gW251bGxdO1xuICAgICAgICBhLnB1c2guYXBwbHkoYSwgYXJncyk7XG4gICAgICAgIHZhciBDb25zdHJ1Y3RvciA9IEZ1bmN0aW9uLmJpbmQuYXBwbHkoUGFyZW50LCBhKTtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gbmV3IENvbnN0cnVjdG9yKCk7XG4gICAgICAgIGlmIChDbGFzcykgX3NldFByb3RvdHlwZU9mKGluc3RhbmNlLCBDbGFzcy5wcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBfY29uc3RydWN0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBmdW5jdGlvbiBfaXNOYXRpdmVGdW5jdGlvbihmbikge1xuICAgIHJldHVybiBGdW5jdGlvbi50b1N0cmluZy5jYWxsKGZuKS5pbmRleE9mKCdbbmF0aXZlIGNvZGVdJykgIT09IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykge1xuICAgIHZhciBfY2FjaGUgPSB0eXBlb2YgTWFwID09PSAnZnVuY3Rpb24nID8gbmV3IE1hcCgpIDogdW5kZWZpbmVkO1xuXG4gICAgX3dyYXBOYXRpdmVTdXBlciA9IGZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHtcbiAgICAgIGlmIChDbGFzcyA9PT0gbnVsbCB8fCAhX2lzTmF0aXZlRnVuY3Rpb24oQ2xhc3MpKSByZXR1cm4gQ2xhc3M7XG5cbiAgICAgIGlmICh0eXBlb2YgQ2xhc3MgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAnU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24nXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgX2NhY2hlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpZiAoX2NhY2hlLmhhcyhDbGFzcykpIHJldHVybiBfY2FjaGUuZ2V0KENsYXNzKTtcblxuICAgICAgICBfY2FjaGUuc2V0KENsYXNzLCBXcmFwcGVyKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gV3JhcHBlcigpIHtcbiAgICAgICAgcmV0dXJuIF9jb25zdHJ1Y3QoQ2xhc3MsIGFyZ3VtZW50cywgX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yKTtcbiAgICAgIH1cblxuICAgICAgV3JhcHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENsYXNzLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgIHZhbHVlOiBXcmFwcGVyLFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YoV3JhcHBlciwgQ2xhc3MpO1xuICAgIH07XG5cbiAgICByZXR1cm4gX3dyYXBOYXRpdmVTdXBlcihDbGFzcyk7XG4gIH1cblxuICBmdW5jdGlvbiBfaW5zdGFuY2VvZihsZWZ0LCByaWdodCkge1xuICAgIGlmIChcbiAgICAgIHJpZ2h0ICE9IG51bGwgJiZcbiAgICAgIHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICByaWdodFtTeW1ib2wuaGFzSW5zdGFuY2VdXG4gICAgKSB7XG4gICAgICByZXR1cm4gcmlnaHRbU3ltYm9sLmhhc0luc3RhbmNlXShsZWZ0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGxlZnQgaW5zdGFuY2VvZiByaWdodDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGVcbiAgICAgID8gb2JqXG4gICAgICA6IHtcbiAgICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICAgICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikge1xuICAgIGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBuZXdPYmogPSB7fTtcblxuICAgICAgaWYgKG9iaiAhPSBudWxsKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgICAgdmFyIGRlc2MgPVxuICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvclxuICAgICAgICAgICAgICAgID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSlcbiAgICAgICAgICAgICAgICA6IHt9O1xuXG4gICAgICAgICAgICBpZiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpIHtcbiAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld09ialtrZXldID0gb2JqW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG5ld09iai5kZWZhdWx0ID0gb2JqO1xuICAgICAgcmV0dXJuIG5ld09iajtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfbmV3QXJyb3dDaGVjayhpbm5lclRoaXMsIGJvdW5kVGhpcykge1xuICAgIGlmIChpbm5lclRoaXMgIT09IGJvdW5kVGhpcykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGluc3RhbnRpYXRlIGFuIGFycm93IGZ1bmN0aW9uJyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX29iamVjdERlc3RydWN0dXJpbmdFbXB0eShvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBkZXN0cnVjdHVyZSB1bmRlZmluZWQnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgICB2YXIgdGFyZ2V0ID0ge307XG4gICAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICAgIHZhciBrZXksIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cblxuICBmdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkge1xuICAgIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuXG4gICAgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpO1xuXG4gICAgdmFyIGtleSwgaTtcblxuICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTtcbiAgICAgICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG5cbiAgZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gICAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFxuICAgICAgICBcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBzZWxmO1xuICB9XG5cbiAgZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICAgIGlmIChjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIGNhbGwgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICByZXR1cm4gY2FsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xuICAgICAgb2JqZWN0ID0gX2dldFByb3RvdHlwZU9mKG9iamVjdCk7XG4gICAgICBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG5cbiAgZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gJ3VuZGVmaW5lZCcgJiYgUmVmbGVjdC5nZXQpIHtcbiAgICAgIF9nZXQgPSBSZWZsZWN0LmdldDtcbiAgICB9IGVsc2Uge1xuICAgICAgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgICAgICAgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTtcblxuICAgICAgICBpZiAoIWJhc2UpIHJldHVybjtcbiAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTtcblxuICAgICAgICBpZiAoZGVzYy5nZXQpIHtcbiAgICAgICAgICByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVzYy52YWx1ZTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgcmVjZWl2ZXIpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgIT09ICd1bmRlZmluZWQnICYmIFJlZmxlY3Quc2V0KSB7XG4gICAgICBzZXQgPSBSZWZsZWN0LnNldDtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0ID0gZnVuY3Rpb24gc2V0KHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCByZWNlaXZlcikge1xuICAgICAgICB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpO1xuXG4gICAgICAgIHZhciBkZXNjO1xuXG4gICAgICAgIGlmIChiYXNlKSB7XG4gICAgICAgICAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpO1xuXG4gICAgICAgICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICAgICAgICBkZXNjLnNldC5jYWxsKHJlY2VpdmVyLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFkZXNjLndyaXRhYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocmVjZWl2ZXIsIHByb3BlcnR5KTtcblxuICAgICAgICBpZiAoZGVzYykge1xuICAgICAgICAgIGlmICghZGVzYy53cml0YWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRlc2MudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVjZWl2ZXIsIHByb3BlcnR5LCBkZXNjKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfZGVmaW5lUHJvcGVydHkocmVjZWl2ZXIsIHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHNldCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgcmVjZWl2ZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gX3NldCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgcmVjZWl2ZXIsIGlzU3RyaWN0KSB7XG4gICAgdmFyIHMgPSBzZXQodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIHJlY2VpdmVyIHx8IHRhcmdldCk7XG5cbiAgICBpZiAoIXMgJiYgaXNTdHJpY3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZmFpbGVkIHRvIHNldCBwcm9wZXJ0eScpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF90YWdnZWRUZW1wbGF0ZUxpdGVyYWwoc3RyaW5ncywgcmF3KSB7XG4gICAgaWYgKCFyYXcpIHtcbiAgICAgIHJhdyA9IHN0cmluZ3Muc2xpY2UoMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhzdHJpbmdzLCB7XG4gICAgICAgIHJhdzoge1xuICAgICAgICAgIHZhbHVlOiBPYmplY3QuZnJlZXplKHJhdylcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gX3RhZ2dlZFRlbXBsYXRlTGl0ZXJhbExvb3NlKHN0cmluZ3MsIHJhdykge1xuICAgIGlmICghcmF3KSB7XG4gICAgICByYXcgPSBzdHJpbmdzLnNsaWNlKDApO1xuICAgIH1cblxuICAgIHN0cmluZ3MucmF3ID0gcmF3O1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgZnVuY3Rpb24gX3RlbXBvcmFsUmVmKHZhbCwgbmFtZSkge1xuICAgIGlmICh2YWwgPT09IF90ZW1wb3JhbFVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKG5hbWUgKyAnIGlzIG5vdCBkZWZpbmVkIC0gdGVtcG9yYWwgZGVhZCB6b25lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX3JlYWRPbmx5RXJyb3IobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignXCInICsgbmFtZSArICdcIiBpcyByZWFkLW9ubHknKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc05hbWVURFpFcnJvcihuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0NsYXNzIFwiJyArIG5hbWUgKyAnXCIgY2Fubm90IGJlIHJlZmVyZW5jZWQgaW4gY29tcHV0ZWQgcHJvcGVydHkga2V5cy4nXG4gICAgKTtcbiAgfVxuXG4gIHZhciBfdGVtcG9yYWxVbmRlZmluZWQgPSB7fTtcblxuICBmdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHtcbiAgICByZXR1cm4gKFxuICAgICAgX2FycmF5V2l0aEhvbGVzKGFycikgfHxcbiAgICAgIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8XG4gICAgICBfbm9uSXRlcmFibGVSZXN0KClcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXlMb29zZShhcnIsIGkpIHtcbiAgICByZXR1cm4gKFxuICAgICAgX2FycmF5V2l0aEhvbGVzKGFycikgfHxcbiAgICAgIF9pdGVyYWJsZVRvQXJyYXlMaW1pdExvb3NlKGFyciwgaSkgfHxcbiAgICAgIF9ub25JdGVyYWJsZVJlc3QoKVxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBfdG9BcnJheShhcnIpIHtcbiAgICByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgICByZXR1cm4gKFxuICAgICAgX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKylcbiAgICAgICAgYXJyMltpXSA9IGFycltpXTtcblxuICAgICAgcmV0dXJuIGFycjI7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG4gIH1cblxuICBmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgICBpZiAoXG4gICAgICBTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXIpIHx8XG4gICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaXRlcikgPT09ICdbb2JqZWN0IEFyZ3VtZW50c10nXG4gICAgKVxuICAgICAgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG4gIH1cblxuICBmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7XG4gICAgdmFyIF9hcnIgPSBbXTtcbiAgICB2YXIgX24gPSB0cnVlO1xuICAgIHZhciBfZCA9IGZhbHNlO1xuICAgIHZhciBfZSA9IHVuZGVmaW5lZDtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKFxuICAgICAgICB2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfcztcbiAgICAgICAgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7XG4gICAgICAgIF9uID0gdHJ1ZVxuICAgICAgKSB7XG4gICAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG5cbiAgICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2QgPSB0cnVlO1xuICAgICAgX2UgPSBlcnI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghX24gJiYgX2lbJ3JldHVybiddICE9IG51bGwpIF9pWydyZXR1cm4nXSgpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gX2FycjtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdExvb3NlKGFyciwgaSkge1xuICAgIHZhciBfYXJyID0gW107XG5cbiAgICBmb3IgKFxuICAgICAgdmFyIF9pdGVyYXRvciA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwO1xuICAgICAgIShfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmU7XG5cbiAgICApIHtcbiAgICAgIF9hcnIucHVzaChfc3RlcC52YWx1ZSk7XG5cbiAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gX2FycjtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZScpO1xuICB9XG5cbiAgZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlJyk7XG4gIH1cblxuICBmdW5jdGlvbiBfc2tpcEZpcnN0R2VuZXJhdG9yTmV4dChmbikge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpdCA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBpdC5uZXh0KCk7XG4gICAgICByZXR1cm4gaXQ7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdvYmplY3QnIHx8IGlucHV0ID09PSBudWxsKSByZXR1cm4gaW5wdXQ7XG4gICAgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdO1xuXG4gICAgaWYgKHByaW0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIHJlcyA9IHByaW0uY2FsbChpbnB1dCwgaGludCB8fCAnZGVmYXVsdCcpO1xuICAgICAgaWYgKHR5cGVvZiByZXMgIT09ICdvYmplY3QnKSByZXR1cm4gcmVzO1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKGhpbnQgPT09ICdzdHJpbmcnID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7XG4gIH1cblxuICBmdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHtcbiAgICB2YXIga2V5ID0gX3RvUHJpbWl0aXZlKGFyZywgJ3N0cmluZycpO1xuXG4gICAgcmV0dXJuIHR5cGVvZiBrZXkgPT09ICdzeW1ib2wnID8ga2V5IDogU3RyaW5nKGtleSk7XG4gIH1cblxuICBmdW5jdGlvbiBfaW5pdGlhbGl6ZXJXYXJuaW5nSGVscGVyKGRlc2NyaXB0b3IsIGNvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnRGVjb3JhdGluZyBjbGFzcyBwcm9wZXJ0eSBmYWlsZWQuIFBsZWFzZSBlbnN1cmUgdGhhdCAnICtcbiAgICAgICAgJ3Byb3Bvc2FsLWNsYXNzLXByb3BlcnRpZXMgaXMgZW5hYmxlZCBhbmQgc2V0IHRvIHVzZSBsb29zZSBtb2RlLiAnICtcbiAgICAgICAgJ1RvIHVzZSBwcm9wb3NhbC1jbGFzcy1wcm9wZXJ0aWVzIGluIHNwZWMgbW9kZSB3aXRoIGRlY29yYXRvcnMsIHdhaXQgZm9yICcgK1xuICAgICAgICAndGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBkZWNvcmF0b3JzIGluIHN0YWdlIDIuJ1xuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5LCBkZXNjcmlwdG9yLCBjb250ZXh0KSB7XG4gICAgaWYgKCFkZXNjcmlwdG9yKSByZXR1cm47XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHksIHtcbiAgICAgIGVudW1lcmFibGU6IGRlc2NyaXB0b3IuZW51bWVyYWJsZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogZGVzY3JpcHRvci5jb25maWd1cmFibGUsXG4gICAgICB3cml0YWJsZTogZGVzY3JpcHRvci53cml0YWJsZSxcbiAgICAgIHZhbHVlOiBkZXNjcmlwdG9yLmluaXRpYWxpemVyXG4gICAgICAgID8gZGVzY3JpcHRvci5pbml0aWFsaXplci5jYWxsKGNvbnRleHQpXG4gICAgICAgIDogdm9pZCAwXG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKFxuICAgIHRhcmdldCxcbiAgICBwcm9wZXJ0eSxcbiAgICBkZWNvcmF0b3JzLFxuICAgIGRlc2NyaXB0b3IsXG4gICAgY29udGV4dFxuICApIHtcbiAgICB2YXIgZGVzYyA9IHt9O1xuICAgIE9iamVjdC5rZXlzKGRlc2NyaXB0b3IpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICBkZXNjW2tleV0gPSBkZXNjcmlwdG9yW2tleV07XG4gICAgfSk7XG4gICAgZGVzYy5lbnVtZXJhYmxlID0gISFkZXNjLmVudW1lcmFibGU7XG4gICAgZGVzYy5jb25maWd1cmFibGUgPSAhIWRlc2MuY29uZmlndXJhYmxlO1xuXG4gICAgaWYgKCd2YWx1ZScgaW4gZGVzYyB8fCBkZXNjLmluaXRpYWxpemVyKSB7XG4gICAgICBkZXNjLndyaXRhYmxlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBkZXNjID0gZGVjb3JhdG9yc1xuICAgICAgLnNsaWNlKClcbiAgICAgIC5yZXZlcnNlKClcbiAgICAgIC5yZWR1Y2UoZnVuY3Rpb24oZGVzYywgZGVjb3JhdG9yKSB7XG4gICAgICAgIHJldHVybiBkZWNvcmF0b3IodGFyZ2V0LCBwcm9wZXJ0eSwgZGVzYykgfHwgZGVzYztcbiAgICAgIH0sIGRlc2MpO1xuXG4gICAgaWYgKGNvbnRleHQgJiYgZGVzYy5pbml0aWFsaXplciAhPT0gdm9pZCAwKSB7XG4gICAgICBkZXNjLnZhbHVlID0gZGVzYy5pbml0aWFsaXplciA/IGRlc2MuaW5pdGlhbGl6ZXIuY2FsbChjb250ZXh0KSA6IHZvaWQgMDtcbiAgICAgIGRlc2MuaW5pdGlhbGl6ZXIgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKGRlc2MuaW5pdGlhbGl6ZXIgPT09IHZvaWQgMCkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHksIGRlc2MpO1xuICAgICAgZGVzYyA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlc2M7XG4gIH1cblxuICB2YXIgaWQgPSAwO1xuXG4gIGZ1bmN0aW9uIF9jbGFzc1ByaXZhdGVGaWVsZExvb3NlS2V5KG5hbWUpIHtcbiAgICByZXR1cm4gJ19fcHJpdmF0ZV8nICsgaWQrKyArICdfJyArIG5hbWU7XG4gIH1cblxuICBmdW5jdGlvbiBfY2xhc3NQcml2YXRlRmllbGRMb29zZUJhc2UocmVjZWl2ZXIsIHByaXZhdGVLZXkpIHtcbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyZWNlaXZlciwgcHJpdmF0ZUtleSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2F0dGVtcHRlZCB0byB1c2UgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2UnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVjZWl2ZXI7XG4gIH1cblxuICBmdW5jdGlvbiBfY2xhc3NQcml2YXRlRmllbGRHZXQocmVjZWl2ZXIsIHByaXZhdGVNYXApIHtcbiAgICBpZiAoIXByaXZhdGVNYXAuaGFzKHJlY2VpdmVyKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXR0ZW1wdGVkIHRvIGdldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZScpO1xuICAgIH1cblxuICAgIHZhciBkZXNjcmlwdG9yID0gcHJpdmF0ZU1hcC5nZXQocmVjZWl2ZXIpO1xuXG4gICAgaWYgKGRlc2NyaXB0b3IuZ2V0KSB7XG4gICAgICByZXR1cm4gZGVzY3JpcHRvci5nZXQuY2FsbChyZWNlaXZlcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlc2NyaXB0b3IudmFsdWU7XG4gIH1cblxuICBmdW5jdGlvbiBfY2xhc3NQcml2YXRlRmllbGRTZXQocmVjZWl2ZXIsIHByaXZhdGVNYXAsIHZhbHVlKSB7XG4gICAgaWYgKCFwcml2YXRlTWFwLmhhcyhyZWNlaXZlcikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2F0dGVtcHRlZCB0byBzZXQgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2UnKTtcbiAgICB9XG5cbiAgICB2YXIgZGVzY3JpcHRvciA9IHByaXZhdGVNYXAuZ2V0KHJlY2VpdmVyKTtcblxuICAgIGlmIChkZXNjcmlwdG9yLnNldCkge1xuICAgICAgZGVzY3JpcHRvci5zZXQuY2FsbChyZWNlaXZlciwgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWRlc2NyaXB0b3Iud3JpdGFibGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXR0ZW1wdGVkIHRvIHNldCByZWFkIG9ubHkgcHJpdmF0ZSBmaWVsZCcpO1xuICAgICAgfVxuXG4gICAgICBkZXNjcmlwdG9yLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgZnVuY3Rpb24gX2NsYXNzU3RhdGljUHJpdmF0ZUZpZWxkU3BlY0dldChcbiAgICByZWNlaXZlcixcbiAgICBjbGFzc0NvbnN0cnVjdG9yLFxuICAgIGRlc2NyaXB0b3JcbiAgKSB7XG4gICAgaWYgKHJlY2VpdmVyICE9PSBjbGFzc0NvbnN0cnVjdG9yKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQcml2YXRlIHN0YXRpYyBhY2Nlc3Mgb2Ygd3JvbmcgcHJvdmVuYW5jZScpO1xuICAgIH1cblxuICAgIHJldHVybiBkZXNjcmlwdG9yLnZhbHVlO1xuICB9XG5cbiAgZnVuY3Rpb24gX2NsYXNzU3RhdGljUHJpdmF0ZUZpZWxkU3BlY1NldChcbiAgICByZWNlaXZlcixcbiAgICBjbGFzc0NvbnN0cnVjdG9yLFxuICAgIGRlc2NyaXB0b3IsXG4gICAgdmFsdWVcbiAgKSB7XG4gICAgaWYgKHJlY2VpdmVyICE9PSBjbGFzc0NvbnN0cnVjdG9yKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQcml2YXRlIHN0YXRpYyBhY2Nlc3Mgb2Ygd3JvbmcgcHJvdmVuYW5jZScpO1xuICAgIH1cblxuICAgIGlmICghZGVzY3JpcHRvci53cml0YWJsZSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXR0ZW1wdGVkIHRvIHNldCByZWFkIG9ubHkgcHJpdmF0ZSBmaWVsZCcpO1xuICAgIH1cblxuICAgIGRlc2NyaXB0b3IudmFsdWUgPSB2YWx1ZTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBmdW5jdGlvbiBfY2xhc3NTdGF0aWNQcml2YXRlTWV0aG9kR2V0KHJlY2VpdmVyLCBjbGFzc0NvbnN0cnVjdG9yLCBtZXRob2QpIHtcbiAgICBpZiAocmVjZWl2ZXIgIT09IGNsYXNzQ29uc3RydWN0b3IpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1ByaXZhdGUgc3RhdGljIGFjY2VzcyBvZiB3cm9uZyBwcm92ZW5hbmNlJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1ldGhvZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc1N0YXRpY1ByaXZhdGVNZXRob2RTZXQoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXR0ZW1wdGVkIHRvIHNldCByZWFkIG9ubHkgc3RhdGljIHByaXZhdGUgZmllbGQnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9kZWNvcmF0ZShkZWNvcmF0b3JzLCBmYWN0b3J5LCBzdXBlckNsYXNzLCBtaXhpbnMpIHtcbiAgICB2YXIgYXBpID0gX2dldERlY29yYXRvcnNBcGkoKTtcblxuICAgIGlmIChtaXhpbnMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWl4aW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFwaSA9IG1peGluc1tpXShhcGkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByID0gZmFjdG9yeShmdW5jdGlvbiBpbml0aWFsaXplKE8pIHtcbiAgICAgIGFwaS5pbml0aWFsaXplSW5zdGFuY2VFbGVtZW50cyhPLCBkZWNvcmF0ZWQuZWxlbWVudHMpO1xuICAgIH0sIHN1cGVyQ2xhc3MpO1xuICAgIHZhciBkZWNvcmF0ZWQgPSBhcGkuZGVjb3JhdGVDbGFzcyhcbiAgICAgIF9jb2FsZXNjZUNsYXNzRWxlbWVudHMoci5kLm1hcChfY3JlYXRlRWxlbWVudERlc2NyaXB0b3IpKSxcbiAgICAgIGRlY29yYXRvcnNcbiAgICApO1xuICAgIGFwaS5pbml0aWFsaXplQ2xhc3NFbGVtZW50cyhyLkYsIGRlY29yYXRlZC5lbGVtZW50cyk7XG4gICAgcmV0dXJuIGFwaS5ydW5DbGFzc0ZpbmlzaGVycyhyLkYsIGRlY29yYXRlZC5maW5pc2hlcnMpO1xuICB9XG5cbiAgZnVuY3Rpb24gX2dldERlY29yYXRvcnNBcGkoKSB7XG4gICAgX2dldERlY29yYXRvcnNBcGkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBhcGk7XG4gICAgfTtcblxuICAgIHZhciBhcGkgPSB7XG4gICAgICBlbGVtZW50c0RlZmluaXRpb25PcmRlcjogW1snbWV0aG9kJ10sIFsnZmllbGQnXV0sXG4gICAgICBpbml0aWFsaXplSW5zdGFuY2VFbGVtZW50czogZnVuY3Rpb24oTywgZWxlbWVudHMpIHtcbiAgICAgICAgWydtZXRob2QnLCAnZmllbGQnXS5mb3JFYWNoKGZ1bmN0aW9uKGtpbmQpIHtcbiAgICAgICAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50LmtpbmQgPT09IGtpbmQgJiYgZWxlbWVudC5wbGFjZW1lbnQgPT09ICdvd24nKSB7XG4gICAgICAgICAgICAgIHRoaXMuZGVmaW5lQ2xhc3NFbGVtZW50KE8sIGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgIH0sXG4gICAgICBpbml0aWFsaXplQ2xhc3NFbGVtZW50czogZnVuY3Rpb24oRiwgZWxlbWVudHMpIHtcbiAgICAgICAgdmFyIHByb3RvID0gRi5wcm90b3R5cGU7XG4gICAgICAgIFsnbWV0aG9kJywgJ2ZpZWxkJ10uZm9yRWFjaChmdW5jdGlvbihraW5kKSB7XG4gICAgICAgICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgcGxhY2VtZW50ID0gZWxlbWVudC5wbGFjZW1lbnQ7XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgZWxlbWVudC5raW5kID09PSBraW5kICYmXG4gICAgICAgICAgICAgIChwbGFjZW1lbnQgPT09ICdzdGF0aWMnIHx8IHBsYWNlbWVudCA9PT0gJ3Byb3RvdHlwZScpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgdmFyIHJlY2VpdmVyID0gcGxhY2VtZW50ID09PSAnc3RhdGljJyA/IEYgOiBwcm90bztcbiAgICAgICAgICAgICAgdGhpcy5kZWZpbmVDbGFzc0VsZW1lbnQocmVjZWl2ZXIsIGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgIH0sXG4gICAgICBkZWZpbmVDbGFzc0VsZW1lbnQ6IGZ1bmN0aW9uKHJlY2VpdmVyLCBlbGVtZW50KSB7XG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gZWxlbWVudC5kZXNjcmlwdG9yO1xuXG4gICAgICAgIGlmIChlbGVtZW50LmtpbmQgPT09ICdmaWVsZCcpIHtcbiAgICAgICAgICB2YXIgaW5pdGlhbGl6ZXIgPSBlbGVtZW50LmluaXRpYWxpemVyO1xuICAgICAgICAgIGRlc2NyaXB0b3IgPSB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBkZXNjcmlwdG9yLmVudW1lcmFibGUsXG4gICAgICAgICAgICB3cml0YWJsZTogZGVzY3JpcHRvci53cml0YWJsZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZGVzY3JpcHRvci5jb25maWd1cmFibGUsXG4gICAgICAgICAgICB2YWx1ZTogaW5pdGlhbGl6ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluaXRpYWxpemVyLmNhbGwocmVjZWl2ZXIpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZWNlaXZlciwgZWxlbWVudC5rZXksIGRlc2NyaXB0b3IpO1xuICAgICAgfSxcbiAgICAgIGRlY29yYXRlQ2xhc3M6IGZ1bmN0aW9uKGVsZW1lbnRzLCBkZWNvcmF0b3JzKSB7XG4gICAgICAgIHZhciBuZXdFbGVtZW50cyA9IFtdO1xuICAgICAgICB2YXIgZmluaXNoZXJzID0gW107XG4gICAgICAgIHZhciBwbGFjZW1lbnRzID0ge1xuICAgICAgICAgIHN0YXRpYzogW10sXG4gICAgICAgICAgcHJvdG90eXBlOiBbXSxcbiAgICAgICAgICBvd246IFtdXG4gICAgICAgIH07XG4gICAgICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgIHRoaXMuYWRkRWxlbWVudFBsYWNlbWVudChlbGVtZW50LCBwbGFjZW1lbnRzKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgIGlmICghX2hhc0RlY29yYXRvcnMoZWxlbWVudCkpIHJldHVybiBuZXdFbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgIHZhciBlbGVtZW50RmluaXNoZXJzRXh0cmFzID0gdGhpcy5kZWNvcmF0ZUVsZW1lbnQoXG4gICAgICAgICAgICBlbGVtZW50LFxuICAgICAgICAgICAgcGxhY2VtZW50c1xuICAgICAgICAgICk7XG4gICAgICAgICAgbmV3RWxlbWVudHMucHVzaChlbGVtZW50RmluaXNoZXJzRXh0cmFzLmVsZW1lbnQpO1xuICAgICAgICAgIG5ld0VsZW1lbnRzLnB1c2guYXBwbHkobmV3RWxlbWVudHMsIGVsZW1lbnRGaW5pc2hlcnNFeHRyYXMuZXh0cmFzKTtcbiAgICAgICAgICBmaW5pc2hlcnMucHVzaC5hcHBseShmaW5pc2hlcnMsIGVsZW1lbnRGaW5pc2hlcnNFeHRyYXMuZmluaXNoZXJzKTtcbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgaWYgKCFkZWNvcmF0b3JzKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVsZW1lbnRzOiBuZXdFbGVtZW50cyxcbiAgICAgICAgICAgIGZpbmlzaGVyczogZmluaXNoZXJzXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmRlY29yYXRlQ29uc3RydWN0b3IobmV3RWxlbWVudHMsIGRlY29yYXRvcnMpO1xuICAgICAgICBmaW5pc2hlcnMucHVzaC5hcHBseShmaW5pc2hlcnMsIHJlc3VsdC5maW5pc2hlcnMpO1xuICAgICAgICByZXN1bHQuZmluaXNoZXJzID0gZmluaXNoZXJzO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSxcbiAgICAgIGFkZEVsZW1lbnRQbGFjZW1lbnQ6IGZ1bmN0aW9uKGVsZW1lbnQsIHBsYWNlbWVudHMsIHNpbGVudCkge1xuICAgICAgICB2YXIga2V5cyA9IHBsYWNlbWVudHNbZWxlbWVudC5wbGFjZW1lbnRdO1xuXG4gICAgICAgIGlmICghc2lsZW50ICYmIGtleXMuaW5kZXhPZihlbGVtZW50LmtleSkgIT09IC0xKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRHVwbGljYXRlZCBlbGVtZW50ICgnICsgZWxlbWVudC5rZXkgKyAnKScpO1xuICAgICAgICB9XG5cbiAgICAgICAga2V5cy5wdXNoKGVsZW1lbnQua2V5KTtcbiAgICAgIH0sXG4gICAgICBkZWNvcmF0ZUVsZW1lbnQ6IGZ1bmN0aW9uKGVsZW1lbnQsIHBsYWNlbWVudHMpIHtcbiAgICAgICAgdmFyIGV4dHJhcyA9IFtdO1xuICAgICAgICB2YXIgZmluaXNoZXJzID0gW107XG5cbiAgICAgICAgZm9yIChcbiAgICAgICAgICB2YXIgZGVjb3JhdG9ycyA9IGVsZW1lbnQuZGVjb3JhdG9ycywgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTtcbiAgICAgICAgICBpID49IDA7XG4gICAgICAgICAgaS0tXG4gICAgICAgICkge1xuICAgICAgICAgIHZhciBrZXlzID0gcGxhY2VtZW50c1tlbGVtZW50LnBsYWNlbWVudF07XG4gICAgICAgICAga2V5cy5zcGxpY2Uoa2V5cy5pbmRleE9mKGVsZW1lbnQua2V5KSwgMSk7XG4gICAgICAgICAgdmFyIGVsZW1lbnRPYmplY3QgPSB0aGlzLmZyb21FbGVtZW50RGVzY3JpcHRvcihlbGVtZW50KTtcbiAgICAgICAgICB2YXIgZWxlbWVudEZpbmlzaGVyRXh0cmFzID0gdGhpcy50b0VsZW1lbnRGaW5pc2hlckV4dHJhcyhcbiAgICAgICAgICAgICgwLCBkZWNvcmF0b3JzW2ldKShlbGVtZW50T2JqZWN0KSB8fCBlbGVtZW50T2JqZWN0XG4gICAgICAgICAgKTtcbiAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudEZpbmlzaGVyRXh0cmFzLmVsZW1lbnQ7XG4gICAgICAgICAgdGhpcy5hZGRFbGVtZW50UGxhY2VtZW50KGVsZW1lbnQsIHBsYWNlbWVudHMpO1xuXG4gICAgICAgICAgaWYgKGVsZW1lbnRGaW5pc2hlckV4dHJhcy5maW5pc2hlcikge1xuICAgICAgICAgICAgZmluaXNoZXJzLnB1c2goZWxlbWVudEZpbmlzaGVyRXh0cmFzLmZpbmlzaGVyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgbmV3RXh0cmFzID0gZWxlbWVudEZpbmlzaGVyRXh0cmFzLmV4dHJhcztcblxuICAgICAgICAgIGlmIChuZXdFeHRyYXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbmV3RXh0cmFzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgIHRoaXMuYWRkRWxlbWVudFBsYWNlbWVudChuZXdFeHRyYXNbal0sIHBsYWNlbWVudHMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBleHRyYXMucHVzaC5hcHBseShleHRyYXMsIG5ld0V4dHJhcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgICAgIGZpbmlzaGVyczogZmluaXNoZXJzLFxuICAgICAgICAgIGV4dHJhczogZXh0cmFzXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgZGVjb3JhdGVDb25zdHJ1Y3RvcjogZnVuY3Rpb24oZWxlbWVudHMsIGRlY29yYXRvcnMpIHtcbiAgICAgICAgdmFyIGZpbmlzaGVycyA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdmFyIG9iaiA9IHRoaXMuZnJvbUNsYXNzRGVzY3JpcHRvcihlbGVtZW50cyk7XG4gICAgICAgICAgdmFyIGVsZW1lbnRzQW5kRmluaXNoZXIgPSB0aGlzLnRvQ2xhc3NEZXNjcmlwdG9yKFxuICAgICAgICAgICAgKDAsIGRlY29yYXRvcnNbaV0pKG9iaikgfHwgb2JqXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGlmIChlbGVtZW50c0FuZEZpbmlzaGVyLmZpbmlzaGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZpbmlzaGVycy5wdXNoKGVsZW1lbnRzQW5kRmluaXNoZXIuZmluaXNoZXIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChlbGVtZW50c0FuZEZpbmlzaGVyLmVsZW1lbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVsZW1lbnRzID0gZWxlbWVudHNBbmRGaW5pc2hlci5lbGVtZW50cztcblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBlbGVtZW50cy5sZW5ndGggLSAxOyBqKyspIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgayA9IGogKyAxOyBrIDwgZWxlbWVudHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICBlbGVtZW50c1tqXS5rZXkgPT09IGVsZW1lbnRzW2tdLmtleSAmJlxuICAgICAgICAgICAgICAgICAgZWxlbWVudHNbal0ucGxhY2VtZW50ID09PSBlbGVtZW50c1trXS5wbGFjZW1lbnRcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICdEdXBsaWNhdGVkIGVsZW1lbnQgKCcgKyBlbGVtZW50c1tqXS5rZXkgKyAnKSdcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBlbGVtZW50czogZWxlbWVudHMsXG4gICAgICAgICAgZmluaXNoZXJzOiBmaW5pc2hlcnNcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBmcm9tRWxlbWVudERlc2NyaXB0b3I6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIG9iaiA9IHtcbiAgICAgICAgICBraW5kOiBlbGVtZW50LmtpbmQsXG4gICAgICAgICAga2V5OiBlbGVtZW50LmtleSxcbiAgICAgICAgICBwbGFjZW1lbnQ6IGVsZW1lbnQucGxhY2VtZW50LFxuICAgICAgICAgIGRlc2NyaXB0b3I6IGVsZW1lbnQuZGVzY3JpcHRvclxuICAgICAgICB9O1xuICAgICAgICB2YXIgZGVzYyA9IHtcbiAgICAgICAgICB2YWx1ZTogJ0Rlc2NyaXB0b3InLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBTeW1ib2wudG9TdHJpbmdUYWcsIGRlc2MpO1xuICAgICAgICBpZiAoZWxlbWVudC5raW5kID09PSAnZmllbGQnKSBvYmouaW5pdGlhbGl6ZXIgPSBlbGVtZW50LmluaXRpYWxpemVyO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgfSxcbiAgICAgIHRvRWxlbWVudERlc2NyaXB0b3JzOiBmdW5jdGlvbihlbGVtZW50T2JqZWN0cykge1xuICAgICAgICBpZiAoZWxlbWVudE9iamVjdHMgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICAgICAgICByZXR1cm4gX3RvQXJyYXkoZWxlbWVudE9iamVjdHMpLm1hcChmdW5jdGlvbihlbGVtZW50T2JqZWN0KSB7XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLnRvRWxlbWVudERlc2NyaXB0b3IoZWxlbWVudE9iamVjdCk7XG4gICAgICAgICAgdGhpcy5kaXNhbGxvd1Byb3BlcnR5KFxuICAgICAgICAgICAgZWxlbWVudE9iamVjdCxcbiAgICAgICAgICAgICdmaW5pc2hlcicsXG4gICAgICAgICAgICAnQW4gZWxlbWVudCBkZXNjcmlwdG9yJ1xuICAgICAgICAgICk7XG4gICAgICAgICAgdGhpcy5kaXNhbGxvd1Byb3BlcnR5KFxuICAgICAgICAgICAgZWxlbWVudE9iamVjdCxcbiAgICAgICAgICAgICdleHRyYXMnLFxuICAgICAgICAgICAgJ0FuIGVsZW1lbnQgZGVzY3JpcHRvcidcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgIH0sXG4gICAgICB0b0VsZW1lbnREZXNjcmlwdG9yOiBmdW5jdGlvbihlbGVtZW50T2JqZWN0KSB7XG4gICAgICAgIHZhciBraW5kID0gU3RyaW5nKGVsZW1lbnRPYmplY3Qua2luZCk7XG5cbiAgICAgICAgaWYgKGtpbmQgIT09ICdtZXRob2QnICYmIGtpbmQgIT09ICdmaWVsZCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgJ0FuIGVsZW1lbnQgZGVzY3JpcHRvclxcJ3MgLmtpbmQgcHJvcGVydHkgbXVzdCBiZSBlaXRoZXIgXCJtZXRob2RcIiBvcicgK1xuICAgICAgICAgICAgICAnIFwiZmllbGRcIiwgYnV0IGEgZGVjb3JhdG9yIGNyZWF0ZWQgYW4gZWxlbWVudCBkZXNjcmlwdG9yIHdpdGgnICtcbiAgICAgICAgICAgICAgJyAua2luZCBcIicgK1xuICAgICAgICAgICAgICBraW5kICtcbiAgICAgICAgICAgICAgJ1wiJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIga2V5ID0gX3RvUHJvcGVydHlLZXkoZWxlbWVudE9iamVjdC5rZXkpO1xuXG4gICAgICAgIHZhciBwbGFjZW1lbnQgPSBTdHJpbmcoZWxlbWVudE9iamVjdC5wbGFjZW1lbnQpO1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgICBwbGFjZW1lbnQgIT09ICdzdGF0aWMnICYmXG4gICAgICAgICAgcGxhY2VtZW50ICE9PSAncHJvdG90eXBlJyAmJlxuICAgICAgICAgIHBsYWNlbWVudCAhPT0gJ293bidcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICdBbiBlbGVtZW50IGRlc2NyaXB0b3JcXCdzIC5wbGFjZW1lbnQgcHJvcGVydHkgbXVzdCBiZSBvbmUgb2YgXCJzdGF0aWNcIiwnICtcbiAgICAgICAgICAgICAgJyBcInByb3RvdHlwZVwiIG9yIFwib3duXCIsIGJ1dCBhIGRlY29yYXRvciBjcmVhdGVkIGFuIGVsZW1lbnQgZGVzY3JpcHRvcicgK1xuICAgICAgICAgICAgICAnIHdpdGggLnBsYWNlbWVudCBcIicgK1xuICAgICAgICAgICAgICBwbGFjZW1lbnQgK1xuICAgICAgICAgICAgICAnXCInXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gZWxlbWVudE9iamVjdC5kZXNjcmlwdG9yO1xuICAgICAgICB0aGlzLmRpc2FsbG93UHJvcGVydHkoXG4gICAgICAgICAgZWxlbWVudE9iamVjdCxcbiAgICAgICAgICAnZWxlbWVudHMnLFxuICAgICAgICAgICdBbiBlbGVtZW50IGRlc2NyaXB0b3InXG4gICAgICAgICk7XG4gICAgICAgIHZhciBlbGVtZW50ID0ge1xuICAgICAgICAgIGtpbmQ6IGtpbmQsXG4gICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICAgICAgZGVzY3JpcHRvcjogT2JqZWN0LmFzc2lnbih7fSwgZGVzY3JpcHRvcilcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoa2luZCAhPT0gJ2ZpZWxkJykge1xuICAgICAgICAgIHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShcbiAgICAgICAgICAgIGVsZW1lbnRPYmplY3QsXG4gICAgICAgICAgICAnaW5pdGlhbGl6ZXInLFxuICAgICAgICAgICAgJ0EgbWV0aG9kIGRlc2NyaXB0b3InXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmRpc2FsbG93UHJvcGVydHkoXG4gICAgICAgICAgICBkZXNjcmlwdG9yLFxuICAgICAgICAgICAgJ2dldCcsXG4gICAgICAgICAgICAnVGhlIHByb3BlcnR5IGRlc2NyaXB0b3Igb2YgYSBmaWVsZCBkZXNjcmlwdG9yJ1xuICAgICAgICAgICk7XG4gICAgICAgICAgdGhpcy5kaXNhbGxvd1Byb3BlcnR5KFxuICAgICAgICAgICAgZGVzY3JpcHRvcixcbiAgICAgICAgICAgICdzZXQnLFxuICAgICAgICAgICAgJ1RoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yIG9mIGEgZmllbGQgZGVzY3JpcHRvcidcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShcbiAgICAgICAgICAgIGRlc2NyaXB0b3IsXG4gICAgICAgICAgICAndmFsdWUnLFxuICAgICAgICAgICAgJ1RoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yIG9mIGEgZmllbGQgZGVzY3JpcHRvcidcbiAgICAgICAgICApO1xuICAgICAgICAgIGVsZW1lbnQuaW5pdGlhbGl6ZXIgPSBlbGVtZW50T2JqZWN0LmluaXRpYWxpemVyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICB9LFxuICAgICAgdG9FbGVtZW50RmluaXNoZXJFeHRyYXM6IGZ1bmN0aW9uKGVsZW1lbnRPYmplY3QpIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLnRvRWxlbWVudERlc2NyaXB0b3IoZWxlbWVudE9iamVjdCk7XG5cbiAgICAgICAgdmFyIGZpbmlzaGVyID0gX29wdGlvbmFsQ2FsbGFibGVQcm9wZXJ0eShlbGVtZW50T2JqZWN0LCAnZmluaXNoZXInKTtcblxuICAgICAgICB2YXIgZXh0cmFzID0gdGhpcy50b0VsZW1lbnREZXNjcmlwdG9ycyhlbGVtZW50T2JqZWN0LmV4dHJhcyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgICBmaW5pc2hlcjogZmluaXNoZXIsXG4gICAgICAgICAgZXh0cmFzOiBleHRyYXNcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBmcm9tQ2xhc3NEZXNjcmlwdG9yOiBmdW5jdGlvbihlbGVtZW50cykge1xuICAgICAgICB2YXIgb2JqID0ge1xuICAgICAgICAgIGtpbmQ6ICdjbGFzcycsXG4gICAgICAgICAgZWxlbWVudHM6IGVsZW1lbnRzLm1hcCh0aGlzLmZyb21FbGVtZW50RGVzY3JpcHRvciwgdGhpcylcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGRlc2MgPSB7XG4gICAgICAgICAgdmFsdWU6ICdEZXNjcmlwdG9yJyxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgU3ltYm9sLnRvU3RyaW5nVGFnLCBkZXNjKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgIH0sXG4gICAgICB0b0NsYXNzRGVzY3JpcHRvcjogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHZhciBraW5kID0gU3RyaW5nKG9iai5raW5kKTtcblxuICAgICAgICBpZiAoa2luZCAhPT0gJ2NsYXNzJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAnQSBjbGFzcyBkZXNjcmlwdG9yXFwncyAua2luZCBwcm9wZXJ0eSBtdXN0IGJlIFwiY2xhc3NcIiwgYnV0IGEgZGVjb3JhdG9yJyArXG4gICAgICAgICAgICAgICcgY3JlYXRlZCBhIGNsYXNzIGRlc2NyaXB0b3Igd2l0aCAua2luZCBcIicgK1xuICAgICAgICAgICAgICBraW5kICtcbiAgICAgICAgICAgICAgJ1wiJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRpc2FsbG93UHJvcGVydHkob2JqLCAna2V5JywgJ0EgY2xhc3MgZGVzY3JpcHRvcicpO1xuICAgICAgICB0aGlzLmRpc2FsbG93UHJvcGVydHkob2JqLCAncGxhY2VtZW50JywgJ0EgY2xhc3MgZGVzY3JpcHRvcicpO1xuICAgICAgICB0aGlzLmRpc2FsbG93UHJvcGVydHkob2JqLCAnZGVzY3JpcHRvcicsICdBIGNsYXNzIGRlc2NyaXB0b3InKTtcbiAgICAgICAgdGhpcy5kaXNhbGxvd1Byb3BlcnR5KG9iaiwgJ2luaXRpYWxpemVyJywgJ0EgY2xhc3MgZGVzY3JpcHRvcicpO1xuICAgICAgICB0aGlzLmRpc2FsbG93UHJvcGVydHkob2JqLCAnZXh0cmFzJywgJ0EgY2xhc3MgZGVzY3JpcHRvcicpO1xuXG4gICAgICAgIHZhciBmaW5pc2hlciA9IF9vcHRpb25hbENhbGxhYmxlUHJvcGVydHkob2JqLCAnZmluaXNoZXInKTtcblxuICAgICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLnRvRWxlbWVudERlc2NyaXB0b3JzKG9iai5lbGVtZW50cyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZWxlbWVudHM6IGVsZW1lbnRzLFxuICAgICAgICAgIGZpbmlzaGVyOiBmaW5pc2hlclxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHJ1bkNsYXNzRmluaXNoZXJzOiBmdW5jdGlvbihjb25zdHJ1Y3RvciwgZmluaXNoZXJzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmluaXNoZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIG5ld0NvbnN0cnVjdG9yID0gKDAsIGZpbmlzaGVyc1tpXSkoY29uc3RydWN0b3IpO1xuXG4gICAgICAgICAgaWYgKG5ld0NvbnN0cnVjdG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmV3Q29uc3RydWN0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmluaXNoZXJzIG11c3QgcmV0dXJuIGEgY29uc3RydWN0b3IuJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0cnVjdG9yID0gbmV3Q29uc3RydWN0b3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yO1xuICAgICAgfSxcbiAgICAgIGRpc2FsbG93UHJvcGVydHk6IGZ1bmN0aW9uKG9iaiwgbmFtZSwgb2JqZWN0VHlwZSkge1xuICAgICAgICBpZiAob2JqW25hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgb2JqZWN0VHlwZSArIFwiIGNhbid0IGhhdmUgYSAuXCIgKyBuYW1lICsgJyBwcm9wZXJ0eS4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGFwaTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9jcmVhdGVFbGVtZW50RGVzY3JpcHRvcihkZWYpIHtcbiAgICB2YXIga2V5ID0gX3RvUHJvcGVydHlLZXkoZGVmLmtleSk7XG5cbiAgICB2YXIgZGVzY3JpcHRvcjtcblxuICAgIGlmIChkZWYua2luZCA9PT0gJ21ldGhvZCcpIHtcbiAgICAgIGRlc2NyaXB0b3IgPSB7XG4gICAgICAgIHZhbHVlOiBkZWYudmFsdWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoZGVmLmtpbmQgPT09ICdnZXQnKSB7XG4gICAgICBkZXNjcmlwdG9yID0ge1xuICAgICAgICBnZXQ6IGRlZi52YWx1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGRlZi5raW5kID09PSAnc2V0Jykge1xuICAgICAgZGVzY3JpcHRvciA9IHtcbiAgICAgICAgc2V0OiBkZWYudmFsdWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChkZWYua2luZCA9PT0gJ2ZpZWxkJykge1xuICAgICAgZGVzY3JpcHRvciA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudCA9IHtcbiAgICAgIGtpbmQ6IGRlZi5raW5kID09PSAnZmllbGQnID8gJ2ZpZWxkJyA6ICdtZXRob2QnLFxuICAgICAga2V5OiBrZXksXG4gICAgICBwbGFjZW1lbnQ6IGRlZi5zdGF0aWNcbiAgICAgICAgPyAnc3RhdGljJ1xuICAgICAgICA6IGRlZi5raW5kID09PSAnZmllbGQnXG4gICAgICAgID8gJ293bidcbiAgICAgICAgOiAncHJvdG90eXBlJyxcbiAgICAgIGRlc2NyaXB0b3I6IGRlc2NyaXB0b3JcbiAgICB9O1xuICAgIGlmIChkZWYuZGVjb3JhdG9ycykgZWxlbWVudC5kZWNvcmF0b3JzID0gZGVmLmRlY29yYXRvcnM7XG4gICAgaWYgKGRlZi5raW5kID09PSAnZmllbGQnKSBlbGVtZW50LmluaXRpYWxpemVyID0gZGVmLnZhbHVlO1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgZnVuY3Rpb24gX2NvYWxlc2NlR2V0dGVyU2V0dGVyKGVsZW1lbnQsIG90aGVyKSB7XG4gICAgaWYgKGVsZW1lbnQuZGVzY3JpcHRvci5nZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgb3RoZXIuZGVzY3JpcHRvci5nZXQgPSBlbGVtZW50LmRlc2NyaXB0b3IuZ2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICBvdGhlci5kZXNjcmlwdG9yLnNldCA9IGVsZW1lbnQuZGVzY3JpcHRvci5zZXQ7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX2NvYWxlc2NlQ2xhc3NFbGVtZW50cyhlbGVtZW50cykge1xuICAgIHZhciBuZXdFbGVtZW50cyA9IFtdO1xuXG4gICAgdmFyIGlzU2FtZUVsZW1lbnQgPSBmdW5jdGlvbihvdGhlcikge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgb3RoZXIua2luZCA9PT0gJ21ldGhvZCcgJiZcbiAgICAgICAgb3RoZXIua2V5ID09PSBlbGVtZW50LmtleSAmJlxuICAgICAgICBvdGhlci5wbGFjZW1lbnQgPT09IGVsZW1lbnQucGxhY2VtZW50XG4gICAgICApO1xuICAgIH07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IGVsZW1lbnRzW2ldO1xuICAgICAgdmFyIG90aGVyO1xuXG4gICAgICBpZiAoXG4gICAgICAgIGVsZW1lbnQua2luZCA9PT0gJ21ldGhvZCcgJiZcbiAgICAgICAgKG90aGVyID0gbmV3RWxlbWVudHMuZmluZChpc1NhbWVFbGVtZW50KSlcbiAgICAgICkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgX2lzRGF0YURlc2NyaXB0b3IoZWxlbWVudC5kZXNjcmlwdG9yKSB8fFxuICAgICAgICAgIF9pc0RhdGFEZXNjcmlwdG9yKG90aGVyLmRlc2NyaXB0b3IpXG4gICAgICAgICkge1xuICAgICAgICAgIGlmIChfaGFzRGVjb3JhdG9ycyhlbGVtZW50KSB8fCBfaGFzRGVjb3JhdG9ycyhvdGhlcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcbiAgICAgICAgICAgICAgJ0R1cGxpY2F0ZWQgbWV0aG9kcyAoJyArIGVsZW1lbnQua2V5ICsgXCIpIGNhbid0IGJlIGRlY29yYXRlZC5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBvdGhlci5kZXNjcmlwdG9yID0gZWxlbWVudC5kZXNjcmlwdG9yO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChfaGFzRGVjb3JhdG9ycyhlbGVtZW50KSkge1xuICAgICAgICAgICAgaWYgKF9oYXNEZWNvcmF0b3JzKG90aGVyKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJEZWNvcmF0b3JzIGNhbid0IGJlIHBsYWNlZCBvbiBkaWZmZXJlbnQgYWNjZXNzb3JzIHdpdGggZm9yIFwiICtcbiAgICAgICAgICAgICAgICAgICd0aGUgc2FtZSBwcm9wZXJ0eSAoJyArXG4gICAgICAgICAgICAgICAgICBlbGVtZW50LmtleSArXG4gICAgICAgICAgICAgICAgICAnKS4nXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG90aGVyLmRlY29yYXRvcnMgPSBlbGVtZW50LmRlY29yYXRvcnM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX2NvYWxlc2NlR2V0dGVyU2V0dGVyKGVsZW1lbnQsIG90aGVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3RWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3RWxlbWVudHM7XG4gIH1cblxuICBmdW5jdGlvbiBfaGFzRGVjb3JhdG9ycyhlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuZGVjb3JhdG9ycyAmJiBlbGVtZW50LmRlY29yYXRvcnMubGVuZ3RoO1xuICB9XG5cbiAgZnVuY3Rpb24gX2lzRGF0YURlc2NyaXB0b3IoZGVzYykge1xuICAgIHJldHVybiAoXG4gICAgICBkZXNjICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICEoZGVzYy52YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGRlc2Mud3JpdGFibGUgPT09IHVuZGVmaW5lZClcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gX29wdGlvbmFsQ2FsbGFibGVQcm9wZXJ0eShvYmosIG5hbWUpIHtcbiAgICB2YXIgdmFsdWUgPSBvYmpbbmFtZV07XG5cbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCAnXCIgKyBuYW1lICsgXCInIHRvIGJlIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgZnVuY3Rpb24gX2NsYXNzUHJpdmF0ZU1ldGhvZEdldChyZWNlaXZlciwgcHJpdmF0ZVNldCwgZm4pIHtcbiAgICBpZiAoIXByaXZhdGVTZXQuaGFzKHJlY2VpdmVyKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXR0ZW1wdGVkIHRvIGdldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZScpO1xuICAgIH1cblxuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc1ByaXZhdGVNZXRob2RTZXQoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXR0ZW1wdGVkIHRvIHJlYXNzaWduIHByaXZhdGUgbWV0aG9kJyk7XG4gIH1cblxuICBmdW5jdGlvbiBfd3JhcFJlZ0V4cChyZSwgZ3JvdXBzKSB7XG4gICAgX3dyYXBSZWdFeHAgPSBmdW5jdGlvbihyZSwgZ3JvdXBzKSB7XG4gICAgICByZXR1cm4gbmV3IEJhYmVsUmVnRXhwKHJlLCBncm91cHMpO1xuICAgIH07XG5cbiAgICB2YXIgX1JlZ0V4cCA9IF93cmFwTmF0aXZlU3VwZXIoUmVnRXhwKTtcblxuICAgIHZhciBfc3VwZXIgPSBSZWdFeHAucHJvdG90eXBlO1xuXG4gICAgdmFyIF9ncm91cHMgPSBuZXcgV2Vha01hcCgpO1xuXG4gICAgZnVuY3Rpb24gQmFiZWxSZWdFeHAocmUsIGdyb3Vwcykge1xuICAgICAgdmFyIF90aGlzID0gX1JlZ0V4cC5jYWxsKHRoaXMsIHJlKTtcblxuICAgICAgX2dyb3Vwcy5zZXQoX3RoaXMsIGdyb3Vwcyk7XG5cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICBfaW5oZXJpdHMoQmFiZWxSZWdFeHAsIF9SZWdFeHApO1xuXG4gICAgQmFiZWxSZWdFeHAucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbihzdHIpIHtcbiAgICAgIHZhciByZXN1bHQgPSBfc3VwZXIuZXhlYy5jYWxsKHRoaXMsIHN0cik7XG5cbiAgICAgIGlmIChyZXN1bHQpIHJlc3VsdC5ncm91cHMgPSBidWlsZEdyb3VwcyhyZXN1bHQsIHRoaXMpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgQmFiZWxSZWdFeHAucHJvdG90eXBlW1N5bWJvbC5yZXBsYWNlXSA9IGZ1bmN0aW9uKHN0ciwgc3Vic3RpdHV0aW9uKSB7XG4gICAgICBpZiAodHlwZW9mIHN1YnN0aXR1dGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIGdyb3VwcyA9IF9ncm91cHMuZ2V0KHRoaXMpO1xuXG4gICAgICAgIHJldHVybiBfc3VwZXJbU3ltYm9sLnJlcGxhY2VdLmNhbGwoXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICBzdHIsXG4gICAgICAgICAgc3Vic3RpdHV0aW9uLnJlcGxhY2UoL1xcJDwoW14+XSspPi9nLCBmdW5jdGlvbihfLCBuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyQnICsgZ3JvdXBzW25hbWVdO1xuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzdWJzdGl0dXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICByZXR1cm4gX3N1cGVyW1N5bWJvbC5yZXBsYWNlXS5jYWxsKHRoaXMsIHN0ciwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICBhcmdzLnB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgYXJncy5wdXNoKGJ1aWxkR3JvdXBzKGFyZ3MsIF90aGlzKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHN1YnN0aXR1dGlvbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gX3N1cGVyW1N5bWJvbC5yZXBsYWNlXS5jYWxsKHRoaXMsIHN0ciwgc3Vic3RpdHV0aW9uKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gYnVpbGRHcm91cHMocmVzdWx0LCByZSkge1xuICAgICAgdmFyIGcgPSBfZ3JvdXBzLmdldChyZSk7XG5cbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyhnKS5yZWR1Y2UoZnVuY3Rpb24oZ3JvdXBzLCBuYW1lKSB7XG4gICAgICAgIGdyb3Vwc1tuYW1lXSA9IHJlc3VsdFtnW25hbWVdXTtcbiAgICAgICAgcmV0dXJuIGdyb3VwcztcbiAgICAgIH0sIE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgIH1cblxuICAgIHJldHVybiBfd3JhcFJlZ0V4cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgdmFyIHZlY3Rvck11bHRpcGx5ID0gZnVuY3Rpb24gdmVjdG9yTXVsdGlwbHkodiwgYW1vdW50KSB7XG4gICAgcmV0dXJuIGNyZWF0ZVZlY3Rvcih2LnggKiBhbW91bnQsIHYueSAqIGFtb3VudCk7XG4gIH07XG5cbiAgdmFyIHZlY3RvckFkZCA9IGZ1bmN0aW9uIHZlY3RvckFkZChhLCBiKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVZlY3RvcihhLnggKyBiLngsIGEueSArIGIueSk7XG4gIH07XG5cbiAgdmFyIHZlY3Rvck5vcm1hbGl6ZSA9IGZ1bmN0aW9uIHZlY3Rvck5vcm1hbGl6ZSh2KSB7XG4gICAgdmFyIGwgPSBNYXRoLnNxcnQodi54ICogdi54ICsgdi55ICogdi55KTtcbiAgICBpZiAobCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZVZlY3Rvcih2LnggLyBsLCB2LnkgLyBsKTtcbiAgfTtcblxuICB2YXIgdmVjdG9yUm90YXRlID0gZnVuY3Rpb24gdmVjdG9yUm90YXRlKHYsIHJhZGlhbnMsIG9yaWdpbikge1xuICAgIHZhciBjb3MgPSBNYXRoLmNvcyhyYWRpYW5zKTtcbiAgICB2YXIgc2luID0gTWF0aC5zaW4ocmFkaWFucyk7XG4gICAgdmFyIHQgPSBjcmVhdGVWZWN0b3Iodi54IC0gb3JpZ2luLngsIHYueSAtIG9yaWdpbi55KTtcbiAgICByZXR1cm4gY3JlYXRlVmVjdG9yKFxuICAgICAgb3JpZ2luLnggKyBjb3MgKiB0LnggLSBzaW4gKiB0LnksXG4gICAgICBvcmlnaW4ueSArIHNpbiAqIHQueCArIGNvcyAqIHQueVxuICAgICk7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZVZlY3RvciA9IGZ1bmN0aW9uIGNyZWF0ZVZlY3RvcigpIHtcbiAgICB2YXIgeCA9XG4gICAgICBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gICAgdmFyIHkgPVxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAgIHJldHVybiB7IHg6IHgsIHk6IHkgfTtcbiAgfTtcblxuICB2YXIgZ2V0TWFya3VwVmFsdWUgPSBmdW5jdGlvbiBnZXRNYXJrdXBWYWx1ZSh2YWx1ZSwgc2l6ZSkge1xuICAgIHZhciBzY2FsYXIgPVxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAxO1xuICAgIHZhciBheGlzID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgPyBhcmd1bWVudHNbM10gOiB1bmRlZmluZWQ7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKSAqIHNjYWxhcjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiB2YWx1ZSAqIChheGlzID8gc2l6ZVtheGlzXSA6IE1hdGgubWluKHNpemUud2lkdGgsIHNpemUuaGVpZ2h0KSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfTtcblxuICB2YXIgZ2V0TWFya3VwU3R5bGVzID0gZnVuY3Rpb24gZ2V0TWFya3VwU3R5bGVzKG1hcmt1cCwgc2l6ZSwgc2NhbGUpIHtcbiAgICB2YXIgbGluZVN0eWxlID0gbWFya3VwLmJvcmRlclN0eWxlIHx8IG1hcmt1cC5saW5lU3R5bGUgfHwgJ3NvbGlkJztcbiAgICB2YXIgZmlsbCA9IG1hcmt1cC5iYWNrZ3JvdW5kQ29sb3IgfHwgbWFya3VwLmZvbnRDb2xvciB8fCAndHJhbnNwYXJlbnQnO1xuICAgIHZhciBzdHJva2UgPSBtYXJrdXAuYm9yZGVyQ29sb3IgfHwgbWFya3VwLmxpbmVDb2xvciB8fCAndHJhbnNwYXJlbnQnO1xuICAgIHZhciBzdHJva2VXaWR0aCA9IGdldE1hcmt1cFZhbHVlKFxuICAgICAgbWFya3VwLmJvcmRlcldpZHRoIHx8IG1hcmt1cC5saW5lV2lkdGgsXG4gICAgICBzaXplLFxuICAgICAgc2NhbGVcbiAgICApO1xuICAgIHZhciBsaW5lQ2FwID0gbWFya3VwLmxpbmVDYXAgfHwgJ3JvdW5kJztcbiAgICB2YXIgbGluZUpvaW4gPSBtYXJrdXAubGluZUpvaW4gfHwgJ3JvdW5kJztcbiAgICB2YXIgZGFzaGVzID1cbiAgICAgIHR5cGVvZiBsaW5lU3R5bGUgPT09ICdzdHJpbmcnXG4gICAgICAgID8gJydcbiAgICAgICAgOiBsaW5lU3R5bGVcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24odikge1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0TWFya3VwVmFsdWUodiwgc2l6ZSwgc2NhbGUpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5qb2luKCcsJyk7XG4gICAgdmFyIG9wYWNpdHkgPSBtYXJrdXAub3BhY2l0eSB8fCAxO1xuICAgIHJldHVybiB7XG4gICAgICAnc3Ryb2tlLWxpbmVjYXAnOiBsaW5lQ2FwLFxuICAgICAgJ3N0cm9rZS1saW5lam9pbic6IGxpbmVKb2luLFxuICAgICAgJ3N0cm9rZS13aWR0aCc6IHN0cm9rZVdpZHRoIHx8IDAsXG4gICAgICAnc3Ryb2tlLWRhc2hhcnJheSc6IGRhc2hlcyxcbiAgICAgIHN0cm9rZTogc3Ryb2tlLFxuICAgICAgZmlsbDogZmlsbCxcbiAgICAgIG9wYWNpdHk6IG9wYWNpdHlcbiAgICB9O1xuICB9O1xuXG4gIHZhciBpc0RlZmluZWQgPSBmdW5jdGlvbiBpc0RlZmluZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT0gbnVsbDtcbiAgfTtcblxuICB2YXIgZ2V0TWFya3VwUmVjdCA9IGZ1bmN0aW9uIGdldE1hcmt1cFJlY3QocmVjdCwgc2l6ZSkge1xuICAgIHZhciBzY2FsYXIgPVxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAxO1xuXG4gICAgdmFyIGxlZnQgPVxuICAgICAgZ2V0TWFya3VwVmFsdWUocmVjdC54LCBzaXplLCBzY2FsYXIsICd3aWR0aCcpIHx8XG4gICAgICBnZXRNYXJrdXBWYWx1ZShyZWN0LmxlZnQsIHNpemUsIHNjYWxhciwgJ3dpZHRoJyk7XG4gICAgdmFyIHRvcCA9XG4gICAgICBnZXRNYXJrdXBWYWx1ZShyZWN0LnksIHNpemUsIHNjYWxhciwgJ2hlaWdodCcpIHx8XG4gICAgICBnZXRNYXJrdXBWYWx1ZShyZWN0LnRvcCwgc2l6ZSwgc2NhbGFyLCAnaGVpZ2h0Jyk7XG4gICAgdmFyIHdpZHRoID0gZ2V0TWFya3VwVmFsdWUocmVjdC53aWR0aCwgc2l6ZSwgc2NhbGFyLCAnd2lkdGgnKTtcbiAgICB2YXIgaGVpZ2h0ID0gZ2V0TWFya3VwVmFsdWUocmVjdC5oZWlnaHQsIHNpemUsIHNjYWxhciwgJ2hlaWdodCcpO1xuICAgIHZhciByaWdodCA9IGdldE1hcmt1cFZhbHVlKHJlY3QucmlnaHQsIHNpemUsIHNjYWxhciwgJ3dpZHRoJyk7XG4gICAgdmFyIGJvdHRvbSA9IGdldE1hcmt1cFZhbHVlKHJlY3QuYm90dG9tLCBzaXplLCBzY2FsYXIsICdoZWlnaHQnKTtcblxuICAgIGlmICghaXNEZWZpbmVkKHRvcCkpIHtcbiAgICAgIGlmIChpc0RlZmluZWQoaGVpZ2h0KSAmJiBpc0RlZmluZWQoYm90dG9tKSkge1xuICAgICAgICB0b3AgPSBzaXplLmhlaWdodCAtIGhlaWdodCAtIGJvdHRvbTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRvcCA9IGJvdHRvbTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWlzRGVmaW5lZChsZWZ0KSkge1xuICAgICAgaWYgKGlzRGVmaW5lZCh3aWR0aCkgJiYgaXNEZWZpbmVkKHJpZ2h0KSkge1xuICAgICAgICBsZWZ0ID0gc2l6ZS53aWR0aCAtIHdpZHRoIC0gcmlnaHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZWZ0ID0gcmlnaHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFpc0RlZmluZWQod2lkdGgpKSB7XG4gICAgICBpZiAoaXNEZWZpbmVkKGxlZnQpICYmIGlzRGVmaW5lZChyaWdodCkpIHtcbiAgICAgICAgd2lkdGggPSBzaXplLndpZHRoIC0gbGVmdCAtIHJpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2lkdGggPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghaXNEZWZpbmVkKGhlaWdodCkpIHtcbiAgICAgIGlmIChpc0RlZmluZWQodG9wKSAmJiBpc0RlZmluZWQoYm90dG9tKSkge1xuICAgICAgICBoZWlnaHQgPSBzaXplLmhlaWdodCAtIHRvcCAtIGJvdHRvbTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhlaWdodCA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGxlZnQgfHwgMCxcbiAgICAgIHk6IHRvcCB8fCAwLFxuICAgICAgd2lkdGg6IHdpZHRoIHx8IDAsXG4gICAgICBoZWlnaHQ6IGhlaWdodCB8fCAwXG4gICAgfTtcbiAgfTtcblxuICB2YXIgcG9pbnRzVG9QYXRoU2hhcGUgPSBmdW5jdGlvbiBwb2ludHNUb1BhdGhTaGFwZShwb2ludHMpIHtcbiAgICByZXR1cm4gcG9pbnRzXG4gICAgICAubWFwKGZ1bmN0aW9uKHBvaW50LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gJydcbiAgICAgICAgICAuY29uY2F0KGluZGV4ID09PSAwID8gJ00nIDogJ0wnLCAnICcpXG4gICAgICAgICAgLmNvbmNhdChwb2ludC54LCAnICcpXG4gICAgICAgICAgLmNvbmNhdChwb2ludC55KTtcbiAgICAgIH0pXG4gICAgICAuam9pbignICcpO1xuICB9O1xuXG4gIHZhciBzZXRBdHRyaWJ1dGVzID0gZnVuY3Rpb24gc2V0QXR0cmlidXRlcyhlbGVtZW50LCBhdHRyKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGF0dHIpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gZWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5LCBhdHRyW2tleV0pO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBucyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XG4gIHZhciBzdmcgPSBmdW5jdGlvbiBzdmcodGFnLCBhdHRyKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobnMsIHRhZyk7XG4gICAgaWYgKGF0dHIpIHtcbiAgICAgIHNldEF0dHJpYnV0ZXMoZWxlbWVudCwgYXR0cik7XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50O1xuICB9O1xuXG4gIHZhciB1cGRhdGVSZWN0ID0gZnVuY3Rpb24gdXBkYXRlUmVjdChlbGVtZW50KSB7XG4gICAgcmV0dXJuIHNldEF0dHJpYnV0ZXMoXG4gICAgICBlbGVtZW50LFxuICAgICAgT2JqZWN0LmFzc2lnbih7fSwgZWxlbWVudC5yZWN0LCBlbGVtZW50LnN0eWxlcylcbiAgICApO1xuICB9O1xuXG4gIHZhciB1cGRhdGVFbGxpcHNlID0gZnVuY3Rpb24gdXBkYXRlRWxsaXBzZShlbGVtZW50KSB7XG4gICAgdmFyIGN4ID0gZWxlbWVudC5yZWN0LnggKyBlbGVtZW50LnJlY3Qud2lkdGggKiAwLjU7XG4gICAgdmFyIGN5ID0gZWxlbWVudC5yZWN0LnkgKyBlbGVtZW50LnJlY3QuaGVpZ2h0ICogMC41O1xuICAgIHZhciByeCA9IGVsZW1lbnQucmVjdC53aWR0aCAqIDAuNTtcbiAgICB2YXIgcnkgPSBlbGVtZW50LnJlY3QuaGVpZ2h0ICogMC41O1xuICAgIHJldHVybiBzZXRBdHRyaWJ1dGVzKFxuICAgICAgZWxlbWVudCxcbiAgICAgIE9iamVjdC5hc3NpZ24oXG4gICAgICAgIHtcbiAgICAgICAgICBjeDogY3gsXG4gICAgICAgICAgY3k6IGN5LFxuICAgICAgICAgIHJ4OiByeCxcbiAgICAgICAgICByeTogcnlcbiAgICAgICAgfSxcbiAgICAgICAgZWxlbWVudC5zdHlsZXNcbiAgICAgIClcbiAgICApO1xuICB9O1xuXG4gIHZhciBJTUFHRV9GSVRfU1RZTEUgPSB7XG4gICAgY29udGFpbjogJ3hNaWRZTWlkIG1lZXQnLFxuICAgIGNvdmVyOiAneE1pZFlNaWQgc2xpY2UnXG4gIH07XG5cbiAgdmFyIHVwZGF0ZUltYWdlID0gZnVuY3Rpb24gdXBkYXRlSW1hZ2UoZWxlbWVudCwgbWFya3VwKSB7XG4gICAgc2V0QXR0cmlidXRlcyhcbiAgICAgIGVsZW1lbnQsXG4gICAgICBPYmplY3QuYXNzaWduKHt9LCBlbGVtZW50LnJlY3QsIGVsZW1lbnQuc3R5bGVzLCB7XG4gICAgICAgIHByZXNlcnZlQXNwZWN0UmF0aW86IElNQUdFX0ZJVF9TVFlMRVttYXJrdXAuZml0XSB8fCAnbm9uZSdcbiAgICAgIH0pXG4gICAgKTtcbiAgfTtcblxuICB2YXIgVEVYVF9BTkNIT1IgPSB7XG4gICAgbGVmdDogJ3N0YXJ0JyxcbiAgICBjZW50ZXI6ICdtaWRkbGUnLFxuICAgIHJpZ2h0OiAnZW5kJ1xuICB9O1xuXG4gIHZhciB1cGRhdGVUZXh0ID0gZnVuY3Rpb24gdXBkYXRlVGV4dChlbGVtZW50LCBtYXJrdXAsIHNpemUsIHNjYWxlKSB7XG4gICAgdmFyIGZvbnRTaXplID0gZ2V0TWFya3VwVmFsdWUobWFya3VwLmZvbnRTaXplLCBzaXplLCBzY2FsZSk7XG4gICAgdmFyIGZvbnRGYW1pbHkgPSBtYXJrdXAuZm9udEZhbWlseSB8fCAnc2Fucy1zZXJpZic7XG4gICAgdmFyIGZvbnRXZWlnaHQgPSBtYXJrdXAuZm9udFdlaWdodCB8fCAnbm9ybWFsJztcbiAgICB2YXIgdGV4dEFsaWduID0gVEVYVF9BTkNIT1JbbWFya3VwLnRleHRBbGlnbl0gfHwgJ3N0YXJ0JztcblxuICAgIHNldEF0dHJpYnV0ZXMoXG4gICAgICBlbGVtZW50LFxuICAgICAgT2JqZWN0LmFzc2lnbih7fSwgZWxlbWVudC5yZWN0LCBlbGVtZW50LnN0eWxlcywge1xuICAgICAgICAnc3Ryb2tlLXdpZHRoJzogMCxcbiAgICAgICAgJ2ZvbnQtd2VpZ2h0JzogZm9udFdlaWdodCxcbiAgICAgICAgJ2ZvbnQtc2l6ZSc6IGZvbnRTaXplLFxuICAgICAgICAnZm9udC1mYW1pbHknOiBmb250RmFtaWx5LFxuICAgICAgICAndGV4dC1hbmNob3InOiB0ZXh0QWxpZ25cbiAgICAgIH0pXG4gICAgKTtcblxuICAgIC8vIHVwZGF0ZSB0ZXh0XG4gICAgaWYgKGVsZW1lbnQudGV4dCAhPT0gbWFya3VwLnRleHQpIHtcbiAgICAgIGVsZW1lbnQudGV4dCA9IG1hcmt1cC50ZXh0O1xuICAgICAgZWxlbWVudC50ZXh0Q29udGVudCA9IG1hcmt1cC50ZXh0Lmxlbmd0aCA/IG1hcmt1cC50ZXh0IDogJyAnO1xuICAgIH1cbiAgfTtcblxuICB2YXIgdXBkYXRlTGluZSA9IGZ1bmN0aW9uIHVwZGF0ZUxpbmUoZWxlbWVudCwgbWFya3VwLCBzaXplLCBzY2FsZSkge1xuICAgIHNldEF0dHJpYnV0ZXMoXG4gICAgICBlbGVtZW50LFxuICAgICAgT2JqZWN0LmFzc2lnbih7fSwgZWxlbWVudC5yZWN0LCBlbGVtZW50LnN0eWxlcywge1xuICAgICAgICBmaWxsOiAnbm9uZSdcbiAgICAgIH0pXG4gICAgKTtcblxuICAgIHZhciBsaW5lID0gZWxlbWVudC5jaGlsZE5vZGVzWzBdO1xuICAgIHZhciBiZWdpbiA9IGVsZW1lbnQuY2hpbGROb2Rlc1sxXTtcbiAgICB2YXIgZW5kID0gZWxlbWVudC5jaGlsZE5vZGVzWzJdO1xuXG4gICAgdmFyIG9yaWdpbiA9IGVsZW1lbnQucmVjdDtcblxuICAgIHZhciB0YXJnZXQgPSB7XG4gICAgICB4OiBlbGVtZW50LnJlY3QueCArIGVsZW1lbnQucmVjdC53aWR0aCxcbiAgICAgIHk6IGVsZW1lbnQucmVjdC55ICsgZWxlbWVudC5yZWN0LmhlaWdodFxuICAgIH07XG5cbiAgICBzZXRBdHRyaWJ1dGVzKGxpbmUsIHtcbiAgICAgIHgxOiBvcmlnaW4ueCxcbiAgICAgIHkxOiBvcmlnaW4ueSxcbiAgICAgIHgyOiB0YXJnZXQueCxcbiAgICAgIHkyOiB0YXJnZXQueVxuICAgIH0pO1xuXG4gICAgaWYgKCFtYXJrdXAubGluZURlY29yYXRpb24pIHJldHVybjtcblxuICAgIGJlZ2luLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgZW5kLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cbiAgICB2YXIgdiA9IHZlY3Rvck5vcm1hbGl6ZSh7XG4gICAgICB4OiB0YXJnZXQueCAtIG9yaWdpbi54LFxuICAgICAgeTogdGFyZ2V0LnkgLSBvcmlnaW4ueVxuICAgIH0pO1xuXG4gICAgdmFyIGwgPSBnZXRNYXJrdXBWYWx1ZSgwLjA1LCBzaXplLCBzY2FsZSk7XG5cbiAgICBpZiAobWFya3VwLmxpbmVEZWNvcmF0aW9uLmluZGV4T2YoJ2Fycm93LWJlZ2luJykgIT09IC0xKSB7XG4gICAgICB2YXIgYXJyb3dCZWdpblJvdGF0aW9uUG9pbnQgPSB2ZWN0b3JNdWx0aXBseSh2LCBsKTtcbiAgICAgIHZhciBhcnJvd0JlZ2luQ2VudGVyID0gdmVjdG9yQWRkKG9yaWdpbiwgYXJyb3dCZWdpblJvdGF0aW9uUG9pbnQpO1xuICAgICAgdmFyIGFycm93QmVnaW5BID0gdmVjdG9yUm90YXRlKG9yaWdpbiwgMiwgYXJyb3dCZWdpbkNlbnRlcik7XG4gICAgICB2YXIgYXJyb3dCZWdpbkIgPSB2ZWN0b3JSb3RhdGUob3JpZ2luLCAtMiwgYXJyb3dCZWdpbkNlbnRlcik7XG5cbiAgICAgIHNldEF0dHJpYnV0ZXMoYmVnaW4sIHtcbiAgICAgICAgc3R5bGU6ICdkaXNwbGF5OmJsb2NrOycsXG4gICAgICAgIGQ6ICdNJ1xuICAgICAgICAgIC5jb25jYXQoYXJyb3dCZWdpbkEueCwgJywnKVxuICAgICAgICAgIC5jb25jYXQoYXJyb3dCZWdpbkEueSwgJyBMJylcbiAgICAgICAgICAuY29uY2F0KG9yaWdpbi54LCAnLCcpXG4gICAgICAgICAgLmNvbmNhdChvcmlnaW4ueSwgJyBMJylcbiAgICAgICAgICAuY29uY2F0KGFycm93QmVnaW5CLngsICcsJylcbiAgICAgICAgICAuY29uY2F0KGFycm93QmVnaW5CLnkpXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAobWFya3VwLmxpbmVEZWNvcmF0aW9uLmluZGV4T2YoJ2Fycm93LWVuZCcpICE9PSAtMSkge1xuICAgICAgdmFyIGFycm93RW5kUm90YXRpb25Qb2ludCA9IHZlY3Rvck11bHRpcGx5KHYsIC1sKTtcbiAgICAgIHZhciBhcnJvd0VuZENlbnRlciA9IHZlY3RvckFkZCh0YXJnZXQsIGFycm93RW5kUm90YXRpb25Qb2ludCk7XG4gICAgICB2YXIgYXJyb3dFbmRBID0gdmVjdG9yUm90YXRlKHRhcmdldCwgMiwgYXJyb3dFbmRDZW50ZXIpO1xuICAgICAgdmFyIGFycm93RW5kQiA9IHZlY3RvclJvdGF0ZSh0YXJnZXQsIC0yLCBhcnJvd0VuZENlbnRlcik7XG5cbiAgICAgIHNldEF0dHJpYnV0ZXMoZW5kLCB7XG4gICAgICAgIHN0eWxlOiAnZGlzcGxheTpibG9jazsnLFxuICAgICAgICBkOiAnTSdcbiAgICAgICAgICAuY29uY2F0KGFycm93RW5kQS54LCAnLCcpXG4gICAgICAgICAgLmNvbmNhdChhcnJvd0VuZEEueSwgJyBMJylcbiAgICAgICAgICAuY29uY2F0KHRhcmdldC54LCAnLCcpXG4gICAgICAgICAgLmNvbmNhdCh0YXJnZXQueSwgJyBMJylcbiAgICAgICAgICAuY29uY2F0KGFycm93RW5kQi54LCAnLCcpXG4gICAgICAgICAgLmNvbmNhdChhcnJvd0VuZEIueSlcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICB2YXIgdXBkYXRlUGF0aCA9IGZ1bmN0aW9uIHVwZGF0ZVBhdGgoZWxlbWVudCwgbWFya3VwLCBzaXplLCBzY2FsZSkge1xuICAgIHNldEF0dHJpYnV0ZXMoXG4gICAgICBlbGVtZW50LFxuICAgICAgT2JqZWN0LmFzc2lnbih7fSwgZWxlbWVudC5zdHlsZXMsIHtcbiAgICAgICAgZmlsbDogJ25vbmUnLFxuICAgICAgICBkOiBwb2ludHNUb1BhdGhTaGFwZShcbiAgICAgICAgICBtYXJrdXAucG9pbnRzLm1hcChmdW5jdGlvbihwb2ludCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgeDogZ2V0TWFya3VwVmFsdWUocG9pbnQueCwgc2l6ZSwgc2NhbGUsICd3aWR0aCcpLFxuICAgICAgICAgICAgICB5OiBnZXRNYXJrdXBWYWx1ZShwb2ludC55LCBzaXplLCBzY2FsZSwgJ2hlaWdodCcpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgIH0pXG4gICAgKTtcbiAgfTtcblxuICB2YXIgY3JlYXRlU2hhcGUgPSBmdW5jdGlvbiBjcmVhdGVTaGFwZShub2RlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG1hcmt1cCkge1xuICAgICAgcmV0dXJuIHN2Zyhub2RlLCB7IGlkOiBtYXJrdXAuaWQgfSk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgY3JlYXRlSW1hZ2UgPSBmdW5jdGlvbiBjcmVhdGVJbWFnZShtYXJrdXApIHtcbiAgICB2YXIgc2hhcGUgPSBzdmcoJ2ltYWdlJywge1xuICAgICAgaWQ6IG1hcmt1cC5pZCxcbiAgICAgICdzdHJva2UtbGluZWNhcCc6ICdyb3VuZCcsXG4gICAgICAnc3Ryb2tlLWxpbmVqb2luJzogJ3JvdW5kJyxcbiAgICAgIG9wYWNpdHk6ICcwJ1xuICAgIH0pO1xuXG4gICAgc2hhcGUub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICBzaGFwZS5zZXRBdHRyaWJ1dGUoJ29wYWNpdHknLCBtYXJrdXAub3BhY2l0eSB8fCAxKTtcbiAgICB9O1xuICAgIHNoYXBlLnNldEF0dHJpYnV0ZU5TKFxuICAgICAgJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLFxuICAgICAgJ3hsaW5rOmhyZWYnLFxuICAgICAgbWFya3VwLnNyY1xuICAgICk7XG4gICAgcmV0dXJuIHNoYXBlO1xuICB9O1xuXG4gIHZhciBjcmVhdGVMaW5lID0gZnVuY3Rpb24gY3JlYXRlTGluZShtYXJrdXApIHtcbiAgICB2YXIgc2hhcGUgPSBzdmcoJ2cnLCB7XG4gICAgICBpZDogbWFya3VwLmlkLFxuICAgICAgJ3N0cm9rZS1saW5lY2FwJzogJ3JvdW5kJyxcbiAgICAgICdzdHJva2UtbGluZWpvaW4nOiAncm91bmQnXG4gICAgfSk7XG5cbiAgICB2YXIgbGluZSA9IHN2ZygnbGluZScpO1xuICAgIHNoYXBlLmFwcGVuZENoaWxkKGxpbmUpO1xuXG4gICAgdmFyIGJlZ2luID0gc3ZnKCdwYXRoJyk7XG4gICAgc2hhcGUuYXBwZW5kQ2hpbGQoYmVnaW4pO1xuXG4gICAgdmFyIGVuZCA9IHN2ZygncGF0aCcpO1xuICAgIHNoYXBlLmFwcGVuZENoaWxkKGVuZCk7XG5cbiAgICByZXR1cm4gc2hhcGU7XG4gIH07XG5cbiAgdmFyIENSRUFURV9UWVBFX1JPVVRFUyA9IHtcbiAgICBpbWFnZTogY3JlYXRlSW1hZ2UsXG4gICAgcmVjdDogY3JlYXRlU2hhcGUoJ3JlY3QnKSxcbiAgICBlbGxpcHNlOiBjcmVhdGVTaGFwZSgnZWxsaXBzZScpLFxuICAgIHRleHQ6IGNyZWF0ZVNoYXBlKCd0ZXh0JyksXG4gICAgcGF0aDogY3JlYXRlU2hhcGUoJ3BhdGgnKSxcbiAgICBsaW5lOiBjcmVhdGVMaW5lXG4gIH07XG5cbiAgdmFyIFVQREFURV9UWVBFX1JPVVRFUyA9IHtcbiAgICByZWN0OiB1cGRhdGVSZWN0LFxuICAgIGVsbGlwc2U6IHVwZGF0ZUVsbGlwc2UsXG4gICAgaW1hZ2U6IHVwZGF0ZUltYWdlLFxuICAgIHRleHQ6IHVwZGF0ZVRleHQsXG4gICAgcGF0aDogdXBkYXRlUGF0aCxcbiAgICBsaW5lOiB1cGRhdGVMaW5lXG4gIH07XG5cbiAgdmFyIGNyZWF0ZU1hcmt1cEJ5VHlwZSA9IGZ1bmN0aW9uIGNyZWF0ZU1hcmt1cEJ5VHlwZSh0eXBlLCBtYXJrdXApIHtcbiAgICByZXR1cm4gQ1JFQVRFX1RZUEVfUk9VVEVTW3R5cGVdKG1hcmt1cCk7XG4gIH07XG5cbiAgdmFyIHVwZGF0ZU1hcmt1cEJ5VHlwZSA9IGZ1bmN0aW9uIHVwZGF0ZU1hcmt1cEJ5VHlwZShcbiAgICBlbGVtZW50LFxuICAgIHR5cGUsXG4gICAgbWFya3VwLFxuICAgIHNpemUsXG4gICAgc2NhbGVcbiAgKSB7XG4gICAgaWYgKHR5cGUgIT09ICdwYXRoJykge1xuICAgICAgZWxlbWVudC5yZWN0ID0gZ2V0TWFya3VwUmVjdChtYXJrdXAsIHNpemUsIHNjYWxlKTtcbiAgICB9XG4gICAgZWxlbWVudC5zdHlsZXMgPSBnZXRNYXJrdXBTdHlsZXMobWFya3VwLCBzaXplLCBzY2FsZSk7XG4gICAgVVBEQVRFX1RZUEVfUk9VVEVTW3R5cGVdKGVsZW1lbnQsIG1hcmt1cCwgc2l6ZSwgc2NhbGUpO1xuICB9O1xuXG4gIHZhciBNQVJLVVBfUkVDVCA9IFtcbiAgICAneCcsXG4gICAgJ3knLFxuICAgICdsZWZ0JyxcbiAgICAndG9wJyxcbiAgICAncmlnaHQnLFxuICAgICdib3R0b20nLFxuICAgICd3aWR0aCcsXG4gICAgJ2hlaWdodCdcbiAgXTtcblxuICB2YXIgdG9PcHRpb25hbEZyYWN0aW9uID0gZnVuY3Rpb24gdG9PcHRpb25hbEZyYWN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgLyUvLnRlc3QodmFsdWUpXG4gICAgICA/IHBhcnNlRmxvYXQodmFsdWUpIC8gMTAwXG4gICAgICA6IHZhbHVlO1xuICB9O1xuXG4gIC8vIGFkZHMgZGVmYXVsdCBtYXJrdXAgcHJvcGVydGllcywgY2xvbmVzIG1hcmt1cFxuICB2YXIgcHJlcGFyZU1hcmt1cCA9IGZ1bmN0aW9uIHByZXBhcmVNYXJrdXAobWFya3VwKSB7XG4gICAgdmFyIF9tYXJrdXAgPSBfc2xpY2VkVG9BcnJheShtYXJrdXAsIDIpLFxuICAgICAgdHlwZSA9IF9tYXJrdXBbMF0sXG4gICAgICBwcm9wcyA9IF9tYXJrdXBbMV07XG5cbiAgICB2YXIgcmVjdCA9IHByb3BzLnBvaW50c1xuICAgICAgPyB7fVxuICAgICAgOiBNQVJLVVBfUkVDVC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3Vycikge1xuICAgICAgICAgIHByZXZbY3Vycl0gPSB0b09wdGlvbmFsRnJhY3Rpb24ocHJvcHNbY3Vycl0pO1xuICAgICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgICB9LCB7fSk7XG5cbiAgICByZXR1cm4gW1xuICAgICAgdHlwZSxcbiAgICAgIE9iamVjdC5hc3NpZ24oXG4gICAgICAgIHtcbiAgICAgICAgICB6SW5kZXg6IDBcbiAgICAgICAgfSxcbiAgICAgICAgcHJvcHMsXG4gICAgICAgIHJlY3RcbiAgICAgIClcbiAgICBdO1xuICB9O1xuXG4gIHZhciBzb3J0TWFya3VwQnlaSW5kZXggPSBmdW5jdGlvbiBzb3J0TWFya3VwQnlaSW5kZXgoYSwgYikge1xuICAgIGlmIChhWzFdLnpJbmRleCA+IGJbMV0uekluZGV4KSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgaWYgKGFbMV0uekluZGV4IDwgYlsxXS56SW5kZXgpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZU1hcmt1cFZpZXcgPSBmdW5jdGlvbiBjcmVhdGVNYXJrdXBWaWV3KF8pIHtcbiAgICByZXR1cm4gXy51dGlscy5jcmVhdGVWaWV3KHtcbiAgICAgIG5hbWU6ICdpbWFnZS1wcmV2aWV3LW1hcmt1cCcsXG4gICAgICB0YWc6ICdzdmcnLFxuICAgICAgaWdub3JlUmVjdDogdHJ1ZSxcbiAgICAgIG1peGluczoge1xuICAgICAgICBhcGlzOiBbJ3dpZHRoJywgJ2hlaWdodCcsICdjcm9wJywgJ21hcmt1cCcsICdyZXNpemUnLCAnZGlydHknXVxuICAgICAgfSxcblxuICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKF9yZWYpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmLnJvb3QsXG4gICAgICAgICAgcHJvcHMgPSBfcmVmLnByb3BzO1xuXG4gICAgICAgIGlmICghcHJvcHMuZGlydHkpIHJldHVybjtcbiAgICAgICAgdmFyIGNyb3AgPSBwcm9wcy5jcm9wLFxuICAgICAgICAgIHJlc2l6ZSA9IHByb3BzLnJlc2l6ZSxcbiAgICAgICAgICBtYXJrdXAgPSBwcm9wcy5tYXJrdXA7XG5cbiAgICAgICAgdmFyIHZpZXdXaWR0aCA9IHByb3BzLndpZHRoO1xuICAgICAgICB2YXIgdmlld0hlaWdodCA9IHByb3BzLmhlaWdodDtcblxuICAgICAgICB2YXIgY3JvcFdpZHRoID0gY3JvcC53aWR0aDtcbiAgICAgICAgdmFyIGNyb3BIZWlnaHQgPSBjcm9wLmhlaWdodDtcblxuICAgICAgICBpZiAocmVzaXplKSB7XG4gICAgICAgICAgdmFyIF9zaXplID0gcmVzaXplLnNpemU7XG5cbiAgICAgICAgICB2YXIgb3V0cHV0V2lkdGggPSBfc2l6ZSAmJiBfc2l6ZS53aWR0aDtcbiAgICAgICAgICB2YXIgb3V0cHV0SGVpZ2h0ID0gX3NpemUgJiYgX3NpemUuaGVpZ2h0O1xuICAgICAgICAgIHZhciBvdXRwdXRGaXQgPSByZXNpemUubW9kZTtcbiAgICAgICAgICB2YXIgb3V0cHV0VXBzY2FsZSA9IHJlc2l6ZS51cHNjYWxlO1xuXG4gICAgICAgICAgaWYgKG91dHB1dFdpZHRoICYmICFvdXRwdXRIZWlnaHQpIG91dHB1dEhlaWdodCA9IG91dHB1dFdpZHRoO1xuICAgICAgICAgIGlmIChvdXRwdXRIZWlnaHQgJiYgIW91dHB1dFdpZHRoKSBvdXRwdXRXaWR0aCA9IG91dHB1dEhlaWdodDtcblxuICAgICAgICAgIHZhciBzaG91bGRVcHNjYWxlID1cbiAgICAgICAgICAgIGNyb3BXaWR0aCA8IG91dHB1dFdpZHRoICYmIGNyb3BIZWlnaHQgPCBvdXRwdXRIZWlnaHQ7XG5cbiAgICAgICAgICBpZiAoIXNob3VsZFVwc2NhbGUgfHwgKHNob3VsZFVwc2NhbGUgJiYgb3V0cHV0VXBzY2FsZSkpIHtcbiAgICAgICAgICAgIHZhciBzY2FsYXJXaWR0aCA9IG91dHB1dFdpZHRoIC8gY3JvcFdpZHRoO1xuICAgICAgICAgICAgdmFyIHNjYWxhckhlaWdodCA9IG91dHB1dEhlaWdodCAvIGNyb3BIZWlnaHQ7XG5cbiAgICAgICAgICAgIGlmIChvdXRwdXRGaXQgPT09ICdmb3JjZScpIHtcbiAgICAgICAgICAgICAgY3JvcFdpZHRoID0gb3V0cHV0V2lkdGg7XG4gICAgICAgICAgICAgIGNyb3BIZWlnaHQgPSBvdXRwdXRIZWlnaHQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgc2NhbGFyO1xuICAgICAgICAgICAgICBpZiAob3V0cHV0Rml0ID09PSAnY292ZXInKSB7XG4gICAgICAgICAgICAgICAgc2NhbGFyID0gTWF0aC5tYXgoc2NhbGFyV2lkdGgsIHNjYWxhckhlaWdodCk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAob3V0cHV0Rml0ID09PSAnY29udGFpbicpIHtcbiAgICAgICAgICAgICAgICBzY2FsYXIgPSBNYXRoLm1pbihzY2FsYXJXaWR0aCwgc2NhbGFySGVpZ2h0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjcm9wV2lkdGggPSBjcm9wV2lkdGggKiBzY2FsYXI7XG4gICAgICAgICAgICAgIGNyb3BIZWlnaHQgPSBjcm9wSGVpZ2h0ICogc2NhbGFyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzaXplID0ge1xuICAgICAgICAgIHdpZHRoOiB2aWV3V2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiB2aWV3SGVpZ2h0XG4gICAgICAgIH07XG5cbiAgICAgICAgcm9vdC5lbGVtZW50LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBzaXplLndpZHRoKTtcbiAgICAgICAgcm9vdC5lbGVtZW50LnNldEF0dHJpYnV0ZSgnaGVpZ2h0Jywgc2l6ZS5oZWlnaHQpO1xuXG4gICAgICAgIHZhciBzY2FsZSA9IE1hdGgubWluKHZpZXdXaWR0aCAvIGNyb3BXaWR0aCwgdmlld0hlaWdodCAvIGNyb3BIZWlnaHQpO1xuXG4gICAgICAgIC8vIGNsZWFyXG4gICAgICAgIHJvb3QuZWxlbWVudC5pbm5lckhUTUwgPSAnJztcblxuICAgICAgICAvLyBnZXQgZmlsdGVyXG4gICAgICAgIHZhciBtYXJrdXBGaWx0ZXIgPSByb290LnF1ZXJ5KCdHRVRfSU1BR0VfUFJFVklFV19NQVJLVVBfRklMVEVSJyk7XG5cbiAgICAgICAgLy8gZHJhdyBuZXdcbiAgICAgICAgbWFya3VwXG4gICAgICAgICAgLmZpbHRlcihtYXJrdXBGaWx0ZXIpXG4gICAgICAgICAgLm1hcChwcmVwYXJlTWFya3VwKVxuICAgICAgICAgIC5zb3J0KHNvcnRNYXJrdXBCeVpJbmRleClcbiAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbihtYXJrdXApIHtcbiAgICAgICAgICAgIHZhciBfbWFya3VwID0gX3NsaWNlZFRvQXJyYXkobWFya3VwLCAyKSxcbiAgICAgICAgICAgICAgdHlwZSA9IF9tYXJrdXBbMF0sXG4gICAgICAgICAgICAgIHNldHRpbmdzID0gX21hcmt1cFsxXTtcblxuICAgICAgICAgICAgLy8gY3JlYXRlXG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IGNyZWF0ZU1hcmt1cEJ5VHlwZSh0eXBlLCBzZXR0aW5ncyk7XG5cbiAgICAgICAgICAgIC8vIHVwZGF0ZVxuICAgICAgICAgICAgdXBkYXRlTWFya3VwQnlUeXBlKGVsZW1lbnQsIHR5cGUsIHNldHRpbmdzLCBzaXplLCBzY2FsZSk7XG5cbiAgICAgICAgICAgIC8vIGFkZFxuICAgICAgICAgICAgcm9vdC5lbGVtZW50LmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHZhciBjcmVhdGVWZWN0b3IkMSA9IGZ1bmN0aW9uIGNyZWF0ZVZlY3Rvcih4LCB5KSB7XG4gICAgcmV0dXJuIHsgeDogeCwgeTogeSB9O1xuICB9O1xuXG4gIHZhciB2ZWN0b3JEb3QgPSBmdW5jdGlvbiB2ZWN0b3JEb3QoYSwgYikge1xuICAgIHJldHVybiBhLnggKiBiLnggKyBhLnkgKiBiLnk7XG4gIH07XG5cbiAgdmFyIHZlY3RvclN1YnRyYWN0ID0gZnVuY3Rpb24gdmVjdG9yU3VidHJhY3QoYSwgYikge1xuICAgIHJldHVybiBjcmVhdGVWZWN0b3IkMShhLnggLSBiLngsIGEueSAtIGIueSk7XG4gIH07XG5cbiAgdmFyIHZlY3RvckRpc3RhbmNlU3F1YXJlZCA9IGZ1bmN0aW9uIHZlY3RvckRpc3RhbmNlU3F1YXJlZChhLCBiKSB7XG4gICAgcmV0dXJuIHZlY3RvckRvdCh2ZWN0b3JTdWJ0cmFjdChhLCBiKSwgdmVjdG9yU3VidHJhY3QoYSwgYikpO1xuICB9O1xuXG4gIHZhciB2ZWN0b3JEaXN0YW5jZSA9IGZ1bmN0aW9uIHZlY3RvckRpc3RhbmNlKGEsIGIpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHZlY3RvckRpc3RhbmNlU3F1YXJlZChhLCBiKSk7XG4gIH07XG5cbiAgdmFyIGdldE9mZnNldFBvaW50T25FZGdlID0gZnVuY3Rpb24gZ2V0T2Zmc2V0UG9pbnRPbkVkZ2UobGVuZ3RoLCByb3RhdGlvbikge1xuICAgIHZhciBhID0gbGVuZ3RoO1xuXG4gICAgdmFyIEEgPSAxLjU3MDc5NjMyNjc5NDg5NjY7XG4gICAgdmFyIEIgPSByb3RhdGlvbjtcbiAgICB2YXIgQyA9IDEuNTcwNzk2MzI2Nzk0ODk2NiAtIHJvdGF0aW9uO1xuXG4gICAgdmFyIHNpbkEgPSBNYXRoLnNpbihBKTtcbiAgICB2YXIgc2luQiA9IE1hdGguc2luKEIpO1xuICAgIHZhciBzaW5DID0gTWF0aC5zaW4oQyk7XG4gICAgdmFyIGNvc0MgPSBNYXRoLmNvcyhDKTtcbiAgICB2YXIgcmF0aW8gPSBhIC8gc2luQTtcbiAgICB2YXIgYiA9IHJhdGlvICogc2luQjtcbiAgICB2YXIgYyA9IHJhdGlvICogc2luQztcblxuICAgIHJldHVybiBjcmVhdGVWZWN0b3IkMShjb3NDICogYiwgY29zQyAqIGMpO1xuICB9O1xuXG4gIHZhciBnZXRSb3RhdGVkUmVjdFNpemUgPSBmdW5jdGlvbiBnZXRSb3RhdGVkUmVjdFNpemUocmVjdCwgcm90YXRpb24pIHtcbiAgICB2YXIgdyA9IHJlY3Qud2lkdGg7XG4gICAgdmFyIGggPSByZWN0LmhlaWdodDtcblxuICAgIHZhciBob3IgPSBnZXRPZmZzZXRQb2ludE9uRWRnZSh3LCByb3RhdGlvbik7XG4gICAgdmFyIHZlciA9IGdldE9mZnNldFBvaW50T25FZGdlKGgsIHJvdGF0aW9uKTtcblxuICAgIHZhciB0bCA9IGNyZWF0ZVZlY3RvciQxKHJlY3QueCArIE1hdGguYWJzKGhvci54KSwgcmVjdC55IC0gTWF0aC5hYnMoaG9yLnkpKTtcblxuICAgIHZhciB0ciA9IGNyZWF0ZVZlY3RvciQxKFxuICAgICAgcmVjdC54ICsgcmVjdC53aWR0aCArIE1hdGguYWJzKHZlci55KSxcbiAgICAgIHJlY3QueSArIE1hdGguYWJzKHZlci54KVxuICAgICk7XG5cbiAgICB2YXIgYmwgPSBjcmVhdGVWZWN0b3IkMShcbiAgICAgIHJlY3QueCAtIE1hdGguYWJzKHZlci55KSxcbiAgICAgIHJlY3QueSArIHJlY3QuaGVpZ2h0IC0gTWF0aC5hYnModmVyLngpXG4gICAgKTtcblxuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogdmVjdG9yRGlzdGFuY2UodGwsIHRyKSxcbiAgICAgIGhlaWdodDogdmVjdG9yRGlzdGFuY2UodGwsIGJsKVxuICAgIH07XG4gIH07XG5cbiAgdmFyIGNhbGN1bGF0ZUNhbnZhc1NpemUgPSBmdW5jdGlvbiBjYWxjdWxhdGVDYW52YXNTaXplKFxuICAgIGltYWdlLFxuICAgIGNhbnZhc0FzcGVjdFJhdGlvXG4gICkge1xuICAgIHZhciB6b29tID1cbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMTtcblxuICAgIHZhciBpbWFnZUFzcGVjdFJhdGlvID0gaW1hZ2UuaGVpZ2h0IC8gaW1hZ2Uud2lkdGg7XG5cbiAgICAvLyBkZXRlcm1pbmUgYWN0dWFsIHBpeGVscyBvbiB4IGFuZCB5IGF4aXNcbiAgICB2YXIgY2FudmFzV2lkdGggPSAxO1xuICAgIHZhciBjYW52YXNIZWlnaHQgPSBjYW52YXNBc3BlY3RSYXRpbztcbiAgICB2YXIgaW1nV2lkdGggPSAxO1xuICAgIHZhciBpbWdIZWlnaHQgPSBpbWFnZUFzcGVjdFJhdGlvO1xuICAgIGlmIChpbWdIZWlnaHQgPiBjYW52YXNIZWlnaHQpIHtcbiAgICAgIGltZ0hlaWdodCA9IGNhbnZhc0hlaWdodDtcbiAgICAgIGltZ1dpZHRoID0gaW1nSGVpZ2h0IC8gaW1hZ2VBc3BlY3RSYXRpbztcbiAgICB9XG5cbiAgICB2YXIgc2NhbGFyID0gTWF0aC5tYXgoY2FudmFzV2lkdGggLyBpbWdXaWR0aCwgY2FudmFzSGVpZ2h0IC8gaW1nSGVpZ2h0KTtcbiAgICB2YXIgd2lkdGggPSBpbWFnZS53aWR0aCAvICh6b29tICogc2NhbGFyICogaW1nV2lkdGgpO1xuICAgIHZhciBoZWlnaHQgPSB3aWR0aCAqIGNhbnZhc0FzcGVjdFJhdGlvO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgfTtcbiAgfTtcblxuICB2YXIgZ2V0SW1hZ2VSZWN0Wm9vbUZhY3RvciA9IGZ1bmN0aW9uIGdldEltYWdlUmVjdFpvb21GYWN0b3IoXG4gICAgaW1hZ2VSZWN0LFxuICAgIGNyb3BSZWN0LFxuICAgIHJvdGF0aW9uLFxuICAgIGNlbnRlclxuICApIHtcbiAgICAvLyBjYWxjdWxhdGUgYXZhaWxhYmxlIHNwYWNlIHJvdW5kIGltYWdlIGNlbnRlciBwb3NpdGlvblxuICAgIHZhciBjeCA9IGNlbnRlci54ID4gMC41ID8gMSAtIGNlbnRlci54IDogY2VudGVyLng7XG4gICAgdmFyIGN5ID0gY2VudGVyLnkgPiAwLjUgPyAxIC0gY2VudGVyLnkgOiBjZW50ZXIueTtcbiAgICB2YXIgaW1hZ2VXaWR0aCA9IGN4ICogMiAqIGltYWdlUmVjdC53aWR0aDtcbiAgICB2YXIgaW1hZ2VIZWlnaHQgPSBjeSAqIDIgKiBpbWFnZVJlY3QuaGVpZ2h0O1xuXG4gICAgLy8gY2FsY3VsYXRlIHJvdGF0ZWQgY3JvcCByZWN0YW5nbGUgc2l6ZVxuICAgIHZhciByb3RhdGVkQ3JvcFNpemUgPSBnZXRSb3RhdGVkUmVjdFNpemUoY3JvcFJlY3QsIHJvdGF0aW9uKTtcblxuICAgIC8vIGNhbGN1bGF0ZSBzY2FsYXIgcmVxdWlyZWQgdG8gZml0IGltYWdlXG4gICAgcmV0dXJuIE1hdGgubWF4KFxuICAgICAgcm90YXRlZENyb3BTaXplLndpZHRoIC8gaW1hZ2VXaWR0aCxcbiAgICAgIHJvdGF0ZWRDcm9wU2l6ZS5oZWlnaHQgLyBpbWFnZUhlaWdodFxuICAgICk7XG4gIH07XG5cbiAgdmFyIGdldENlbnRlcmVkQ3JvcFJlY3QgPSBmdW5jdGlvbiBnZXRDZW50ZXJlZENyb3BSZWN0KFxuICAgIGNvbnRhaW5lcixcbiAgICBhc3BlY3RSYXRpb1xuICApIHtcbiAgICB2YXIgd2lkdGggPSBjb250YWluZXIud2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IHdpZHRoICogYXNwZWN0UmF0aW87XG4gICAgaWYgKGhlaWdodCA+IGNvbnRhaW5lci5oZWlnaHQpIHtcbiAgICAgIGhlaWdodCA9IGNvbnRhaW5lci5oZWlnaHQ7XG4gICAgICB3aWR0aCA9IGhlaWdodCAvIGFzcGVjdFJhdGlvO1xuICAgIH1cbiAgICB2YXIgeCA9IChjb250YWluZXIud2lkdGggLSB3aWR0aCkgKiAwLjU7XG4gICAgdmFyIHkgPSAoY29udGFpbmVyLmhlaWdodCAtIGhlaWdodCkgKiAwLjU7XG5cbiAgICByZXR1cm4ge1xuICAgICAgeDogeCxcbiAgICAgIHk6IHksXG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IGhlaWdodFxuICAgIH07XG4gIH07XG5cbiAgdmFyIGdldEN1cnJlbnRDcm9wU2l6ZSA9IGZ1bmN0aW9uIGdldEN1cnJlbnRDcm9wU2l6ZShpbWFnZVNpemUpIHtcbiAgICB2YXIgY3JvcCA9XG4gICAgICBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciB6b29tID0gY3JvcC56b29tLFxuICAgICAgcm90YXRpb24gPSBjcm9wLnJvdGF0aW9uLFxuICAgICAgY2VudGVyID0gY3JvcC5jZW50ZXIsXG4gICAgICBhc3BlY3RSYXRpbyA9IGNyb3AuYXNwZWN0UmF0aW87XG5cbiAgICBpZiAoIWFzcGVjdFJhdGlvKSBhc3BlY3RSYXRpbyA9IGltYWdlU2l6ZS5oZWlnaHQgLyBpbWFnZVNpemUud2lkdGg7XG5cbiAgICB2YXIgY2FudmFzU2l6ZSA9IGNhbGN1bGF0ZUNhbnZhc1NpemUoaW1hZ2VTaXplLCBhc3BlY3RSYXRpbywgem9vbSk7XG5cbiAgICB2YXIgY2FudmFzQ2VudGVyID0ge1xuICAgICAgeDogY2FudmFzU2l6ZS53aWR0aCAqIDAuNSxcbiAgICAgIHk6IGNhbnZhc1NpemUuaGVpZ2h0ICogMC41XG4gICAgfTtcblxuICAgIHZhciBzdGFnZSA9IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwLFxuICAgICAgd2lkdGg6IGNhbnZhc1NpemUud2lkdGgsXG4gICAgICBoZWlnaHQ6IGNhbnZhc1NpemUuaGVpZ2h0LFxuICAgICAgY2VudGVyOiBjYW52YXNDZW50ZXJcbiAgICB9O1xuXG4gICAgdmFyIHNob3VsZExpbWl0ID0gdHlwZW9mIGNyb3Auc2NhbGVUb0ZpdCA9PT0gJ3VuZGVmaW5lZCcgfHwgY3JvcC5zY2FsZVRvRml0O1xuXG4gICAgdmFyIHN0YWdlWm9vbUZhY3RvciA9IGdldEltYWdlUmVjdFpvb21GYWN0b3IoXG4gICAgICBpbWFnZVNpemUsXG4gICAgICBnZXRDZW50ZXJlZENyb3BSZWN0KHN0YWdlLCBhc3BlY3RSYXRpbyksXG4gICAgICByb3RhdGlvbixcbiAgICAgIHNob3VsZExpbWl0ID8gY2VudGVyIDogeyB4OiAwLjUsIHk6IDAuNSB9XG4gICAgKTtcblxuICAgIHZhciBzY2FsZSA9IHpvb20gKiBzdGFnZVpvb21GYWN0b3I7XG5cbiAgICAvLyBzdGFydCBkcmF3aW5nXG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoRmxvYXQ6IGNhbnZhc1NpemUud2lkdGggLyBzY2FsZSxcbiAgICAgIGhlaWdodEZsb2F0OiBjYW52YXNTaXplLmhlaWdodCAvIHNjYWxlLFxuICAgICAgd2lkdGg6IE1hdGgucm91bmQoY2FudmFzU2l6ZS53aWR0aCAvIHNjYWxlKSxcbiAgICAgIGhlaWdodDogTWF0aC5yb3VuZChjYW52YXNTaXplLmhlaWdodCAvIHNjYWxlKVxuICAgIH07XG4gIH07XG5cbiAgdmFyIElNQUdFX1NDQUxFX1NQUklOR19QUk9QUyA9IHtcbiAgICB0eXBlOiAnc3ByaW5nJyxcbiAgICBzdGlmZm5lc3M6IDAuNSxcbiAgICBkYW1waW5nOiAwLjQ1LFxuICAgIG1hc3M6IDEwXG4gIH07XG5cbiAgLy8gZG9lcyBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbCBmbGlwcGluZ1xuICB2YXIgY3JlYXRlQml0bWFwVmlldyA9IGZ1bmN0aW9uIGNyZWF0ZUJpdG1hcFZpZXcoXykge1xuICAgIHJldHVybiBfLnV0aWxzLmNyZWF0ZVZpZXcoe1xuICAgICAgbmFtZTogJ2ltYWdlLWJpdG1hcCcsXG4gICAgICBpZ25vcmVSZWN0OiB0cnVlLFxuICAgICAgbWl4aW5zOiB7IHN0eWxlczogWydzY2FsZVgnLCAnc2NhbGVZJ10gfSxcbiAgICAgIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlKF9yZWYpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmLnJvb3QsXG4gICAgICAgICAgcHJvcHMgPSBfcmVmLnByb3BzO1xuICAgICAgICByb290LmFwcGVuZENoaWxkKHByb3BzLmltYWdlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICAvLyBzaGlmdHMgYW5kIHJvdGF0ZXMgaW1hZ2VcbiAgdmFyIGNyZWF0ZUltYWdlQ2FudmFzV3JhcHBlciA9IGZ1bmN0aW9uIGNyZWF0ZUltYWdlQ2FudmFzV3JhcHBlcihfKSB7XG4gICAgcmV0dXJuIF8udXRpbHMuY3JlYXRlVmlldyh7XG4gICAgICBuYW1lOiAnaW1hZ2UtY2FudmFzLXdyYXBwZXInLFxuICAgICAgdGFnOiAnZGl2JyxcbiAgICAgIGlnbm9yZVJlY3Q6IHRydWUsXG4gICAgICBtaXhpbnM6IHtcbiAgICAgICAgYXBpczogWydjcm9wJywgJ3dpZHRoJywgJ2hlaWdodCddLFxuXG4gICAgICAgIHN0eWxlczogW1xuICAgICAgICAgICdvcmlnaW5YJyxcbiAgICAgICAgICAnb3JpZ2luWScsXG4gICAgICAgICAgJ3RyYW5zbGF0ZVgnLFxuICAgICAgICAgICd0cmFuc2xhdGVZJyxcbiAgICAgICAgICAnc2NhbGVYJyxcbiAgICAgICAgICAnc2NhbGVZJyxcbiAgICAgICAgICAncm90YXRlWidcbiAgICAgICAgXSxcblxuICAgICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgICAgb3JpZ2luWDogSU1BR0VfU0NBTEVfU1BSSU5HX1BST1BTLFxuICAgICAgICAgIG9yaWdpblk6IElNQUdFX1NDQUxFX1NQUklOR19QUk9QUyxcbiAgICAgICAgICBzY2FsZVg6IElNQUdFX1NDQUxFX1NQUklOR19QUk9QUyxcbiAgICAgICAgICBzY2FsZVk6IElNQUdFX1NDQUxFX1NQUklOR19QUk9QUyxcbiAgICAgICAgICB0cmFuc2xhdGVYOiBJTUFHRV9TQ0FMRV9TUFJJTkdfUFJPUFMsXG4gICAgICAgICAgdHJhbnNsYXRlWTogSU1BR0VfU0NBTEVfU1BSSU5HX1BST1BTLFxuICAgICAgICAgIHJvdGF0ZVo6IElNQUdFX1NDQUxFX1NQUklOR19QUk9QU1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZShfcmVmMikge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWYyLnJvb3QsXG4gICAgICAgICAgcHJvcHMgPSBfcmVmMi5wcm9wcztcbiAgICAgICAgcHJvcHMud2lkdGggPSBwcm9wcy5pbWFnZS53aWR0aDtcbiAgICAgICAgcHJvcHMuaGVpZ2h0ID0gcHJvcHMuaW1hZ2UuaGVpZ2h0O1xuICAgICAgICByb290LnJlZi5iaXRtYXAgPSByb290LmFwcGVuZENoaWxkVmlldyhcbiAgICAgICAgICByb290LmNyZWF0ZUNoaWxkVmlldyhjcmVhdGVCaXRtYXBWaWV3KF8pLCB7IGltYWdlOiBwcm9wcy5pbWFnZSB9KVxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZShfcmVmMykge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWYzLnJvb3QsXG4gICAgICAgICAgcHJvcHMgPSBfcmVmMy5wcm9wcztcbiAgICAgICAgdmFyIGZsaXAgPSBwcm9wcy5jcm9wLmZsaXA7XG4gICAgICAgIHZhciBiaXRtYXAgPSByb290LnJlZi5iaXRtYXA7XG4gICAgICAgIGJpdG1hcC5zY2FsZVggPSBmbGlwLmhvcml6b250YWwgPyAtMSA6IDE7XG4gICAgICAgIGJpdG1hcC5zY2FsZVkgPSBmbGlwLnZlcnRpY2FsID8gLTEgOiAxO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIC8vIGNsaXBzIGNhbnZhcyB0byBjb3JyZWN0IGFzcGVjdCByYXRpb1xuICB2YXIgY3JlYXRlQ2xpcFZpZXcgPSBmdW5jdGlvbiBjcmVhdGVDbGlwVmlldyhfKSB7XG4gICAgcmV0dXJuIF8udXRpbHMuY3JlYXRlVmlldyh7XG4gICAgICBuYW1lOiAnaW1hZ2UtY2xpcCcsXG4gICAgICB0YWc6ICdkaXYnLFxuICAgICAgaWdub3JlUmVjdDogdHJ1ZSxcbiAgICAgIG1peGluczoge1xuICAgICAgICBhcGlzOiBbXG4gICAgICAgICAgJ2Nyb3AnLFxuICAgICAgICAgICdtYXJrdXAnLFxuICAgICAgICAgICdyZXNpemUnLFxuICAgICAgICAgICd3aWR0aCcsXG4gICAgICAgICAgJ2hlaWdodCcsXG4gICAgICAgICAgJ2RpcnR5JyxcbiAgICAgICAgICAnYmFja2dyb3VuZCdcbiAgICAgICAgXSxcblxuICAgICAgICBzdHlsZXM6IFsnd2lkdGgnLCAnaGVpZ2h0JywgJ29wYWNpdHknXSxcbiAgICAgICAgYW5pbWF0aW9uczoge1xuICAgICAgICAgIG9wYWNpdHk6IHsgdHlwZTogJ3R3ZWVuJywgZHVyYXRpb246IDI1MCB9XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGRpZFdyaXRlVmlldzogZnVuY3Rpb24gZGlkV3JpdGVWaWV3KF9yZWY0KSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjQucm9vdCxcbiAgICAgICAgICBwcm9wcyA9IF9yZWY0LnByb3BzO1xuICAgICAgICBpZiAoIXByb3BzLmJhY2tncm91bmQpIHJldHVybjtcbiAgICAgICAgcm9vdC5lbGVtZW50LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHByb3BzLmJhY2tncm91bmQ7XG4gICAgICB9LFxuICAgICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUoX3JlZjUpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmNS5yb290LFxuICAgICAgICAgIHByb3BzID0gX3JlZjUucHJvcHM7XG5cbiAgICAgICAgcm9vdC5yZWYuaW1hZ2UgPSByb290LmFwcGVuZENoaWxkVmlldyhcbiAgICAgICAgICByb290LmNyZWF0ZUNoaWxkVmlldyhcbiAgICAgICAgICAgIGNyZWF0ZUltYWdlQ2FudmFzV3JhcHBlcihfKSxcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oe30sIHByb3BzKVxuICAgICAgICAgIClcbiAgICAgICAgKTtcblxuICAgICAgICByb290LnJlZi5jcmVhdGVNYXJrdXAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAocm9vdC5yZWYubWFya3VwKSByZXR1cm47XG4gICAgICAgICAgcm9vdC5yZWYubWFya3VwID0gcm9vdC5hcHBlbmRDaGlsZFZpZXcoXG4gICAgICAgICAgICByb290LmNyZWF0ZUNoaWxkVmlldyhjcmVhdGVNYXJrdXBWaWV3KF8pLCBPYmplY3QuYXNzaWduKHt9LCBwcm9wcykpXG4gICAgICAgICAgKTtcbiAgICAgICAgfTtcblxuICAgICAgICByb290LnJlZi5kZXN0cm95TWFya3VwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKCFyb290LnJlZi5tYXJrdXApIHJldHVybjtcbiAgICAgICAgICByb290LnJlbW92ZUNoaWxkVmlldyhyb290LnJlZi5tYXJrdXApO1xuICAgICAgICAgIHJvb3QucmVmLm1hcmt1cCA9IG51bGw7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gc2V0IHVwIHRyYW5zcGFyZW5jeSBncmlkXG4gICAgICAgIHZhciB0cmFuc3BhcmVuY3lJbmRpY2F0b3IgPSByb290LnF1ZXJ5KFxuICAgICAgICAgICdHRVRfSU1BR0VfUFJFVklFV19UUkFOU1BBUkVOQ1lfSU5ESUNBVE9SJ1xuICAgICAgICApO1xuICAgICAgICBpZiAodHJhbnNwYXJlbmN5SW5kaWNhdG9yID09PSBudWxsKSByZXR1cm47XG5cbiAgICAgICAgLy8gZ3JpZCBwYXR0ZXJuXG4gICAgICAgIGlmICh0cmFuc3BhcmVuY3lJbmRpY2F0b3IgPT09ICdncmlkJykge1xuICAgICAgICAgIHJvb3QuZWxlbWVudC5kYXRhc2V0LnRyYW5zcGFyZW5jeUluZGljYXRvciA9IHRyYW5zcGFyZW5jeUluZGljYXRvcjtcbiAgICAgICAgfVxuICAgICAgICAvLyBiYXNpYyBjb2xvclxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByb290LmVsZW1lbnQuZGF0YXNldC50cmFuc3BhcmVuY3lJbmRpY2F0b3IgPSAnY29sb3InO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKF9yZWY2KSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjYucm9vdCxcbiAgICAgICAgICBwcm9wcyA9IF9yZWY2LnByb3BzLFxuICAgICAgICAgIHNob3VsZE9wdGltaXplID0gX3JlZjYuc2hvdWxkT3B0aW1pemU7XG4gICAgICAgIHZhciBjcm9wID0gcHJvcHMuY3JvcCxcbiAgICAgICAgICBtYXJrdXAgPSBwcm9wcy5tYXJrdXAsXG4gICAgICAgICAgcmVzaXplID0gcHJvcHMucmVzaXplLFxuICAgICAgICAgIGRpcnR5ID0gcHJvcHMuZGlydHksXG4gICAgICAgICAgd2lkdGggPSBwcm9wcy53aWR0aCxcbiAgICAgICAgICBoZWlnaHQgPSBwcm9wcy5oZWlnaHQ7XG5cbiAgICAgICAgcm9vdC5yZWYuaW1hZ2UuY3JvcCA9IGNyb3A7XG5cbiAgICAgICAgdmFyIHN0YWdlID0ge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMCxcbiAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgICAgY2VudGVyOiB7XG4gICAgICAgICAgICB4OiB3aWR0aCAqIDAuNSxcbiAgICAgICAgICAgIHk6IGhlaWdodCAqIDAuNVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgaW1hZ2UgPSB7XG4gICAgICAgICAgd2lkdGg6IHJvb3QucmVmLmltYWdlLndpZHRoLFxuICAgICAgICAgIGhlaWdodDogcm9vdC5yZWYuaW1hZ2UuaGVpZ2h0XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIG9yaWdpbiA9IHtcbiAgICAgICAgICB4OiBjcm9wLmNlbnRlci54ICogaW1hZ2Uud2lkdGgsXG4gICAgICAgICAgeTogY3JvcC5jZW50ZXIueSAqIGltYWdlLmhlaWdodFxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciB0cmFuc2xhdGlvbiA9IHtcbiAgICAgICAgICB4OiBzdGFnZS5jZW50ZXIueCAtIGltYWdlLndpZHRoICogY3JvcC5jZW50ZXIueCxcbiAgICAgICAgICB5OiBzdGFnZS5jZW50ZXIueSAtIGltYWdlLmhlaWdodCAqIGNyb3AuY2VudGVyLnlcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcm90YXRpb24gPSBNYXRoLlBJICogMiArIChjcm9wLnJvdGF0aW9uICUgKE1hdGguUEkgKiAyKSk7XG5cbiAgICAgICAgdmFyIGNyb3BBc3BlY3RSYXRpbyA9IGNyb3AuYXNwZWN0UmF0aW8gfHwgaW1hZ2UuaGVpZ2h0IC8gaW1hZ2Uud2lkdGg7XG5cbiAgICAgICAgdmFyIHNob3VsZExpbWl0ID1cbiAgICAgICAgICB0eXBlb2YgY3JvcC5zY2FsZVRvRml0ID09PSAndW5kZWZpbmVkJyB8fCBjcm9wLnNjYWxlVG9GaXQ7XG5cbiAgICAgICAgdmFyIHN0YWdlWm9vbUZhY3RvciA9IGdldEltYWdlUmVjdFpvb21GYWN0b3IoXG4gICAgICAgICAgaW1hZ2UsXG4gICAgICAgICAgZ2V0Q2VudGVyZWRDcm9wUmVjdChzdGFnZSwgY3JvcEFzcGVjdFJhdGlvKSxcblxuICAgICAgICAgIHJvdGF0aW9uLFxuICAgICAgICAgIHNob3VsZExpbWl0ID8gY3JvcC5jZW50ZXIgOiB7IHg6IDAuNSwgeTogMC41IH1cbiAgICAgICAgKTtcblxuICAgICAgICB2YXIgc2NhbGUgPSBjcm9wLnpvb20gKiBzdGFnZVpvb21GYWN0b3I7XG5cbiAgICAgICAgLy8gdXBkYXRlIG1hcmt1cCB2aWV3XG4gICAgICAgIGlmIChtYXJrdXAgJiYgbWFya3VwLmxlbmd0aCkge1xuICAgICAgICAgIHJvb3QucmVmLmNyZWF0ZU1hcmt1cCgpO1xuICAgICAgICAgIHJvb3QucmVmLm1hcmt1cC53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgIHJvb3QucmVmLm1hcmt1cC5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgcm9vdC5yZWYubWFya3VwLnJlc2l6ZSA9IHJlc2l6ZTtcbiAgICAgICAgICByb290LnJlZi5tYXJrdXAuZGlydHkgPSBkaXJ0eTtcbiAgICAgICAgICByb290LnJlZi5tYXJrdXAubWFya3VwID0gbWFya3VwO1xuICAgICAgICAgIHJvb3QucmVmLm1hcmt1cC5jcm9wID0gZ2V0Q3VycmVudENyb3BTaXplKGltYWdlLCBjcm9wKTtcbiAgICAgICAgfSBlbHNlIGlmIChyb290LnJlZi5tYXJrdXApIHtcbiAgICAgICAgICByb290LnJlZi5kZXN0cm95TWFya3VwKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1cGRhdGUgaW1hZ2Ugdmlld1xuICAgICAgICB2YXIgaW1hZ2VWaWV3ID0gcm9vdC5yZWYuaW1hZ2U7XG5cbiAgICAgICAgLy8gZG9uJ3QgdXBkYXRlIGNsaXAgbGF5b3V0XG4gICAgICAgIGlmIChzaG91bGRPcHRpbWl6ZSkge1xuICAgICAgICAgIGltYWdlVmlldy5vcmlnaW5YID0gbnVsbDtcbiAgICAgICAgICBpbWFnZVZpZXcub3JpZ2luWSA9IG51bGw7XG4gICAgICAgICAgaW1hZ2VWaWV3LnRyYW5zbGF0ZVggPSBudWxsO1xuICAgICAgICAgIGltYWdlVmlldy50cmFuc2xhdGVZID0gbnVsbDtcbiAgICAgICAgICBpbWFnZVZpZXcucm90YXRlWiA9IG51bGw7XG4gICAgICAgICAgaW1hZ2VWaWV3LnNjYWxlWCA9IG51bGw7XG4gICAgICAgICAgaW1hZ2VWaWV3LnNjYWxlWSA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaW1hZ2VWaWV3Lm9yaWdpblggPSBvcmlnaW4ueDtcbiAgICAgICAgaW1hZ2VWaWV3Lm9yaWdpblkgPSBvcmlnaW4ueTtcbiAgICAgICAgaW1hZ2VWaWV3LnRyYW5zbGF0ZVggPSB0cmFuc2xhdGlvbi54O1xuICAgICAgICBpbWFnZVZpZXcudHJhbnNsYXRlWSA9IHRyYW5zbGF0aW9uLnk7XG4gICAgICAgIGltYWdlVmlldy5yb3RhdGVaID0gcm90YXRpb247XG4gICAgICAgIGltYWdlVmlldy5zY2FsZVggPSBzY2FsZTtcbiAgICAgICAgaW1hZ2VWaWV3LnNjYWxlWSA9IHNjYWxlO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHZhciBjcmVhdGVJbWFnZVZpZXcgPSBmdW5jdGlvbiBjcmVhdGVJbWFnZVZpZXcoXykge1xuICAgIHJldHVybiBfLnV0aWxzLmNyZWF0ZVZpZXcoe1xuICAgICAgbmFtZTogJ2ltYWdlLXByZXZpZXcnLFxuICAgICAgdGFnOiAnZGl2JyxcbiAgICAgIGlnbm9yZVJlY3Q6IHRydWUsXG4gICAgICBtaXhpbnM6IHtcbiAgICAgICAgYXBpczogWydpbWFnZScsICdjcm9wJywgJ21hcmt1cCcsICdyZXNpemUnLCAnZGlydHknLCAnYmFja2dyb3VuZCddLFxuXG4gICAgICAgIHN0eWxlczogWyd0cmFuc2xhdGVZJywgJ3NjYWxlWCcsICdzY2FsZVknLCAnb3BhY2l0eSddLFxuXG4gICAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgICBzY2FsZVg6IElNQUdFX1NDQUxFX1NQUklOR19QUk9QUyxcbiAgICAgICAgICBzY2FsZVk6IElNQUdFX1NDQUxFX1NQUklOR19QUk9QUyxcbiAgICAgICAgICB0cmFuc2xhdGVZOiBJTUFHRV9TQ0FMRV9TUFJJTkdfUFJPUFMsXG4gICAgICAgICAgb3BhY2l0eTogeyB0eXBlOiAndHdlZW4nLCBkdXJhdGlvbjogNDAwIH1cbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUoX3JlZjcpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmNy5yb290LFxuICAgICAgICAgIHByb3BzID0gX3JlZjcucHJvcHM7XG4gICAgICAgIHJvb3QucmVmLmNsaXAgPSByb290LmFwcGVuZENoaWxkVmlldyhcbiAgICAgICAgICByb290LmNyZWF0ZUNoaWxkVmlldyhjcmVhdGVDbGlwVmlldyhfKSwge1xuICAgICAgICAgICAgaWQ6IHByb3BzLmlkLFxuICAgICAgICAgICAgaW1hZ2U6IHByb3BzLmltYWdlLFxuICAgICAgICAgICAgY3JvcDogcHJvcHMuY3JvcCxcbiAgICAgICAgICAgIG1hcmt1cDogcHJvcHMubWFya3VwLFxuICAgICAgICAgICAgcmVzaXplOiBwcm9wcy5yZXNpemUsXG4gICAgICAgICAgICBkaXJ0eTogcHJvcHMuZGlydHksXG4gICAgICAgICAgICBiYWNrZ3JvdW5kOiBwcm9wcy5iYWNrZ3JvdW5kXG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUoX3JlZjgpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmOC5yb290LFxuICAgICAgICAgIHByb3BzID0gX3JlZjgucHJvcHMsXG4gICAgICAgICAgc2hvdWxkT3B0aW1pemUgPSBfcmVmOC5zaG91bGRPcHRpbWl6ZTtcbiAgICAgICAgdmFyIGNsaXAgPSByb290LnJlZi5jbGlwO1xuICAgICAgICB2YXIgaW1hZ2UgPSBwcm9wcy5pbWFnZSxcbiAgICAgICAgICBjcm9wID0gcHJvcHMuY3JvcCxcbiAgICAgICAgICBtYXJrdXAgPSBwcm9wcy5tYXJrdXAsXG4gICAgICAgICAgcmVzaXplID0gcHJvcHMucmVzaXplLFxuICAgICAgICAgIGRpcnR5ID0gcHJvcHMuZGlydHk7XG5cbiAgICAgICAgY2xpcC5jcm9wID0gY3JvcDtcbiAgICAgICAgY2xpcC5tYXJrdXAgPSBtYXJrdXA7XG4gICAgICAgIGNsaXAucmVzaXplID0gcmVzaXplO1xuICAgICAgICBjbGlwLmRpcnR5ID0gZGlydHk7XG5cbiAgICAgICAgLy8gZG9uJ3QgdXBkYXRlIGNsaXAgbGF5b3V0XG4gICAgICAgIGNsaXAub3BhY2l0eSA9IHNob3VsZE9wdGltaXplID8gMCA6IDE7XG5cbiAgICAgICAgLy8gZG9uJ3QgcmUtcmVuZGVyIGlmIG9wdGltaXppbmcgb3IgaGlkZGVuICh3aWR0aCB3aWxsIGJlIHplcm8gcmVzdWx0aW5nIGluIHdlaXJkIGFuaW1hdGlvbnMpXG4gICAgICAgIGlmIChzaG91bGRPcHRpbWl6ZSB8fCByb290LnJlY3QuZWxlbWVudC5oaWRkZW4pIHJldHVybjtcblxuICAgICAgICAvLyBjYWxjdWxhdGUgc2NhbGVkIHByZXZpZXcgaW1hZ2Ugc2l6ZVxuICAgICAgICB2YXIgaW1hZ2VBc3BlY3RSYXRpbyA9IGltYWdlLmhlaWdodCAvIGltYWdlLndpZHRoO1xuICAgICAgICB2YXIgYXNwZWN0UmF0aW8gPSBjcm9wLmFzcGVjdFJhdGlvIHx8IGltYWdlQXNwZWN0UmF0aW87XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIGNvbnRhaW5lciBzaXplXG4gICAgICAgIHZhciBjb250YWluZXJXaWR0aCA9IHJvb3QucmVjdC5pbm5lci53aWR0aDtcbiAgICAgICAgdmFyIGNvbnRhaW5lckhlaWdodCA9IHJvb3QucmVjdC5pbm5lci5oZWlnaHQ7XG5cbiAgICAgICAgdmFyIGZpeGVkUHJldmlld0hlaWdodCA9IHJvb3QucXVlcnkoJ0dFVF9JTUFHRV9QUkVWSUVXX0hFSUdIVCcpO1xuICAgICAgICB2YXIgbWluUHJldmlld0hlaWdodCA9IHJvb3QucXVlcnkoJ0dFVF9JTUFHRV9QUkVWSUVXX01JTl9IRUlHSFQnKTtcbiAgICAgICAgdmFyIG1heFByZXZpZXdIZWlnaHQgPSByb290LnF1ZXJ5KCdHRVRfSU1BR0VfUFJFVklFV19NQVhfSEVJR0hUJyk7XG5cbiAgICAgICAgdmFyIHBhbmVsQXNwZWN0UmF0aW8gPSByb290LnF1ZXJ5KCdHRVRfUEFORUxfQVNQRUNUX1JBVElPJyk7XG4gICAgICAgIHZhciBhbGxvd011bHRpcGxlID0gcm9vdC5xdWVyeSgnR0VUX0FMTE9XX01VTFRJUExFJyk7XG5cbiAgICAgICAgaWYgKHBhbmVsQXNwZWN0UmF0aW8gJiYgIWFsbG93TXVsdGlwbGUpIHtcbiAgICAgICAgICBmaXhlZFByZXZpZXdIZWlnaHQgPSBjb250YWluZXJXaWR0aCAqIHBhbmVsQXNwZWN0UmF0aW87XG4gICAgICAgICAgYXNwZWN0UmF0aW8gPSBwYW5lbEFzcGVjdFJhdGlvO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZGV0ZXJtaW5lIGNsaXAgd2lkdGggYW5kIGhlaWdodFxuICAgICAgICB2YXIgY2xpcEhlaWdodCA9XG4gICAgICAgICAgZml4ZWRQcmV2aWV3SGVpZ2h0ICE9PSBudWxsXG4gICAgICAgICAgICA/IGZpeGVkUHJldmlld0hlaWdodFxuICAgICAgICAgICAgOiBNYXRoLm1heChcbiAgICAgICAgICAgICAgICBtaW5QcmV2aWV3SGVpZ2h0LFxuICAgICAgICAgICAgICAgIE1hdGgubWluKGNvbnRhaW5lcldpZHRoICogYXNwZWN0UmF0aW8sIG1heFByZXZpZXdIZWlnaHQpXG4gICAgICAgICAgICAgICk7XG5cbiAgICAgICAgdmFyIGNsaXBXaWR0aCA9IGNsaXBIZWlnaHQgLyBhc3BlY3RSYXRpbztcbiAgICAgICAgaWYgKGNsaXBXaWR0aCA+IGNvbnRhaW5lcldpZHRoKSB7XG4gICAgICAgICAgY2xpcFdpZHRoID0gY29udGFpbmVyV2lkdGg7XG4gICAgICAgICAgY2xpcEhlaWdodCA9IGNsaXBXaWR0aCAqIGFzcGVjdFJhdGlvO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNsaXBIZWlnaHQgPiBjb250YWluZXJIZWlnaHQpIHtcbiAgICAgICAgICBjbGlwSGVpZ2h0ID0gY29udGFpbmVySGVpZ2h0O1xuICAgICAgICAgIGNsaXBXaWR0aCA9IGNvbnRhaW5lckhlaWdodCAvIGFzcGVjdFJhdGlvO1xuICAgICAgICB9XG5cbiAgICAgICAgY2xpcC53aWR0aCA9IGNsaXBXaWR0aDtcbiAgICAgICAgY2xpcC5oZWlnaHQgPSBjbGlwSGVpZ2h0O1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHZhciBTVkdfTUFTSyA9XG4gICAgJzxzdmcgd2lkdGg9XCI1MDBcIiBoZWlnaHQ9XCIyMDBcIiB2aWV3Qm94PVwiMCAwIDUwMCAyMDBcIiBwcmVzZXJ2ZUFzcGVjdFJhdGlvPVwibm9uZVwiPlxcbiAgICA8ZGVmcz5cXG4gICAgICAgIDxyYWRpYWxHcmFkaWVudCBpZD1cImdyYWRpZW50LV9fVUlEX19cIiBjeD1cIi41XCIgY3k9XCIxLjI1XCIgcj1cIjEuMTVcIj5cXG4gICAgICAgICAgICA8c3RvcCBvZmZzZXQ9XFwnNTAlXFwnIHN0b3AtY29sb3I9XFwnIzAwMDAwMFxcJy8+XFxuICAgICAgICAgICAgPHN0b3Agb2Zmc2V0PVxcJzU2JVxcJyBzdG9wLWNvbG9yPVxcJyMwYTBhMGFcXCcvPlxcbiAgICAgICAgICAgIDxzdG9wIG9mZnNldD1cXCc2MyVcXCcgc3RvcC1jb2xvcj1cXCcjMjYyNjI2XFwnLz5cXG4gICAgICAgICAgICA8c3RvcCBvZmZzZXQ9XFwnNjklXFwnIHN0b3AtY29sb3I9XFwnIzRmNGY0ZlxcJy8+XFxuICAgICAgICAgICAgPHN0b3Agb2Zmc2V0PVxcJzc1JVxcJyBzdG9wLWNvbG9yPVxcJyM4MDgwODBcXCcvPlxcbiAgICAgICAgICAgIDxzdG9wIG9mZnNldD1cXCc4MSVcXCcgc3RvcC1jb2xvcj1cXCcjYjFiMWIxXFwnLz5cXG4gICAgICAgICAgICA8c3RvcCBvZmZzZXQ9XFwnODglXFwnIHN0b3AtY29sb3I9XFwnI2RhZGFkYVxcJy8+XFxuICAgICAgICAgICAgPHN0b3Agb2Zmc2V0PVxcJzk0JVxcJyBzdG9wLWNvbG9yPVxcJyNmNmY2ZjZcXCcvPlxcbiAgICAgICAgICAgIDxzdG9wIG9mZnNldD1cXCcxMDAlXFwnIHN0b3AtY29sb3I9XFwnI2ZmZmZmZlxcJy8+XFxuICAgICAgICA8L3JhZGlhbEdyYWRpZW50PlxcbiAgICAgICAgPG1hc2sgaWQ9XCJtYXNrLV9fVUlEX19cIj5cXG4gICAgICAgICAgICA8cmVjdCB4PVwiMFwiIHk9XCIwXCIgd2lkdGg9XCI1MDBcIiBoZWlnaHQ9XCIyMDBcIiBmaWxsPVwidXJsKCNncmFkaWVudC1fX1VJRF9fKVwiPjwvcmVjdD5cXG4gICAgICAgIDwvbWFzaz5cXG4gICAgPC9kZWZzPlxcbiAgICA8cmVjdCB4PVwiMFwiIHdpZHRoPVwiNTAwXCIgaGVpZ2h0PVwiMjAwXCIgZmlsbD1cImN1cnJlbnRDb2xvclwiIG1hc2s9XCJ1cmwoI21hc2stX19VSURfXylcIj48L3JlY3Q+XFxuPC9zdmc+JztcblxuICB2YXIgY2hlY2tlZE15QmFzZXMgPSBmYWxzZTtcbiAgdmFyIFNWR01hc2tVbmlxdWVJZCA9IDA7XG5cbiAgdmFyIGNyZWF0ZUltYWdlT3ZlcmxheVZpZXcgPSBmdW5jdGlvbiBjcmVhdGVJbWFnZU92ZXJsYXlWaWV3KGZwQVBJKSB7XG4gICAgcmV0dXJuIGZwQVBJLnV0aWxzLmNyZWF0ZVZpZXcoe1xuICAgICAgbmFtZTogJ2ltYWdlLXByZXZpZXctb3ZlcmxheScsXG4gICAgICB0YWc6ICdkaXYnLFxuICAgICAgaWdub3JlUmVjdDogdHJ1ZSxcbiAgICAgIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlKF9yZWYpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmLnJvb3QsXG4gICAgICAgICAgcHJvcHMgPSBfcmVmLnByb3BzO1xuXG4gICAgICAgIGlmICghY2hlY2tlZE15QmFzZXMgJiYgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYmFzZScpKSB7XG4gICAgICAgICAgU1ZHX01BU0sgPSBTVkdfTUFTSy5yZXBsYWNlKFxuICAgICAgICAgICAgL3VybFxcKFxcIy9nLFxuICAgICAgICAgICAgJ3VybCgnICtcbiAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYucmVwbGFjZSh3aW5kb3cubG9jYXRpb24uaGFzaCwgJycpICtcbiAgICAgICAgICAgICAgJyMnXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjaGVja2VkTXlCYXNlcyA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBTVkdNYXNrVW5pcXVlSWQrKztcbiAgICAgICAgcm9vdC5lbGVtZW50LmNsYXNzTGlzdC5hZGQoXG4gICAgICAgICAgJ2ZpbGVwb25kLS1pbWFnZS1wcmV2aWV3LW92ZXJsYXktJy5jb25jYXQocHJvcHMuc3RhdHVzKVxuICAgICAgICApO1xuICAgICAgICByb290LmVsZW1lbnQuaW5uZXJIVE1MID0gU1ZHX01BU0sucmVwbGFjZSgvX19VSURfXy9nLCBTVkdNYXNrVW5pcXVlSWQpO1xuICAgICAgfSxcbiAgICAgIG1peGluczoge1xuICAgICAgICBzdHlsZXM6IFsnb3BhY2l0eSddLFxuICAgICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgICAgb3BhY2l0eTogeyB0eXBlOiAnc3ByaW5nJywgbWFzczogMjUgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEJpdG1hcCBXb3JrZXJcbiAgICovXG4gIHZhciBCaXRtYXBXb3JrZXIgPSBmdW5jdGlvbiBCaXRtYXBXb3JrZXIoKSB7XG4gICAgc2VsZi5vbm1lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgICBjcmVhdGVJbWFnZUJpdG1hcChlLmRhdGEubWVzc2FnZS5maWxlKS50aGVuKGZ1bmN0aW9uKGJpdG1hcCkge1xuICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHsgaWQ6IGUuZGF0YS5pZCwgbWVzc2FnZTogYml0bWFwIH0sIFtiaXRtYXBdKTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbG9yTWF0cml4IFdvcmtlclxuICAgKi9cbiAgdmFyIENvbG9yTWF0cml4V29ya2VyID0gZnVuY3Rpb24gQ29sb3JNYXRyaXhXb3JrZXIoKSB7XG4gICAgc2VsZi5vbm1lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gZS5kYXRhLm1lc3NhZ2UuaW1hZ2VEYXRhO1xuICAgICAgdmFyIG1hdHJpeCA9IGUuZGF0YS5tZXNzYWdlLmNvbG9yTWF0cml4O1xuXG4gICAgICB2YXIgZGF0YSA9IGltYWdlRGF0YS5kYXRhO1xuICAgICAgdmFyIGwgPSBkYXRhLmxlbmd0aDtcblxuICAgICAgdmFyIG0xMSA9IG1hdHJpeFswXTtcbiAgICAgIHZhciBtMTIgPSBtYXRyaXhbMV07XG4gICAgICB2YXIgbTEzID0gbWF0cml4WzJdO1xuICAgICAgdmFyIG0xNCA9IG1hdHJpeFszXTtcbiAgICAgIHZhciBtMTUgPSBtYXRyaXhbNF07XG5cbiAgICAgIHZhciBtMjEgPSBtYXRyaXhbNV07XG4gICAgICB2YXIgbTIyID0gbWF0cml4WzZdO1xuICAgICAgdmFyIG0yMyA9IG1hdHJpeFs3XTtcbiAgICAgIHZhciBtMjQgPSBtYXRyaXhbOF07XG4gICAgICB2YXIgbTI1ID0gbWF0cml4WzldO1xuXG4gICAgICB2YXIgbTMxID0gbWF0cml4WzEwXTtcbiAgICAgIHZhciBtMzIgPSBtYXRyaXhbMTFdO1xuICAgICAgdmFyIG0zMyA9IG1hdHJpeFsxMl07XG4gICAgICB2YXIgbTM0ID0gbWF0cml4WzEzXTtcbiAgICAgIHZhciBtMzUgPSBtYXRyaXhbMTRdO1xuXG4gICAgICB2YXIgbTQxID0gbWF0cml4WzE1XTtcbiAgICAgIHZhciBtNDIgPSBtYXRyaXhbMTZdO1xuICAgICAgdmFyIG00MyA9IG1hdHJpeFsxN107XG4gICAgICB2YXIgbTQ0ID0gbWF0cml4WzE4XTtcbiAgICAgIHZhciBtNDUgPSBtYXRyaXhbMTldO1xuXG4gICAgICB2YXIgaW5kZXggPSAwLFxuICAgICAgICByID0gMC4wLFxuICAgICAgICBnID0gMC4wLFxuICAgICAgICBiID0gMC4wLFxuICAgICAgICBhID0gMC4wO1xuXG4gICAgICBmb3IgKDsgaW5kZXggPCBsOyBpbmRleCArPSA0KSB7XG4gICAgICAgIHIgPSBkYXRhW2luZGV4XSAvIDI1NTtcbiAgICAgICAgZyA9IGRhdGFbaW5kZXggKyAxXSAvIDI1NTtcbiAgICAgICAgYiA9IGRhdGFbaW5kZXggKyAyXSAvIDI1NTtcbiAgICAgICAgYSA9IGRhdGFbaW5kZXggKyAzXSAvIDI1NTtcbiAgICAgICAgZGF0YVtpbmRleF0gPSBNYXRoLm1heChcbiAgICAgICAgICAwLFxuICAgICAgICAgIE1hdGgubWluKChyICogbTExICsgZyAqIG0xMiArIGIgKiBtMTMgKyBhICogbTE0ICsgbTE1KSAqIDI1NSwgMjU1KVxuICAgICAgICApO1xuICAgICAgICBkYXRhW2luZGV4ICsgMV0gPSBNYXRoLm1heChcbiAgICAgICAgICAwLFxuICAgICAgICAgIE1hdGgubWluKChyICogbTIxICsgZyAqIG0yMiArIGIgKiBtMjMgKyBhICogbTI0ICsgbTI1KSAqIDI1NSwgMjU1KVxuICAgICAgICApO1xuICAgICAgICBkYXRhW2luZGV4ICsgMl0gPSBNYXRoLm1heChcbiAgICAgICAgICAwLFxuICAgICAgICAgIE1hdGgubWluKChyICogbTMxICsgZyAqIG0zMiArIGIgKiBtMzMgKyBhICogbTM0ICsgbTM1KSAqIDI1NSwgMjU1KVxuICAgICAgICApO1xuICAgICAgICBkYXRhW2luZGV4ICsgM10gPSBNYXRoLm1heChcbiAgICAgICAgICAwLFxuICAgICAgICAgIE1hdGgubWluKChyICogbTQxICsgZyAqIG00MiArIGIgKiBtNDMgKyBhICogbTQ0ICsgbTQ1KSAqIDI1NSwgMjU1KVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBzZWxmLnBvc3RNZXNzYWdlKHsgaWQ6IGUuZGF0YS5pZCwgbWVzc2FnZTogaW1hZ2VEYXRhIH0sIFtcbiAgICAgICAgaW1hZ2VEYXRhLmRhdGEuYnVmZmVyXG4gICAgICBdKTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBnZXRJbWFnZVNpemUgPSBmdW5jdGlvbiBnZXRJbWFnZVNpemUodXJsLCBjYikge1xuICAgIHZhciBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgIGltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHdpZHRoID0gaW1hZ2UubmF0dXJhbFdpZHRoO1xuICAgICAgdmFyIGhlaWdodCA9IGltYWdlLm5hdHVyYWxIZWlnaHQ7XG4gICAgICBpbWFnZSA9IG51bGw7XG4gICAgICBjYih3aWR0aCwgaGVpZ2h0KTtcbiAgICB9O1xuICAgIGltYWdlLnNyYyA9IHVybDtcbiAgfTtcblxuICB2YXIgdHJhbnNmb3JtcyA9IHtcbiAgICAxOiBmdW5jdGlvbiBfKCkge1xuICAgICAgcmV0dXJuIFsxLCAwLCAwLCAxLCAwLCAwXTtcbiAgICB9LFxuICAgIDI6IGZ1bmN0aW9uIF8od2lkdGgpIHtcbiAgICAgIHJldHVybiBbLTEsIDAsIDAsIDEsIHdpZHRoLCAwXTtcbiAgICB9LFxuICAgIDM6IGZ1bmN0aW9uIF8od2lkdGgsIGhlaWdodCkge1xuICAgICAgcmV0dXJuIFstMSwgMCwgMCwgLTEsIHdpZHRoLCBoZWlnaHRdO1xuICAgIH0sXG4gICAgNDogZnVuY3Rpb24gXyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICByZXR1cm4gWzEsIDAsIDAsIC0xLCAwLCBoZWlnaHRdO1xuICAgIH0sXG4gICAgNTogZnVuY3Rpb24gXygpIHtcbiAgICAgIHJldHVybiBbMCwgMSwgMSwgMCwgMCwgMF07XG4gICAgfSxcbiAgICA2OiBmdW5jdGlvbiBfKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHJldHVybiBbMCwgMSwgLTEsIDAsIGhlaWdodCwgMF07XG4gICAgfSxcbiAgICA3OiBmdW5jdGlvbiBfKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHJldHVybiBbMCwgLTEsIC0xLCAwLCBoZWlnaHQsIHdpZHRoXTtcbiAgICB9LFxuICAgIDg6IGZ1bmN0aW9uIF8od2lkdGgpIHtcbiAgICAgIHJldHVybiBbMCwgLTEsIDEsIDAsIDAsIHdpZHRoXTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGZpeEltYWdlT3JpZW50YXRpb24gPSBmdW5jdGlvbiBmaXhJbWFnZU9yaWVudGF0aW9uKFxuICAgIGN0eCxcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgb3JpZW50YXRpb25cbiAgKSB7XG4gICAgLy8gbm8gb3JpZW50YXRpb24gc3VwcGxpZWRcbiAgICBpZiAob3JpZW50YXRpb24gPT09IC0xKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY3R4LnRyYW5zZm9ybS5hcHBseShjdHgsIHRyYW5zZm9ybXNbb3JpZW50YXRpb25dKHdpZHRoLCBoZWlnaHQpKTtcbiAgfTtcblxuICAvLyBkcmF3cyB0aGUgcHJldmlldyBpbWFnZSB0byBjYW52YXNcbiAgdmFyIGNyZWF0ZVByZXZpZXdJbWFnZSA9IGZ1bmN0aW9uIGNyZWF0ZVByZXZpZXdJbWFnZShcbiAgICBkYXRhLFxuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBvcmllbnRhdGlvblxuICApIHtcbiAgICAvLyBjYW4ndCBkcmF3IG9uIGhhbGYgcGl4ZWxzXG4gICAgd2lkdGggPSBNYXRoLnJvdW5kKHdpZHRoKTtcbiAgICBoZWlnaHQgPSBNYXRoLnJvdW5kKGhlaWdodCk7XG5cbiAgICAvLyBkcmF3IGltYWdlXG4gICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgLy8gaWYgaXMgcm90YXRlZCBpbmNvcnJlY3RseSBzd2FwIHdpZHRoIGFuZCBoZWlnaHRcbiAgICBpZiAob3JpZW50YXRpb24gPj0gNSAmJiBvcmllbnRhdGlvbiA8PSA4KSB7XG4gICAgICB2YXIgX3JlZiA9IFtoZWlnaHQsIHdpZHRoXTtcbiAgICAgIHdpZHRoID0gX3JlZlswXTtcbiAgICAgIGhlaWdodCA9IF9yZWZbMV07XG4gICAgfVxuXG4gICAgLy8gY29ycmVjdCBpbWFnZSBvcmllbnRhdGlvblxuICAgIGZpeEltYWdlT3JpZW50YXRpb24oY3R4LCB3aWR0aCwgaGVpZ2h0LCBvcmllbnRhdGlvbik7XG5cbiAgICAvLyBkcmF3IHRoZSBpbWFnZVxuICAgIGN0eC5kcmF3SW1hZ2UoZGF0YSwgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICByZXR1cm4gY2FudmFzO1xuICB9O1xuXG4gIHZhciBpc0JpdG1hcCA9IGZ1bmN0aW9uIGlzQml0bWFwKGZpbGUpIHtcbiAgICByZXR1cm4gL15pbWFnZS8udGVzdChmaWxlLnR5cGUpICYmICEvc3ZnLy50ZXN0KGZpbGUudHlwZSk7XG4gIH07XG5cbiAgdmFyIE1BWF9XSURUSCA9IDEwO1xuICB2YXIgTUFYX0hFSUdIVCA9IDEwO1xuXG4gIHZhciBjYWxjdWxhdGVBdmVyYWdlQ29sb3IgPSBmdW5jdGlvbiBjYWxjdWxhdGVBdmVyYWdlQ29sb3IoaW1hZ2UpIHtcbiAgICB2YXIgc2NhbGFyID0gTWF0aC5taW4oTUFYX1dJRFRIIC8gaW1hZ2Uud2lkdGgsIE1BWF9IRUlHSFQgLyBpbWFnZS5oZWlnaHQpO1xuXG4gICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB2YXIgd2lkdGggPSAoY2FudmFzLndpZHRoID0gTWF0aC5jZWlsKGltYWdlLndpZHRoICogc2NhbGFyKSk7XG4gICAgdmFyIGhlaWdodCA9IChjYW52YXMuaGVpZ2h0ID0gTWF0aC5jZWlsKGltYWdlLmhlaWdodCAqIHNjYWxhcikpO1xuICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgIHZhciBkYXRhID0gbnVsbDtcbiAgICB0cnkge1xuICAgICAgZGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgd2lkdGgsIGhlaWdodCkuZGF0YTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGwgPSBkYXRhLmxlbmd0aDtcblxuICAgIHZhciByID0gMDtcbiAgICB2YXIgZyA9IDA7XG4gICAgdmFyIGIgPSAwO1xuICAgIHZhciBpID0gMDtcblxuICAgIGZvciAoOyBpIDwgbDsgaSArPSA0KSB7XG4gICAgICByICs9IGRhdGFbaV0gKiBkYXRhW2ldO1xuICAgICAgZyArPSBkYXRhW2kgKyAxXSAqIGRhdGFbaSArIDFdO1xuICAgICAgYiArPSBkYXRhW2kgKyAyXSAqIGRhdGFbaSArIDJdO1xuICAgIH1cblxuICAgIHIgPSBhdmVyYWdlQ29sb3IociwgbCk7XG4gICAgZyA9IGF2ZXJhZ2VDb2xvcihnLCBsKTtcbiAgICBiID0gYXZlcmFnZUNvbG9yKGIsIGwpO1xuXG4gICAgcmV0dXJuIHsgcjogciwgZzogZywgYjogYiB9O1xuICB9O1xuXG4gIHZhciBhdmVyYWdlQ29sb3IgPSBmdW5jdGlvbiBhdmVyYWdlQ29sb3IoYywgbCkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGguc3FydChjIC8gKGwgLyA0KSkpO1xuICB9O1xuXG4gIHZhciBjbG9uZUNhbnZhcyA9IGZ1bmN0aW9uIGNsb25lQ2FudmFzKG9yaWdpbiwgdGFyZ2V0KSB7XG4gICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIHRhcmdldC53aWR0aCA9IG9yaWdpbi53aWR0aDtcbiAgICB0YXJnZXQuaGVpZ2h0ID0gb3JpZ2luLmhlaWdodDtcbiAgICB2YXIgY3R4ID0gdGFyZ2V0LmdldENvbnRleHQoJzJkJyk7XG4gICAgY3R4LmRyYXdJbWFnZShvcmlnaW4sIDAsIDApO1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG5cbiAgdmFyIGNsb25lSW1hZ2VEYXRhID0gZnVuY3Rpb24gY2xvbmVJbWFnZURhdGEoaW1hZ2VEYXRhKSB7XG4gICAgdmFyIGlkO1xuICAgIHRyeSB7XG4gICAgICBpZCA9IG5ldyBJbWFnZURhdGEoaW1hZ2VEYXRhLndpZHRoLCBpbWFnZURhdGEuaGVpZ2h0KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBpZCA9IGN0eC5jcmVhdGVJbWFnZURhdGEoaW1hZ2VEYXRhLndpZHRoLCBpbWFnZURhdGEuaGVpZ2h0KTtcbiAgICB9XG4gICAgaWQuZGF0YS5zZXQobmV3IFVpbnQ4Q2xhbXBlZEFycmF5KGltYWdlRGF0YS5kYXRhKSk7XG4gICAgcmV0dXJuIGlkO1xuICB9O1xuXG4gIHZhciBsb2FkSW1hZ2UgPSBmdW5jdGlvbiBsb2FkSW1hZ2UodXJsKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIGltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgaW1nLmNyb3NzT3JpZ2luID0gJ0Fub255bW91cyc7XG4gICAgICBpbWcub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlc29sdmUoaW1nKTtcbiAgICAgIH07XG4gICAgICBpbWcub25lcnJvciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfTtcbiAgICAgIGltZy5zcmMgPSB1cmw7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUltYWdlV3JhcHBlclZpZXcgPSBmdW5jdGlvbiBjcmVhdGVJbWFnZVdyYXBwZXJWaWV3KF8pIHtcbiAgICAvLyBjcmVhdGUgb3ZlcmxheSB2aWV3XG4gICAgdmFyIE92ZXJsYXlWaWV3ID0gY3JlYXRlSW1hZ2VPdmVybGF5VmlldyhfKTtcblxuICAgIHZhciBJbWFnZVZpZXcgPSBjcmVhdGVJbWFnZVZpZXcoXyk7XG4gICAgdmFyIGNyZWF0ZVdvcmtlciA9IF8udXRpbHMuY3JlYXRlV29ya2VyO1xuXG4gICAgdmFyIGFwcGx5RmlsdGVyID0gZnVuY3Rpb24gYXBwbHlGaWx0ZXIocm9vdCwgZmlsdGVyLCB0YXJnZXQpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgIC8vIHdpbGwgc3RvcmUgaW1hZ2UgZGF0YSBmb3IgZnV0dXJlIGZpbHRlciB1cGRhdGVzXG4gICAgICAgIGlmICghcm9vdC5yZWYuaW1hZ2VEYXRhKSB7XG4gICAgICAgICAgcm9vdC5yZWYuaW1hZ2VEYXRhID0gdGFyZ2V0XG4gICAgICAgICAgICAuZ2V0Q29udGV4dCgnMmQnKVxuICAgICAgICAgICAgLmdldEltYWdlRGF0YSgwLCAwLCB0YXJnZXQud2lkdGgsIHRhcmdldC5oZWlnaHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2V0IGltYWdlIGRhdGEgcmVmZXJlbmNlXG4gICAgICAgIHZhciBpbWFnZURhdGEgPSBjbG9uZUltYWdlRGF0YShyb290LnJlZi5pbWFnZURhdGEpO1xuXG4gICAgICAgIGlmICghZmlsdGVyIHx8IGZpbHRlci5sZW5ndGggIT09IDIwKSB7XG4gICAgICAgICAgdGFyZ2V0LmdldENvbnRleHQoJzJkJykucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMCk7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB3b3JrZXIgPSBjcmVhdGVXb3JrZXIoQ29sb3JNYXRyaXhXb3JrZXIpO1xuICAgICAgICB3b3JrZXIucG9zdChcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpbWFnZURhdGE6IGltYWdlRGF0YSxcbiAgICAgICAgICAgIGNvbG9yTWF0cml4OiBmaWx0ZXJcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIC8vIGFwcGx5IGZpbHRlcmVkIGNvbG9yc1xuICAgICAgICAgICAgdGFyZ2V0LmdldENvbnRleHQoJzJkJykucHV0SW1hZ2VEYXRhKHJlc3BvbnNlLCAwLCAwKTtcblxuICAgICAgICAgICAgLy8gc3RvcCB3b3JrZXJcbiAgICAgICAgICAgIHdvcmtlci50ZXJtaW5hdGUoKTtcblxuICAgICAgICAgICAgLy8gZG9uZSFcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIFtpbWFnZURhdGEuZGF0YS5idWZmZXJdXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIHJlbW92ZUltYWdlVmlldyA9IGZ1bmN0aW9uIHJlbW92ZUltYWdlVmlldyhyb290LCBpbWFnZVZpZXcpIHtcbiAgICAgIHJvb3QucmVtb3ZlQ2hpbGRWaWV3KGltYWdlVmlldyk7XG4gICAgICBpbWFnZVZpZXcuaW1hZ2Uud2lkdGggPSAxO1xuICAgICAgaW1hZ2VWaWV3LmltYWdlLmhlaWdodCA9IDE7XG4gICAgICBpbWFnZVZpZXcuX2Rlc3Ryb3koKTtcbiAgICB9O1xuXG4gICAgLy8gcmVtb3ZlIGFuIGltYWdlXG4gICAgdmFyIHNoaWZ0SW1hZ2UgPSBmdW5jdGlvbiBzaGlmdEltYWdlKF9yZWYpIHtcbiAgICAgIHZhciByb290ID0gX3JlZi5yb290O1xuICAgICAgdmFyIGltYWdlVmlldyA9IHJvb3QucmVmLmltYWdlcy5zaGlmdCgpO1xuICAgICAgaW1hZ2VWaWV3Lm9wYWNpdHkgPSAwO1xuICAgICAgaW1hZ2VWaWV3LnRyYW5zbGF0ZVkgPSAtMTU7XG4gICAgICByb290LnJlZi5pbWFnZVZpZXdCaW4ucHVzaChpbWFnZVZpZXcpO1xuICAgICAgcmV0dXJuIGltYWdlVmlldztcbiAgICB9O1xuXG4gICAgLy8gYWRkIG5ldyBpbWFnZVxuICAgIHZhciBwdXNoSW1hZ2UgPSBmdW5jdGlvbiBwdXNoSW1hZ2UoX3JlZjIpIHtcbiAgICAgIHZhciByb290ID0gX3JlZjIucm9vdCxcbiAgICAgICAgcHJvcHMgPSBfcmVmMi5wcm9wcyxcbiAgICAgICAgaW1hZ2UgPSBfcmVmMi5pbWFnZTtcblxuICAgICAgdmFyIGlkID0gcHJvcHMuaWQ7XG4gICAgICB2YXIgaXRlbSA9IHJvb3QucXVlcnkoJ0dFVF9JVEVNJywgeyBpZDogaWQgfSk7XG4gICAgICBpZiAoIWl0ZW0pIHJldHVybjtcblxuICAgICAgdmFyIGNyb3AgPSBpdGVtLmdldE1ldGFkYXRhKCdjcm9wJykgfHwge1xuICAgICAgICBjZW50ZXI6IHtcbiAgICAgICAgICB4OiAwLjUsXG4gICAgICAgICAgeTogMC41XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmxpcDoge1xuICAgICAgICAgIGhvcml6b250YWw6IGZhbHNlLFxuICAgICAgICAgIHZlcnRpY2FsOiBmYWxzZVxuICAgICAgICB9LFxuXG4gICAgICAgIHpvb206IDEsXG4gICAgICAgIHJvdGF0aW9uOiAwLFxuICAgICAgICBhc3BlY3RSYXRpbzogbnVsbFxuICAgICAgfTtcblxuICAgICAgdmFyIGJhY2tncm91bmQgPSByb290LnF1ZXJ5KFxuICAgICAgICAnR0VUX0lNQUdFX1RSQU5TRk9STV9DQU5WQVNfQkFDS0dST1VORF9DT0xPUidcbiAgICAgICk7XG5cbiAgICAgIHZhciBtYXJrdXA7XG4gICAgICB2YXIgcmVzaXplO1xuICAgICAgdmFyIGRpcnR5ID0gZmFsc2U7XG4gICAgICBpZiAocm9vdC5xdWVyeSgnR0VUX0lNQUdFX1BSRVZJRVdfTUFSS1VQX1NIT1cnKSkge1xuICAgICAgICBtYXJrdXAgPSBpdGVtLmdldE1ldGFkYXRhKCdtYXJrdXAnKSB8fCBbXTtcbiAgICAgICAgcmVzaXplID0gaXRlbS5nZXRNZXRhZGF0YSgncmVzaXplJyk7XG4gICAgICAgIGRpcnR5ID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gYXBwZW5kIGltYWdlIHByZXNlbnRlclxuICAgICAgdmFyIGltYWdlVmlldyA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KFxuICAgICAgICByb290LmNyZWF0ZUNoaWxkVmlldyhJbWFnZVZpZXcsIHtcbiAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgaW1hZ2U6IGltYWdlLFxuICAgICAgICAgIGNyb3A6IGNyb3AsXG4gICAgICAgICAgcmVzaXplOiByZXNpemUsXG4gICAgICAgICAgbWFya3VwOiBtYXJrdXAsXG4gICAgICAgICAgZGlydHk6IGRpcnR5LFxuICAgICAgICAgIGJhY2tncm91bmQ6IGJhY2tncm91bmQsXG4gICAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgICBzY2FsZVg6IDEuMTUsXG4gICAgICAgICAgc2NhbGVZOiAxLjE1LFxuICAgICAgICAgIHRyYW5zbGF0ZVk6IDE1XG4gICAgICAgIH0pLFxuXG4gICAgICAgIHJvb3QuY2hpbGRWaWV3cy5sZW5ndGhcbiAgICAgICk7XG5cbiAgICAgIHJvb3QucmVmLmltYWdlcy5wdXNoKGltYWdlVmlldyk7XG5cbiAgICAgIC8vIHJldmVhbCB0aGUgcHJldmlldyBpbWFnZVxuICAgICAgaW1hZ2VWaWV3Lm9wYWNpdHkgPSAxO1xuICAgICAgaW1hZ2VWaWV3LnNjYWxlWCA9IDE7XG4gICAgICBpbWFnZVZpZXcuc2NhbGVZID0gMTtcbiAgICAgIGltYWdlVmlldy50cmFuc2xhdGVZID0gMDtcblxuICAgICAgLy8gdGhlIHByZXZpZXcgaXMgbm93IHJlYWR5IHRvIGJlIGRyYXduXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICByb290LmRpc3BhdGNoKCdESURfSU1BR0VfUFJFVklFV19TSE9XJywgeyBpZDogaWQgfSk7XG4gICAgICB9LCAyNTApO1xuICAgIH07XG5cbiAgICB2YXIgdXBkYXRlSW1hZ2UgPSBmdW5jdGlvbiB1cGRhdGVJbWFnZShfcmVmMykge1xuICAgICAgdmFyIHJvb3QgPSBfcmVmMy5yb290LFxuICAgICAgICBwcm9wcyA9IF9yZWYzLnByb3BzO1xuICAgICAgdmFyIGl0ZW0gPSByb290LnF1ZXJ5KCdHRVRfSVRFTScsIHsgaWQ6IHByb3BzLmlkIH0pO1xuICAgICAgaWYgKCFpdGVtKSByZXR1cm47XG4gICAgICB2YXIgaW1hZ2VWaWV3ID0gcm9vdC5yZWYuaW1hZ2VzW3Jvb3QucmVmLmltYWdlcy5sZW5ndGggLSAxXTtcbiAgICAgIGltYWdlVmlldy5jcm9wID0gaXRlbS5nZXRNZXRhZGF0YSgnY3JvcCcpO1xuICAgICAgaW1hZ2VWaWV3LmJhY2tncm91bmQgPSByb290LnF1ZXJ5KFxuICAgICAgICAnR0VUX0lNQUdFX1RSQU5TRk9STV9DQU5WQVNfQkFDS0dST1VORF9DT0xPUidcbiAgICAgICk7XG4gICAgICBpZiAocm9vdC5xdWVyeSgnR0VUX0lNQUdFX1BSRVZJRVdfTUFSS1VQX1NIT1cnKSkge1xuICAgICAgICBpbWFnZVZpZXcuZGlydHkgPSB0cnVlO1xuICAgICAgICBpbWFnZVZpZXcucmVzaXplID0gaXRlbS5nZXRNZXRhZGF0YSgncmVzaXplJyk7XG4gICAgICAgIGltYWdlVmlldy5tYXJrdXAgPSBpdGVtLmdldE1ldGFkYXRhKCdtYXJrdXAnKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gcmVwbGFjZSBpbWFnZSBwcmV2aWV3XG4gICAgdmFyIGRpZFVwZGF0ZUl0ZW1NZXRhZGF0YSA9IGZ1bmN0aW9uIGRpZFVwZGF0ZUl0ZW1NZXRhZGF0YShfcmVmNCkge1xuICAgICAgdmFyIHJvb3QgPSBfcmVmNC5yb290LFxuICAgICAgICBwcm9wcyA9IF9yZWY0LnByb3BzLFxuICAgICAgICBhY3Rpb24gPSBfcmVmNC5hY3Rpb247XG5cbiAgICAgIC8vIG9ubHkgZmlsdGVyIGFuZCBjcm9wIHRyaWdnZXIgcmVkcmF3XG4gICAgICBpZiAoIS9jcm9wfGZpbHRlcnxtYXJrdXB8cmVzaXplLy50ZXN0KGFjdGlvbi5jaGFuZ2Uua2V5KSkgcmV0dXJuO1xuXG4gICAgICAvLyBubyBpbWFnZXMgdG8gdXBkYXRlLCBleGl0XG4gICAgICBpZiAoIXJvb3QucmVmLmltYWdlcy5sZW5ndGgpIHJldHVybjtcblxuICAgICAgLy8gbm8gaXRlbSBmb3VuZCwgZXhpdFxuICAgICAgdmFyIGl0ZW0gPSByb290LnF1ZXJ5KCdHRVRfSVRFTScsIHsgaWQ6IHByb3BzLmlkIH0pO1xuICAgICAgaWYgKCFpdGVtKSByZXR1cm47XG5cbiAgICAgIC8vIGZvciBub3csIHVwZGF0ZSBleGlzdGluZyBpbWFnZSB3aGVuIGZpbHRlcmluZ1xuICAgICAgaWYgKC9maWx0ZXIvLnRlc3QoYWN0aW9uLmNoYW5nZS5rZXkpKSB7XG4gICAgICAgIHZhciBpbWFnZVZpZXcgPSByb290LnJlZi5pbWFnZXNbcm9vdC5yZWYuaW1hZ2VzLmxlbmd0aCAtIDFdO1xuICAgICAgICBhcHBseUZpbHRlcihyb290LCBhY3Rpb24uY2hhbmdlLnZhbHVlLCBpbWFnZVZpZXcuaW1hZ2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICgvY3JvcHxtYXJrdXB8cmVzaXplLy50ZXN0KGFjdGlvbi5jaGFuZ2Uua2V5KSkge1xuICAgICAgICB2YXIgY3JvcCA9IGl0ZW0uZ2V0TWV0YWRhdGEoJ2Nyb3AnKTtcbiAgICAgICAgdmFyIGltYWdlID0gcm9vdC5yZWYuaW1hZ2VzW3Jvb3QucmVmLmltYWdlcy5sZW5ndGggLSAxXTtcblxuICAgICAgICAvLyBpZiBhc3BlY3QgcmF0aW8gaGFzIGNoYW5nZWQsIHdlIG5lZWQgdG8gY3JlYXRlIGEgbmV3IGltYWdlXG4gICAgICAgIGlmIChNYXRoLmFicyhjcm9wLmFzcGVjdFJhdGlvIC0gaW1hZ2UuY3JvcC5hc3BlY3RSYXRpbykgPiAwLjAwMDAxKSB7XG4gICAgICAgICAgdmFyIF9pbWFnZVZpZXcgPSBzaGlmdEltYWdlKHsgcm9vdDogcm9vdCB9KTtcbiAgICAgICAgICBwdXNoSW1hZ2Uoe1xuICAgICAgICAgICAgcm9vdDogcm9vdCxcbiAgICAgICAgICAgIHByb3BzOiBwcm9wcyxcbiAgICAgICAgICAgIGltYWdlOiBjbG9uZUNhbnZhcyhfaW1hZ2VWaWV3LmltYWdlKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIG5vdCwgd2UgY2FuIHVwZGF0ZSB0aGUgY3VycmVudCBpbWFnZVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB1cGRhdGVJbWFnZSh7IHJvb3Q6IHJvb3QsIHByb3BzOiBwcm9wcyB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgY2FuQ3JlYXRlSW1hZ2VCaXRtYXAgPSBmdW5jdGlvbiBjYW5DcmVhdGVJbWFnZUJpdG1hcChmaWxlKSB7XG4gICAgICAvLyBGaXJlZm94IHZlcnNpb25zIGJlZm9yZSA1OCB3aWxsIGZyZWV6ZSB3aGVuIHJ1bm5pbmcgY3JlYXRlSW1hZ2VCaXRtYXBcbiAgICAgIC8vIGluIGEgV2ViIFdvcmtlciBzbyB3ZSBkZXRlY3QgdGhvc2UgdmVyc2lvbnMgYW5kIHJldHVybiBmYWxzZSBmb3Igc3VwcG9ydFxuICAgICAgdmFyIHVzZXJBZ2VudCA9IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50O1xuICAgICAgdmFyIGlzRmlyZWZveCA9IHVzZXJBZ2VudC5tYXRjaCgvRmlyZWZveFxcLyhbMC05XSspXFwuLyk7XG4gICAgICB2YXIgZmlyZWZveFZlcnNpb24gPSBpc0ZpcmVmb3ggPyBwYXJzZUludChpc0ZpcmVmb3hbMV0pIDogbnVsbDtcbiAgICAgIGlmIChmaXJlZm94VmVyc2lvbiA8PSA1OCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICByZXR1cm4gJ2NyZWF0ZUltYWdlQml0bWFwJyBpbiB3aW5kb3cgJiYgaXNCaXRtYXAoZmlsZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFdyaXRlIGhhbmRsZXIgZm9yIHdoZW4gcHJldmlldyBjb250YWluZXIgaGFzIGJlZW4gY3JlYXRlZFxuICAgICAqL1xuICAgIHZhciBkaWRDcmVhdGVQcmV2aWV3Q29udGFpbmVyID0gZnVuY3Rpb24gZGlkQ3JlYXRlUHJldmlld0NvbnRhaW5lcihfcmVmNSkge1xuICAgICAgdmFyIHJvb3QgPSBfcmVmNS5yb290LFxuICAgICAgICBwcm9wcyA9IF9yZWY1LnByb3BzO1xuICAgICAgdmFyIGlkID0gcHJvcHMuaWQ7XG5cbiAgICAgIC8vIHdlIG5lZWQgdG8gZ2V0IHRoZSBmaWxlIGRhdGEgdG8gZGV0ZXJtaW5lIHRoZSBldmVudHVhbCBpbWFnZSBzaXplXG4gICAgICB2YXIgaXRlbSA9IHJvb3QucXVlcnkoJ0dFVF9JVEVNJywgaWQpO1xuICAgICAgaWYgKCFpdGVtKSByZXR1cm47XG5cbiAgICAgIC8vIGdldCB1cmwgdG8gZmlsZSAod2UnbGwgcmV2b2tlIGl0IGxhdGVyIG9uIHdoZW4gZG9uZSlcbiAgICAgIHZhciBmaWxlVVJMID0gVVJMLmNyZWF0ZU9iamVjdFVSTChpdGVtLmZpbGUpO1xuXG4gICAgICAvLyBkZXRlcm1pbmUgaW1hZ2Ugc2l6ZSBvZiB0aGlzIGl0ZW1cbiAgICAgIGdldEltYWdlU2l6ZShmaWxlVVJMLCBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIC8vIHdlIGNhbiBub3cgc2NhbGUgdGhlIHBhbmVsIHRvIHRoZSBmaW5hbCBzaXplXG4gICAgICAgIHJvb3QuZGlzcGF0Y2goJ0RJRF9JTUFHRV9QUkVWSUVXX0NBTENVTEFURV9TSVpFJywge1xuICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIGRyYXdQcmV2aWV3ID0gZnVuY3Rpb24gZHJhd1ByZXZpZXcoX3JlZjYpIHtcbiAgICAgIHZhciByb290ID0gX3JlZjYucm9vdCxcbiAgICAgICAgcHJvcHMgPSBfcmVmNi5wcm9wcztcbiAgICAgIHZhciBpZCA9IHByb3BzLmlkO1xuXG4gICAgICAvLyB3ZSBuZWVkIHRvIGdldCB0aGUgZmlsZSBkYXRhIHRvIGRldGVybWluZSB0aGUgZXZlbnR1YWwgaW1hZ2Ugc2l6ZVxuICAgICAgdmFyIGl0ZW0gPSByb290LnF1ZXJ5KCdHRVRfSVRFTScsIGlkKTtcbiAgICAgIGlmICghaXRlbSkgcmV0dXJuO1xuXG4gICAgICAvLyBnZXQgdXJsIHRvIGZpbGUgKHdlJ2xsIHJldm9rZSBpdCBsYXRlciBvbiB3aGVuIGRvbmUpXG4gICAgICB2YXIgZmlsZVVSTCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoaXRlbS5maWxlKTtcblxuICAgICAgLy8gZmFsbGJhY2tcbiAgICAgIHZhciBsb2FkUHJldmlld0ZhbGxiYWNrID0gZnVuY3Rpb24gbG9hZFByZXZpZXdGYWxsYmFjaygpIHtcbiAgICAgICAgLy8gbGV0J3Mgc2NhbGUgdGhlIGltYWdlIGluIHRoZSBtYWluIHRocmVhZCA6KFxuICAgICAgICBsb2FkSW1hZ2UoZmlsZVVSTCkudGhlbihwcmV2aWV3SW1hZ2VMb2FkZWQpO1xuICAgICAgfTtcblxuICAgICAgLy8gaW1hZ2UgaXMgbm93IHJlYWR5XG4gICAgICB2YXIgcHJldmlld0ltYWdlTG9hZGVkID0gZnVuY3Rpb24gcHJldmlld0ltYWdlTG9hZGVkKGltYWdlRGF0YSkge1xuICAgICAgICAvLyB0aGUgZmlsZSB1cmwgaXMgbm8gbG9uZ2VyIG5lZWRlZFxuICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKGZpbGVVUkwpO1xuXG4gICAgICAgIC8vIGRyYXcgdGhlIHNjYWxlZCBkb3duIHZlcnNpb24gaGVyZSBhbmQgdXNlIHRoYXQgYXMgc291cmNlIHNvIGJpdG1hcGRhdGEgY2FuIGJlIGNsb3NlZFxuICAgICAgICAvLyBvcmllbnRhdGlvbiBpbmZvXG4gICAgICAgIHZhciBleGlmID0gaXRlbS5nZXRNZXRhZGF0YSgnZXhpZicpIHx8IHt9O1xuICAgICAgICB2YXIgb3JpZW50YXRpb24gPSBleGlmLm9yaWVudGF0aW9uIHx8IC0xO1xuXG4gICAgICAgIC8vIGdldCB3aWR0aCBhbmQgaGVpZ2h0IGZyb20gYWN0aW9uLCBhbmQgc3dhcCBpZiBvcmllbnRhdGlvbiBpcyBpbmNvcnJlY3RcbiAgICAgICAgdmFyIHdpZHRoID0gaW1hZ2VEYXRhLndpZHRoLFxuICAgICAgICAgIGhlaWdodCA9IGltYWdlRGF0YS5oZWlnaHQ7XG4gICAgICAgIGlmIChvcmllbnRhdGlvbiA+PSA1ICYmIG9yaWVudGF0aW9uIDw9IDgpIHtcbiAgICAgICAgICB2YXIgX3JlZjcgPSBbaGVpZ2h0LCB3aWR0aF07XG4gICAgICAgICAgd2lkdGggPSBfcmVmN1swXTtcbiAgICAgICAgICBoZWlnaHQgPSBfcmVmN1sxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNjYWxlIGNhbnZhcyBiYXNlZCBvbiBwaXhlbCBkZW5zaXR5XG4gICAgICAgIC8vIHdlIG11bHRpcGx5IGJ5IC43NSBhcyB0aGF0IGNyZWF0ZXMgc21hbGxlciBidXQgc3RpbGwgY2xlYXIgaW1hZ2VzIG9uIHNjcmVlbnMgd2l0aCBoaWdoIHJlcyBkaXNwbGF5c1xuICAgICAgICB2YXIgcGl4ZWxEZW5zaXR5RmFjdG9yID0gTWF0aC5tYXgoMSwgd2luZG93LmRldmljZVBpeGVsUmF0aW8gKiAwLjc1KTtcblxuICAgICAgICAvLyB3ZSB3YW50IGFzIG11Y2ggcGl4ZWxzIHRvIHdvcmsgd2l0aCBhcyBwb3NzaWJsZSxcbiAgICAgICAgLy8gdGhpcyBtdWx0aXBsaWVzIHRoZSBtaW5pbXVtIGltYWdlIHJlc29sdXRpb24sXG4gICAgICAgIC8vIHNvIHdoZW4gem9vbWluZyBpbiBpdCBkb2Vzbid0IGdldCB0b28gYmx1cnJ5XG4gICAgICAgIHZhciB6b29tRmFjdG9yID0gcm9vdC5xdWVyeSgnR0VUX0lNQUdFX1BSRVZJRVdfWk9PTV9GQUNUT1InKTtcblxuICAgICAgICAvLyBpbWFlZyBzY2FsZSBmYWN0b3JcbiAgICAgICAgdmFyIHNjYWxlRmFjdG9yID0gem9vbUZhY3RvciAqIHBpeGVsRGVuc2l0eUZhY3RvcjtcblxuICAgICAgICAvLyBjYWxjdWxhdGUgc2NhbGVkIHByZXZpZXcgaW1hZ2Ugc2l6ZVxuICAgICAgICB2YXIgcHJldmlld0ltYWdlUmF0aW8gPSBoZWlnaHQgLyB3aWR0aDtcblxuICAgICAgICAvLyBjYWxjdWxhdGUgaW1hZ2UgcHJldmlldyBoZWlnaHQgYW5kIHdpZHRoXG4gICAgICAgIHZhciBwcmV2aWV3Q29udGFpbmVyV2lkdGggPSByb290LnJlY3QuZWxlbWVudC53aWR0aDtcbiAgICAgICAgdmFyIHByZXZpZXdDb250YWluZXJIZWlnaHQgPSByb290LnJlY3QuZWxlbWVudC5oZWlnaHQ7XG5cbiAgICAgICAgdmFyIGltYWdlV2lkdGggPSBwcmV2aWV3Q29udGFpbmVyV2lkdGg7XG4gICAgICAgIHZhciBpbWFnZUhlaWdodCA9IGltYWdlV2lkdGggKiBwcmV2aWV3SW1hZ2VSYXRpbztcblxuICAgICAgICBpZiAocHJldmlld0ltYWdlUmF0aW8gPiAxKSB7XG4gICAgICAgICAgaW1hZ2VXaWR0aCA9IE1hdGgubWluKHdpZHRoLCBwcmV2aWV3Q29udGFpbmVyV2lkdGggKiBzY2FsZUZhY3Rvcik7XG4gICAgICAgICAgaW1hZ2VIZWlnaHQgPSBpbWFnZVdpZHRoICogcHJldmlld0ltYWdlUmF0aW87XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW1hZ2VIZWlnaHQgPSBNYXRoLm1pbihoZWlnaHQsIHByZXZpZXdDb250YWluZXJIZWlnaHQgKiBzY2FsZUZhY3Rvcik7XG4gICAgICAgICAgaW1hZ2VXaWR0aCA9IGltYWdlSGVpZ2h0IC8gcHJldmlld0ltYWdlUmF0aW87XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0cmFuc2ZlciB0byBpbWFnZSB0YWcgc28gbm8gY2FudmFzIG1lbW9yeSB3YXN0ZWQgb24gaU9TXG4gICAgICAgIHZhciBwcmV2aWV3SW1hZ2UgPSBjcmVhdGVQcmV2aWV3SW1hZ2UoXG4gICAgICAgICAgaW1hZ2VEYXRhLFxuICAgICAgICAgIGltYWdlV2lkdGgsXG4gICAgICAgICAgaW1hZ2VIZWlnaHQsXG4gICAgICAgICAgb3JpZW50YXRpb25cbiAgICAgICAgKTtcblxuICAgICAgICAvLyBkb25lXG4gICAgICAgIHZhciBkb25lID0gZnVuY3Rpb24gZG9uZSgpIHtcbiAgICAgICAgICAvLyBjYWxjdWxhdGUgYXZlcmFnZSBpbWFnZSBjb2xvciwgZGlzYWJsZWQgZm9yIG5vd1xuICAgICAgICAgIHZhciBhdmVyYWdlQ29sb3IgPSByb290LnF1ZXJ5KFxuICAgICAgICAgICAgJ0dFVF9JTUFHRV9QUkVWSUVXX0NBTENVTEFURV9BVkVSQUdFX0lNQUdFX0NPTE9SJ1xuICAgICAgICAgIClcbiAgICAgICAgICAgID8gY2FsY3VsYXRlQXZlcmFnZUNvbG9yKGRhdGEpXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgaXRlbS5zZXRNZXRhZGF0YSgnY29sb3InLCBhdmVyYWdlQ29sb3IsIHRydWUpO1xuXG4gICAgICAgICAgLy8gZGF0YSBoYXMgYmVlbiB0cmFuc2ZlcnJlZCB0byBjYW52YXMgKCBpZiB3YXMgSW1hZ2VCaXRtYXAgKVxuICAgICAgICAgIGlmICgnY2xvc2UnIGluIGltYWdlRGF0YSkge1xuICAgICAgICAgICAgaW1hZ2VEYXRhLmNsb3NlKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gc2hvdyB0aGUgb3ZlcmxheVxuICAgICAgICAgIHJvb3QucmVmLm92ZXJsYXlTaGFkb3cub3BhY2l0eSA9IDE7XG5cbiAgICAgICAgICAvLyBjcmVhdGUgdGhlIGZpcnN0IGltYWdlXG4gICAgICAgICAgcHVzaEltYWdlKHsgcm9vdDogcm9vdCwgcHJvcHM6IHByb3BzLCBpbWFnZTogcHJldmlld0ltYWdlIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGFwcGx5IGZpbHRlclxuICAgICAgICB2YXIgZmlsdGVyID0gaXRlbS5nZXRNZXRhZGF0YSgnZmlsdGVyJyk7XG4gICAgICAgIGlmIChmaWx0ZXIpIHtcbiAgICAgICAgICBhcHBseUZpbHRlcihyb290LCBmaWx0ZXIsIHByZXZpZXdJbWFnZSkudGhlbihkb25lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vIGlmIHdlIHN1cHBvcnQgc2NhbGluZyB1c2luZyBjcmVhdGVJbWFnZUJpdG1hcCB3ZSB1c2UgYSB3b3JrZXJcbiAgICAgIGlmIChjYW5DcmVhdGVJbWFnZUJpdG1hcChpdGVtLmZpbGUpKSB7XG4gICAgICAgIC8vIGxldCdzIHNjYWxlIHRoZSBpbWFnZSBpbiBhIHdvcmtlclxuICAgICAgICB2YXIgd29ya2VyID0gY3JlYXRlV29ya2VyKEJpdG1hcFdvcmtlcik7XG5cbiAgICAgICAgd29ya2VyLnBvc3QoXG4gICAgICAgICAge1xuICAgICAgICAgICAgZmlsZTogaXRlbS5maWxlXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGZ1bmN0aW9uKGltYWdlQml0bWFwKSB7XG4gICAgICAgICAgICAvLyBkZXN0cm95IHdvcmtlclxuICAgICAgICAgICAgd29ya2VyLnRlcm1pbmF0ZSgpO1xuXG4gICAgICAgICAgICAvLyBubyBiaXRtYXAgcmV0dXJuZWQsIG11c3QgYmUgc29tZXRoaW5nIHdyb25nLFxuICAgICAgICAgICAgLy8gdHJ5IHRoZSBvbGRzY2hvb2wgd2F5XG4gICAgICAgICAgICBpZiAoIWltYWdlQml0bWFwKSB7XG4gICAgICAgICAgICAgIGxvYWRQcmV2aWV3RmFsbGJhY2soKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB5YXkgd2UgZ290IG91ciBiaXRtYXAsIGxldCdzIGNvbnRpbnVlIHNob3dpbmcgdGhlIHByZXZpZXdcbiAgICAgICAgICAgIHByZXZpZXdJbWFnZUxvYWRlZChpbWFnZUJpdG1hcCk7XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY3JlYXRlIGZhbGxiYWNrIHByZXZpZXdcbiAgICAgICAgbG9hZFByZXZpZXdGYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBXcml0ZSBoYW5kbGVyIGZvciB3aGVuIHRoZSBwcmV2aWV3IGltYWdlIGlzIHJlYWR5IHRvIGJlIGFuaW1hdGVkXG4gICAgICovXG4gICAgdmFyIGRpZERyYXdQcmV2aWV3ID0gZnVuY3Rpb24gZGlkRHJhd1ByZXZpZXcoX3JlZjgpIHtcbiAgICAgIHZhciByb290ID0gX3JlZjgucm9vdDtcbiAgICAgIC8vIGdldCBsYXN0IGFkZGVkIGltYWdlXG4gICAgICB2YXIgaW1hZ2UgPSByb290LnJlZi5pbWFnZXNbcm9vdC5yZWYuaW1hZ2VzLmxlbmd0aCAtIDFdO1xuICAgICAgaW1hZ2UudHJhbnNsYXRlWSA9IDA7XG4gICAgICBpbWFnZS5zY2FsZVggPSAxLjA7XG4gICAgICBpbWFnZS5zY2FsZVkgPSAxLjA7XG4gICAgICBpbWFnZS5vcGFjaXR5ID0gMTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogV3JpdGUgaGFuZGxlciBmb3Igd2hlbiB0aGUgcHJldmlldyBoYXMgYmVlbiBsb2FkZWRcbiAgICAgKi9cbiAgICB2YXIgcmVzdG9yZU92ZXJsYXkgPSBmdW5jdGlvbiByZXN0b3JlT3ZlcmxheShfcmVmOSkge1xuICAgICAgdmFyIHJvb3QgPSBfcmVmOS5yb290O1xuICAgICAgcm9vdC5yZWYub3ZlcmxheVNoYWRvdy5vcGFjaXR5ID0gMTtcbiAgICAgIHJvb3QucmVmLm92ZXJsYXlFcnJvci5vcGFjaXR5ID0gMDtcbiAgICAgIHJvb3QucmVmLm92ZXJsYXlTdWNjZXNzLm9wYWNpdHkgPSAwO1xuICAgIH07XG5cbiAgICB2YXIgZGlkVGhyb3dFcnJvciA9IGZ1bmN0aW9uIGRpZFRocm93RXJyb3IoX3JlZjEwKSB7XG4gICAgICB2YXIgcm9vdCA9IF9yZWYxMC5yb290O1xuICAgICAgcm9vdC5yZWYub3ZlcmxheVNoYWRvdy5vcGFjaXR5ID0gMC4yNTtcbiAgICAgIHJvb3QucmVmLm92ZXJsYXlFcnJvci5vcGFjaXR5ID0gMTtcbiAgICB9O1xuXG4gICAgdmFyIGRpZENvbXBsZXRlUHJvY2Vzc2luZyA9IGZ1bmN0aW9uIGRpZENvbXBsZXRlUHJvY2Vzc2luZyhfcmVmMTEpIHtcbiAgICAgIHZhciByb290ID0gX3JlZjExLnJvb3Q7XG4gICAgICByb290LnJlZi5vdmVybGF5U2hhZG93Lm9wYWNpdHkgPSAwLjI1O1xuICAgICAgcm9vdC5yZWYub3ZlcmxheVN1Y2Nlc3Mub3BhY2l0eSA9IDE7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICovXG4gICAgdmFyIGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShfcmVmMTIpIHtcbiAgICAgIHZhciByb290ID0gX3JlZjEyLnJvb3Q7XG5cbiAgICAgIC8vIGltYWdlIHZpZXdcbiAgICAgIHJvb3QucmVmLmltYWdlcyA9IFtdO1xuXG4gICAgICAvLyB0aGUgcHJldmlldyBpbWFnZSBkYXRhICh3ZSBuZWVkIHRoaXMgdG8gZmlsdGVyIHRoZSBpbWFnZSlcbiAgICAgIHJvb3QucmVmLmltYWdlRGF0YSA9IG51bGw7XG5cbiAgICAgIC8vIGltYWdlIGJpblxuICAgICAgcm9vdC5yZWYuaW1hZ2VWaWV3QmluID0gW107XG5cbiAgICAgIC8vIGltYWdlIG92ZXJsYXlzXG4gICAgICByb290LnJlZi5vdmVybGF5U2hhZG93ID0gcm9vdC5hcHBlbmRDaGlsZFZpZXcoXG4gICAgICAgIHJvb3QuY3JlYXRlQ2hpbGRWaWV3KE92ZXJsYXlWaWV3LCB7XG4gICAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgICBzdGF0dXM6ICdpZGxlJ1xuICAgICAgICB9KVxuICAgICAgKTtcblxuICAgICAgcm9vdC5yZWYub3ZlcmxheVN1Y2Nlc3MgPSByb290LmFwcGVuZENoaWxkVmlldyhcbiAgICAgICAgcm9vdC5jcmVhdGVDaGlsZFZpZXcoT3ZlcmxheVZpZXcsIHtcbiAgICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICAgIHN0YXR1czogJ3N1Y2Nlc3MnXG4gICAgICAgIH0pXG4gICAgICApO1xuXG4gICAgICByb290LnJlZi5vdmVybGF5RXJyb3IgPSByb290LmFwcGVuZENoaWxkVmlldyhcbiAgICAgICAgcm9vdC5jcmVhdGVDaGlsZFZpZXcoT3ZlcmxheVZpZXcsIHtcbiAgICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICAgIHN0YXR1czogJ2ZhaWx1cmUnXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH07XG5cbiAgICByZXR1cm4gXy51dGlscy5jcmVhdGVWaWV3KHtcbiAgICAgIG5hbWU6ICdpbWFnZS1wcmV2aWV3LXdyYXBwZXInLFxuICAgICAgY3JlYXRlOiBjcmVhdGUsXG4gICAgICBzdHlsZXM6IFsnaGVpZ2h0J10sXG5cbiAgICAgIGFwaXM6IFsnaGVpZ2h0J10sXG5cbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koX3JlZjEzKSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjEzLnJvb3Q7XG4gICAgICAgIC8vIHdlIHJlc2l6ZSB0aGUgaW1hZ2Ugc28gbWVtb3J5IG9uIGlPUyAxMiBpcyByZWxlYXNlZCBtb3JlIHF1aWNrbHkgKGl0IHNlZW1zKVxuICAgICAgICByb290LnJlZi5pbWFnZXMuZm9yRWFjaChmdW5jdGlvbihpbWFnZVZpZXcpIHtcbiAgICAgICAgICBpbWFnZVZpZXcuaW1hZ2Uud2lkdGggPSAxO1xuICAgICAgICAgIGltYWdlVmlldy5pbWFnZS5oZWlnaHQgPSAxO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBkaWRXcml0ZVZpZXc6IGZ1bmN0aW9uIGRpZFdyaXRlVmlldyhfcmVmMTQpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmMTQucm9vdDtcbiAgICAgICAgcm9vdC5yZWYuaW1hZ2VzLmZvckVhY2goZnVuY3Rpb24oaW1hZ2VWaWV3KSB7XG4gICAgICAgICAgaW1hZ2VWaWV3LmRpcnR5ID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIHdyaXRlOiBfLnV0aWxzLmNyZWF0ZVJvdXRlKFxuICAgICAgICB7XG4gICAgICAgICAgLy8gaW1hZ2UgcHJldmlldyBzdGF0ZWRcbiAgICAgICAgICBESURfSU1BR0VfUFJFVklFV19EUkFXOiBkaWREcmF3UHJldmlldyxcbiAgICAgICAgICBESURfSU1BR0VfUFJFVklFV19DT05UQUlORVJfQ1JFQVRFOiBkaWRDcmVhdGVQcmV2aWV3Q29udGFpbmVyLFxuICAgICAgICAgIERJRF9GSU5JU0hfQ0FMQ1VMQVRFX1BSRVZJRVdTSVpFOiBkcmF3UHJldmlldyxcbiAgICAgICAgICBESURfVVBEQVRFX0lURU1fTUVUQURBVEE6IGRpZFVwZGF0ZUl0ZW1NZXRhZGF0YSxcblxuICAgICAgICAgIC8vIGZpbGUgc3RhdGVzXG4gICAgICAgICAgRElEX1RIUk9XX0lURU1fTE9BRF9FUlJPUjogZGlkVGhyb3dFcnJvcixcbiAgICAgICAgICBESURfVEhST1dfSVRFTV9QUk9DRVNTSU5HX0VSUk9SOiBkaWRUaHJvd0Vycm9yLFxuICAgICAgICAgIERJRF9USFJPV19JVEVNX0lOVkFMSUQ6IGRpZFRocm93RXJyb3IsXG4gICAgICAgICAgRElEX0NPTVBMRVRFX0lURU1fUFJPQ0VTU0lORzogZGlkQ29tcGxldGVQcm9jZXNzaW5nLFxuICAgICAgICAgIERJRF9TVEFSVF9JVEVNX1BST0NFU1NJTkc6IHJlc3RvcmVPdmVybGF5LFxuICAgICAgICAgIERJRF9SRVZFUlRfSVRFTV9QUk9DRVNTSU5HOiByZXN0b3JlT3ZlcmxheVxuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbihfcmVmMTUpIHtcbiAgICAgICAgICB2YXIgcm9vdCA9IF9yZWYxNS5yb290O1xuXG4gICAgICAgICAgLy8gdmlld3Mgb24gZGVhdGggcm93XG4gICAgICAgICAgdmFyIHZpZXdzVG9SZW1vdmUgPSByb290LnJlZi5pbWFnZVZpZXdCaW4uZmlsdGVyKGZ1bmN0aW9uKGltYWdlVmlldykge1xuICAgICAgICAgICAgcmV0dXJuIGltYWdlVmlldy5vcGFjaXR5ID09PSAwO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gdmlld3MgdG8gcmV0YWluXG4gICAgICAgICAgcm9vdC5yZWYuaW1hZ2VWaWV3QmluID0gcm9vdC5yZWYuaW1hZ2VWaWV3QmluLmZpbHRlcihmdW5jdGlvbihcbiAgICAgICAgICAgIGltYWdlVmlld1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIGltYWdlVmlldy5vcGFjaXR5ID4gMDtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIHJlbW92ZSB0aGVzZSB2aWV3c1xuICAgICAgICAgIHZpZXdzVG9SZW1vdmUuZm9yRWFjaChmdW5jdGlvbihpbWFnZVZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiByZW1vdmVJbWFnZVZpZXcocm9vdCwgaW1hZ2VWaWV3KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2aWV3c1RvUmVtb3ZlLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgIClcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogSW1hZ2UgUHJldmlldyBQbHVnaW5cbiAgICovXG4gIHZhciBwbHVnaW4gPSBmdW5jdGlvbiBwbHVnaW4oZnBBUEkpIHtcbiAgICB2YXIgYWRkRmlsdGVyID0gZnBBUEkuYWRkRmlsdGVyLFxuICAgICAgdXRpbHMgPSBmcEFQSS51dGlscztcbiAgICB2YXIgVHlwZSA9IHV0aWxzLlR5cGUsXG4gICAgICBjcmVhdGVSb3V0ZSA9IHV0aWxzLmNyZWF0ZVJvdXRlLFxuICAgICAgaXNGaWxlID0gdXRpbHMuaXNGaWxlO1xuXG4gICAgLy8gaW1hZ2VQcmV2aWV3Vmlld1xuICAgIHZhciBpbWFnZVByZXZpZXdWaWV3ID0gY3JlYXRlSW1hZ2VXcmFwcGVyVmlldyhmcEFQSSk7XG5cbiAgICAvLyBjYWxsZWQgZm9yIGVhY2ggdmlldyB0aGF0IGlzIGNyZWF0ZWQgcmlnaHQgYWZ0ZXIgdGhlICdjcmVhdGUnIG1ldGhvZFxuICAgIGFkZEZpbHRlcignQ1JFQVRFX1ZJRVcnLCBmdW5jdGlvbih2aWV3QVBJKSB7XG4gICAgICAvLyBnZXQgcmVmZXJlbmNlIHRvIGNyZWF0ZWQgdmlld1xuICAgICAgdmFyIGlzID0gdmlld0FQSS5pcyxcbiAgICAgICAgdmlldyA9IHZpZXdBUEkudmlldyxcbiAgICAgICAgcXVlcnkgPSB2aWV3QVBJLnF1ZXJ5O1xuXG4gICAgICAvLyBvbmx5IGhvb2sgdXAgdG8gaXRlbSB2aWV3IGFuZCBvbmx5IGlmIGlzIGVuYWJsZWQgZm9yIHRoaXMgY3JvcHBlclxuICAgICAgaWYgKCFpcygnZmlsZScpIHx8ICFxdWVyeSgnR0VUX0FMTE9XX0lNQUdFX1BSRVZJRVcnKSkgcmV0dXJuO1xuXG4gICAgICAvLyBjcmVhdGUgdGhlIGltYWdlIHByZXZpZXcgcGx1Z2luLCBidXQgb25seSBkbyBzbyBpZiB0aGUgaXRlbSBpcyBhbiBpbWFnZVxuICAgICAgdmFyIGRpZExvYWRJdGVtID0gZnVuY3Rpb24gZGlkTG9hZEl0ZW0oX3JlZikge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWYucm9vdCxcbiAgICAgICAgICBwcm9wcyA9IF9yZWYucHJvcHM7XG4gICAgICAgIHZhciBpZCA9IHByb3BzLmlkO1xuICAgICAgICB2YXIgaXRlbSA9IHF1ZXJ5KCdHRVRfSVRFTScsIGlkKTtcblxuICAgICAgICAvLyBpdGVtIGNvdWxkIHRoZW9yZXRpY2FsbHkgaGF2ZSBiZWVuIHJlbW92ZWQgaW4gdGhlIG1lYW4gdGltZVxuICAgICAgICBpZiAoIWl0ZW0gfHwgIWlzRmlsZShpdGVtLmZpbGUpIHx8IGl0ZW0uYXJjaGl2ZWQpIHJldHVybjtcblxuICAgICAgICAvLyBnZXQgdGhlIGZpbGUgb2JqZWN0XG4gICAgICAgIHZhciBmaWxlID0gaXRlbS5maWxlO1xuXG4gICAgICAgIC8vIGV4aXQgaWYgdGhpcyBpcyBub3QgYW4gaW1hZ2VcbiAgICAgICAgaWYgKCFpc1ByZXZpZXdhYmxlSW1hZ2UoZmlsZSkpIHJldHVybjtcblxuICAgICAgICAvLyB0ZXN0IGlmIGlzIGZpbHRlcmVkXG4gICAgICAgIGlmICghcXVlcnkoJ0dFVF9JTUFHRV9QUkVWSUVXX0ZJTFRFUl9JVEVNJykoaXRlbSkpIHJldHVybjtcblxuICAgICAgICAvLyBleGl0IGlmIGltYWdlIHNpemUgaXMgdG9vIGhpZ2ggYW5kIG5vIGNyZWF0ZUltYWdlQml0bWFwIHN1cHBvcnRcbiAgICAgICAgLy8gdGhpcyB3b3VsZCBzaW1wbHkgYnJpbmcgdGhlIGJyb3dzZXIgdG8gaXRzIGtuZWVzIGFuZCB0aGF0IGlzIG5vdCB3aGF0IHdlIHdhbnRcbiAgICAgICAgdmFyIHN1cHBvcnRzQ3JlYXRlSW1hZ2VCaXRtYXAgPSAnY3JlYXRlSW1hZ2VCaXRtYXAnIGluICh3aW5kb3cgfHwge30pO1xuICAgICAgICB2YXIgbWF4UHJldmlld0ZpbGVTaXplID0gcXVlcnkoJ0dFVF9JTUFHRV9QUkVWSUVXX01BWF9GSUxFX1NJWkUnKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICFzdXBwb3J0c0NyZWF0ZUltYWdlQml0bWFwICYmXG4gICAgICAgICAgbWF4UHJldmlld0ZpbGVTaXplICYmXG4gICAgICAgICAgZmlsZS5zaXplID4gbWF4UHJldmlld0ZpbGVTaXplXG4gICAgICAgIClcbiAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgLy8gc2V0IHByZXZpZXcgdmlld1xuICAgICAgICByb290LnJlZi5pbWFnZVByZXZpZXcgPSB2aWV3LmFwcGVuZENoaWxkVmlldyhcbiAgICAgICAgICB2aWV3LmNyZWF0ZUNoaWxkVmlldyhpbWFnZVByZXZpZXdWaWV3LCB7IGlkOiBpZCB9KVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIHVwZGF0ZSBoZWlnaHQgaWYgaXMgZml4ZWRcbiAgICAgICAgdmFyIGZpeGVkUHJldmlld0hlaWdodCA9IHJvb3QucXVlcnkoJ0dFVF9JTUFHRV9QUkVWSUVXX0hFSUdIVCcpO1xuICAgICAgICBpZiAoZml4ZWRQcmV2aWV3SGVpZ2h0KSB7XG4gICAgICAgICAgcm9vdC5kaXNwYXRjaCgnRElEX1VQREFURV9QQU5FTF9IRUlHSFQnLCB7XG4gICAgICAgICAgICBpZDogaXRlbS5pZCxcbiAgICAgICAgICAgIGhlaWdodDogZml4ZWRQcmV2aWV3SGVpZ2h0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBub3cgcmVhZHlcbiAgICAgICAgdmFyIHF1ZXVlID1cbiAgICAgICAgICAhc3VwcG9ydHNDcmVhdGVJbWFnZUJpdG1hcCAmJlxuICAgICAgICAgIGZpbGUuc2l6ZSA+IHF1ZXJ5KCdHRVRfSU1BR0VfUFJFVklFV19NQVhfSU5TVEFOVF9QUkVWSUVXX0ZJTEVfU0laRScpO1xuICAgICAgICByb290LmRpc3BhdGNoKCdESURfSU1BR0VfUFJFVklFV19DT05UQUlORVJfQ1JFQVRFJywgeyBpZDogaWQgfSwgcXVldWUpO1xuICAgICAgfTtcblxuICAgICAgdmFyIHJlc2NhbGVJdGVtID0gZnVuY3Rpb24gcmVzY2FsZUl0ZW0ocm9vdCwgcHJvcHMpIHtcbiAgICAgICAgaWYgKCFyb290LnJlZi5pbWFnZVByZXZpZXcpIHJldHVybjtcbiAgICAgICAgdmFyIGlkID0gcHJvcHMuaWQ7XG5cbiAgICAgICAgLy8gZ2V0IGl0ZW1cbiAgICAgICAgdmFyIGl0ZW0gPSByb290LnF1ZXJ5KCdHRVRfSVRFTScsIHsgaWQ6IGlkIH0pO1xuICAgICAgICBpZiAoIWl0ZW0pIHJldHVybjtcblxuICAgICAgICAvLyBpZiBpcyBmaXhlZCBoZWlnaHQgb3IgcGFuZWwgaGFzIGFzcGVjdCByYXRpbywgZXhpdCBoZXJlLCBoZWlnaHQgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkXG4gICAgICAgIHZhciBwYW5lbEFzcGVjdFJhdGlvID0gcm9vdC5xdWVyeSgnR0VUX1BBTkVMX0FTUEVDVF9SQVRJTycpO1xuICAgICAgICB2YXIgaXRlbVBhbmVsQXNwZWN0UmF0aW8gPSByb290LnF1ZXJ5KCdHRVRfSVRFTV9QQU5FTF9BU1BFQ1RfUkFUSU8nKTtcbiAgICAgICAgdmFyIGZpeGVkSGVpZ2h0ID0gcm9vdC5xdWVyeSgnR0VUX0lNQUdFX1BSRVZJRVdfSEVJR0hUJyk7XG4gICAgICAgIGlmIChwYW5lbEFzcGVjdFJhdGlvIHx8IGl0ZW1QYW5lbEFzcGVjdFJhdGlvIHx8IGZpeGVkSGVpZ2h0KSByZXR1cm47XG5cbiAgICAgICAgLy8gbm8gZGF0YSFcbiAgICAgICAgdmFyIF9yb290JHJlZiA9IHJvb3QucmVmLFxuICAgICAgICAgIGltYWdlV2lkdGggPSBfcm9vdCRyZWYuaW1hZ2VXaWR0aCxcbiAgICAgICAgICBpbWFnZUhlaWdodCA9IF9yb290JHJlZi5pbWFnZUhlaWdodDtcbiAgICAgICAgaWYgKCFpbWFnZVdpZHRoIHx8ICFpbWFnZUhlaWdodCkgcmV0dXJuO1xuXG4gICAgICAgIC8vIGdldCBoZWlnaHQgbWluIGFuZCBtYXhcbiAgICAgICAgdmFyIG1pblByZXZpZXdIZWlnaHQgPSByb290LnF1ZXJ5KCdHRVRfSU1BR0VfUFJFVklFV19NSU5fSEVJR0hUJyk7XG4gICAgICAgIHZhciBtYXhQcmV2aWV3SGVpZ2h0ID0gcm9vdC5xdWVyeSgnR0VUX0lNQUdFX1BSRVZJRVdfTUFYX0hFSUdIVCcpO1xuXG4gICAgICAgIC8vIG9yaWVudGF0aW9uIGluZm9cbiAgICAgICAgdmFyIGV4aWYgPSBpdGVtLmdldE1ldGFkYXRhKCdleGlmJykgfHwge307XG4gICAgICAgIHZhciBvcmllbnRhdGlvbiA9IGV4aWYub3JpZW50YXRpb24gfHwgLTE7XG5cbiAgICAgICAgLy8gZ2V0IHdpZHRoIGFuZCBoZWlnaHQgZnJvbSBhY3Rpb24sIGFuZCBzd2FwIG9mIG9yaWVudGF0aW9uIGlzIGluY29ycmVjdFxuICAgICAgICBpZiAob3JpZW50YXRpb24gPj0gNSAmJiBvcmllbnRhdGlvbiA8PSA4KSB7XG4gICAgICAgICAgdmFyIF9yZWYyID0gW2ltYWdlSGVpZ2h0LCBpbWFnZVdpZHRoXTtcbiAgICAgICAgICBpbWFnZVdpZHRoID0gX3JlZjJbMF07XG4gICAgICAgICAgaW1hZ2VIZWlnaHQgPSBfcmVmMlsxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNjYWxlIHVwIHdpZHRoIGFuZCBoZWlnaHQgd2hlbiB3ZSdyZSBkZWFsaW5nIHdpdGggYW4gU1ZHXG4gICAgICAgIGlmICghaXNCaXRtYXAoaXRlbS5maWxlKSB8fCByb290LnF1ZXJ5KCdHRVRfSU1BR0VfUFJFVklFV19VUFNDQUxFJykpIHtcbiAgICAgICAgICB2YXIgc2NhbGFyID0gMjA0OCAvIGltYWdlV2lkdGg7XG4gICAgICAgICAgaW1hZ2VXaWR0aCAqPSBzY2FsYXI7XG4gICAgICAgICAgaW1hZ2VIZWlnaHQgKj0gc2NhbGFyO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaW1hZ2UgYXNwZWN0IHJhdGlvXG4gICAgICAgIHZhciBpbWFnZUFzcGVjdFJhdGlvID0gaW1hZ2VIZWlnaHQgLyBpbWFnZVdpZHRoO1xuXG4gICAgICAgIC8vIHdlIG5lZWQgdGhlIGl0ZW0gdG8gZ2V0IHRvIHRoZSBjcm9wIHNpemVcbiAgICAgICAgdmFyIHByZXZpZXdBc3BlY3RSYXRpbyA9XG4gICAgICAgICAgKGl0ZW0uZ2V0TWV0YWRhdGEoJ2Nyb3AnKSB8fCB7fSkuYXNwZWN0UmF0aW8gfHwgaW1hZ2VBc3BlY3RSYXRpbztcblxuICAgICAgICAvLyBwcmV2aWV3IGhlaWdodCByYW5nZVxuICAgICAgICB2YXIgcHJldmlld0hlaWdodE1heCA9IE1hdGgubWF4KFxuICAgICAgICAgIG1pblByZXZpZXdIZWlnaHQsXG4gICAgICAgICAgTWF0aC5taW4oaW1hZ2VIZWlnaHQsIG1heFByZXZpZXdIZWlnaHQpXG4gICAgICAgICk7XG4gICAgICAgIHZhciBpdGVtV2lkdGggPSByb290LnJlY3QuZWxlbWVudC53aWR0aDtcbiAgICAgICAgdmFyIHByZXZpZXdIZWlnaHQgPSBNYXRoLm1pbihcbiAgICAgICAgICBpdGVtV2lkdGggKiBwcmV2aWV3QXNwZWN0UmF0aW8sXG4gICAgICAgICAgcHJldmlld0hlaWdodE1heFxuICAgICAgICApO1xuXG4gICAgICAgIC8vIHJlcXVlc3QgdXBkYXRlIHRvIHBhbmVsIGhlaWdodFxuICAgICAgICByb290LmRpc3BhdGNoKCdESURfVVBEQVRFX1BBTkVMX0hFSUdIVCcsIHtcbiAgICAgICAgICBpZDogaXRlbS5pZCxcbiAgICAgICAgICBoZWlnaHQ6IHByZXZpZXdIZWlnaHRcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgZGlkUmVzaXplVmlldyA9IGZ1bmN0aW9uIGRpZFJlc2l6ZVZpZXcoX3JlZjMpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmMy5yb290O1xuICAgICAgICAvLyBhY3Rpb25zIGluIG5leHQgd3JpdGUgb3BlcmF0aW9uXG4gICAgICAgIHJvb3QucmVmLnNob3VsZFJlc2NhbGUgPSB0cnVlO1xuICAgICAgfTtcblxuICAgICAgdmFyIGRpZFVwZGF0ZUl0ZW1NZXRhZGF0YSA9IGZ1bmN0aW9uIGRpZFVwZGF0ZUl0ZW1NZXRhZGF0YShfcmVmNCkge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWY0LnJvb3QsXG4gICAgICAgICAgYWN0aW9uID0gX3JlZjQuYWN0aW9uO1xuXG4gICAgICAgIGlmIChhY3Rpb24uY2hhbmdlLmtleSAhPT0gJ2Nyb3AnKSByZXR1cm47XG5cbiAgICAgICAgLy8gYWN0aW9ucyBpbiBuZXh0IHdyaXRlIG9wZXJhdGlvblxuICAgICAgICByb290LnJlZi5zaG91bGRSZXNjYWxlID0gdHJ1ZTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBkaWRDYWxjdWxhdGVQcmV2aWV3U2l6ZSA9IGZ1bmN0aW9uIGRpZENhbGN1bGF0ZVByZXZpZXdTaXplKF9yZWY1KSB7XG4gICAgICAgIHZhciByb290ID0gX3JlZjUucm9vdCxcbiAgICAgICAgICBhY3Rpb24gPSBfcmVmNS5hY3Rpb247XG5cbiAgICAgICAgLy8gcmVtZW1iZXIgZGltZW5zaW9uc1xuICAgICAgICByb290LnJlZi5pbWFnZVdpZHRoID0gYWN0aW9uLndpZHRoO1xuICAgICAgICByb290LnJlZi5pbWFnZUhlaWdodCA9IGFjdGlvbi5oZWlnaHQ7XG5cbiAgICAgICAgLy8gYWN0aW9ucyBpbiBuZXh0IHdyaXRlIG9wZXJhdGlvblxuICAgICAgICByb290LnJlZi5zaG91bGRSZXNjYWxlID0gdHJ1ZTtcbiAgICAgICAgcm9vdC5yZWYuc2hvdWxkRHJhd1ByZXZpZXcgPSB0cnVlO1xuXG4gICAgICAgIC8vIGFzIGltYWdlIGxvYWQgY291bGQgdGFrZSBhIHdoaWxlIGFuZCBmaXJlIHdoZW4gZHJhdyBsb29wIGlzIHJlc3Rpbmcgd2UgbmVlZCB0byBnaXZlIGl0IGEga2lja1xuICAgICAgICByb290LmRpc3BhdGNoKCdLSUNLJyk7XG4gICAgICB9O1xuXG4gICAgICAvLyBzdGFydCB3cml0aW5nXG4gICAgICB2aWV3LnJlZ2lzdGVyV3JpdGVyKFxuICAgICAgICBjcmVhdGVSb3V0ZShcbiAgICAgICAgICB7XG4gICAgICAgICAgICBESURfUkVTSVpFX1JPT1Q6IGRpZFJlc2l6ZVZpZXcsXG4gICAgICAgICAgICBESURfU1RPUF9SRVNJWkU6IGRpZFJlc2l6ZVZpZXcsXG4gICAgICAgICAgICBESURfTE9BRF9JVEVNOiBkaWRMb2FkSXRlbSxcbiAgICAgICAgICAgIERJRF9JTUFHRV9QUkVWSUVXX0NBTENVTEFURV9TSVpFOiBkaWRDYWxjdWxhdGVQcmV2aWV3U2l6ZSxcbiAgICAgICAgICAgIERJRF9VUERBVEVfSVRFTV9NRVRBREFUQTogZGlkVXBkYXRlSXRlbU1ldGFkYXRhXG4gICAgICAgICAgfSxcbiAgICAgICAgICBmdW5jdGlvbihfcmVmNikge1xuICAgICAgICAgICAgdmFyIHJvb3QgPSBfcmVmNi5yb290LFxuICAgICAgICAgICAgICBwcm9wcyA9IF9yZWY2LnByb3BzO1xuXG4gICAgICAgICAgICAvLyBubyBwcmV2aWV3IHZpZXcgYXR0YWNoZWRcbiAgICAgICAgICAgIGlmICghcm9vdC5yZWYuaW1hZ2VQcmV2aWV3KSByZXR1cm47XG5cbiAgICAgICAgICAgIC8vIGRvbid0IGRvIGFueXRoaW5nIHdoaWxlIGhpZGRlblxuICAgICAgICAgICAgaWYgKHJvb3QucmVjdC5lbGVtZW50LmhpZGRlbikgcmV0dXJuO1xuXG4gICAgICAgICAgICAvLyByZXNpemUgdGhlIGl0ZW0gcGFuZWxcbiAgICAgICAgICAgIGlmIChyb290LnJlZi5zaG91bGRSZXNjYWxlKSB7XG4gICAgICAgICAgICAgIHJlc2NhbGVJdGVtKHJvb3QsIHByb3BzKTtcbiAgICAgICAgICAgICAgcm9vdC5yZWYuc2hvdWxkUmVzY2FsZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocm9vdC5yZWYuc2hvdWxkRHJhd1ByZXZpZXcpIHtcbiAgICAgICAgICAgICAgLy8gcXVldWUgdGlsbCBuZXh0IGZyYW1lIHNvIHdlJ3JlIHN1cmUgdGhlIGhlaWdodCBoYXMgYmVlbiBhcHBsaWVkIHRoaXMgZm9yY2VzIHRoZSBkcmF3IGltYWdlIGNhbGwgaW5zaWRlIHRoZSB3cmFwcGVyIHZpZXcgdG8gdXNlIHRoZSBjb3JyZWN0IGhlaWdodFxuICAgICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcm9vdC5kaXNwYXRjaCgnRElEX0ZJTklTSF9DQUxDVUxBVEVfUFJFVklFV1NJWkUnLCB7XG4gICAgICAgICAgICAgICAgICBpZDogcHJvcHMuaWRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJvb3QucmVmLnNob3VsZERyYXdQcmV2aWV3ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICApXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgLy8gZXhwb3NlIHBsdWdpblxuICAgIHJldHVybiB7XG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIC8vIEVuYWJsZSBvciBkaXNhYmxlIGltYWdlIHByZXZpZXdcbiAgICAgICAgYWxsb3dJbWFnZVByZXZpZXc6IFt0cnVlLCBUeXBlLkJPT0xFQU5dLFxuXG4gICAgICAgIC8vIGZpbHRlcnMgZmlsZSBpdGVtcyB0byBkZXRlcm1pbmUgd2hpY2ggYXJlIHNob3duIGFzIHByZXZpZXdcbiAgICAgICAgaW1hZ2VQcmV2aWV3RmlsdGVySXRlbTogW1xuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBUeXBlLkZVTkNUSU9OXG4gICAgICAgIF0sXG5cbiAgICAgICAgLy8gRml4ZWQgcHJldmlldyBoZWlnaHRcbiAgICAgICAgaW1hZ2VQcmV2aWV3SGVpZ2h0OiBbbnVsbCwgVHlwZS5JTlRdLFxuXG4gICAgICAgIC8vIE1pbiBpbWFnZSBoZWlnaHRcbiAgICAgICAgaW1hZ2VQcmV2aWV3TWluSGVpZ2h0OiBbNDQsIFR5cGUuSU5UXSxcblxuICAgICAgICAvLyBNYXggaW1hZ2UgaGVpZ2h0XG4gICAgICAgIGltYWdlUHJldmlld01heEhlaWdodDogWzI1NiwgVHlwZS5JTlRdLFxuXG4gICAgICAgIC8vIE1heCBzaXplIG9mIHByZXZpZXcgZmlsZSBmb3Igd2hlbiBjcmVhdGVJbWFnZUJpdG1hcCBpcyBub3Qgc3VwcG9ydGVkXG4gICAgICAgIGltYWdlUHJldmlld01heEZpbGVTaXplOiBbbnVsbCwgVHlwZS5JTlRdLFxuXG4gICAgICAgIC8vIFRoZSBhbW91bnQgb2YgZXh0cmEgcGl4ZWxzIGFkZGVkIHRvIHRoZSBpbWFnZSBwcmV2aWV3IHRvIGFsbG93IGNvbWZvcnRhYmxlIHpvb21pbmdcbiAgICAgICAgaW1hZ2VQcmV2aWV3Wm9vbUZhY3RvcjogWzIsIFR5cGUuSU5UXSxcblxuICAgICAgICAvLyBTaG91bGQgd2UgdXBzY2FsZSBzbWFsbCBpbWFnZXMgdG8gZml0IHRoZSBtYXggYm91bmRpbmcgYm94IG9mIHRoZSBwcmV2aWV3IGFyZWFcbiAgICAgICAgaW1hZ2VQcmV2aWV3VXBzY2FsZTogW2ZhbHNlLCBUeXBlLkJPT0xFQU5dLFxuXG4gICAgICAgIC8vIE1heCBzaXplIG9mIHByZXZpZXcgZmlsZSB0aGF0IHdlIGFsbG93IHRvIHRyeSB0byBpbnN0YW50IHByZXZpZXcgaWYgY3JlYXRlSW1hZ2VCaXRtYXAgaXMgbm90IHN1cHBvcnRlZCwgZWxzZSBpbWFnZSBpcyBxdWV1ZWQgZm9yIGxvYWRpbmdcbiAgICAgICAgaW1hZ2VQcmV2aWV3TWF4SW5zdGFudFByZXZpZXdGaWxlU2l6ZTogWzEwMDAwMDAsIFR5cGUuSU5UXSxcblxuICAgICAgICAvLyBTdHlsZSBvZiB0aGUgdHJhbnNwYXJhbmN5IGluZGljYXRvciB1c2VkIGJlaGluZCBpbWFnZXNcbiAgICAgICAgaW1hZ2VQcmV2aWV3VHJhbnNwYXJlbmN5SW5kaWNhdG9yOiBbbnVsbCwgVHlwZS5TVFJJTkddLFxuXG4gICAgICAgIC8vIEVuYWJsZXMgb3IgZGlzYWJsZXMgcmVhZGluZyBhdmVyYWdlIGltYWdlIGNvbG9yXG4gICAgICAgIGltYWdlUHJldmlld0NhbGN1bGF0ZUF2ZXJhZ2VJbWFnZUNvbG9yOiBbZmFsc2UsIFR5cGUuQk9PTEVBTl0sXG5cbiAgICAgICAgLy8gRW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgcHJldmlld2luZyBvZiBtYXJrdXBcbiAgICAgICAgaW1hZ2VQcmV2aWV3TWFya3VwU2hvdzogW3RydWUsIFR5cGUuQk9PTEVBTl0sXG5cbiAgICAgICAgLy8gQWxsb3dzIGZpbHRlcmluZyBvZiBtYXJrdXAgdG8gb25seSBzaG93IGNlcnRhaW4gc2hhcGVzXG4gICAgICAgIGltYWdlUHJldmlld01hcmt1cEZpbHRlcjogW1xuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBUeXBlLkZVTkNUSU9OXG4gICAgICAgIF1cbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIC8vIGZpcmUgcGx1Z2lubG9hZGVkIGV2ZW50IGlmIHJ1bm5pbmcgaW4gYnJvd3NlciwgdGhpcyBhbGxvd3MgcmVnaXN0ZXJpbmcgdGhlIHBsdWdpbiB3aGVuIHVzaW5nIGFzeW5jIHNjcmlwdCB0YWdzXG4gIHZhciBpc0Jyb3dzZXIgPVxuICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnO1xuICBpZiAoaXNCcm93c2VyKSB7XG4gICAgZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChcbiAgICAgIG5ldyBDdXN0b21FdmVudCgnRmlsZVBvbmQ6cGx1Z2lubG9hZGVkJywgeyBkZXRhaWw6IHBsdWdpbiB9KVxuICAgICk7XG4gIH1cblxuICByZXR1cm4gcGx1Z2luO1xufSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/filepond-plugin-image-preview/dist/filepond-plugin-image-preview.js\n");

/***/ }),

/***/ "./node_modules/filepond/dist/filepond.js":
/*!************************************************!*\
  !*** ./node_modules/filepond/dist/filepond.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * FilePond 4.23.1\n * Licensed under MIT, https://opensource.org/licenses/MIT/\n * Please visit https://pqina.nl/filepond/ for details.\n */\n\n/* eslint-disable */\n\n(function(global, factory) {\n   true\n    ? factory(exports)\n    : undefined;\n})(this, function(exports) {\n  'use strict';\n\n  var isNode = function isNode(value) {\n    return value instanceof HTMLElement;\n  };\n\n  var createStore = function createStore(initialState) {\n    var queries =\n      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    var actions =\n      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    // internal state\n    var state = Object.assign({}, initialState);\n\n    // contains all actions for next frame, is clear when actions are requested\n    var actionQueue = [];\n    var dispatchQueue = [];\n\n    // returns a duplicate of the current state\n    var getState = function getState() {\n      return Object.assign({}, state);\n    };\n\n    // returns a duplicate of the actions array and clears the actions array\n    var processActionQueue = function processActionQueue() {\n      // create copy of actions queue\n      var queue = [].concat(actionQueue);\n\n      // clear actions queue (we don't want no double actions)\n      actionQueue.length = 0;\n\n      return queue;\n    };\n\n    // processes actions that might block the main UI thread\n    var processDispatchQueue = function processDispatchQueue() {\n      // create copy of actions queue\n      var queue = [].concat(dispatchQueue);\n\n      // clear actions queue (we don't want no double actions)\n      dispatchQueue.length = 0;\n\n      // now dispatch these actions\n      queue.forEach(function(_ref) {\n        var type = _ref.type,\n          data = _ref.data;\n        dispatch(type, data);\n      });\n    };\n\n    // adds a new action, calls its handler and\n    var dispatch = function dispatch(type, data, isBlocking) {\n      // is blocking action (should never block if document is hidden)\n      if (isBlocking && !document.hidden) {\n        dispatchQueue.push({ type: type, data: data });\n        return;\n      }\n\n      // if this action has a handler, handle the action\n      if (actionHandlers[type]) {\n        actionHandlers[type](data);\n      }\n\n      // now add action\n      actionQueue.push({\n        type: type,\n        data: data\n      });\n    };\n\n    var query = function query(str) {\n      var _queryHandles;\n      for (\n        var _len = arguments.length,\n          args = new Array(_len > 1 ? _len - 1 : 0),\n          _key = 1;\n        _key < _len;\n        _key++\n      ) {\n        args[_key - 1] = arguments[_key];\n      }\n      return queryHandles[str]\n        ? (_queryHandles = queryHandles)[str].apply(_queryHandles, args)\n        : null;\n    };\n\n    var api = {\n      getState: getState,\n      processActionQueue: processActionQueue,\n      processDispatchQueue: processDispatchQueue,\n      dispatch: dispatch,\n      query: query\n    };\n\n    var queryHandles = {};\n    queries.forEach(function(query) {\n      queryHandles = Object.assign({}, query(state), {}, queryHandles);\n    });\n\n    var actionHandlers = {};\n    actions.forEach(function(action) {\n      actionHandlers = Object.assign(\n        {},\n        action(dispatch, query, state),\n        {},\n        actionHandlers\n      );\n    });\n\n    return api;\n  };\n\n  var defineProperty = function defineProperty(obj, property, definition) {\n    if (typeof definition === 'function') {\n      obj[property] = definition;\n      return;\n    }\n    Object.defineProperty(obj, property, Object.assign({}, definition));\n  };\n\n  var forin = function forin(obj, cb) {\n    for (var key in obj) {\n      if (!obj.hasOwnProperty(key)) {\n        continue;\n      }\n\n      cb(key, obj[key]);\n    }\n  };\n\n  var createObject = function createObject(definition) {\n    var obj = {};\n    forin(definition, function(property) {\n      defineProperty(obj, property, definition[property]);\n    });\n    return obj;\n  };\n\n  var attr = function attr(node, name) {\n    var value =\n      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    if (value === null) {\n      return node.getAttribute(name) || node.hasAttribute(name);\n    }\n    node.setAttribute(name, value);\n  };\n\n  var ns = 'http://www.w3.org/2000/svg';\n  var svgElements = ['svg', 'path']; // only svg elements used\n\n  var isSVGElement = function isSVGElement(tag) {\n    return svgElements.includes(tag);\n  };\n\n  var createElement = function createElement(tag, className) {\n    var attributes =\n      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (typeof className === 'object') {\n      attributes = className;\n      className = null;\n    }\n    var element = isSVGElement(tag)\n      ? document.createElementNS(ns, tag)\n      : document.createElement(tag);\n    if (className) {\n      if (isSVGElement(tag)) {\n        attr(element, 'class', className);\n      } else {\n        element.className = className;\n      }\n    }\n    forin(attributes, function(name, value) {\n      attr(element, name, value);\n    });\n    return element;\n  };\n\n  var appendChild = function appendChild(parent) {\n    return function(child, index) {\n      if (typeof index !== 'undefined' && parent.children[index]) {\n        parent.insertBefore(child, parent.children[index]);\n      } else {\n        parent.appendChild(child);\n      }\n    };\n  };\n\n  var appendChildView = function appendChildView(parent, childViews) {\n    return function(view, index) {\n      if (typeof index !== 'undefined') {\n        childViews.splice(index, 0, view);\n      } else {\n        childViews.push(view);\n      }\n\n      return view;\n    };\n  };\n\n  var removeChildView = function removeChildView(parent, childViews) {\n    return function(view) {\n      // remove from child views\n      childViews.splice(childViews.indexOf(view), 1);\n\n      // remove the element\n      if (view.element.parentNode) {\n        parent.removeChild(view.element);\n      }\n\n      return view;\n    };\n  };\n\n  var IS_BROWSER = (function() {\n    return (\n      typeof window !== 'undefined' && typeof window.document !== 'undefined'\n    );\n  })();\n  var isBrowser = function isBrowser() {\n    return IS_BROWSER;\n  };\n\n  var testElement = isBrowser() ? createElement('svg') : {};\n  var getChildCount =\n    'children' in testElement\n      ? function(el) {\n          return el.children.length;\n        }\n      : function(el) {\n          return el.childNodes.length;\n        };\n\n  var getViewRect = function getViewRect(\n    elementRect,\n    childViews,\n    offset,\n    scale\n  ) {\n    var left = offset[0] || elementRect.left;\n    var top = offset[1] || elementRect.top;\n    var right = left + elementRect.width;\n    var bottom = top + elementRect.height * (scale[1] || 1);\n\n    var rect = {\n      // the rectangle of the element itself\n      element: Object.assign({}, elementRect),\n\n      // the rectangle of the element expanded to contain its children, does not include any margins\n      inner: {\n        left: elementRect.left,\n        top: elementRect.top,\n        right: elementRect.right,\n        bottom: elementRect.bottom\n      },\n\n      // the rectangle of the element expanded to contain its children including own margin and child margins\n      // margins will be added after we've recalculated the size\n      outer: {\n        left: left,\n        top: top,\n        right: right,\n        bottom: bottom\n      }\n    };\n\n    // expand rect to fit all child rectangles\n    childViews\n      .filter(function(childView) {\n        return !childView.isRectIgnored();\n      })\n      .map(function(childView) {\n        return childView.rect;\n      })\n      .forEach(function(childViewRect) {\n        expandRect(rect.inner, Object.assign({}, childViewRect.inner));\n        expandRect(rect.outer, Object.assign({}, childViewRect.outer));\n      });\n\n    // calculate inner width and height\n    calculateRectSize(rect.inner);\n\n    // append additional margin (top and left margins are included in top and left automatically)\n    rect.outer.bottom += rect.element.marginBottom;\n    rect.outer.right += rect.element.marginRight;\n\n    // calculate outer width and height\n    calculateRectSize(rect.outer);\n\n    return rect;\n  };\n\n  var expandRect = function expandRect(parent, child) {\n    // adjust for parent offset\n    child.top += parent.top;\n    child.right += parent.left;\n    child.bottom += parent.top;\n    child.left += parent.left;\n\n    if (child.bottom > parent.bottom) {\n      parent.bottom = child.bottom;\n    }\n\n    if (child.right > parent.right) {\n      parent.right = child.right;\n    }\n  };\n\n  var calculateRectSize = function calculateRectSize(rect) {\n    rect.width = rect.right - rect.left;\n    rect.height = rect.bottom - rect.top;\n  };\n\n  var isNumber = function isNumber(value) {\n    return typeof value === 'number';\n  };\n\n  /**\n   * Determines if position is at destination\n   * @param position\n   * @param destination\n   * @param velocity\n   * @param errorMargin\n   * @returns {boolean}\n   */\n  var thereYet = function thereYet(position, destination, velocity) {\n    var errorMargin =\n      arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.001;\n    return (\n      Math.abs(position - destination) < errorMargin &&\n      Math.abs(velocity) < errorMargin\n    );\n  };\n\n  /**\n   * Spring animation\n   */\n  var spring =\n    // default options\n    function spring() // method definition\n    {\n      var _ref =\n          arguments.length > 0 && arguments[0] !== undefined\n            ? arguments[0]\n            : {},\n        _ref$stiffness = _ref.stiffness,\n        stiffness = _ref$stiffness === void 0 ? 0.5 : _ref$stiffness,\n        _ref$damping = _ref.damping,\n        damping = _ref$damping === void 0 ? 0.75 : _ref$damping,\n        _ref$mass = _ref.mass,\n        mass = _ref$mass === void 0 ? 10 : _ref$mass;\n      var target = null;\n      var position = null;\n      var velocity = 0;\n      var resting = false;\n\n      // updates spring state\n      var interpolate = function interpolate(ts, skipToEndState) {\n        // in rest, don't animate\n        if (resting) return;\n\n        // need at least a target or position to do springy things\n        if (!(isNumber(target) && isNumber(position))) {\n          resting = true;\n          velocity = 0;\n          return;\n        }\n\n        // calculate spring force\n        var f = -(position - target) * stiffness;\n\n        // update velocity by adding force based on mass\n        velocity += f / mass;\n\n        // update position by adding velocity\n        position += velocity;\n\n        // slow down based on amount of damping\n        velocity *= damping;\n\n        // we've arrived if we're near target and our velocity is near zero\n        if (thereYet(position, target, velocity) || skipToEndState) {\n          position = target;\n          velocity = 0;\n          resting = true;\n\n          // we done\n          api.onupdate(position);\n          api.oncomplete(position);\n        } else {\n          // progress update\n          api.onupdate(position);\n        }\n      };\n\n      /**\n       * Set new target value\n       * @param value\n       */\n      var setTarget = function setTarget(value) {\n        // if currently has no position, set target and position to this value\n        if (isNumber(value) && !isNumber(position)) {\n          position = value;\n        }\n\n        // next target value will not be animated to\n        if (target === null) {\n          target = value;\n          position = value;\n        }\n\n        // let start moving to target\n        target = value;\n\n        // already at target\n        if (position === target || typeof target === 'undefined') {\n          // now resting as target is current position, stop moving\n          resting = true;\n          velocity = 0;\n\n          // done!\n          api.onupdate(position);\n          api.oncomplete(position);\n\n          return;\n        }\n\n        resting = false;\n      };\n\n      // need 'api' to call onupdate callback\n      var api = createObject({\n        interpolate: interpolate,\n        target: {\n          set: setTarget,\n          get: function get() {\n            return target;\n          }\n        },\n\n        resting: {\n          get: function get() {\n            return resting;\n          }\n        },\n\n        onupdate: function onupdate(value) {},\n        oncomplete: function oncomplete(value) {}\n      });\n\n      return api;\n    };\n\n  var easeLinear = function easeLinear(t) {\n    return t;\n  };\n  var easeInOutQuad = function easeInOutQuad(t) {\n    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n  };\n\n  var tween =\n    // default values\n    function tween() // method definition\n    {\n      var _ref =\n          arguments.length > 0 && arguments[0] !== undefined\n            ? arguments[0]\n            : {},\n        _ref$duration = _ref.duration,\n        duration = _ref$duration === void 0 ? 500 : _ref$duration,\n        _ref$easing = _ref.easing,\n        easing = _ref$easing === void 0 ? easeInOutQuad : _ref$easing,\n        _ref$delay = _ref.delay,\n        delay = _ref$delay === void 0 ? 0 : _ref$delay;\n      var start = null;\n      var t;\n      var p;\n      var resting = true;\n      var reverse = false;\n      var target = null;\n\n      var interpolate = function interpolate(ts, skipToEndState) {\n        if (resting || target === null) return;\n\n        if (start === null) {\n          start = ts;\n        }\n\n        if (ts - start < delay) return;\n\n        t = ts - start - delay;\n\n        if (t >= duration || skipToEndState) {\n          t = 1;\n          p = reverse ? 0 : 1;\n          api.onupdate(p * target);\n          api.oncomplete(p * target);\n          resting = true;\n        } else {\n          p = t / duration;\n          api.onupdate((t >= 0 ? easing(reverse ? 1 - p : p) : 0) * target);\n        }\n      };\n\n      // need 'api' to call onupdate callback\n      var api = createObject({\n        interpolate: interpolate,\n        target: {\n          get: function get() {\n            return reverse ? 0 : target;\n          },\n          set: function set(value) {\n            // is initial value\n            if (target === null) {\n              target = value;\n              api.onupdate(value);\n              api.oncomplete(value);\n              return;\n            }\n\n            // want to tween to a smaller value and have a current value\n            if (value < target) {\n              target = 1;\n              reverse = true;\n            } else {\n              // not tweening to a smaller value\n              reverse = false;\n              target = value;\n            }\n\n            // let's go!\n            resting = false;\n            start = null;\n          }\n        },\n\n        resting: {\n          get: function get() {\n            return resting;\n          }\n        },\n\n        onupdate: function onupdate(value) {},\n        oncomplete: function oncomplete(value) {}\n      });\n\n      return api;\n    };\n\n  var animator = {\n    spring: spring,\n    tween: tween\n  };\n\n  /*\n                       { type: 'spring', stiffness: .5, damping: .75, mass: 10 };\n                       { translation: { type: 'spring', ... }, ... }\n                       { translation: { x: { type: 'spring', ... } } }\n                      */\n  var createAnimator = function createAnimator(definition, category, property) {\n    // default is single definition\n    // we check if transform is set, if so, we check if property is set\n    var def =\n      definition[category] && typeof definition[category][property] === 'object'\n        ? definition[category][property]\n        : definition[category] || definition;\n\n    var type = typeof def === 'string' ? def : def.type;\n    var props = typeof def === 'object' ? Object.assign({}, def) : {};\n\n    return animator[type] ? animator[type](props) : null;\n  };\n\n  var addGetSet = function addGetSet(keys, obj, props) {\n    var overwrite =\n      arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    obj = Array.isArray(obj) ? obj : [obj];\n    obj.forEach(function(o) {\n      keys.forEach(function(key) {\n        var name = key;\n        var getter = function getter() {\n          return props[key];\n        };\n        var setter = function setter(value) {\n          return (props[key] = value);\n        };\n\n        if (typeof key === 'object') {\n          name = key.key;\n          getter = key.getter || getter;\n          setter = key.setter || setter;\n        }\n\n        if (o[name] && !overwrite) {\n          return;\n        }\n\n        o[name] = {\n          get: getter,\n          set: setter\n        };\n      });\n    });\n  };\n\n  // add to state,\n  // add getters and setters to internal and external api (if not set)\n  // setup animators\n\n  var animations = function animations(_ref) {\n    var mixinConfig = _ref.mixinConfig,\n      viewProps = _ref.viewProps,\n      viewInternalAPI = _ref.viewInternalAPI,\n      viewExternalAPI = _ref.viewExternalAPI;\n    // initial properties\n    var initialProps = Object.assign({}, viewProps);\n\n    // list of all active animations\n    var animations = [];\n\n    // setup animators\n    forin(mixinConfig, function(property, animation) {\n      var animator = createAnimator(animation);\n      if (!animator) {\n        return;\n      }\n\n      // when the animator updates, update the view state value\n      animator.onupdate = function(value) {\n        viewProps[property] = value;\n      };\n\n      // set animator target\n      animator.target = initialProps[property];\n\n      // when value is set, set the animator target value\n      var prop = {\n        key: property,\n        setter: function setter(value) {\n          // if already at target, we done!\n          if (animator.target === value) {\n            return;\n          }\n\n          animator.target = value;\n        },\n        getter: function getter() {\n          return viewProps[property];\n        }\n      };\n\n      // add getters and setters\n      addGetSet([prop], [viewInternalAPI, viewExternalAPI], viewProps, true);\n\n      // add it to the list for easy updating from the _write method\n      animations.push(animator);\n    });\n\n    // expose internal write api\n    return {\n      write: function write(ts) {\n        var skipToEndState = document.hidden;\n        var resting = true;\n        animations.forEach(function(animation) {\n          if (!animation.resting) resting = false;\n          animation.interpolate(ts, skipToEndState);\n        });\n        return resting;\n      },\n      destroy: function destroy() {}\n    };\n  };\n\n  var addEvent = function addEvent(element) {\n    return function(type, fn) {\n      element.addEventListener(type, fn);\n    };\n  };\n\n  var removeEvent = function removeEvent(element) {\n    return function(type, fn) {\n      element.removeEventListener(type, fn);\n    };\n  };\n\n  // mixin\n  var listeners = function listeners(_ref) {\n    var mixinConfig = _ref.mixinConfig,\n      viewProps = _ref.viewProps,\n      viewInternalAPI = _ref.viewInternalAPI,\n      viewExternalAPI = _ref.viewExternalAPI,\n      viewState = _ref.viewState,\n      view = _ref.view;\n    var events = [];\n\n    var add = addEvent(view.element);\n    var remove = removeEvent(view.element);\n\n    viewExternalAPI.on = function(type, fn) {\n      events.push({\n        type: type,\n        fn: fn\n      });\n\n      add(type, fn);\n    };\n\n    viewExternalAPI.off = function(type, fn) {\n      events.splice(\n        events.findIndex(function(event) {\n          return event.type === type && event.fn === fn;\n        }),\n        1\n      );\n\n      remove(type, fn);\n    };\n\n    return {\n      write: function write() {\n        // not busy\n        return true;\n      },\n      destroy: function destroy() {\n        events.forEach(function(event) {\n          remove(event.type, event.fn);\n        });\n      }\n    };\n  };\n\n  // add to external api and link to props\n\n  var apis = function apis(_ref) {\n    var mixinConfig = _ref.mixinConfig,\n      viewProps = _ref.viewProps,\n      viewExternalAPI = _ref.viewExternalAPI;\n    addGetSet(mixinConfig, viewExternalAPI, viewProps);\n  };\n\n  var isDefined = function isDefined(value) {\n    return value != null;\n  };\n\n  // add to state,\n  // add getters and setters to internal and external api (if not set)\n  // set initial state based on props in viewProps\n  // apply as transforms each frame\n\n  var defaults = {\n    opacity: 1,\n    scaleX: 1,\n    scaleY: 1,\n    translateX: 0,\n    translateY: 0,\n    rotateX: 0,\n    rotateY: 0,\n    rotateZ: 0,\n    originX: 0,\n    originY: 0\n  };\n\n  var styles = function styles(_ref) {\n    var mixinConfig = _ref.mixinConfig,\n      viewProps = _ref.viewProps,\n      viewInternalAPI = _ref.viewInternalAPI,\n      viewExternalAPI = _ref.viewExternalAPI,\n      view = _ref.view;\n    // initial props\n    var initialProps = Object.assign({}, viewProps);\n\n    // current props\n    var currentProps = {};\n\n    // we will add those properties to the external API and link them to the viewState\n    addGetSet(mixinConfig, [viewInternalAPI, viewExternalAPI], viewProps);\n\n    // override rect on internal and external rect getter so it takes in account transforms\n    var getOffset = function getOffset() {\n      return [viewProps['translateX'] || 0, viewProps['translateY'] || 0];\n    };\n\n    var getScale = function getScale() {\n      return [viewProps['scaleX'] || 0, viewProps['scaleY'] || 0];\n    };\n    var getRect = function getRect() {\n      return view.rect\n        ? getViewRect(view.rect, view.childViews, getOffset(), getScale())\n        : null;\n    };\n    viewInternalAPI.rect = { get: getRect };\n    viewExternalAPI.rect = { get: getRect };\n\n    // apply view props\n    mixinConfig.forEach(function(key) {\n      viewProps[key] =\n        typeof initialProps[key] === 'undefined'\n          ? defaults[key]\n          : initialProps[key];\n    });\n\n    // expose api\n    return {\n      write: function write() {\n        // see if props have changed\n        if (!propsHaveChanged(currentProps, viewProps)) {\n          return;\n        }\n\n        // moves element to correct position on screen\n        applyStyles(view.element, viewProps);\n\n        // store new transforms\n        Object.assign(currentProps, Object.assign({}, viewProps));\n\n        // no longer busy\n        return true;\n      },\n      destroy: function destroy() {}\n    };\n  };\n\n  var propsHaveChanged = function propsHaveChanged(currentProps, newProps) {\n    // different amount of keys\n    if (Object.keys(currentProps).length !== Object.keys(newProps).length) {\n      return true;\n    }\n\n    // lets analyze the individual props\n    for (var prop in newProps) {\n      if (newProps[prop] !== currentProps[prop]) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  var applyStyles = function applyStyles(element, _ref2) {\n    var opacity = _ref2.opacity,\n      perspective = _ref2.perspective,\n      translateX = _ref2.translateX,\n      translateY = _ref2.translateY,\n      scaleX = _ref2.scaleX,\n      scaleY = _ref2.scaleY,\n      rotateX = _ref2.rotateX,\n      rotateY = _ref2.rotateY,\n      rotateZ = _ref2.rotateZ,\n      originX = _ref2.originX,\n      originY = _ref2.originY,\n      width = _ref2.width,\n      height = _ref2.height;\n\n    var transforms = '';\n    var styles = '';\n\n    // handle transform origin\n    if (isDefined(originX) || isDefined(originY)) {\n      styles +=\n        'transform-origin: ' + (originX || 0) + 'px ' + (originY || 0) + 'px;';\n    }\n\n    // transform order is relevant\n    // 0. perspective\n    if (isDefined(perspective)) {\n      transforms += 'perspective(' + perspective + 'px) ';\n    }\n\n    // 1. translate\n    if (isDefined(translateX) || isDefined(translateY)) {\n      transforms +=\n        'translate3d(' +\n        (translateX || 0) +\n        'px, ' +\n        (translateY || 0) +\n        'px, 0) ';\n    }\n\n    // 2. scale\n    if (isDefined(scaleX) || isDefined(scaleY)) {\n      transforms +=\n        'scale3d(' +\n        (isDefined(scaleX) ? scaleX : 1) +\n        ', ' +\n        (isDefined(scaleY) ? scaleY : 1) +\n        ', 1) ';\n    }\n\n    // 3. rotate\n    if (isDefined(rotateZ)) {\n      transforms += 'rotateZ(' + rotateZ + 'rad) ';\n    }\n\n    if (isDefined(rotateX)) {\n      transforms += 'rotateX(' + rotateX + 'rad) ';\n    }\n\n    if (isDefined(rotateY)) {\n      transforms += 'rotateY(' + rotateY + 'rad) ';\n    }\n\n    // add transforms\n    if (transforms.length) {\n      styles += 'transform:' + transforms + ';';\n    }\n\n    // add opacity\n    if (isDefined(opacity)) {\n      styles += 'opacity:' + opacity + ';';\n\n      // if we reach zero, we make the element inaccessible\n      if (opacity === 0) {\n        styles += 'visibility:hidden;';\n      }\n\n      // if we're below 100% opacity this element can't be clicked\n      if (opacity < 1) {\n        styles += 'pointer-events:none;';\n      }\n    }\n\n    // add height\n    if (isDefined(height)) {\n      styles += 'height:' + height + 'px;';\n    }\n\n    // add width\n    if (isDefined(width)) {\n      styles += 'width:' + width + 'px;';\n    }\n\n    // apply styles\n    var elementCurrentStyle = element.elementCurrentStyle || '';\n\n    // if new styles does not match current styles, lets update!\n    if (\n      styles.length !== elementCurrentStyle.length ||\n      styles !== elementCurrentStyle\n    ) {\n      element.style.cssText = styles;\n      // store current styles so we can compare them to new styles later on\n      // _not_ getting the style value is faster\n      element.elementCurrentStyle = styles;\n    }\n  };\n\n  var Mixins = {\n    styles: styles,\n    listeners: listeners,\n    animations: animations,\n    apis: apis\n  };\n\n  var updateRect = function updateRect() {\n    var rect =\n      arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var element =\n      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var style =\n      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (!element.layoutCalculated) {\n      rect.paddingTop = parseInt(style.paddingTop, 10) || 0;\n      rect.marginTop = parseInt(style.marginTop, 10) || 0;\n      rect.marginRight = parseInt(style.marginRight, 10) || 0;\n      rect.marginBottom = parseInt(style.marginBottom, 10) || 0;\n      rect.marginLeft = parseInt(style.marginLeft, 10) || 0;\n      element.layoutCalculated = true;\n    }\n\n    rect.left = element.offsetLeft || 0;\n    rect.top = element.offsetTop || 0;\n    rect.width = element.offsetWidth || 0;\n    rect.height = element.offsetHeight || 0;\n\n    rect.right = rect.left + rect.width;\n    rect.bottom = rect.top + rect.height;\n\n    rect.scrollTop = element.scrollTop;\n\n    rect.hidden = element.offsetParent === null;\n\n    return rect;\n  };\n\n  var createView =\n    // default view definition\n    function createView() {\n      var _ref =\n          arguments.length > 0 && arguments[0] !== undefined\n            ? arguments[0]\n            : {},\n        _ref$tag = _ref.tag,\n        tag = _ref$tag === void 0 ? 'div' : _ref$tag,\n        _ref$name = _ref.name,\n        name = _ref$name === void 0 ? null : _ref$name,\n        _ref$attributes = _ref.attributes,\n        attributes = _ref$attributes === void 0 ? {} : _ref$attributes,\n        _ref$read = _ref.read,\n        read = _ref$read === void 0 ? function() {} : _ref$read,\n        _ref$write = _ref.write,\n        write = _ref$write === void 0 ? function() {} : _ref$write,\n        _ref$create = _ref.create,\n        create = _ref$create === void 0 ? function() {} : _ref$create,\n        _ref$destroy = _ref.destroy,\n        destroy = _ref$destroy === void 0 ? function() {} : _ref$destroy,\n        _ref$filterFrameActio = _ref.filterFrameActionsForChild,\n        filterFrameActionsForChild =\n          _ref$filterFrameActio === void 0\n            ? function(child, actions) {\n                return actions;\n              }\n            : _ref$filterFrameActio,\n        _ref$didCreateView = _ref.didCreateView,\n        didCreateView =\n          _ref$didCreateView === void 0 ? function() {} : _ref$didCreateView,\n        _ref$didWriteView = _ref.didWriteView,\n        didWriteView =\n          _ref$didWriteView === void 0 ? function() {} : _ref$didWriteView,\n        _ref$ignoreRect = _ref.ignoreRect,\n        ignoreRect = _ref$ignoreRect === void 0 ? false : _ref$ignoreRect,\n        _ref$ignoreRectUpdate = _ref.ignoreRectUpdate,\n        ignoreRectUpdate =\n          _ref$ignoreRectUpdate === void 0 ? false : _ref$ignoreRectUpdate,\n        _ref$mixins = _ref.mixins,\n        mixins = _ref$mixins === void 0 ? [] : _ref$mixins;\n      return function(\n        // each view requires reference to store\n        store\n      ) {\n        var props =\n          arguments.length > 1 && arguments[1] !== undefined\n            ? arguments[1]\n            : {};\n        // root element should not be changed\n        var element = createElement(tag, 'filepond--' + name, attributes);\n\n        // style reference should also not be changed\n        var style = window.getComputedStyle(element, null);\n\n        // element rectangle\n        var rect = updateRect();\n        var frameRect = null;\n\n        // rest state\n        var isResting = false;\n\n        // pretty self explanatory\n        var childViews = [];\n\n        // loaded mixins\n        var activeMixins = [];\n\n        // references to created children\n        var ref = {};\n\n        // state used for each instance\n        var state = {};\n\n        // list of writers that will be called to update this view\n        var writers = [\n          write // default writer\n        ];\n\n        var readers = [\n          read // default reader\n        ];\n\n        var destroyers = [\n          destroy // default destroy\n        ];\n\n        // core view methods\n        var getElement = function getElement() {\n          return element;\n        };\n        var getChildViews = function getChildViews() {\n          return childViews.concat();\n        };\n        var getReference = function getReference() {\n          return ref;\n        };\n        var createChildView = function createChildView(store) {\n          return function(view, props) {\n            return view(store, props);\n          };\n        };\n        var getRect = function getRect() {\n          if (frameRect) {\n            return frameRect;\n          }\n          frameRect = getViewRect(rect, childViews, [0, 0], [1, 1]);\n          return frameRect;\n        };\n        var getStyle = function getStyle() {\n          return style;\n        };\n\n        /**\n         * Read data from DOM\n         * @private\n         */\n        var _read = function _read() {\n          frameRect = null;\n\n          // read child views\n          childViews.forEach(function(child) {\n            return child._read();\n          });\n\n          var shouldUpdate = !(ignoreRectUpdate && rect.width && rect.height);\n          if (shouldUpdate) {\n            updateRect(rect, element, style);\n          }\n\n          // readers\n          var api = { root: internalAPI, props: props, rect: rect };\n          readers.forEach(function(reader) {\n            return reader(api);\n          });\n        };\n\n        /**\n         * Write data to DOM\n         * @private\n         */\n        var _write = function _write(ts, frameActions, shouldOptimize) {\n          // if no actions, we assume that the view is resting\n          var resting = frameActions.length === 0;\n\n          // writers\n          writers.forEach(function(writer) {\n            var writerResting = writer({\n              props: props,\n              root: internalAPI,\n              actions: frameActions,\n              timestamp: ts,\n              shouldOptimize: shouldOptimize\n            });\n\n            if (writerResting === false) {\n              resting = false;\n            }\n          });\n\n          // run mixins\n          activeMixins.forEach(function(mixin) {\n            // if one of the mixins is still busy after write operation, we are not resting\n            var mixinResting = mixin.write(ts);\n            if (mixinResting === false) {\n              resting = false;\n            }\n          });\n\n          // updates child views that are currently attached to the DOM\n          childViews\n            .filter(function(child) {\n              return !!child.element.parentNode;\n            })\n            .forEach(function(child) {\n              // if a child view is not resting, we are not resting\n              var childResting = child._write(\n                ts,\n                filterFrameActionsForChild(child, frameActions),\n                shouldOptimize\n              );\n\n              if (!childResting) {\n                resting = false;\n              }\n            });\n\n          // append new elements to DOM and update those\n          childViews\n            //.filter(child => !child.element.parentNode)\n            .forEach(function(child, index) {\n              // skip\n              if (child.element.parentNode) {\n                return;\n              }\n\n              // append to DOM\n              internalAPI.appendChild(child.element, index);\n\n              // call read (need to know the size of these elements)\n              child._read();\n\n              // re-call write\n              child._write(\n                ts,\n                filterFrameActionsForChild(child, frameActions),\n                shouldOptimize\n              );\n\n              // we just added somthing to the dom, no rest\n              resting = false;\n            });\n\n          // update resting state\n          isResting = resting;\n\n          didWriteView({\n            props: props,\n            root: internalAPI,\n            actions: frameActions,\n            timestamp: ts\n          });\n\n          // let parent know if we are resting\n          return resting;\n        };\n\n        var _destroy = function _destroy() {\n          activeMixins.forEach(function(mixin) {\n            return mixin.destroy();\n          });\n          destroyers.forEach(function(destroyer) {\n            destroyer({ root: internalAPI, props: props });\n          });\n          childViews.forEach(function(child) {\n            return child._destroy();\n          });\n        };\n\n        // sharedAPI\n        var sharedAPIDefinition = {\n          element: {\n            get: getElement\n          },\n\n          style: {\n            get: getStyle\n          },\n\n          childViews: {\n            get: getChildViews\n          }\n        };\n\n        // private API definition\n        var internalAPIDefinition = Object.assign({}, sharedAPIDefinition, {\n          rect: {\n            get: getRect\n          },\n\n          // access to custom children references\n          ref: {\n            get: getReference\n          },\n\n          // dom modifiers\n          is: function is(needle) {\n            return name === needle;\n          },\n          appendChild: appendChild(element),\n          createChildView: createChildView(store),\n          linkView: function linkView(view) {\n            childViews.push(view);\n            return view;\n          },\n          unlinkView: function unlinkView(view) {\n            childViews.splice(childViews.indexOf(view), 1);\n          },\n          appendChildView: appendChildView(element, childViews),\n          removeChildView: removeChildView(element, childViews),\n          registerWriter: function registerWriter(writer) {\n            return writers.push(writer);\n          },\n          registerReader: function registerReader(reader) {\n            return readers.push(reader);\n          },\n          registerDestroyer: function registerDestroyer(destroyer) {\n            return destroyers.push(destroyer);\n          },\n          invalidateLayout: function invalidateLayout() {\n            return (element.layoutCalculated = false);\n          },\n\n          // access to data store\n          dispatch: store.dispatch,\n          query: store.query\n        });\n\n        // public view API methods\n        var externalAPIDefinition = {\n          element: {\n            get: getElement\n          },\n\n          childViews: {\n            get: getChildViews\n          },\n\n          rect: {\n            get: getRect\n          },\n\n          resting: {\n            get: function get() {\n              return isResting;\n            }\n          },\n\n          isRectIgnored: function isRectIgnored() {\n            return ignoreRect;\n          },\n          _read: _read,\n          _write: _write,\n          _destroy: _destroy\n        };\n\n        // mixin API methods\n        var mixinAPIDefinition = Object.assign({}, sharedAPIDefinition, {\n          rect: {\n            get: function get() {\n              return rect;\n            }\n          }\n        });\n\n        // add mixin functionality\n        Object.keys(mixins)\n          .sort(function(a, b) {\n            // move styles to the back of the mixin list (so adjustments of other mixins are applied to the props correctly)\n            if (a === 'styles') {\n              return 1;\n            } else if (b === 'styles') {\n              return -1;\n            }\n            return 0;\n          })\n          .forEach(function(key) {\n            var mixinAPI = Mixins[key]({\n              mixinConfig: mixins[key],\n              viewProps: props,\n              viewState: state,\n              viewInternalAPI: internalAPIDefinition,\n              viewExternalAPI: externalAPIDefinition,\n              view: createObject(mixinAPIDefinition)\n            });\n\n            if (mixinAPI) {\n              activeMixins.push(mixinAPI);\n            }\n          });\n\n        // construct private api\n        var internalAPI = createObject(internalAPIDefinition);\n\n        // create the view\n        create({\n          root: internalAPI,\n          props: props\n        });\n\n        // append created child views to root node\n        var childCount = getChildCount(element); // need to know the current child count so appending happens in correct order\n        childViews.forEach(function(child, index) {\n          internalAPI.appendChild(child.element, childCount + index);\n        });\n\n        // call did create\n        didCreateView(internalAPI);\n\n        // expose public api\n        return createObject(externalAPIDefinition);\n      };\n    };\n\n  var createPainter = function createPainter(read, write) {\n    var fps =\n      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 60;\n\n    var name = '__framePainter';\n\n    // set global painter\n    if (window[name]) {\n      window[name].readers.push(read);\n      window[name].writers.push(write);\n      return;\n    }\n\n    window[name] = {\n      readers: [read],\n      writers: [write]\n    };\n\n    var painter = window[name];\n\n    var interval = 1000 / fps;\n    var last = null;\n    var id = null;\n    var requestTick = null;\n    var cancelTick = null;\n\n    var setTimerType = function setTimerType() {\n      if (document.hidden) {\n        requestTick = function requestTick() {\n          return window.setTimeout(function() {\n            return tick(performance.now());\n          }, interval);\n        };\n        cancelTick = function cancelTick() {\n          return window.clearTimeout(id);\n        };\n      } else {\n        requestTick = function requestTick() {\n          return window.requestAnimationFrame(tick);\n        };\n        cancelTick = function cancelTick() {\n          return window.cancelAnimationFrame(id);\n        };\n      }\n    };\n\n    document.addEventListener('visibilitychange', function() {\n      if (cancelTick) cancelTick();\n      setTimerType();\n      tick(performance.now());\n    });\n\n    var tick = function tick(ts) {\n      // queue next tick\n      id = requestTick(tick);\n\n      // limit fps\n      if (!last) {\n        last = ts;\n      }\n\n      var delta = ts - last;\n\n      if (delta <= interval) {\n        // skip frame\n        return;\n      }\n\n      // align next frame\n      last = ts - (delta % interval);\n\n      // update view\n      painter.readers.forEach(function(read) {\n        return read();\n      });\n      painter.writers.forEach(function(write) {\n        return write(ts);\n      });\n    };\n\n    setTimerType();\n    tick(performance.now());\n\n    return {\n      pause: function pause() {\n        cancelTick(id);\n      }\n    };\n  };\n\n  var createRoute = function createRoute(routes, fn) {\n    return function(_ref) {\n      var root = _ref.root,\n        props = _ref.props,\n        _ref$actions = _ref.actions,\n        actions = _ref$actions === void 0 ? [] : _ref$actions,\n        timestamp = _ref.timestamp,\n        shouldOptimize = _ref.shouldOptimize;\n      actions\n        .filter(function(action) {\n          return routes[action.type];\n        })\n        .forEach(function(action) {\n          return routes[action.type]({\n            root: root,\n            props: props,\n            action: action.data,\n            timestamp: timestamp,\n            shouldOptimize: shouldOptimize\n          });\n        });\n\n      if (fn) {\n        fn({\n          root: root,\n          props: props,\n          actions: actions,\n          timestamp: timestamp,\n          shouldOptimize: shouldOptimize\n        });\n      }\n    };\n  };\n\n  var insertBefore = function insertBefore(newNode, referenceNode) {\n    return referenceNode.parentNode.insertBefore(newNode, referenceNode);\n  };\n\n  var insertAfter = function insertAfter(newNode, referenceNode) {\n    return referenceNode.parentNode.insertBefore(\n      newNode,\n      referenceNode.nextSibling\n    );\n  };\n\n  var isArray = function isArray(value) {\n    return Array.isArray(value);\n  };\n\n  var isEmpty = function isEmpty(value) {\n    return value == null;\n  };\n\n  var trim = function trim(str) {\n    return str.trim();\n  };\n\n  var toString = function toString(value) {\n    return '' + value;\n  };\n\n  var toArray = function toArray(value) {\n    var splitter =\n      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ',';\n    if (isEmpty(value)) {\n      return [];\n    }\n    if (isArray(value)) {\n      return value;\n    }\n    return toString(value)\n      .split(splitter)\n      .map(trim)\n      .filter(function(str) {\n        return str.length;\n      });\n  };\n\n  var isBoolean = function isBoolean(value) {\n    return typeof value === 'boolean';\n  };\n\n  var toBoolean = function toBoolean(value) {\n    return isBoolean(value) ? value : value === 'true';\n  };\n\n  var isString = function isString(value) {\n    return typeof value === 'string';\n  };\n\n  var toNumber = function toNumber(value) {\n    return isNumber(value)\n      ? value\n      : isString(value)\n      ? toString(value).replace(/[a-z]+/gi, '')\n      : 0;\n  };\n\n  var toInt = function toInt(value) {\n    return parseInt(toNumber(value), 10);\n  };\n\n  var toFloat = function toFloat(value) {\n    return parseFloat(toNumber(value));\n  };\n\n  var isInt = function isInt(value) {\n    return isNumber(value) && isFinite(value) && Math.floor(value) === value;\n  };\n\n  var toBytes = function toBytes(value) {\n    var base =\n      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;\n    // is in bytes\n    if (isInt(value)) {\n      return value;\n    }\n\n    // is natural file size\n    var naturalFileSize = toString(value).trim();\n\n    // if is value in megabytes\n    if (/MB$/i.test(naturalFileSize)) {\n      naturalFileSize = naturalFileSize.replace(/MB$i/, '').trim();\n      return toInt(naturalFileSize) * base * base;\n    }\n\n    // if is value in kilobytes\n    if (/KB/i.test(naturalFileSize)) {\n      naturalFileSize = naturalFileSize.replace(/KB$i/, '').trim();\n      return toInt(naturalFileSize) * base;\n    }\n\n    return toInt(naturalFileSize);\n  };\n\n  var isFunction = function isFunction(value) {\n    return typeof value === 'function';\n  };\n\n  var toFunctionReference = function toFunctionReference(string) {\n    var ref = self;\n    var levels = string.split('.');\n    var level = null;\n    while ((level = levels.shift())) {\n      ref = ref[level];\n      if (!ref) {\n        return null;\n      }\n    }\n    return ref;\n  };\n\n  var methods = {\n    process: 'POST',\n    patch: 'PATCH',\n    revert: 'DELETE',\n    fetch: 'GET',\n    restore: 'GET',\n    load: 'GET'\n  };\n\n  var createServerAPI = function createServerAPI(outline) {\n    var api = {};\n\n    api.url = isString(outline) ? outline : outline.url || '';\n    api.timeout = outline.timeout ? parseInt(outline.timeout, 10) : 0;\n    api.headers = outline.headers ? outline.headers : {};\n\n    forin(methods, function(key) {\n      api[key] = createAction(\n        key,\n        outline[key],\n        methods[key],\n        api.timeout,\n        api.headers\n      );\n    });\n\n    // special treatment for remove\n    api.remove = outline.remove || null;\n\n    // remove generic headers from api object\n    delete api.headers;\n\n    return api;\n  };\n\n  var createAction = function createAction(\n    name,\n    outline,\n    method,\n    timeout,\n    headers\n  ) {\n    // is explicitely set to null so disable\n    if (outline === null) {\n      return null;\n    }\n\n    // if is custom function, done! Dev handles everything.\n    if (typeof outline === 'function') {\n      return outline;\n    }\n\n    // build action object\n    var action = {\n      url: method === 'GET' || method === 'PATCH' ? '?' + name + '=' : '',\n      method: method,\n      headers: headers,\n      withCredentials: false,\n      timeout: timeout,\n      onload: null,\n      ondata: null,\n      onerror: null\n    };\n\n    // is a single url\n    if (isString(outline)) {\n      action.url = outline;\n      return action;\n    }\n\n    // overwrite\n    Object.assign(action, outline);\n\n    // see if should reformat headers;\n    if (isString(action.headers)) {\n      var parts = action.headers.split(/:(.+)/);\n      action.headers = {\n        header: parts[0],\n        value: parts[1]\n      };\n    }\n\n    // if is bool withCredentials\n    action.withCredentials = toBoolean(action.withCredentials);\n\n    return action;\n  };\n\n  var toServerAPI = function toServerAPI(value) {\n    return createServerAPI(value);\n  };\n\n  var isNull = function isNull(value) {\n    return value === null;\n  };\n\n  var isObject = function isObject(value) {\n    return typeof value === 'object' && value !== null;\n  };\n\n  var isAPI = function isAPI(value) {\n    return (\n      isObject(value) &&\n      isString(value.url) &&\n      isObject(value.process) &&\n      isObject(value.revert) &&\n      isObject(value.restore) &&\n      isObject(value.fetch)\n    );\n  };\n\n  var getType = function getType(value) {\n    if (isArray(value)) {\n      return 'array';\n    }\n\n    if (isNull(value)) {\n      return 'null';\n    }\n\n    if (isInt(value)) {\n      return 'int';\n    }\n\n    if (/^[0-9]+ ?(?:GB|MB|KB)$/gi.test(value)) {\n      return 'bytes';\n    }\n\n    if (isAPI(value)) {\n      return 'api';\n    }\n\n    return typeof value;\n  };\n\n  var replaceSingleQuotes = function replaceSingleQuotes(str) {\n    return str\n      .replace(/{\\s*'/g, '{\"')\n      .replace(/'\\s*}/g, '\"}')\n      .replace(/'\\s*:/g, '\":')\n      .replace(/:\\s*'/g, ':\"')\n      .replace(/,\\s*'/g, ',\"')\n      .replace(/'\\s*,/g, '\",');\n  };\n\n  var conversionTable = {\n    array: toArray,\n    boolean: toBoolean,\n    int: function int(value) {\n      return getType(value) === 'bytes' ? toBytes(value) : toInt(value);\n    },\n    number: toFloat,\n    float: toFloat,\n    bytes: toBytes,\n    string: function string(value) {\n      return isFunction(value) ? value : toString(value);\n    },\n    function: function _function(value) {\n      return toFunctionReference(value);\n    },\n    serverapi: toServerAPI,\n    object: function object(value) {\n      try {\n        return JSON.parse(replaceSingleQuotes(value));\n      } catch (e) {\n        return null;\n      }\n    }\n  };\n\n  var convertTo = function convertTo(value, type) {\n    return conversionTable[type](value);\n  };\n\n  var getValueByType = function getValueByType(\n    newValue,\n    defaultValue,\n    valueType\n  ) {\n    // can always assign default value\n    if (newValue === defaultValue) {\n      return newValue;\n    }\n\n    // get the type of the new value\n    var newValueType = getType(newValue);\n\n    // is valid type?\n    if (newValueType !== valueType) {\n      // is string input, let's attempt to convert\n      var convertedValue = convertTo(newValue, valueType);\n\n      // what is the type now\n      newValueType = getType(convertedValue);\n\n      // no valid conversions found\n      if (convertedValue === null) {\n        throw 'Trying to assign value with incorrect type to \"' +\n          option +\n          '\", allowed type: \"' +\n          valueType +\n          '\"';\n      } else {\n        newValue = convertedValue;\n      }\n    }\n\n    // assign new value\n    return newValue;\n  };\n\n  var createOption = function createOption(defaultValue, valueType) {\n    var currentValue = defaultValue;\n    return {\n      enumerable: true,\n      get: function get() {\n        return currentValue;\n      },\n      set: function set(newValue) {\n        currentValue = getValueByType(newValue, defaultValue, valueType);\n      }\n    };\n  };\n\n  var createOptions = function createOptions(options) {\n    var obj = {};\n    forin(options, function(prop) {\n      var optionDefinition = options[prop];\n      obj[prop] = createOption(optionDefinition[0], optionDefinition[1]);\n    });\n    return createObject(obj);\n  };\n\n  var createInitialState = function createInitialState(options) {\n    return {\n      // model\n      items: [],\n\n      // timeout used for calling update items\n      listUpdateTimeout: null,\n\n      // timeout used for stacking metadata updates\n      itemUpdateTimeout: null,\n\n      // queue of items waiting to be processed\n      processingQueue: [],\n\n      // options\n      options: createOptions(options)\n    };\n  };\n\n  var fromCamels = function fromCamels(string) {\n    var separator =\n      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '-';\n    return string\n      .split(/(?=[A-Z])/)\n      .map(function(part) {\n        return part.toLowerCase();\n      })\n      .join(separator);\n  };\n\n  var createOptionAPI = function createOptionAPI(store, options) {\n    var obj = {};\n    forin(options, function(key) {\n      obj[key] = {\n        get: function get() {\n          return store.getState().options[key];\n        },\n        set: function set(value) {\n          store.dispatch('SET_' + fromCamels(key, '_').toUpperCase(), {\n            value: value\n          });\n        }\n      };\n    });\n    return obj;\n  };\n\n  var createOptionActions = function createOptionActions(options) {\n    return function(dispatch, query, state) {\n      var obj = {};\n      forin(options, function(key) {\n        var name = fromCamels(key, '_').toUpperCase();\n\n        obj['SET_' + name] = function(action) {\n          try {\n            state.options[key] = action.value;\n          } catch (e) {} // nope, failed\n\n          // we successfully set the value of this option\n          dispatch('DID_SET_' + name, { value: state.options[key] });\n        };\n      });\n      return obj;\n    };\n  };\n\n  var createOptionQueries = function createOptionQueries(options) {\n    return function(state) {\n      var obj = {};\n      forin(options, function(key) {\n        obj['GET_' + fromCamels(key, '_').toUpperCase()] = function(action) {\n          return state.options[key];\n        };\n      });\n      return obj;\n    };\n  };\n\n  var InteractionMethod = {\n    API: 1,\n    DROP: 2,\n    BROWSE: 3,\n    PASTE: 4,\n    NONE: 5\n  };\n\n  var getUniqueId = function getUniqueId() {\n    return Math.random()\n      .toString(36)\n      .substr(2, 9);\n  };\n\n  function _typeof(obj) {\n    if (typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol') {\n      _typeof = function(obj) {\n        return typeof obj;\n      };\n    } else {\n      _typeof = function(obj) {\n        return obj &&\n          typeof Symbol === 'function' &&\n          obj.constructor === Symbol &&\n          obj !== Symbol.prototype\n          ? 'symbol'\n          : typeof obj;\n      };\n    }\n\n    return _typeof(obj);\n  }\n\n  var REACT_ELEMENT_TYPE;\n\n  function _jsx(type, props, key, children) {\n    if (!REACT_ELEMENT_TYPE) {\n      REACT_ELEMENT_TYPE =\n        (typeof Symbol === 'function' &&\n          Symbol['for'] &&\n          Symbol['for']('react.element')) ||\n        0xeac7;\n    }\n\n    var defaultProps = type && type.defaultProps;\n    var childrenLength = arguments.length - 3;\n\n    if (!props && childrenLength !== 0) {\n      props = {\n        children: void 0\n      };\n    }\n\n    if (props && defaultProps) {\n      for (var propName in defaultProps) {\n        if (props[propName] === void 0) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    } else if (!props) {\n      props = defaultProps || {};\n    }\n\n    if (childrenLength === 1) {\n      props.children = children;\n    } else if (childrenLength > 1) {\n      var childArray = new Array(childrenLength);\n\n      for (var i = 0; i < childrenLength; i++) {\n        childArray[i] = arguments[i + 3];\n      }\n\n      props.children = childArray;\n    }\n\n    return {\n      $$typeof: REACT_ELEMENT_TYPE,\n      type: type,\n      key: key === undefined ? null : '' + key,\n      ref: null,\n      props: props,\n      _owner: null\n    };\n  }\n\n  function _asyncIterator(iterable) {\n    var method;\n\n    if (typeof Symbol !== 'undefined') {\n      if (Symbol.asyncIterator) {\n        method = iterable[Symbol.asyncIterator];\n        if (method != null) return method.call(iterable);\n      }\n\n      if (Symbol.iterator) {\n        method = iterable[Symbol.iterator];\n        if (method != null) return method.call(iterable);\n      }\n    }\n\n    throw new TypeError('Object is not async iterable');\n  }\n\n  function _AwaitValue(value) {\n    this.wrapped = value;\n  }\n\n  function _AsyncGenerator(gen) {\n    var front, back;\n\n    function send(key, arg) {\n      return new Promise(function(resolve, reject) {\n        var request = {\n          key: key,\n          arg: arg,\n          resolve: resolve,\n          reject: reject,\n          next: null\n        };\n\n        if (back) {\n          back = back.next = request;\n        } else {\n          front = back = request;\n          resume(key, arg);\n        }\n      });\n    }\n\n    function resume(key, arg) {\n      try {\n        var result = gen[key](arg);\n        var value = result.value;\n        var wrappedAwait = value instanceof _AwaitValue;\n        Promise.resolve(wrappedAwait ? value.wrapped : value).then(\n          function(arg) {\n            if (wrappedAwait) {\n              resume('next', arg);\n              return;\n            }\n\n            settle(result.done ? 'return' : 'normal', arg);\n          },\n          function(err) {\n            resume('throw', err);\n          }\n        );\n      } catch (err) {\n        settle('throw', err);\n      }\n    }\n\n    function settle(type, value) {\n      switch (type) {\n        case 'return':\n          front.resolve({\n            value: value,\n            done: true\n          });\n          break;\n\n        case 'throw':\n          front.reject(value);\n          break;\n\n        default:\n          front.resolve({\n            value: value,\n            done: false\n          });\n          break;\n      }\n\n      front = front.next;\n\n      if (front) {\n        resume(front.key, front.arg);\n      } else {\n        back = null;\n      }\n    }\n\n    this._invoke = send;\n\n    if (typeof gen.return !== 'function') {\n      this.return = undefined;\n    }\n  }\n\n  if (typeof Symbol === 'function' && Symbol.asyncIterator) {\n    _AsyncGenerator.prototype[Symbol.asyncIterator] = function() {\n      return this;\n    };\n  }\n\n  _AsyncGenerator.prototype.next = function(arg) {\n    return this._invoke('next', arg);\n  };\n\n  _AsyncGenerator.prototype.throw = function(arg) {\n    return this._invoke('throw', arg);\n  };\n\n  _AsyncGenerator.prototype.return = function(arg) {\n    return this._invoke('return', arg);\n  };\n\n  function _wrapAsyncGenerator(fn) {\n    return function() {\n      return new _AsyncGenerator(fn.apply(this, arguments));\n    };\n  }\n\n  function _awaitAsyncGenerator(value) {\n    return new _AwaitValue(value);\n  }\n\n  function _asyncGeneratorDelegate(inner, awaitWrap) {\n    var iter = {},\n      waiting = false;\n\n    function pump(key, value) {\n      waiting = true;\n      value = new Promise(function(resolve) {\n        resolve(inner[key](value));\n      });\n      return {\n        done: false,\n        value: awaitWrap(value)\n      };\n    }\n\n    if (typeof Symbol === 'function' && Symbol.iterator) {\n      iter[Symbol.iterator] = function() {\n        return this;\n      };\n    }\n\n    iter.next = function(value) {\n      if (waiting) {\n        waiting = false;\n        return value;\n      }\n\n      return pump('next', value);\n    };\n\n    if (typeof inner.throw === 'function') {\n      iter.throw = function(value) {\n        if (waiting) {\n          waiting = false;\n          throw value;\n        }\n\n        return pump('throw', value);\n      };\n    }\n\n    if (typeof inner.return === 'function') {\n      iter.return = function(value) {\n        return pump('return', value);\n      };\n    }\n\n    return iter;\n  }\n\n  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n      var info = gen[key](arg);\n      var value = info.value;\n    } catch (error) {\n      reject(error);\n      return;\n    }\n\n    if (info.done) {\n      resolve(value);\n    } else {\n      Promise.resolve(value).then(_next, _throw);\n    }\n  }\n\n  function _asyncToGenerator(fn) {\n    return function() {\n      var self = this,\n        args = arguments;\n      return new Promise(function(resolve, reject) {\n        var gen = fn.apply(self, args);\n\n        function _next(value) {\n          asyncGeneratorStep(\n            gen,\n            resolve,\n            reject,\n            _next,\n            _throw,\n            'next',\n            value\n          );\n        }\n\n        function _throw(err) {\n          asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'throw', err);\n        }\n\n        _next(undefined);\n      });\n    };\n  }\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError('Cannot call a class as a function');\n    }\n  }\n\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if ('value' in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n  }\n\n  function _defineEnumerableProperties(obj, descs) {\n    for (var key in descs) {\n      var desc = descs[key];\n      desc.configurable = desc.enumerable = true;\n      if ('value' in desc) desc.writable = true;\n      Object.defineProperty(obj, key, desc);\n    }\n\n    if (Object.getOwnPropertySymbols) {\n      var objectSymbols = Object.getOwnPropertySymbols(descs);\n\n      for (var i = 0; i < objectSymbols.length; i++) {\n        var sym = objectSymbols[i];\n        var desc = descs[sym];\n        desc.configurable = desc.enumerable = true;\n        if ('value' in desc) desc.writable = true;\n        Object.defineProperty(obj, sym, desc);\n      }\n    }\n\n    return obj;\n  }\n\n  function _defaults(obj, defaults) {\n    var keys = Object.getOwnPropertyNames(defaults);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      var value = Object.getOwnPropertyDescriptor(defaults, key);\n\n      if (value && value.configurable && obj[key] === undefined) {\n        Object.defineProperty(obj, key, value);\n      }\n    }\n\n    return obj;\n  }\n\n  function _defineProperty(obj, key, value) {\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  function _extends() {\n    _extends =\n      Object.assign ||\n      function(target) {\n        for (var i = 1; i < arguments.length; i++) {\n          var source = arguments[i];\n\n          for (var key in source) {\n            if (Object.prototype.hasOwnProperty.call(source, key)) {\n              target[key] = source[key];\n            }\n          }\n        }\n\n        return target;\n      };\n\n    return _extends.apply(this, arguments);\n  }\n\n  function _objectSpread(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i] != null ? arguments[i] : {};\n      var ownKeys = Object.keys(source);\n\n      if (typeof Object.getOwnPropertySymbols === 'function') {\n        ownKeys = ownKeys.concat(\n          Object.getOwnPropertySymbols(source).filter(function(sym) {\n            return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n          })\n        );\n      }\n\n      ownKeys.forEach(function(key) {\n        _defineProperty(target, key, source[key]);\n      });\n    }\n\n    return target;\n  }\n\n  function ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n\n    if (Object.getOwnPropertySymbols) {\n      var symbols = Object.getOwnPropertySymbols(object);\n      if (enumerableOnly)\n        symbols = symbols.filter(function(sym) {\n          return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        });\n      keys.push.apply(keys, symbols);\n    }\n\n    return keys;\n  }\n\n  function _objectSpread2(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i] != null ? arguments[i] : {};\n\n      if (i % 2) {\n        ownKeys(source, true).forEach(function(key) {\n          _defineProperty(target, key, source[key]);\n        });\n      } else if (Object.getOwnPropertyDescriptors) {\n        Object.defineProperties(\n          target,\n          Object.getOwnPropertyDescriptors(source)\n        );\n      } else {\n        ownKeys(source).forEach(function(key) {\n          Object.defineProperty(\n            target,\n            key,\n            Object.getOwnPropertyDescriptor(source, key)\n          );\n        });\n      }\n    }\n\n    return target;\n  }\n\n  function _inherits(subClass, superClass) {\n    if (typeof superClass !== 'function' && superClass !== null) {\n      throw new TypeError('Super expression must either be null or a function');\n    }\n\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n      constructor: {\n        value: subClass,\n        writable: true,\n        configurable: true\n      }\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n  }\n\n  function _inheritsLoose(subClass, superClass) {\n    subClass.prototype = Object.create(superClass.prototype);\n    subClass.prototype.constructor = subClass;\n    subClass.__proto__ = superClass;\n  }\n\n  function _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf\n      ? Object.getPrototypeOf\n      : function _getPrototypeOf(o) {\n          return o.__proto__ || Object.getPrototypeOf(o);\n        };\n    return _getPrototypeOf(o);\n  }\n\n  function _setPrototypeOf(o, p) {\n    _setPrototypeOf =\n      Object.setPrototypeOf ||\n      function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n      };\n\n    return _setPrototypeOf(o, p);\n  }\n\n  function isNativeReflectConstruct() {\n    if (typeof Reflect === 'undefined' || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === 'function') return true;\n\n    try {\n      Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  function _construct(Parent, args, Class) {\n    if (isNativeReflectConstruct()) {\n      _construct = Reflect.construct;\n    } else {\n      _construct = function _construct(Parent, args, Class) {\n        var a = [null];\n        a.push.apply(a, args);\n        var Constructor = Function.bind.apply(Parent, a);\n        var instance = new Constructor();\n        if (Class) _setPrototypeOf(instance, Class.prototype);\n        return instance;\n      };\n    }\n\n    return _construct.apply(null, arguments);\n  }\n\n  function _isNativeFunction(fn) {\n    return Function.toString.call(fn).indexOf('[native code]') !== -1;\n  }\n\n  function _wrapNativeSuper(Class) {\n    var _cache = typeof Map === 'function' ? new Map() : undefined;\n\n    _wrapNativeSuper = function _wrapNativeSuper(Class) {\n      if (Class === null || !_isNativeFunction(Class)) return Class;\n\n      if (typeof Class !== 'function') {\n        throw new TypeError(\n          'Super expression must either be null or a function'\n        );\n      }\n\n      if (typeof _cache !== 'undefined') {\n        if (_cache.has(Class)) return _cache.get(Class);\n\n        _cache.set(Class, Wrapper);\n      }\n\n      function Wrapper() {\n        return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n      }\n\n      Wrapper.prototype = Object.create(Class.prototype, {\n        constructor: {\n          value: Wrapper,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      });\n      return _setPrototypeOf(Wrapper, Class);\n    };\n\n    return _wrapNativeSuper(Class);\n  }\n\n  function _instanceof(left, right) {\n    if (\n      right != null &&\n      typeof Symbol !== 'undefined' &&\n      right[Symbol.hasInstance]\n    ) {\n      return !!right[Symbol.hasInstance](left);\n    } else {\n      return left instanceof right;\n    }\n  }\n\n  function _interopRequireDefault(obj) {\n    return obj && obj.__esModule\n      ? obj\n      : {\n          default: obj\n        };\n  }\n\n  function _interopRequireWildcard(obj) {\n    if (obj && obj.__esModule) {\n      return obj;\n    } else {\n      var newObj = {};\n\n      if (obj != null) {\n        for (var key in obj) {\n          if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc =\n              Object.defineProperty && Object.getOwnPropertyDescriptor\n                ? Object.getOwnPropertyDescriptor(obj, key)\n                : {};\n\n            if (desc.get || desc.set) {\n              Object.defineProperty(newObj, key, desc);\n            } else {\n              newObj[key] = obj[key];\n            }\n          }\n        }\n      }\n\n      newObj.default = obj;\n      return newObj;\n    }\n  }\n\n  function _newArrowCheck(innerThis, boundThis) {\n    if (innerThis !== boundThis) {\n      throw new TypeError('Cannot instantiate an arrow function');\n    }\n  }\n\n  function _objectDestructuringEmpty(obj) {\n    if (obj == null) throw new TypeError('Cannot destructure undefined');\n  }\n\n  function _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n\n    for (i = 0; i < sourceKeys.length; i++) {\n      key = sourceKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      target[key] = source[key];\n    }\n\n    return target;\n  }\n\n  function _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n\n    var key, i;\n\n    if (Object.getOwnPropertySymbols) {\n      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n      for (i = 0; i < sourceSymbolKeys.length; i++) {\n        key = sourceSymbolKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n        target[key] = source[key];\n      }\n    }\n\n    return target;\n  }\n\n  function _assertThisInitialized(self) {\n    if (self === void 0) {\n      throw new ReferenceError(\n        \"this hasn't been initialised - super() hasn't been called\"\n      );\n    }\n\n    return self;\n  }\n\n  function _possibleConstructorReturn(self, call) {\n    if (call && (typeof call === 'object' || typeof call === 'function')) {\n      return call;\n    }\n\n    return _assertThisInitialized(self);\n  }\n\n  function _superPropBase(object, property) {\n    while (!Object.prototype.hasOwnProperty.call(object, property)) {\n      object = _getPrototypeOf(object);\n      if (object === null) break;\n    }\n\n    return object;\n  }\n\n  function _get(target, property, receiver) {\n    if (typeof Reflect !== 'undefined' && Reflect.get) {\n      _get = Reflect.get;\n    } else {\n      _get = function _get(target, property, receiver) {\n        var base = _superPropBase(target, property);\n\n        if (!base) return;\n        var desc = Object.getOwnPropertyDescriptor(base, property);\n\n        if (desc.get) {\n          return desc.get.call(receiver);\n        }\n\n        return desc.value;\n      };\n    }\n\n    return _get(target, property, receiver || target);\n  }\n\n  function set(target, property, value, receiver) {\n    if (typeof Reflect !== 'undefined' && Reflect.set) {\n      set = Reflect.set;\n    } else {\n      set = function set(target, property, value, receiver) {\n        var base = _superPropBase(target, property);\n\n        var desc;\n\n        if (base) {\n          desc = Object.getOwnPropertyDescriptor(base, property);\n\n          if (desc.set) {\n            desc.set.call(receiver, value);\n            return true;\n          } else if (!desc.writable) {\n            return false;\n          }\n        }\n\n        desc = Object.getOwnPropertyDescriptor(receiver, property);\n\n        if (desc) {\n          if (!desc.writable) {\n            return false;\n          }\n\n          desc.value = value;\n          Object.defineProperty(receiver, property, desc);\n        } else {\n          _defineProperty(receiver, property, value);\n        }\n\n        return true;\n      };\n    }\n\n    return set(target, property, value, receiver);\n  }\n\n  function _set(target, property, value, receiver, isStrict) {\n    var s = set(target, property, value, receiver || target);\n\n    if (!s && isStrict) {\n      throw new Error('failed to set property');\n    }\n\n    return value;\n  }\n\n  function _taggedTemplateLiteral(strings, raw) {\n    if (!raw) {\n      raw = strings.slice(0);\n    }\n\n    return Object.freeze(\n      Object.defineProperties(strings, {\n        raw: {\n          value: Object.freeze(raw)\n        }\n      })\n    );\n  }\n\n  function _taggedTemplateLiteralLoose(strings, raw) {\n    if (!raw) {\n      raw = strings.slice(0);\n    }\n\n    strings.raw = raw;\n    return strings;\n  }\n\n  function _temporalRef(val, name) {\n    if (val === _temporalUndefined) {\n      throw new ReferenceError(name + ' is not defined - temporal dead zone');\n    } else {\n      return val;\n    }\n  }\n\n  function _readOnlyError(name) {\n    throw new Error('\"' + name + '\" is read-only');\n  }\n\n  function _classNameTDZError(name) {\n    throw new Error(\n      'Class \"' + name + '\" cannot be referenced in computed property keys.'\n    );\n  }\n\n  var _temporalUndefined = {};\n\n  function _slicedToArray(arr, i) {\n    return (\n      _arrayWithHoles(arr) ||\n      _iterableToArrayLimit(arr, i) ||\n      _nonIterableRest()\n    );\n  }\n\n  function _slicedToArrayLoose(arr, i) {\n    return (\n      _arrayWithHoles(arr) ||\n      _iterableToArrayLimitLoose(arr, i) ||\n      _nonIterableRest()\n    );\n  }\n\n  function _toArray(arr) {\n    return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest();\n  }\n\n  function _toConsumableArray(arr) {\n    return (\n      _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread()\n    );\n  }\n\n  function _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) {\n      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++)\n        arr2[i] = arr[i];\n\n      return arr2;\n    }\n  }\n\n  function _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n  }\n\n  function _iterableToArray(iter) {\n    if (\n      Symbol.iterator in Object(iter) ||\n      Object.prototype.toString.call(iter) === '[object Arguments]'\n    )\n      return Array.from(iter);\n  }\n\n  function _iterableToArrayLimit(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (\n        var _i = arr[Symbol.iterator](), _s;\n        !(_n = (_s = _i.next()).done);\n        _n = true\n      ) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i['return'] != null) _i['return']();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  function _iterableToArrayLimitLoose(arr, i) {\n    var _arr = [];\n\n    for (\n      var _iterator = arr[Symbol.iterator](), _step;\n      !(_step = _iterator.next()).done;\n\n    ) {\n      _arr.push(_step.value);\n\n      if (i && _arr.length === i) break;\n    }\n\n    return _arr;\n  }\n\n  function _nonIterableSpread() {\n    throw new TypeError('Invalid attempt to spread non-iterable instance');\n  }\n\n  function _nonIterableRest() {\n    throw new TypeError('Invalid attempt to destructure non-iterable instance');\n  }\n\n  function _skipFirstGeneratorNext(fn) {\n    return function() {\n      var it = fn.apply(this, arguments);\n      it.next();\n      return it;\n    };\n  }\n\n  function _toPrimitive(input, hint) {\n    if (typeof input !== 'object' || input === null) return input;\n    var prim = input[Symbol.toPrimitive];\n\n    if (prim !== undefined) {\n      var res = prim.call(input, hint || 'default');\n      if (typeof res !== 'object') return res;\n      throw new TypeError('@@toPrimitive must return a primitive value.');\n    }\n\n    return (hint === 'string' ? String : Number)(input);\n  }\n\n  function _toPropertyKey(arg) {\n    var key = _toPrimitive(arg, 'string');\n\n    return typeof key === 'symbol' ? key : String(key);\n  }\n\n  function _initializerWarningHelper(descriptor, context) {\n    throw new Error(\n      'Decorating class property failed. Please ensure that ' +\n        'proposal-class-properties is enabled and set to use loose mode. ' +\n        'To use proposal-class-properties in spec mode with decorators, wait for ' +\n        'the next major version of decorators in stage 2.'\n    );\n  }\n\n  function _initializerDefineProperty(target, property, descriptor, context) {\n    if (!descriptor) return;\n    Object.defineProperty(target, property, {\n      enumerable: descriptor.enumerable,\n      configurable: descriptor.configurable,\n      writable: descriptor.writable,\n      value: descriptor.initializer\n        ? descriptor.initializer.call(context)\n        : void 0\n    });\n  }\n\n  function _applyDecoratedDescriptor(\n    target,\n    property,\n    decorators,\n    descriptor,\n    context\n  ) {\n    var desc = {};\n    Object.keys(descriptor).forEach(function(key) {\n      desc[key] = descriptor[key];\n    });\n    desc.enumerable = !!desc.enumerable;\n    desc.configurable = !!desc.configurable;\n\n    if ('value' in desc || desc.initializer) {\n      desc.writable = true;\n    }\n\n    desc = decorators\n      .slice()\n      .reverse()\n      .reduce(function(desc, decorator) {\n        return decorator(target, property, desc) || desc;\n      }, desc);\n\n    if (context && desc.initializer !== void 0) {\n      desc.value = desc.initializer ? desc.initializer.call(context) : void 0;\n      desc.initializer = undefined;\n    }\n\n    if (desc.initializer === void 0) {\n      Object.defineProperty(target, property, desc);\n      desc = null;\n    }\n\n    return desc;\n  }\n\n  var id = 0;\n\n  function _classPrivateFieldLooseKey(name) {\n    return '__private_' + id++ + '_' + name;\n  }\n\n  function _classPrivateFieldLooseBase(receiver, privateKey) {\n    if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {\n      throw new TypeError('attempted to use private field on non-instance');\n    }\n\n    return receiver;\n  }\n\n  function _classPrivateFieldGet(receiver, privateMap) {\n    var descriptor = privateMap.get(receiver);\n\n    if (!descriptor) {\n      throw new TypeError('attempted to get private field on non-instance');\n    }\n\n    if (descriptor.get) {\n      return descriptor.get.call(receiver);\n    }\n\n    return descriptor.value;\n  }\n\n  function _classPrivateFieldSet(receiver, privateMap, value) {\n    var descriptor = privateMap.get(receiver);\n\n    if (!descriptor) {\n      throw new TypeError('attempted to set private field on non-instance');\n    }\n\n    if (descriptor.set) {\n      descriptor.set.call(receiver, value);\n    } else {\n      if (!descriptor.writable) {\n        throw new TypeError('attempted to set read only private field');\n      }\n\n      descriptor.value = value;\n    }\n\n    return value;\n  }\n\n  function _classPrivateFieldDestructureSet(receiver, privateMap) {\n    if (!privateMap.has(receiver)) {\n      throw new TypeError('attempted to set private field on non-instance');\n    }\n\n    var descriptor = privateMap.get(receiver);\n\n    if (descriptor.set) {\n      if (!('__destrObj' in descriptor)) {\n        descriptor.__destrObj = {\n          set value(v) {\n            descriptor.set.call(receiver, v);\n          }\n        };\n      }\n\n      return descriptor.__destrObj;\n    } else {\n      if (!descriptor.writable) {\n        throw new TypeError('attempted to set read only private field');\n      }\n\n      return descriptor;\n    }\n  }\n\n  function _classStaticPrivateFieldSpecGet(\n    receiver,\n    classConstructor,\n    descriptor\n  ) {\n    if (receiver !== classConstructor) {\n      throw new TypeError('Private static access of wrong provenance');\n    }\n\n    return descriptor.value;\n  }\n\n  function _classStaticPrivateFieldSpecSet(\n    receiver,\n    classConstructor,\n    descriptor,\n    value\n  ) {\n    if (receiver !== classConstructor) {\n      throw new TypeError('Private static access of wrong provenance');\n    }\n\n    if (!descriptor.writable) {\n      throw new TypeError('attempted to set read only private field');\n    }\n\n    descriptor.value = value;\n    return value;\n  }\n\n  function _classStaticPrivateMethodGet(receiver, classConstructor, method) {\n    if (receiver !== classConstructor) {\n      throw new TypeError('Private static access of wrong provenance');\n    }\n\n    return method;\n  }\n\n  function _classStaticPrivateMethodSet() {\n    throw new TypeError('attempted to set read only static private field');\n  }\n\n  function _decorate(decorators, factory, superClass, mixins) {\n    var api = _getDecoratorsApi();\n\n    if (mixins) {\n      for (var i = 0; i < mixins.length; i++) {\n        api = mixins[i](api);\n      }\n    }\n\n    var r = factory(function initialize(O) {\n      api.initializeInstanceElements(O, decorated.elements);\n    }, superClass);\n    var decorated = api.decorateClass(\n      _coalesceClassElements(r.d.map(_createElementDescriptor)),\n      decorators\n    );\n    api.initializeClassElements(r.F, decorated.elements);\n    return api.runClassFinishers(r.F, decorated.finishers);\n  }\n\n  function _getDecoratorsApi() {\n    _getDecoratorsApi = function() {\n      return api;\n    };\n\n    var api = {\n      elementsDefinitionOrder: [['method'], ['field']],\n      initializeInstanceElements: function(O, elements) {\n        ['method', 'field'].forEach(function(kind) {\n          elements.forEach(function(element) {\n            if (element.kind === kind && element.placement === 'own') {\n              this.defineClassElement(O, element);\n            }\n          }, this);\n        }, this);\n      },\n      initializeClassElements: function(F, elements) {\n        var proto = F.prototype;\n        ['method', 'field'].forEach(function(kind) {\n          elements.forEach(function(element) {\n            var placement = element.placement;\n\n            if (\n              element.kind === kind &&\n              (placement === 'static' || placement === 'prototype')\n            ) {\n              var receiver = placement === 'static' ? F : proto;\n              this.defineClassElement(receiver, element);\n            }\n          }, this);\n        }, this);\n      },\n      defineClassElement: function(receiver, element) {\n        var descriptor = element.descriptor;\n\n        if (element.kind === 'field') {\n          var initializer = element.initializer;\n          descriptor = {\n            enumerable: descriptor.enumerable,\n            writable: descriptor.writable,\n            configurable: descriptor.configurable,\n            value: initializer === void 0 ? void 0 : initializer.call(receiver)\n          };\n        }\n\n        Object.defineProperty(receiver, element.key, descriptor);\n      },\n      decorateClass: function(elements, decorators) {\n        var newElements = [];\n        var finishers = [];\n        var placements = {\n          static: [],\n          prototype: [],\n          own: []\n        };\n        elements.forEach(function(element) {\n          this.addElementPlacement(element, placements);\n        }, this);\n        elements.forEach(function(element) {\n          if (!_hasDecorators(element)) return newElements.push(element);\n          var elementFinishersExtras = this.decorateElement(\n            element,\n            placements\n          );\n          newElements.push(elementFinishersExtras.element);\n          newElements.push.apply(newElements, elementFinishersExtras.extras);\n          finishers.push.apply(finishers, elementFinishersExtras.finishers);\n        }, this);\n\n        if (!decorators) {\n          return {\n            elements: newElements,\n            finishers: finishers\n          };\n        }\n\n        var result = this.decorateConstructor(newElements, decorators);\n        finishers.push.apply(finishers, result.finishers);\n        result.finishers = finishers;\n        return result;\n      },\n      addElementPlacement: function(element, placements, silent) {\n        var keys = placements[element.placement];\n\n        if (!silent && keys.indexOf(element.key) !== -1) {\n          throw new TypeError('Duplicated element (' + element.key + ')');\n        }\n\n        keys.push(element.key);\n      },\n      decorateElement: function(element, placements) {\n        var extras = [];\n        var finishers = [];\n\n        for (\n          var decorators = element.decorators, i = decorators.length - 1;\n          i >= 0;\n          i--\n        ) {\n          var keys = placements[element.placement];\n          keys.splice(keys.indexOf(element.key), 1);\n          var elementObject = this.fromElementDescriptor(element);\n          var elementFinisherExtras = this.toElementFinisherExtras(\n            (0, decorators[i])(elementObject) || elementObject\n          );\n          element = elementFinisherExtras.element;\n          this.addElementPlacement(element, placements);\n\n          if (elementFinisherExtras.finisher) {\n            finishers.push(elementFinisherExtras.finisher);\n          }\n\n          var newExtras = elementFinisherExtras.extras;\n\n          if (newExtras) {\n            for (var j = 0; j < newExtras.length; j++) {\n              this.addElementPlacement(newExtras[j], placements);\n            }\n\n            extras.push.apply(extras, newExtras);\n          }\n        }\n\n        return {\n          element: element,\n          finishers: finishers,\n          extras: extras\n        };\n      },\n      decorateConstructor: function(elements, decorators) {\n        var finishers = [];\n\n        for (var i = decorators.length - 1; i >= 0; i--) {\n          var obj = this.fromClassDescriptor(elements);\n          var elementsAndFinisher = this.toClassDescriptor(\n            (0, decorators[i])(obj) || obj\n          );\n\n          if (elementsAndFinisher.finisher !== undefined) {\n            finishers.push(elementsAndFinisher.finisher);\n          }\n\n          if (elementsAndFinisher.elements !== undefined) {\n            elements = elementsAndFinisher.elements;\n\n            for (var j = 0; j < elements.length - 1; j++) {\n              for (var k = j + 1; k < elements.length; k++) {\n                if (\n                  elements[j].key === elements[k].key &&\n                  elements[j].placement === elements[k].placement\n                ) {\n                  throw new TypeError(\n                    'Duplicated element (' + elements[j].key + ')'\n                  );\n                }\n              }\n            }\n          }\n        }\n\n        return {\n          elements: elements,\n          finishers: finishers\n        };\n      },\n      fromElementDescriptor: function(element) {\n        var obj = {\n          kind: element.kind,\n          key: element.key,\n          placement: element.placement,\n          descriptor: element.descriptor\n        };\n        var desc = {\n          value: 'Descriptor',\n          configurable: true\n        };\n        Object.defineProperty(obj, Symbol.toStringTag, desc);\n        if (element.kind === 'field') obj.initializer = element.initializer;\n        return obj;\n      },\n      toElementDescriptors: function(elementObjects) {\n        if (elementObjects === undefined) return;\n        return _toArray(elementObjects).map(function(elementObject) {\n          var element = this.toElementDescriptor(elementObject);\n          this.disallowProperty(\n            elementObject,\n            'finisher',\n            'An element descriptor'\n          );\n          this.disallowProperty(\n            elementObject,\n            'extras',\n            'An element descriptor'\n          );\n          return element;\n        }, this);\n      },\n      toElementDescriptor: function(elementObject) {\n        var kind = String(elementObject.kind);\n\n        if (kind !== 'method' && kind !== 'field') {\n          throw new TypeError(\n            'An element descriptor\\'s .kind property must be either \"method\" or' +\n              ' \"field\", but a decorator created an element descriptor with' +\n              ' .kind \"' +\n              kind +\n              '\"'\n          );\n        }\n\n        var key = _toPropertyKey(elementObject.key);\n\n        var placement = String(elementObject.placement);\n\n        if (\n          placement !== 'static' &&\n          placement !== 'prototype' &&\n          placement !== 'own'\n        ) {\n          throw new TypeError(\n            'An element descriptor\\'s .placement property must be one of \"static\",' +\n              ' \"prototype\" or \"own\", but a decorator created an element descriptor' +\n              ' with .placement \"' +\n              placement +\n              '\"'\n          );\n        }\n\n        var descriptor = elementObject.descriptor;\n        this.disallowProperty(\n          elementObject,\n          'elements',\n          'An element descriptor'\n        );\n        var element = {\n          kind: kind,\n          key: key,\n          placement: placement,\n          descriptor: Object.assign({}, descriptor)\n        };\n\n        if (kind !== 'field') {\n          this.disallowProperty(\n            elementObject,\n            'initializer',\n            'A method descriptor'\n          );\n        } else {\n          this.disallowProperty(\n            descriptor,\n            'get',\n            'The property descriptor of a field descriptor'\n          );\n          this.disallowProperty(\n            descriptor,\n            'set',\n            'The property descriptor of a field descriptor'\n          );\n          this.disallowProperty(\n            descriptor,\n            'value',\n            'The property descriptor of a field descriptor'\n          );\n          element.initializer = elementObject.initializer;\n        }\n\n        return element;\n      },\n      toElementFinisherExtras: function(elementObject) {\n        var element = this.toElementDescriptor(elementObject);\n\n        var finisher = _optionalCallableProperty(elementObject, 'finisher');\n\n        var extras = this.toElementDescriptors(elementObject.extras);\n        return {\n          element: element,\n          finisher: finisher,\n          extras: extras\n        };\n      },\n      fromClassDescriptor: function(elements) {\n        var obj = {\n          kind: 'class',\n          elements: elements.map(this.fromElementDescriptor, this)\n        };\n        var desc = {\n          value: 'Descriptor',\n          configurable: true\n        };\n        Object.defineProperty(obj, Symbol.toStringTag, desc);\n        return obj;\n      },\n      toClassDescriptor: function(obj) {\n        var kind = String(obj.kind);\n\n        if (kind !== 'class') {\n          throw new TypeError(\n            'A class descriptor\\'s .kind property must be \"class\", but a decorator' +\n              ' created a class descriptor with .kind \"' +\n              kind +\n              '\"'\n          );\n        }\n\n        this.disallowProperty(obj, 'key', 'A class descriptor');\n        this.disallowProperty(obj, 'placement', 'A class descriptor');\n        this.disallowProperty(obj, 'descriptor', 'A class descriptor');\n        this.disallowProperty(obj, 'initializer', 'A class descriptor');\n        this.disallowProperty(obj, 'extras', 'A class descriptor');\n\n        var finisher = _optionalCallableProperty(obj, 'finisher');\n\n        var elements = this.toElementDescriptors(obj.elements);\n        return {\n          elements: elements,\n          finisher: finisher\n        };\n      },\n      runClassFinishers: function(constructor, finishers) {\n        for (var i = 0; i < finishers.length; i++) {\n          var newConstructor = (0, finishers[i])(constructor);\n\n          if (newConstructor !== undefined) {\n            if (typeof newConstructor !== 'function') {\n              throw new TypeError('Finishers must return a constructor.');\n            }\n\n            constructor = newConstructor;\n          }\n        }\n\n        return constructor;\n      },\n      disallowProperty: function(obj, name, objectType) {\n        if (obj[name] !== undefined) {\n          throw new TypeError(\n            objectType + \" can't have a .\" + name + ' property.'\n          );\n        }\n      }\n    };\n    return api;\n  }\n\n  function _createElementDescriptor(def) {\n    var key = _toPropertyKey(def.key);\n\n    var descriptor;\n\n    if (def.kind === 'method') {\n      descriptor = {\n        value: def.value,\n        writable: true,\n        configurable: true,\n        enumerable: false\n      };\n    } else if (def.kind === 'get') {\n      descriptor = {\n        get: def.value,\n        configurable: true,\n        enumerable: false\n      };\n    } else if (def.kind === 'set') {\n      descriptor = {\n        set: def.value,\n        configurable: true,\n        enumerable: false\n      };\n    } else if (def.kind === 'field') {\n      descriptor = {\n        configurable: true,\n        writable: true,\n        enumerable: true\n      };\n    }\n\n    var element = {\n      kind: def.kind === 'field' ? 'field' : 'method',\n      key: key,\n      placement: def.static\n        ? 'static'\n        : def.kind === 'field'\n        ? 'own'\n        : 'prototype',\n      descriptor: descriptor\n    };\n    if (def.decorators) element.decorators = def.decorators;\n    if (def.kind === 'field') element.initializer = def.value;\n    return element;\n  }\n\n  function _coalesceGetterSetter(element, other) {\n    if (element.descriptor.get !== undefined) {\n      other.descriptor.get = element.descriptor.get;\n    } else {\n      other.descriptor.set = element.descriptor.set;\n    }\n  }\n\n  function _coalesceClassElements(elements) {\n    var newElements = [];\n\n    var isSameElement = function(other) {\n      return (\n        other.kind === 'method' &&\n        other.key === element.key &&\n        other.placement === element.placement\n      );\n    };\n\n    for (var i = 0; i < elements.length; i++) {\n      var element = elements[i];\n      var other;\n\n      if (\n        element.kind === 'method' &&\n        (other = newElements.find(isSameElement))\n      ) {\n        if (\n          _isDataDescriptor(element.descriptor) ||\n          _isDataDescriptor(other.descriptor)\n        ) {\n          if (_hasDecorators(element) || _hasDecorators(other)) {\n            throw new ReferenceError(\n              'Duplicated methods (' + element.key + \") can't be decorated.\"\n            );\n          }\n\n          other.descriptor = element.descriptor;\n        } else {\n          if (_hasDecorators(element)) {\n            if (_hasDecorators(other)) {\n              throw new ReferenceError(\n                \"Decorators can't be placed on different accessors with for \" +\n                  'the same property (' +\n                  element.key +\n                  ').'\n              );\n            }\n\n            other.decorators = element.decorators;\n          }\n\n          _coalesceGetterSetter(element, other);\n        }\n      } else {\n        newElements.push(element);\n      }\n    }\n\n    return newElements;\n  }\n\n  function _hasDecorators(element) {\n    return element.decorators && element.decorators.length;\n  }\n\n  function _isDataDescriptor(desc) {\n    return (\n      desc !== undefined &&\n      !(desc.value === undefined && desc.writable === undefined)\n    );\n  }\n\n  function _optionalCallableProperty(obj, name) {\n    var value = obj[name];\n\n    if (value !== undefined && typeof value !== 'function') {\n      throw new TypeError(\"Expected '\" + name + \"' to be a function\");\n    }\n\n    return value;\n  }\n\n  function _classPrivateMethodGet(receiver, privateSet, fn) {\n    if (!privateSet.has(receiver)) {\n      throw new TypeError('attempted to get private field on non-instance');\n    }\n\n    return fn;\n  }\n\n  function _classPrivateMethodSet() {\n    throw new TypeError('attempted to reassign private method');\n  }\n\n  function _wrapRegExp(re, groups) {\n    _wrapRegExp = function(re, groups) {\n      return new BabelRegExp(re, groups);\n    };\n\n    var _RegExp = _wrapNativeSuper(RegExp);\n\n    var _super = RegExp.prototype;\n\n    var _groups = new WeakMap();\n\n    function BabelRegExp(re, groups) {\n      var _this = _RegExp.call(this, re);\n\n      _groups.set(_this, groups);\n\n      return _this;\n    }\n\n    _inherits(BabelRegExp, _RegExp);\n\n    BabelRegExp.prototype.exec = function(str) {\n      var result = _super.exec.call(this, str);\n\n      if (result) result.groups = buildGroups(result, this);\n      return result;\n    };\n\n    BabelRegExp.prototype[Symbol.replace] = function(str, substitution) {\n      if (typeof substitution === 'string') {\n        var groups = _groups.get(this);\n\n        return _super[Symbol.replace].call(\n          this,\n          str,\n          substitution.replace(/\\$<([^>]+)>/g, function(_, name) {\n            return '$' + groups[name];\n          })\n        );\n      } else if (typeof substitution === 'function') {\n        var _this = this;\n\n        return _super[Symbol.replace].call(this, str, function() {\n          var args = [];\n          args.push.apply(args, arguments);\n\n          if (typeof args[args.length - 1] !== 'object') {\n            args.push(buildGroups(args, _this));\n          }\n\n          return substitution.apply(this, args);\n        });\n      } else {\n        return _super[Symbol.replace].call(this, str, substitution);\n      }\n    };\n\n    function buildGroups(result, re) {\n      var g = _groups.get(re);\n\n      return Object.keys(g).reduce(function(groups, name) {\n        groups[name] = result[g[name]];\n        return groups;\n      }, Object.create(null));\n    }\n\n    return _wrapRegExp.apply(this, arguments);\n  }\n\n  var arrayRemove = function arrayRemove(arr, index) {\n    return arr.splice(index, 1);\n  };\n\n  var run = function run(cb, sync) {\n    if (sync) {\n      cb();\n    } else if (document.hidden) {\n      Promise.resolve(1).then(cb);\n    } else {\n      setTimeout(cb, 0);\n    }\n  };\n\n  var on = function on() {\n    var listeners = [];\n    var off = function off(event, cb) {\n      arrayRemove(\n        listeners,\n        listeners.findIndex(function(listener) {\n          return listener.event === event && (listener.cb === cb || !cb);\n        })\n      );\n    };\n    var _fire = function fire(event, args, sync) {\n      listeners\n        .filter(function(listener) {\n          return listener.event === event;\n        })\n        .map(function(listener) {\n          return listener.cb;\n        })\n        .forEach(function(cb) {\n          return run(function() {\n            return cb.apply(void 0, _toConsumableArray(args));\n          }, sync);\n        });\n    };\n    return {\n      fireSync: function fireSync(event) {\n        for (\n          var _len = arguments.length,\n            args = new Array(_len > 1 ? _len - 1 : 0),\n            _key = 1;\n          _key < _len;\n          _key++\n        ) {\n          args[_key - 1] = arguments[_key];\n        }\n        _fire(event, args, true);\n      },\n      fire: function fire(event) {\n        for (\n          var _len2 = arguments.length,\n            args = new Array(_len2 > 1 ? _len2 - 1 : 0),\n            _key2 = 1;\n          _key2 < _len2;\n          _key2++\n        ) {\n          args[_key2 - 1] = arguments[_key2];\n        }\n        _fire(event, args, false);\n      },\n      on: function on(event, cb) {\n        listeners.push({ event: event, cb: cb });\n      },\n      onOnce: function onOnce(event, _cb) {\n        listeners.push({\n          event: event,\n          cb: function cb() {\n            off(event, _cb);\n            _cb.apply(void 0, arguments);\n          }\n        });\n      },\n      off: off\n    };\n  };\n\n  var copyObjectPropertiesToObject = function copyObjectPropertiesToObject(\n    src,\n    target,\n    excluded\n  ) {\n    Object.getOwnPropertyNames(src)\n      .filter(function(property) {\n        return !excluded.includes(property);\n      })\n      .forEach(function(key) {\n        return Object.defineProperty(\n          target,\n          key,\n          Object.getOwnPropertyDescriptor(src, key)\n        );\n      });\n  };\n\n  var PRIVATE = [\n    'fire',\n    'process',\n    'revert',\n    'load',\n    'on',\n    'off',\n    'onOnce',\n    'retryLoad',\n    'extend',\n    'archive',\n    'archived',\n    'release',\n    'released',\n    'requestProcessing',\n    'freeze'\n  ];\n\n  var createItemAPI = function createItemAPI(item) {\n    var api = {};\n    copyObjectPropertiesToObject(item, api, PRIVATE);\n    return api;\n  };\n\n  var removeReleasedItems = function removeReleasedItems(items) {\n    items.forEach(function(item, index) {\n      if (item.released) {\n        arrayRemove(items, index);\n      }\n    });\n  };\n\n  var ItemStatus = {\n    INIT: 1,\n    IDLE: 2,\n    PROCESSING_QUEUED: 9,\n    PROCESSING: 3,\n    PROCESSING_COMPLETE: 5,\n    PROCESSING_ERROR: 6,\n    PROCESSING_REVERT_ERROR: 10,\n    LOADING: 7,\n    LOAD_ERROR: 8\n  };\n\n  var FileOrigin = {\n    INPUT: 1,\n    LIMBO: 2,\n    LOCAL: 3\n  };\n\n  var getNonNumeric = function getNonNumeric(str) {\n    return /[^0-9]+/.exec(str);\n  };\n\n  var getDecimalSeparator = function getDecimalSeparator() {\n    return getNonNumeric((1.1).toLocaleString())[0];\n  };\n\n  var getThousandsSeparator = function getThousandsSeparator() {\n    // Added for browsers that do not return the thousands separator (happend on native browser Android 4.4.4)\n    // We check against the normal toString output and if they're the same return a comma when decimal separator is a dot\n    var decimalSeparator = getDecimalSeparator();\n    var thousandsStringWithSeparator = (1000.0).toLocaleString();\n    var thousandsStringWithoutSeparator = (1000.0).toString();\n    if (thousandsStringWithSeparator !== thousandsStringWithoutSeparator) {\n      return getNonNumeric(thousandsStringWithSeparator)[0];\n    }\n    return decimalSeparator === '.' ? ',' : '.';\n  };\n\n  var Type = {\n    BOOLEAN: 'boolean',\n    INT: 'int',\n    NUMBER: 'number',\n    STRING: 'string',\n    ARRAY: 'array',\n    OBJECT: 'object',\n    FUNCTION: 'function',\n    ACTION: 'action',\n    SERVER_API: 'serverapi',\n    REGEX: 'regex'\n  };\n\n  // all registered filters\n  var filters = [];\n\n  // loops over matching filters and passes options to each filter, returning the mapped results\n  var applyFilterChain = function applyFilterChain(key, value, utils) {\n    return new Promise(function(resolve, reject) {\n      // find matching filters for this key\n      var matchingFilters = filters\n        .filter(function(f) {\n          return f.key === key;\n        })\n        .map(function(f) {\n          return f.cb;\n        });\n\n      // resolve now\n      if (matchingFilters.length === 0) {\n        resolve(value);\n        return;\n      }\n\n      // first filter to kick things of\n      var initialFilter = matchingFilters.shift();\n\n      // chain filters\n      matchingFilters\n        .reduce(\n          // loop over promises passing value to next promise\n          function(current, next) {\n            return current.then(function(value) {\n              return next(value, utils);\n            });\n          },\n\n          // call initial filter, will return a promise\n          initialFilter(value, utils)\n\n          // all executed\n        )\n        .then(function(value) {\n          return resolve(value);\n        })\n        .catch(function(error) {\n          return reject(error);\n        });\n    });\n  };\n\n  var applyFilters = function applyFilters(key, value, utils) {\n    return filters\n      .filter(function(f) {\n        return f.key === key;\n      })\n      .map(function(f) {\n        return f.cb(value, utils);\n      });\n  };\n\n  // adds a new filter to the list\n  var addFilter = function addFilter(key, cb) {\n    return filters.push({ key: key, cb: cb });\n  };\n\n  var extendDefaultOptions = function extendDefaultOptions(additionalOptions) {\n    return Object.assign(defaultOptions, additionalOptions);\n  };\n\n  var getOptions = function getOptions() {\n    return Object.assign({}, defaultOptions);\n  };\n\n  var setOptions = function setOptions(opts) {\n    forin(opts, function(key, value) {\n      // key does not exist, so this option cannot be set\n      if (!defaultOptions[key]) {\n        return;\n      }\n      defaultOptions[key][0] = getValueByType(\n        value,\n        defaultOptions[key][0],\n        defaultOptions[key][1]\n      );\n    });\n  };\n\n  // default options on app\n  var defaultOptions = {\n    // the id to add to the root element\n    id: [null, Type.STRING],\n\n    // input field name to use\n    name: ['filepond', Type.STRING],\n\n    // disable the field\n    disabled: [false, Type.BOOLEAN],\n\n    // classname to put on wrapper\n    className: [null, Type.STRING],\n\n    // is the field required\n    required: [false, Type.BOOLEAN],\n\n    // Allow media capture when value is set\n    captureMethod: [null, Type.STRING],\n    // - \"camera\", \"microphone\" or \"camcorder\",\n    // - Does not work with multiple on apple devices\n    // - If set, acceptedFileTypes must be made to match with media wildcard \"image/*\", \"audio/*\" or \"video/*\"\n\n    // sync `acceptedFileTypes` property with `accept` attribute\n    allowSyncAcceptAttribute: [true, Type.BOOLEAN],\n\n    // Feature toggles\n    allowDrop: [true, Type.BOOLEAN], // Allow dropping of files\n    allowBrowse: [true, Type.BOOLEAN], // Allow browsing the file system\n    allowPaste: [true, Type.BOOLEAN], // Allow pasting files\n    allowMultiple: [false, Type.BOOLEAN], // Allow multiple files (disabled by default, as multiple attribute is also required on input to allow multiple)\n    allowReplace: [true, Type.BOOLEAN], // Allow dropping a file on other file to replace it (only works when multiple is set to false)\n    allowRevert: [true, Type.BOOLEAN], // Allows user to revert file upload\n    allowRemove: [true, Type.BOOLEAN], // Allow user to remove a file\n    allowProcess: [true, Type.BOOLEAN], // Allows user to process a file, when set to false, this removes the file upload button\n    allowReorder: [false, Type.BOOLEAN], // Allow reordering of files\n    allowDirectoriesOnly: [false, Type.BOOLEAN], // Allow only selecting directories with browse (no support for filtering dnd at this point)\n\n    // Revert mode\n    forceRevert: [false, Type.BOOLEAN], // Set to 'force' to require the file to be reverted before removal\n\n    // Input requirements\n    maxFiles: [null, Type.INT], // Max number of files\n    checkValidity: [false, Type.BOOLEAN], // Enables custom validity messages\n\n    // Where to put file\n    itemInsertLocationFreedom: [true, Type.BOOLEAN], // Set to false to always add items to begin or end of list\n    itemInsertLocation: ['before', Type.STRING], // Default index in list to add items that have been dropped at the top of the list\n    itemInsertInterval: [75, Type.INT],\n\n    // Drag 'n Drop related\n    dropOnPage: [false, Type.BOOLEAN], // Allow dropping of files anywhere on page (prevents browser from opening file if dropped outside of Up)\n    dropOnElement: [true, Type.BOOLEAN], // Drop needs to happen on element (set to false to also load drops outside of Up)\n    dropValidation: [false, Type.BOOLEAN], // Enable or disable validating files on drop\n    ignoredFiles: [['.ds_store', 'thumbs.db', 'desktop.ini'], Type.ARRAY],\n\n    // Upload related\n    instantUpload: [true, Type.BOOLEAN], // Should upload files immediately on drop\n    maxParallelUploads: [2, Type.INT], // Maximum files to upload in parallel\n\n    // Chunks\n    chunkUploads: [false, Type.BOOLEAN], // Enable chunked uploads\n    chunkForce: [false, Type.BOOLEAN], // Force use of chunk uploads even for files smaller than chunk size\n    chunkSize: [5000000, Type.INT], // Size of chunks (5MB default)\n    chunkRetryDelays: [[500, 1000, 3000], Type.Array], // Amount of times to retry upload of a chunk when it fails\n\n    // The server api end points to use for uploading (see docs)\n    server: [null, Type.SERVER_API],\n\n    // File size calculations, can set to 1024, this is only used for display, properties use file size base 1000\n    fileSizeBase: [1000, Type.INT],\n\n    // Labels and status messages\n    labelDecimalSeparator: [getDecimalSeparator(), Type.STRING], // Default is locale separator\n    labelThousandsSeparator: [getThousandsSeparator(), Type.STRING], // Default is locale separator\n\n    labelIdle: [\n      'Drag & Drop your files or <span class=\"filepond--label-action\">Browse</span>',\n      Type.STRING\n    ],\n    labelInvalidField: ['Field contains invalid files', Type.STRING],\n    labelFileWaitingForSize: ['Waiting for size', Type.STRING],\n    labelFileSizeNotAvailable: ['Size not available', Type.STRING],\n    labelFileCountSingular: ['file in list', Type.STRING],\n    labelFileCountPlural: ['files in list', Type.STRING],\n    labelFileLoading: ['Loading', Type.STRING],\n    labelFileAdded: ['Added', Type.STRING], // assistive only\n    labelFileLoadError: ['Error during load', Type.STRING],\n    labelFileRemoved: ['Removed', Type.STRING], // assistive only\n    labelFileRemoveError: ['Error during remove', Type.STRING],\n    labelFileProcessing: ['Uploading', Type.STRING],\n    labelFileProcessingComplete: ['Upload complete', Type.STRING],\n    labelFileProcessingAborted: ['Upload cancelled', Type.STRING],\n    labelFileProcessingError: ['Error during upload', Type.STRING],\n    labelFileProcessingRevertError: ['Error during revert', Type.STRING],\n\n    labelTapToCancel: ['tap to cancel', Type.STRING],\n    labelTapToRetry: ['tap to retry', Type.STRING],\n    labelTapToUndo: ['tap to undo', Type.STRING],\n\n    labelButtonRemoveItem: ['Remove', Type.STRING],\n    labelButtonAbortItemLoad: ['Abort', Type.STRING],\n    labelButtonRetryItemLoad: ['Retry', Type.STRING],\n    labelButtonAbortItemProcessing: ['Cancel', Type.STRING],\n    labelButtonUndoItemProcessing: ['Undo', Type.STRING],\n    labelButtonRetryItemProcessing: ['Retry', Type.STRING],\n    labelButtonProcessItem: ['Upload', Type.STRING],\n\n    // make sure width and height plus viewpox are even numbers so icons are nicely centered\n    iconRemove: [\n      '<svg width=\"26\" height=\"26\" viewBox=\"0 0 26 26\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M11.586 13l-2.293 2.293a1 1 0 0 0 1.414 1.414L13 14.414l2.293 2.293a1 1 0 0 0 1.414-1.414L14.414 13l2.293-2.293a1 1 0 0 0-1.414-1.414L13 11.586l-2.293-2.293a1 1 0 0 0-1.414 1.414L11.586 13z\" fill=\"currentColor\" fill-rule=\"nonzero\"/></svg>',\n      Type.STRING\n    ],\n\n    iconProcess: [\n      '<svg width=\"26\" height=\"26\" viewBox=\"0 0 26 26\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M14 10.414v3.585a1 1 0 0 1-2 0v-3.585l-1.293 1.293a1 1 0 0 1-1.414-1.415l3-3a1 1 0 0 1 1.414 0l3 3a1 1 0 0 1-1.414 1.415L14 10.414zM9 18a1 1 0 0 1 0-2h8a1 1 0 0 1 0 2H9z\" fill=\"currentColor\" fill-rule=\"evenodd\"/></svg>',\n      Type.STRING\n    ],\n\n    iconRetry: [\n      '<svg width=\"26\" height=\"26\" viewBox=\"0 0 26 26\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M10.81 9.185l-.038.02A4.997 4.997 0 0 0 8 13.683a5 5 0 0 0 5 5 5 5 0 0 0 5-5 1 1 0 0 1 2 0A7 7 0 1 1 9.722 7.496l-.842-.21a.999.999 0 1 1 .484-1.94l3.23.806c.535.133.86.675.73 1.21l-.804 3.233a.997.997 0 0 1-1.21.73.997.997 0 0 1-.73-1.21l.23-.928v-.002z\" fill=\"currentColor\" fill-rule=\"nonzero\"/></svg>',\n      Type.STRING\n    ],\n\n    iconUndo: [\n      '<svg width=\"26\" height=\"26\" viewBox=\"0 0 26 26\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M9.185 10.81l.02-.038A4.997 4.997 0 0 1 13.683 8a5 5 0 0 1 5 5 5 5 0 0 1-5 5 1 1 0 0 0 0 2A7 7 0 1 0 7.496 9.722l-.21-.842a.999.999 0 1 0-1.94.484l.806 3.23c.133.535.675.86 1.21.73l3.233-.803a.997.997 0 0 0 .73-1.21.997.997 0 0 0-1.21-.73l-.928.23-.002-.001z\" fill=\"currentColor\" fill-rule=\"nonzero\"/></svg>',\n      Type.STRING\n    ],\n\n    iconDone: [\n      '<svg width=\"26\" height=\"26\" viewBox=\"0 0 26 26\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M18.293 9.293a1 1 0 0 1 1.414 1.414l-7.002 7a1 1 0 0 1-1.414 0l-3.998-4a1 1 0 1 1 1.414-1.414L12 15.586l6.294-6.293z\" fill=\"currentColor\" fill-rule=\"nonzero\"/></svg>',\n      Type.STRING\n    ],\n\n    // event handlers\n    oninit: [null, Type.FUNCTION],\n    onwarning: [null, Type.FUNCTION],\n    onerror: [null, Type.FUNCTION],\n    onactivatefile: [null, Type.FUNCTION],\n    oninitfile: [null, Type.FUNCTION],\n    onaddfilestart: [null, Type.FUNCTION],\n    onaddfileprogress: [null, Type.FUNCTION],\n    onaddfile: [null, Type.FUNCTION],\n    onprocessfilestart: [null, Type.FUNCTION],\n    onprocessfileprogress: [null, Type.FUNCTION],\n    onprocessfileabort: [null, Type.FUNCTION],\n    onprocessfilerevert: [null, Type.FUNCTION],\n    onprocessfile: [null, Type.FUNCTION],\n    onprocessfiles: [null, Type.FUNCTION],\n    onremovefile: [null, Type.FUNCTION],\n    onpreparefile: [null, Type.FUNCTION],\n    onupdatefiles: [null, Type.FUNCTION],\n    onreorderfiles: [null, Type.FUNCTION],\n\n    // hooks\n    beforeDropFile: [null, Type.FUNCTION],\n    beforeAddFile: [null, Type.FUNCTION],\n    beforeRemoveFile: [null, Type.FUNCTION],\n\n    // styles\n    stylePanelLayout: [null, Type.STRING], // null 'integrated', 'compact', 'circle'\n    stylePanelAspectRatio: [null, Type.STRING], // null or '3:2' or 1\n    styleItemPanelAspectRatio: [null, Type.STRING],\n    styleButtonRemoveItemPosition: ['left', Type.STRING],\n    styleButtonProcessItemPosition: ['right', Type.STRING],\n    styleLoadIndicatorPosition: ['right', Type.STRING],\n    styleProgressIndicatorPosition: ['right', Type.STRING],\n    styleButtonRemoveItemAlign: [false, Type.BOOLEAN],\n\n    // custom initial files array\n    files: [[], Type.ARRAY],\n\n    // show support by displaying credits\n    credits: [['https://pqina.nl/', 'Powered by PQINA'], Type.ARRAY]\n  };\n\n  var getItemByQuery = function getItemByQuery(items, query) {\n    // just return first index\n    if (isEmpty(query)) {\n      return items[0] || null;\n    }\n\n    // query is index\n    if (isInt(query)) {\n      return items[query] || null;\n    }\n\n    // if query is item, get the id\n    if (typeof query === 'object') {\n      query = query.id;\n    }\n\n    // assume query is a string and return item by id\n    return (\n      items.find(function(item) {\n        return item.id === query;\n      }) || null\n    );\n  };\n\n  var getNumericAspectRatioFromString = function getNumericAspectRatioFromString(\n    aspectRatio\n  ) {\n    if (isEmpty(aspectRatio)) {\n      return aspectRatio;\n    }\n    if (/:/.test(aspectRatio)) {\n      var parts = aspectRatio.split(':');\n      return parts[1] / parts[0];\n    }\n    return parseFloat(aspectRatio);\n  };\n\n  var getActiveItems = function getActiveItems(items) {\n    return items.filter(function(item) {\n      return !item.archived;\n    });\n  };\n\n  var Status = {\n    EMPTY: 0,\n    IDLE: 1, // waiting\n    ERROR: 2, // a file is in error state\n    BUSY: 3, // busy processing or loading\n    READY: 4 // all files uploaded\n  };\n\n  var ITEM_ERROR = [\n    ItemStatus.LOAD_ERROR,\n    ItemStatus.PROCESSING_ERROR,\n    ItemStatus.PROCESSING_REVERT_ERROR\n  ];\n  var ITEM_BUSY = [\n    ItemStatus.LOADING,\n    ItemStatus.PROCESSING,\n    ItemStatus.PROCESSING_QUEUED,\n    ItemStatus.INIT\n  ];\n  var ITEM_READY = [ItemStatus.PROCESSING_COMPLETE];\n\n  var isItemInErrorState = function isItemInErrorState(item) {\n    return ITEM_ERROR.includes(item.status);\n  };\n  var isItemInBusyState = function isItemInBusyState(item) {\n    return ITEM_BUSY.includes(item.status);\n  };\n  var isItemInReadyState = function isItemInReadyState(item) {\n    return ITEM_READY.includes(item.status);\n  };\n\n  var queries = function queries(state) {\n    return {\n      GET_STATUS: function GET_STATUS() {\n        var items = getActiveItems(state.items);\n        var EMPTY = Status.EMPTY,\n          ERROR = Status.ERROR,\n          BUSY = Status.BUSY,\n          IDLE = Status.IDLE,\n          READY = Status.READY;\n\n        if (items.length === 0) return EMPTY;\n\n        if (items.some(isItemInErrorState)) return ERROR;\n\n        if (items.some(isItemInBusyState)) return BUSY;\n\n        if (items.some(isItemInReadyState)) return READY;\n\n        return IDLE;\n      },\n\n      GET_ITEM: function GET_ITEM(query) {\n        return getItemByQuery(state.items, query);\n      },\n\n      GET_ACTIVE_ITEM: function GET_ACTIVE_ITEM(query) {\n        return getItemByQuery(getActiveItems(state.items), query);\n      },\n\n      GET_ACTIVE_ITEMS: function GET_ACTIVE_ITEMS() {\n        return getActiveItems(state.items);\n      },\n\n      GET_ITEMS: function GET_ITEMS() {\n        return state.items;\n      },\n\n      GET_ITEM_NAME: function GET_ITEM_NAME(query) {\n        var item = getItemByQuery(state.items, query);\n        return item ? item.filename : null;\n      },\n\n      GET_ITEM_SIZE: function GET_ITEM_SIZE(query) {\n        var item = getItemByQuery(state.items, query);\n        return item ? item.fileSize : null;\n      },\n\n      GET_STYLES: function GET_STYLES() {\n        return Object.keys(state.options)\n          .filter(function(key) {\n            return /^style/.test(key);\n          })\n          .map(function(option) {\n            return {\n              name: option,\n              value: state.options[option]\n            };\n          });\n      },\n\n      GET_PANEL_ASPECT_RATIO: function GET_PANEL_ASPECT_RATIO() {\n        var isShapeCircle = /circle/.test(state.options.stylePanelLayout);\n        var aspectRatio = isShapeCircle\n          ? 1\n          : getNumericAspectRatioFromString(\n              state.options.stylePanelAspectRatio\n            );\n        return aspectRatio;\n      },\n\n      GET_ITEM_PANEL_ASPECT_RATIO: function GET_ITEM_PANEL_ASPECT_RATIO() {\n        return state.options.styleItemPanelAspectRatio;\n      },\n\n      GET_ITEMS_BY_STATUS: function GET_ITEMS_BY_STATUS(status) {\n        return getActiveItems(state.items).filter(function(item) {\n          return item.status === status;\n        });\n      },\n\n      GET_TOTAL_ITEMS: function GET_TOTAL_ITEMS() {\n        return getActiveItems(state.items).length;\n      },\n\n      IS_ASYNC: function IS_ASYNC() {\n        return (\n          isObject(state.options.server) &&\n          (isObject(state.options.server.process) ||\n            isFunction(state.options.server.process))\n        );\n      }\n    };\n  };\n\n  var hasRoomForItem = function hasRoomForItem(state) {\n    var count = getActiveItems(state.items).length;\n\n    // if cannot have multiple items, to add one item it should currently not contain items\n    if (!state.options.allowMultiple) {\n      return count === 0;\n    }\n\n    // if allows multiple items, we check if a max item count has been set, if not, there's no limit\n    var maxFileCount = state.options.maxFiles;\n    if (maxFileCount === null) {\n      return true;\n    }\n\n    // we check if the current count is smaller than the max count, if so, another file can still be added\n    if (count < maxFileCount) {\n      return true;\n    }\n\n    // no more room for another file\n    return false;\n  };\n\n  var limit = function limit(value, min, max) {\n    return Math.max(Math.min(max, value), min);\n  };\n\n  var arrayInsert = function arrayInsert(arr, index, item) {\n    return arr.splice(index, 0, item);\n  };\n\n  var insertItem = function insertItem(items, item, index) {\n    if (isEmpty(item)) {\n      return null;\n    }\n\n    // if index is undefined, append\n    if (typeof index === 'undefined') {\n      items.push(item);\n      return item;\n    }\n\n    // limit the index to the size of the items array\n    index = limit(index, 0, items.length);\n\n    // add item to array\n    arrayInsert(items, index, item);\n\n    // expose\n    return item;\n  };\n\n  var isBase64DataURI = function isBase64DataURI(str) {\n    return /^\\s*data:([a-z]+\\/[a-z0-9-+.]+(;[a-z-]+=[a-z0-9-]+)?)?(;base64)?,([a-z0-9!$&',()*+;=\\-._~:@\\/?%\\s]*)\\s*$/i.test(\n      str\n    );\n  };\n\n  var getFilenameFromURL = function getFilenameFromURL(url) {\n    return url\n      .split('/')\n      .pop()\n      .split('?')\n      .shift();\n  };\n\n  var getExtensionFromFilename = function getExtensionFromFilename(name) {\n    return name.split('.').pop();\n  };\n\n  var guesstimateExtension = function guesstimateExtension(type) {\n    // if no extension supplied, exit here\n    if (typeof type !== 'string') {\n      return '';\n    }\n\n    // get subtype\n    var subtype = type.split('/').pop();\n\n    // is svg subtype\n    if (/svg/.test(subtype)) {\n      return 'svg';\n    }\n\n    if (/zip|compressed/.test(subtype)) {\n      return 'zip';\n    }\n\n    if (/plain/.test(subtype)) {\n      return 'txt';\n    }\n\n    if (/msword/.test(subtype)) {\n      return 'doc';\n    }\n\n    // if is valid subtype\n    if (/[a-z]+/.test(subtype)) {\n      // always use jpg extension\n      if (subtype === 'jpeg') {\n        return 'jpg';\n      }\n\n      // return subtype\n      return subtype;\n    }\n\n    return '';\n  };\n\n  var leftPad = function leftPad(value) {\n    var padding =\n      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n    return (padding + value).slice(-padding.length);\n  };\n\n  var getDateString = function getDateString() {\n    var date =\n      arguments.length > 0 && arguments[0] !== undefined\n        ? arguments[0]\n        : new Date();\n    return (\n      date.getFullYear() +\n      '-' +\n      leftPad(date.getMonth() + 1, '00') +\n      '-' +\n      leftPad(date.getDate(), '00') +\n      '_' +\n      leftPad(date.getHours(), '00') +\n      '-' +\n      leftPad(date.getMinutes(), '00') +\n      '-' +\n      leftPad(date.getSeconds(), '00')\n    );\n  };\n\n  var getFileFromBlob = function getFileFromBlob(blob, filename) {\n    var type =\n      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    var extension =\n      arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    var file =\n      typeof type === 'string'\n        ? blob.slice(0, blob.size, type)\n        : blob.slice(0, blob.size, blob.type);\n    file.lastModifiedDate = new Date();\n\n    // copy relative path\n    if (blob._relativePath) file._relativePath = blob._relativePath;\n\n    // if blob has name property, use as filename if no filename supplied\n    if (!isString(filename)) {\n      filename = getDateString();\n    }\n\n    // if filename supplied but no extension and filename has extension\n    if (filename && extension === null && getExtensionFromFilename(filename)) {\n      file.name = filename;\n    } else {\n      extension = extension || guesstimateExtension(file.type);\n      file.name = filename + (extension ? '.' + extension : '');\n    }\n\n    return file;\n  };\n\n  var getBlobBuilder = function getBlobBuilder() {\n    return (window.BlobBuilder =\n      window.BlobBuilder ||\n      window.WebKitBlobBuilder ||\n      window.MozBlobBuilder ||\n      window.MSBlobBuilder);\n  };\n\n  var createBlob = function createBlob(arrayBuffer, mimeType) {\n    var BB = getBlobBuilder();\n\n    if (BB) {\n      var bb = new BB();\n      bb.append(arrayBuffer);\n      return bb.getBlob(mimeType);\n    }\n\n    return new Blob([arrayBuffer], {\n      type: mimeType\n    });\n  };\n\n  var getBlobFromByteStringWithMimeType = function getBlobFromByteStringWithMimeType(\n    byteString,\n    mimeType\n  ) {\n    var ab = new ArrayBuffer(byteString.length);\n    var ia = new Uint8Array(ab);\n\n    for (var i = 0; i < byteString.length; i++) {\n      ia[i] = byteString.charCodeAt(i);\n    }\n\n    return createBlob(ab, mimeType);\n  };\n\n  var getMimeTypeFromBase64DataURI = function getMimeTypeFromBase64DataURI(\n    dataURI\n  ) {\n    return (/^data:(.+);/.exec(dataURI) || [])[1] || null;\n  };\n\n  var getBase64DataFromBase64DataURI = function getBase64DataFromBase64DataURI(\n    dataURI\n  ) {\n    // get data part of string (remove data:image/jpeg...,)\n    var data = dataURI.split(',')[1];\n\n    // remove any whitespace as that causes InvalidCharacterError in IE\n    return data.replace(/\\s/g, '');\n  };\n\n  var getByteStringFromBase64DataURI = function getByteStringFromBase64DataURI(\n    dataURI\n  ) {\n    return atob(getBase64DataFromBase64DataURI(dataURI));\n  };\n\n  var getBlobFromBase64DataURI = function getBlobFromBase64DataURI(dataURI) {\n    var mimeType = getMimeTypeFromBase64DataURI(dataURI);\n    var byteString = getByteStringFromBase64DataURI(dataURI);\n\n    return getBlobFromByteStringWithMimeType(byteString, mimeType);\n  };\n\n  var getFileFromBase64DataURI = function getFileFromBase64DataURI(\n    dataURI,\n    filename,\n    extension\n  ) {\n    return getFileFromBlob(\n      getBlobFromBase64DataURI(dataURI),\n      filename,\n      null,\n      extension\n    );\n  };\n\n  var getFileNameFromHeader = function getFileNameFromHeader(header) {\n    // test if is content disposition header, if not exit\n    if (!/^content-disposition:/i.test(header)) return null;\n\n    // get filename parts\n    var matches = header\n      .split(/filename=|filename\\*=.+''/)\n      .splice(1)\n      .map(function(name) {\n        return name.trim().replace(/^[\"']|[;\"']{0,2}$/g, '');\n      })\n      .filter(function(name) {\n        return name.length;\n      });\n\n    return matches.length ? decodeURI(matches[matches.length - 1]) : null;\n  };\n\n  var getFileSizeFromHeader = function getFileSizeFromHeader(header) {\n    if (/content-length:/i.test(header)) {\n      var size = header.match(/[0-9]+/)[0];\n      return size ? parseInt(size, 10) : null;\n    }\n    return null;\n  };\n\n  var getTranfserIdFromHeader = function getTranfserIdFromHeader(header) {\n    if (/x-content-transfer-id:/i.test(header)) {\n      var id = (header.split(':')[1] || '').trim();\n      return id || null;\n    }\n    return null;\n  };\n\n  var getFileInfoFromHeaders = function getFileInfoFromHeaders(headers) {\n    var info = {\n      source: null,\n      name: null,\n      size: null\n    };\n\n    var rows = headers.split('\\n');\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n    try {\n      for (\n        var _iterator = rows[Symbol.iterator](), _step;\n        !(_iteratorNormalCompletion = (_step = _iterator.next()).done);\n        _iteratorNormalCompletion = true\n      ) {\n        var header = _step.value;\n\n        var name = getFileNameFromHeader(header);\n        if (name) {\n          info.name = name;\n          continue;\n        }\n\n        var size = getFileSizeFromHeader(header);\n        if (size) {\n          info.size = size;\n          continue;\n        }\n\n        var source = getTranfserIdFromHeader(header);\n        if (source) {\n          info.source = source;\n          continue;\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return info;\n  };\n\n  var createFileLoader = function createFileLoader(fetchFn) {\n    var state = {\n      source: null,\n      complete: false,\n      progress: 0,\n      size: null,\n      timestamp: null,\n      duration: 0,\n      request: null\n    };\n\n    var getProgress = function getProgress() {\n      return state.progress;\n    };\n    var abort = function abort() {\n      if (state.request && state.request.abort) {\n        state.request.abort();\n      }\n    };\n\n    // load source\n    var load = function load() {\n      // get quick reference\n      var source = state.source;\n\n      api.fire('init', source);\n\n      // Load Files\n      if (source instanceof File) {\n        api.fire('load', source);\n      } else if (source instanceof Blob) {\n        // Load blobs, set default name to current date\n        api.fire('load', getFileFromBlob(source, source.name));\n      } else if (isBase64DataURI(source)) {\n        // Load base 64, set default name to current date\n        api.fire('load', getFileFromBase64DataURI(source));\n      } else {\n        // Deal as if is external URL, let's load it!\n        loadURL(source);\n      }\n    };\n\n    // loads a url\n    var loadURL = function loadURL(url) {\n      // is remote url and no fetch method supplied\n      if (!fetchFn) {\n        api.fire('error', {\n          type: 'error',\n          body: \"Can't load URL\",\n          code: 400\n        });\n\n        return;\n      }\n\n      // set request start\n      state.timestamp = Date.now();\n\n      // load file\n      state.request = fetchFn(\n        url,\n        function(response) {\n          // update duration\n          state.duration = Date.now() - state.timestamp;\n\n          // done!\n          state.complete = true;\n\n          // turn blob response into a file\n          if (response instanceof Blob) {\n            response = getFileFromBlob(\n              response,\n              response.name || getFilenameFromURL(url)\n            );\n          }\n\n          api.fire(\n            'load',\n            // if has received blob, we go with blob, if no response, we return null\n            response instanceof Blob\n              ? response\n              : response\n              ? response.body\n              : null\n          );\n        },\n        function(error) {\n          api.fire(\n            'error',\n            typeof error === 'string'\n              ? {\n                  type: 'error',\n                  code: 0,\n                  body: error\n                }\n              : error\n          );\n        },\n        function(computable, current, total) {\n          // collected some meta data already\n          if (total) {\n            state.size = total;\n          }\n\n          // update duration\n          state.duration = Date.now() - state.timestamp;\n\n          // if we can't compute progress, we're not going to fire progress events\n          if (!computable) {\n            state.progress = null;\n            return;\n          }\n\n          // update progress percentage\n          state.progress = current / total;\n\n          // expose\n          api.fire('progress', state.progress);\n        },\n        function() {\n          api.fire('abort');\n        },\n        function(response) {\n          var fileinfo = getFileInfoFromHeaders(\n            typeof response === 'string' ? response : response.headers\n          );\n          api.fire('meta', {\n            size: state.size || fileinfo.size,\n            filename: fileinfo.name,\n            source: fileinfo.source\n          });\n        }\n      );\n    };\n\n    var api = Object.assign({}, on(), {\n      setSource: function setSource(source) {\n        return (state.source = source);\n      },\n      getProgress: getProgress, // file load progress\n      abort: abort, // abort file load\n      load: load // start load\n    });\n\n    return api;\n  };\n\n  var isGet = function isGet(method) {\n    return /GET|HEAD/.test(method);\n  };\n\n  var sendRequest = function sendRequest(data, url, options) {\n    var api = {\n      onheaders: function onheaders() {},\n      onprogress: function onprogress() {},\n      onload: function onload() {},\n      ontimeout: function ontimeout() {},\n      onerror: function onerror() {},\n      onabort: function onabort() {},\n      abort: function abort() {\n        aborted = true;\n        xhr.abort();\n      }\n    };\n\n    // timeout identifier, only used when timeout is defined\n    var aborted = false;\n    var headersReceived = false;\n\n    // set default options\n    options = Object.assign(\n      {\n        method: 'POST',\n        headers: {},\n        withCredentials: false\n      },\n      options\n    );\n\n    // encode url\n    url = encodeURI(url);\n\n    // if method is GET, add any received data to url\n\n    if (isGet(options.method) && data) {\n      url =\n        '' +\n        url +\n        encodeURIComponent(\n          typeof data === 'string' ? data : JSON.stringify(data)\n        );\n    }\n\n    // create request\n    var xhr = new XMLHttpRequest();\n\n    // progress of load\n    var process = isGet(options.method) ? xhr : xhr.upload;\n    process.onprogress = function(e) {\n      // no progress event when aborted ( onprogress is called once after abort() )\n      if (aborted) {\n        return;\n      }\n\n      api.onprogress(e.lengthComputable, e.loaded, e.total);\n    };\n\n    // tries to get header info to the app as fast as possible\n    xhr.onreadystatechange = function() {\n      // not interesting in these states ('unsent' and 'openend' as they don't give us any additional info)\n      if (xhr.readyState < 2) {\n        return;\n      }\n\n      // no server response\n      if (xhr.readyState === 4 && xhr.status === 0) {\n        return;\n      }\n\n      if (headersReceived) {\n        return;\n      }\n\n      headersReceived = true;\n\n      // we've probably received some useful data in response headers\n      api.onheaders(xhr);\n    };\n\n    // load successful\n    xhr.onload = function() {\n      // is classified as valid response\n      if (xhr.status >= 200 && xhr.status < 300) {\n        api.onload(xhr);\n      } else {\n        api.onerror(xhr);\n      }\n    };\n\n    // error during load\n    xhr.onerror = function() {\n      return api.onerror(xhr);\n    };\n\n    // request aborted\n    xhr.onabort = function() {\n      aborted = true;\n      api.onabort();\n    };\n\n    // request timeout\n    xhr.ontimeout = function() {\n      return api.ontimeout(xhr);\n    };\n\n    // open up open up!\n    xhr.open(options.method, url, true);\n\n    // set timeout if defined (do it after open so IE11 plays ball)\n    if (isInt(options.timeout)) {\n      xhr.timeout = options.timeout;\n    }\n\n    // add headers\n    Object.keys(options.headers).forEach(function(key) {\n      var value = unescape(encodeURIComponent(options.headers[key]));\n      xhr.setRequestHeader(key, value);\n    });\n\n    // set type of response\n    if (options.responseType) {\n      xhr.responseType = options.responseType;\n    }\n\n    // set credentials\n    if (options.withCredentials) {\n      xhr.withCredentials = true;\n    }\n\n    // let's send our data\n    xhr.send(data);\n\n    return api;\n  };\n\n  var createResponse = function createResponse(type, code, body, headers) {\n    return {\n      type: type,\n      code: code,\n      body: body,\n      headers: headers\n    };\n  };\n\n  var createTimeoutResponse = function createTimeoutResponse(cb) {\n    return function(xhr) {\n      cb(createResponse('error', 0, 'Timeout', xhr.getAllResponseHeaders()));\n    };\n  };\n\n  var hasQS = function hasQS(str) {\n    return /\\?/.test(str);\n  };\n  var buildURL = function buildURL() {\n    var url = '';\n    for (\n      var _len = arguments.length, parts = new Array(_len), _key = 0;\n      _key < _len;\n      _key++\n    ) {\n      parts[_key] = arguments[_key];\n    }\n    parts.forEach(function(part) {\n      url += hasQS(url) && hasQS(part) ? part.replace(/\\?/, '&') : part;\n    });\n    return url;\n  };\n\n  var createFetchFunction = function createFetchFunction() {\n    var apiUrl =\n      arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    var action = arguments.length > 1 ? arguments[1] : undefined;\n    // custom handler (should also handle file, load, error, progress and abort)\n    if (typeof action === 'function') {\n      return action;\n    }\n\n    // no action supplied\n    if (!action || !isString(action.url)) {\n      return null;\n    }\n\n    // set onload hanlder\n    var onload =\n      action.onload ||\n      function(res) {\n        return res;\n      };\n    var onerror =\n      action.onerror ||\n      function(res) {\n        return null;\n      };\n\n    // internal handler\n    return function(url, load, error, progress, abort, headers) {\n      // do local or remote request based on if the url is external\n      var request = sendRequest(\n        url,\n        buildURL(apiUrl, action.url),\n        Object.assign({}, action, {\n          responseType: 'blob'\n        })\n      );\n\n      request.onload = function(xhr) {\n        // get headers\n        var headers = xhr.getAllResponseHeaders();\n\n        // get filename\n        var filename =\n          getFileInfoFromHeaders(headers).name || getFilenameFromURL(url);\n\n        // create response\n        load(\n          createResponse(\n            'load',\n            xhr.status,\n            action.method === 'HEAD'\n              ? null\n              : getFileFromBlob(onload(xhr.response), filename),\n            headers\n          )\n        );\n      };\n\n      request.onerror = function(xhr) {\n        error(\n          createResponse(\n            'error',\n            xhr.status,\n            onerror(xhr.response) || xhr.statusText,\n            xhr.getAllResponseHeaders()\n          )\n        );\n      };\n\n      request.onheaders = function(xhr) {\n        headers(\n          createResponse(\n            'headers',\n            xhr.status,\n            null,\n            xhr.getAllResponseHeaders()\n          )\n        );\n      };\n\n      request.ontimeout = createTimeoutResponse(error);\n      request.onprogress = progress;\n      request.onabort = abort;\n\n      // should return request\n      return request;\n    };\n  };\n\n  var ChunkStatus = {\n    QUEUED: 0,\n    COMPLETE: 1,\n    PROCESSING: 2,\n    ERROR: 3,\n    WAITING: 4\n  };\n\n  /*\n                                                       function signature:\n                                                         (file, metadata, load, error, progress, abort, transfer, options) => {\n                                                           return {\n                                                           abort:() => {}\n                                                         }\n                                                       }\n                                                       */\n\n  // apiUrl, action, name, file, metadata, load, error, progress, abort, transfer, options\n  var processFileChunked = function processFileChunked(\n    apiUrl,\n    action,\n    name,\n    file,\n    metadata,\n    load,\n    error,\n    progress,\n    abort,\n    transfer,\n    options\n  ) {\n    // all chunks\n    var chunks = [];\n    var chunkTransferId = options.chunkTransferId,\n      chunkServer = options.chunkServer,\n      chunkSize = options.chunkSize,\n      chunkRetryDelays = options.chunkRetryDelays;\n\n    // default state\n    var state = {\n      serverId: chunkTransferId,\n      aborted: false\n    };\n\n    // set onload handlers\n    var ondata =\n      action.ondata ||\n      function(fd) {\n        return fd;\n      };\n    var onload =\n      action.onload ||\n      function(xhr, method) {\n        return method === 'HEAD'\n          ? xhr.getResponseHeader('Upload-Offset')\n          : xhr.response;\n      };\n    var onerror =\n      action.onerror ||\n      function(res) {\n        return null;\n      };\n\n    // create server hook\n    var requestTransferId = function requestTransferId(cb) {\n      var formData = new FormData();\n\n      // add metadata under same name\n      if (isObject(metadata)) formData.append(name, JSON.stringify(metadata));\n\n      var headers =\n        typeof action.headers === 'function'\n          ? action.headers(file, metadata)\n          : Object.assign({}, action.headers, {\n              'Upload-Length': file.size\n            });\n\n      var requestParams = Object.assign({}, action, {\n        headers: headers\n      });\n\n      // send request object\n      var request = sendRequest(\n        ondata(formData),\n        buildURL(apiUrl, action.url),\n        requestParams\n      );\n\n      request.onload = function(xhr) {\n        return cb(onload(xhr, requestParams.method));\n      };\n\n      request.onerror = function(xhr) {\n        return error(\n          createResponse(\n            'error',\n            xhr.status,\n            onerror(xhr.response) || xhr.statusText,\n            xhr.getAllResponseHeaders()\n          )\n        );\n      };\n\n      request.ontimeout = createTimeoutResponse(error);\n    };\n\n    var requestTransferOffset = function requestTransferOffset(cb) {\n      var requestUrl = buildURL(apiUrl, chunkServer.url, state.serverId);\n\n      var headers =\n        typeof action.headers === 'function'\n          ? action.headers(state.serverId)\n          : Object.assign({}, action.headers);\n\n      var requestParams = {\n        headers: headers,\n        method: 'HEAD'\n      };\n\n      var request = sendRequest(null, requestUrl, requestParams);\n\n      request.onload = function(xhr) {\n        return cb(onload(xhr, requestParams.method));\n      };\n\n      request.onerror = function(xhr) {\n        return error(\n          createResponse(\n            'error',\n            xhr.status,\n            onerror(xhr.response) || xhr.statusText,\n            xhr.getAllResponseHeaders()\n          )\n        );\n      };\n\n      request.ontimeout = createTimeoutResponse(error);\n    };\n\n    // create chunks\n    var lastChunkIndex = Math.floor(file.size / chunkSize);\n    for (var i = 0; i <= lastChunkIndex; i++) {\n      var offset = i * chunkSize;\n      var data = file.slice(\n        offset,\n        offset + chunkSize,\n        'application/offset+octet-stream'\n      );\n      chunks[i] = {\n        index: i,\n        size: data.size,\n        offset: offset,\n        data: data,\n        file: file,\n        progress: 0,\n        retries: _toConsumableArray(chunkRetryDelays),\n        status: ChunkStatus.QUEUED,\n        error: null,\n        request: null,\n        timeout: null\n      };\n    }\n\n    var completeProcessingChunks = function completeProcessingChunks() {\n      return load(state.serverId);\n    };\n\n    var canProcessChunk = function canProcessChunk(chunk) {\n      return (\n        chunk.status === ChunkStatus.QUEUED ||\n        chunk.status === ChunkStatus.ERROR\n      );\n    };\n\n    var processChunk = function processChunk(chunk) {\n      // processing is paused, wait here\n      if (state.aborted) return;\n\n      // get next chunk to process\n      chunk = chunk || chunks.find(canProcessChunk);\n\n      // no more chunks to process\n      if (!chunk) {\n        // all done?\n        if (\n          chunks.every(function(chunk) {\n            return chunk.status === ChunkStatus.COMPLETE;\n          })\n        ) {\n          completeProcessingChunks();\n        }\n\n        // no chunk to handle\n        return;\n      }\n\n      // now processing this chunk\n      chunk.status = ChunkStatus.PROCESSING;\n      chunk.progress = null;\n\n      // allow parsing of formdata\n      var ondata =\n        chunkServer.ondata ||\n        function(fd) {\n          return fd;\n        };\n      var onerror =\n        chunkServer.onerror ||\n        function(res) {\n          return null;\n        };\n\n      // send request object\n      var requestUrl = buildURL(apiUrl, chunkServer.url, state.serverId);\n\n      var headers =\n        typeof chunkServer.headers === 'function'\n          ? chunkServer.headers(chunk)\n          : Object.assign({}, chunkServer.headers, {\n              'Content-Type': 'application/offset+octet-stream',\n              'Upload-Offset': chunk.offset,\n              'Upload-Length': file.size,\n              'Upload-Name': file.name\n            });\n\n      var request = (chunk.request = sendRequest(\n        ondata(chunk.data),\n        requestUrl,\n        Object.assign({}, chunkServer, {\n          headers: headers\n        })\n      ));\n\n      request.onload = function() {\n        // done!\n        chunk.status = ChunkStatus.COMPLETE;\n\n        // remove request reference\n        chunk.request = null;\n\n        // start processing more chunks\n        processChunks();\n      };\n\n      request.onprogress = function(lengthComputable, loaded, total) {\n        chunk.progress = lengthComputable ? loaded : null;\n        updateTotalProgress();\n      };\n\n      request.onerror = function(xhr) {\n        chunk.status = ChunkStatus.ERROR;\n        chunk.request = null;\n        chunk.error = onerror(xhr.response) || xhr.statusText;\n        if (!retryProcessChunk(chunk)) {\n          error(\n            createResponse(\n              'error',\n              xhr.status,\n              onerror(xhr.response) || xhr.statusText,\n              xhr.getAllResponseHeaders()\n            )\n          );\n        }\n      };\n\n      request.ontimeout = function(xhr) {\n        chunk.status = ChunkStatus.ERROR;\n        chunk.request = null;\n        if (!retryProcessChunk(chunk)) {\n          createTimeoutResponse(error)(xhr);\n        }\n      };\n\n      request.onabort = function() {\n        chunk.status = ChunkStatus.QUEUED;\n        chunk.request = null;\n        abort();\n      };\n    };\n\n    var retryProcessChunk = function retryProcessChunk(chunk) {\n      // no more retries left\n      if (chunk.retries.length === 0) return false;\n\n      // new retry\n      chunk.status = ChunkStatus.WAITING;\n      clearTimeout(chunk.timeout);\n      chunk.timeout = setTimeout(function() {\n        processChunk(chunk);\n      }, chunk.retries.shift());\n\n      // we're going to retry\n      return true;\n    };\n\n    var updateTotalProgress = function updateTotalProgress() {\n      // calculate total progress fraction\n      var totalBytesTransfered = chunks.reduce(function(p, chunk) {\n        if (p === null || chunk.progress === null) return null;\n        return p + chunk.progress;\n      }, 0);\n\n      // can't compute progress\n      if (totalBytesTransfered === null) return progress(false, 0, 0);\n\n      // calculate progress values\n      var totalSize = chunks.reduce(function(total, chunk) {\n        return total + chunk.size;\n      }, 0);\n\n      // can update progress indicator\n      progress(true, totalBytesTransfered, totalSize);\n    };\n\n    // process new chunks\n    var processChunks = function processChunks() {\n      var totalProcessing = chunks.filter(function(chunk) {\n        return chunk.status === ChunkStatus.PROCESSING;\n      }).length;\n      if (totalProcessing >= 1) return;\n      processChunk();\n    };\n\n    var abortChunks = function abortChunks() {\n      chunks.forEach(function(chunk) {\n        clearTimeout(chunk.timeout);\n        if (chunk.request) {\n          chunk.request.abort();\n        }\n      });\n    };\n\n    // let's go!\n    if (!state.serverId) {\n      requestTransferId(function(serverId) {\n        // stop here if aborted, might have happened in between request and callback\n        if (state.aborted) return;\n\n        // pass back to item so we can use it if something goes wrong\n        transfer(serverId);\n\n        // store internally\n        state.serverId = serverId;\n        processChunks();\n      });\n    } else {\n      requestTransferOffset(function(offset) {\n        // stop here if aborted, might have happened in between request and callback\n        if (state.aborted) return;\n\n        // mark chunks with lower offset as complete\n        chunks\n          .filter(function(chunk) {\n            return chunk.offset < offset;\n          })\n          .forEach(function(chunk) {\n            chunk.status = ChunkStatus.COMPLETE;\n            chunk.progress = chunk.size;\n          });\n\n        // continue processing\n        processChunks();\n      });\n    }\n\n    return {\n      abort: function abort() {\n        state.aborted = true;\n        abortChunks();\n      }\n    };\n  };\n\n  /*\n                                                               function signature:\n                                                                 (file, metadata, load, error, progress, abort) => {\n                                                                   return {\n                                                                   abort:() => {}\n                                                                 }\n                                                               }\n                                                               */\n  var createFileProcessorFunction = function createFileProcessorFunction(\n    apiUrl,\n    action,\n    name,\n    options\n  ) {\n    return function(file, metadata, load, error, progress, abort, transfer) {\n      // no file received\n      if (!file) return;\n\n      // if was passed a file, and we can chunk it, exit here\n      var canChunkUpload = options.chunkUploads;\n      var shouldChunkUpload = canChunkUpload && file.size > options.chunkSize;\n      var willChunkUpload =\n        canChunkUpload && (shouldChunkUpload || options.chunkForce);\n      if (file instanceof Blob && willChunkUpload)\n        return processFileChunked(\n          apiUrl,\n          action,\n          name,\n          file,\n          metadata,\n          load,\n          error,\n          progress,\n          abort,\n          transfer,\n          options\n        );\n\n      // set handlers\n      var ondata =\n        action.ondata ||\n        function(fd) {\n          return fd;\n        };\n      var onload =\n        action.onload ||\n        function(res) {\n          return res;\n        };\n      var onerror =\n        action.onerror ||\n        function(res) {\n          return null;\n        };\n\n      // create formdata object\n      var formData = new FormData();\n\n      // add metadata under same name\n      if (isObject(metadata)) {\n        formData.append(name, JSON.stringify(metadata));\n      }\n\n      // Turn into an array of objects so no matter what the input, we can handle it the same way\n      (file instanceof Blob ? [{ name: null, file: file }] : file).forEach(\n        function(item) {\n          formData.append(\n            name,\n            item.file,\n            item.name === null\n              ? item.file.name\n              : '' + item.name + item.file.name\n          );\n        }\n      );\n\n      // send request object\n      var request = sendRequest(\n        ondata(formData),\n        buildURL(apiUrl, action.url),\n        action\n      );\n      request.onload = function(xhr) {\n        load(\n          createResponse(\n            'load',\n            xhr.status,\n            onload(xhr.response),\n            xhr.getAllResponseHeaders()\n          )\n        );\n      };\n\n      request.onerror = function(xhr) {\n        error(\n          createResponse(\n            'error',\n            xhr.status,\n            onerror(xhr.response) || xhr.statusText,\n            xhr.getAllResponseHeaders()\n          )\n        );\n      };\n\n      request.ontimeout = createTimeoutResponse(error);\n      request.onprogress = progress;\n      request.onabort = abort;\n\n      // should return request\n      return request;\n    };\n  };\n\n  var createProcessorFunction = function createProcessorFunction() {\n    var apiUrl =\n      arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    var action = arguments.length > 1 ? arguments[1] : undefined;\n    var name = arguments.length > 2 ? arguments[2] : undefined;\n    var options = arguments.length > 3 ? arguments[3] : undefined;\n\n    // custom handler (should also handle file, load, error, progress and abort)\n    if (typeof action === 'function')\n      return function() {\n        for (\n          var _len = arguments.length, params = new Array(_len), _key = 0;\n          _key < _len;\n          _key++\n        ) {\n          params[_key] = arguments[_key];\n        }\n        return action.apply(void 0, [name].concat(params, [options]));\n      };\n\n    // no action supplied\n    if (!action || !isString(action.url)) return null;\n\n    // internal handler\n    return createFileProcessorFunction(apiUrl, action, name, options);\n  };\n\n  /*\n                                                      function signature:\n                                                      (uniqueFileId, load, error) => { }\n                                                      */\n  var createRevertFunction = function createRevertFunction() {\n    var apiUrl =\n      arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    var action = arguments.length > 1 ? arguments[1] : undefined;\n    // is custom implementation\n    if (typeof action === 'function') {\n      return action;\n    }\n\n    // no action supplied, return stub function, interface will work, but file won't be removed\n    if (!action || !isString(action.url)) {\n      return function(uniqueFileId, load) {\n        return load();\n      };\n    }\n\n    // set onload hanlder\n    var onload =\n      action.onload ||\n      function(res) {\n        return res;\n      };\n    var onerror =\n      action.onerror ||\n      function(res) {\n        return null;\n      };\n\n    // internal implementation\n    return function(uniqueFileId, load, error) {\n      var request = sendRequest(\n        uniqueFileId,\n        apiUrl + action.url,\n        action // contains method, headers and withCredentials properties\n      );\n      request.onload = function(xhr) {\n        load(\n          createResponse(\n            'load',\n            xhr.status,\n            onload(xhr.response),\n            xhr.getAllResponseHeaders()\n          )\n        );\n      };\n\n      request.onerror = function(xhr) {\n        error(\n          createResponse(\n            'error',\n            xhr.status,\n            onerror(xhr.response) || xhr.statusText,\n            xhr.getAllResponseHeaders()\n          )\n        );\n      };\n\n      request.ontimeout = createTimeoutResponse(error);\n\n      return request;\n    };\n  };\n\n  var getRandomNumber = function getRandomNumber() {\n    var min =\n      arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var max =\n      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    return min + Math.random() * (max - min);\n  };\n\n  var createPerceivedPerformanceUpdater = function createPerceivedPerformanceUpdater(\n    cb\n  ) {\n    var duration =\n      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;\n    var offset =\n      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var tickMin =\n      arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 25;\n    var tickMax =\n      arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 250;\n    var timeout = null;\n    var start = Date.now();\n\n    var tick = function tick() {\n      var runtime = Date.now() - start;\n      var delay = getRandomNumber(tickMin, tickMax);\n\n      if (runtime + delay > duration) {\n        delay = runtime + delay - duration;\n      }\n\n      var progress = runtime / duration;\n      if (progress >= 1 || document.hidden) {\n        cb(1);\n        return;\n      }\n\n      cb(progress);\n\n      timeout = setTimeout(tick, delay);\n    };\n\n    tick();\n\n    return {\n      clear: function clear() {\n        clearTimeout(timeout);\n      }\n    };\n  };\n\n  var createFileProcessor = function createFileProcessor(processFn) {\n    var state = {\n      complete: false,\n      perceivedProgress: 0,\n      perceivedPerformanceUpdater: null,\n      progress: null,\n      timestamp: null,\n      perceivedDuration: 0,\n      duration: 0,\n      request: null,\n      response: null\n    };\n\n    var process = function process(file, metadata) {\n      var progressFn = function progressFn() {\n        // we've not yet started the real download, stop here\n        // the request might not go through, for instance, there might be some server trouble\n        // if state.progress is null, the server does not allow computing progress and we show the spinner instead\n        if (state.duration === 0 || state.progress === null) return;\n\n        // as we're now processing, fire the progress event\n        api.fire('progress', api.getProgress());\n      };\n\n      var completeFn = function completeFn() {\n        state.complete = true;\n        api.fire('load-perceived', state.response.body);\n      };\n\n      // let's start processing\n      api.fire('start');\n\n      // set request start\n      state.timestamp = Date.now();\n\n      // create perceived performance progress indicator\n      state.perceivedPerformanceUpdater = createPerceivedPerformanceUpdater(\n        function(progress) {\n          state.perceivedProgress = progress;\n          state.perceivedDuration = Date.now() - state.timestamp;\n\n          progressFn();\n\n          // if fake progress is done, and a response has been received,\n          // and we've not yet called the complete method\n          if (\n            state.response &&\n            state.perceivedProgress === 1 &&\n            !state.complete\n          ) {\n            // we done!\n            completeFn();\n          }\n        },\n        // random delay as in a list of files you start noticing\n        // files uploading at the exact same speed\n        getRandomNumber(750, 1500)\n      );\n\n      // remember request so we can abort it later\n      state.request = processFn(\n        // the file to process\n        file,\n\n        // the metadata to send along\n        metadata,\n\n        // callbacks (load, error, progress, abort, transfer)\n        // load expects the body to be a server id if\n        // you want to make use of revert\n        function(response) {\n          // we put the response in state so we can access\n          // it outside of this method\n          state.response = isObject(response)\n            ? response\n            : {\n                type: 'load',\n                code: 200,\n                body: '' + response,\n                headers: {}\n              };\n\n          // update duration\n          state.duration = Date.now() - state.timestamp;\n\n          // force progress to 1 as we're now done\n          state.progress = 1;\n\n          // actual load is done let's share results\n          api.fire('load', state.response.body);\n\n          // we are really done\n          // if perceived progress is 1 ( wait for perceived progress to complete )\n          // or if server does not support progress ( null )\n          if (state.perceivedProgress === 1) {\n            completeFn();\n          }\n        },\n\n        // error is expected to be an object with type, code, body\n        function(error) {\n          // cancel updater\n          state.perceivedPerformanceUpdater.clear();\n\n          // update others about this error\n          api.fire(\n            'error',\n            isObject(error)\n              ? error\n              : {\n                  type: 'error',\n                  code: 0,\n                  body: '' + error\n                }\n          );\n        },\n\n        // actual processing progress\n        function(computable, current, total) {\n          // update actual duration\n          state.duration = Date.now() - state.timestamp;\n\n          // update actual progress\n          state.progress = computable ? current / total : null;\n\n          progressFn();\n        },\n\n        // abort does not expect a value\n        function() {\n          // stop updater\n          state.perceivedPerformanceUpdater.clear();\n\n          // fire the abort event so we can switch visuals\n          api.fire('abort', state.response ? state.response.body : null);\n        },\n\n        // register the id for this transfer\n        function(transferId) {\n          api.fire('transfer', transferId);\n        }\n      );\n    };\n\n    var abort = function abort() {\n      // no request running, can't abort\n      if (!state.request) return;\n\n      // stop updater\n      state.perceivedPerformanceUpdater.clear();\n\n      // abort actual request\n      if (state.request.abort) state.request.abort();\n\n      // if has response object, we've completed the request\n      state.complete = true;\n    };\n\n    var reset = function reset() {\n      abort();\n      state.complete = false;\n      state.perceivedProgress = 0;\n      state.progress = 0;\n      state.timestamp = null;\n      state.perceivedDuration = 0;\n      state.duration = 0;\n      state.request = null;\n      state.response = null;\n    };\n\n    var getProgress = function getProgress() {\n      return state.progress\n        ? Math.min(state.progress, state.perceivedProgress)\n        : null;\n    };\n    var getDuration = function getDuration() {\n      return Math.min(state.duration, state.perceivedDuration);\n    };\n\n    var api = Object.assign({}, on(), {\n      process: process, // start processing file\n      abort: abort, // abort active process request\n      getProgress: getProgress,\n      getDuration: getDuration,\n      reset: reset\n    });\n\n    return api;\n  };\n\n  var getFilenameWithoutExtension = function getFilenameWithoutExtension(name) {\n    return name.substr(0, name.lastIndexOf('.')) || name;\n  };\n\n  var createFileStub = function createFileStub(source) {\n    var data = [source.name, source.size, source.type];\n\n    // is blob or base64, then we need to set the name\n    if (source instanceof Blob || isBase64DataURI(source)) {\n      data[0] = source.name || getDateString();\n    } else if (isBase64DataURI(source)) {\n      // if is base64 data uri we need to determine the average size and type\n      data[1] = source.length;\n      data[2] = getMimeTypeFromBase64DataURI(source);\n    } else if (isString(source)) {\n      // url\n      data[0] = getFilenameFromURL(source);\n      data[1] = 0;\n      data[2] = 'application/octet-stream';\n    }\n\n    return {\n      name: data[0],\n      size: data[1],\n      type: data[2]\n    };\n  };\n\n  var isFile = function isFile(value) {\n    return !!(value instanceof File || (value instanceof Blob && value.name));\n  };\n\n  var deepCloneObject = function deepCloneObject(src) {\n    if (!isObject(src)) return src;\n    var target = isArray(src) ? [] : {};\n    for (var key in src) {\n      if (!src.hasOwnProperty(key)) continue;\n      var v = src[key];\n      target[key] = v && isObject(v) ? deepCloneObject(v) : v;\n    }\n    return target;\n  };\n\n  var createItem = function createItem() {\n    var origin =\n      arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    var serverFileReference =\n      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var file =\n      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    // unique id for this item, is used to identify the item across views\n    var id = getUniqueId();\n\n    /**\n     * Internal item state\n     */\n    var state = {\n      // is archived\n      archived: false,\n\n      // if is frozen, no longer fires events\n      frozen: false,\n\n      // removed from view\n      released: false,\n\n      // original source\n      source: null,\n\n      // file model reference\n      file: file,\n\n      // id of file on server\n      serverFileReference: serverFileReference,\n\n      // id of file transfer on server\n      transferId: null,\n\n      // is aborted\n      processingAborted: false,\n\n      // current item status\n      status: serverFileReference\n        ? ItemStatus.PROCESSING_COMPLETE\n        : ItemStatus.INIT,\n\n      // active processes\n      activeLoader: null,\n      activeProcessor: null\n    };\n\n    // callback used when abort processing is called to link back to the resolve method\n    var abortProcessingRequestComplete = null;\n\n    /**\n     * Externally added item metadata\n     */\n    var metadata = {};\n\n    // item data\n    var setStatus = function setStatus(status) {\n      return (state.status = status);\n    };\n\n    // fire event unless the item has been archived\n    var fire = function fire(event) {\n      if (state.released || state.frozen) return;\n      for (\n        var _len = arguments.length,\n          params = new Array(_len > 1 ? _len - 1 : 0),\n          _key = 1;\n        _key < _len;\n        _key++\n      ) {\n        params[_key - 1] = arguments[_key];\n      }\n      api.fire.apply(api, [event].concat(params));\n    };\n\n    // file data\n    var getFileExtension = function getFileExtension() {\n      return getExtensionFromFilename(state.file.name);\n    };\n    var getFileType = function getFileType() {\n      return state.file.type;\n    };\n    var getFileSize = function getFileSize() {\n      return state.file.size;\n    };\n    var getFile = function getFile() {\n      return state.file;\n    };\n\n    //\n    // logic to load a file\n    //\n    var load = function load(source, loader, onload) {\n      // remember the original item source\n      state.source = source;\n\n      // source is known\n      api.fireSync('init');\n\n      // file stub is already there\n      if (state.file) {\n        api.fireSync('load-skip');\n        return;\n      }\n\n      // set a stub file object while loading the actual data\n      state.file = createFileStub(source);\n\n      // starts loading\n      loader.on('init', function() {\n        fire('load-init');\n      });\n\n      // we'eve received a size indication, let's update the stub\n      loader.on('meta', function(meta) {\n        // set size of file stub\n        state.file.size = meta.size;\n\n        // set name of file stub\n        state.file.filename = meta.filename;\n\n        // if has received source, we done\n        if (meta.source) {\n          origin = FileOrigin.LIMBO;\n          state.serverFileReference = meta.source;\n          state.status = ItemStatus.PROCESSING_COMPLETE;\n        }\n\n        // size has been updated\n        fire('load-meta');\n      });\n\n      // the file is now loading we need to update the progress indicators\n      loader.on('progress', function(progress) {\n        setStatus(ItemStatus.LOADING);\n\n        fire('load-progress', progress);\n      });\n\n      // an error was thrown while loading the file, we need to switch to error state\n      loader.on('error', function(error) {\n        setStatus(ItemStatus.LOAD_ERROR);\n\n        fire('load-request-error', error);\n      });\n\n      // user or another process aborted the file load (cannot retry)\n      loader.on('abort', function() {\n        setStatus(ItemStatus.INIT);\n        fire('load-abort');\n      });\n\n      // done loading\n      loader.on('load', function(file) {\n        // as we've now loaded the file the loader is no longer required\n        state.activeLoader = null;\n\n        // called when file has loaded succesfully\n        var success = function success(result) {\n          // set (possibly) transformed file\n          state.file = isFile(result) ? result : state.file;\n\n          // file received\n          if (origin === FileOrigin.LIMBO && state.serverFileReference) {\n            setStatus(ItemStatus.PROCESSING_COMPLETE);\n          } else {\n            setStatus(ItemStatus.IDLE);\n          }\n\n          fire('load');\n        };\n\n        var error = function error(result) {\n          // set original file\n          state.file = file;\n          fire('load-meta');\n\n          setStatus(ItemStatus.LOAD_ERROR);\n          fire('load-file-error', result);\n        };\n\n        // if we already have a server file reference, we don't need to call the onload method\n        if (state.serverFileReference) {\n          success(file);\n          return;\n        }\n\n        // no server id, let's give this file the full treatment\n        onload(file, success, error);\n      });\n\n      // set loader source data\n      loader.setSource(source);\n\n      // set as active loader\n      state.activeLoader = loader;\n\n      // load the source data\n      loader.load();\n    };\n\n    var retryLoad = function retryLoad() {\n      if (!state.activeLoader) {\n        return;\n      }\n      state.activeLoader.load();\n    };\n\n    var abortLoad = function abortLoad() {\n      if (state.activeLoader) {\n        state.activeLoader.abort();\n        return;\n      }\n      setStatus(ItemStatus.INIT);\n      fire('load-abort');\n    };\n\n    //\n    // logic to process a file\n    //\n    var process = function process(processor, onprocess) {\n      // processing was aborted\n      if (state.processingAborted) {\n        state.processingAborted = false;\n        return;\n      }\n\n      // now processing\n      setStatus(ItemStatus.PROCESSING);\n\n      // reset abort callback\n      abortProcessingRequestComplete = null;\n\n      // if no file loaded we'll wait for the load event\n      if (!(state.file instanceof Blob)) {\n        api.on('load', function() {\n          process(processor, onprocess);\n        });\n        return;\n      }\n\n      // setup processor\n      processor.on('load', function(serverFileReference) {\n        // need this id to be able to revert the upload\n        state.transferId = null;\n        state.serverFileReference = serverFileReference;\n      });\n\n      // register transfer id\n      processor.on('transfer', function(transferId) {\n        // need this id to be able to revert the upload\n        state.transferId = transferId;\n      });\n\n      processor.on('load-perceived', function(serverFileReference) {\n        // no longer required\n        state.activeProcessor = null;\n\n        // need this id to be able to rever the upload\n        state.transferId = null;\n        state.serverFileReference = serverFileReference;\n\n        setStatus(ItemStatus.PROCESSING_COMPLETE);\n        fire('process-complete', serverFileReference);\n      });\n\n      processor.on('start', function() {\n        fire('process-start');\n      });\n\n      processor.on('error', function(error) {\n        state.activeProcessor = null;\n        setStatus(ItemStatus.PROCESSING_ERROR);\n        fire('process-error', error);\n      });\n\n      processor.on('abort', function(serverFileReference) {\n        state.activeProcessor = null;\n\n        // if file was uploaded but processing was cancelled during perceived processor time store file reference\n        state.transferId = null;\n        state.serverFileReference = serverFileReference;\n\n        setStatus(ItemStatus.IDLE);\n        fire('process-abort');\n\n        // has timeout so doesn't interfere with remove action\n        if (abortProcessingRequestComplete) {\n          abortProcessingRequestComplete();\n        }\n      });\n\n      processor.on('progress', function(progress) {\n        fire('process-progress', progress);\n      });\n\n      // when successfully transformed\n      var success = function success(file) {\n        // if was archived in the mean time, don't process\n        if (state.archived) return;\n\n        // process file!\n        processor.process(file, Object.assign({}, metadata));\n      };\n\n      // something went wrong during transform phase\n      var error = console.error;\n\n      // start processing the file\n      onprocess(state.file, success, error);\n\n      // set as active processor\n      state.activeProcessor = processor;\n    };\n\n    var requestProcessing = function requestProcessing() {\n      state.processingAborted = false;\n      setStatus(ItemStatus.PROCESSING_QUEUED);\n    };\n\n    var abortProcessing = function abortProcessing() {\n      return new Promise(function(resolve) {\n        if (!state.activeProcessor) {\n          state.processingAborted = true;\n\n          setStatus(ItemStatus.IDLE);\n          fire('process-abort');\n\n          resolve();\n          return;\n        }\n\n        abortProcessingRequestComplete = function abortProcessingRequestComplete() {\n          resolve();\n        };\n\n        state.activeProcessor.abort();\n      });\n    };\n\n    //\n    // logic to revert a processed file\n    //\n    var revert = function revert(revertFileUpload, forceRevert) {\n      return new Promise(function(resolve, reject) {\n        // cannot revert without a server id for this process\n        if (state.serverFileReference === null) {\n          resolve();\n          return;\n        }\n\n        // revert the upload (fire and forget)\n        revertFileUpload(\n          state.serverFileReference,\n          function() {\n            // reset file server id as now it's no available on the server\n            state.serverFileReference = null;\n            resolve();\n          },\n          function(error) {\n            // don't set error state when reverting is optional, it will always resolve\n            if (!forceRevert) {\n              resolve();\n              return;\n            }\n\n            // oh no errors\n            setStatus(ItemStatus.PROCESSING_REVERT_ERROR);\n            fire('process-revert-error');\n            reject(error);\n          }\n        );\n\n        // fire event\n        setStatus(ItemStatus.IDLE);\n        fire('process-revert');\n      });\n    };\n\n    // exposed methods\n    var _setMetadata = function setMetadata(key, value, silent) {\n      var keys = key.split('.');\n      var root = keys[0];\n      var last = keys.pop();\n      var data = metadata;\n      keys.forEach(function(key) {\n        return (data = data[key]);\n      });\n\n      // compare old value against new value, if they're the same, we're not updating\n      if (JSON.stringify(data[last]) === JSON.stringify(value)) return;\n\n      // update value\n      data[last] = value;\n\n      // don't fire update\n      if (silent) return;\n\n      // fire update\n      fire('metadata-update', {\n        key: root,\n        value: metadata[root]\n      });\n    };\n\n    var getMetadata = function getMetadata(key) {\n      return deepCloneObject(key ? metadata[key] : metadata);\n    };\n\n    var api = Object.assign(\n      {\n        id: {\n          get: function get() {\n            return id;\n          }\n        },\n        origin: {\n          get: function get() {\n            return origin;\n          }\n        },\n        serverId: {\n          get: function get() {\n            return state.serverFileReference;\n          }\n        },\n        transferId: {\n          get: function get() {\n            return state.transferId;\n          }\n        },\n        status: {\n          get: function get() {\n            return state.status;\n          }\n        },\n        filename: {\n          get: function get() {\n            return state.file.name;\n          }\n        },\n        filenameWithoutExtension: {\n          get: function get() {\n            return getFilenameWithoutExtension(state.file.name);\n          }\n        },\n        fileExtension: { get: getFileExtension },\n        fileType: { get: getFileType },\n        fileSize: { get: getFileSize },\n        file: { get: getFile },\n        relativePath: {\n          get: function get() {\n            return state.file._relativePath;\n          }\n        },\n\n        source: {\n          get: function get() {\n            return state.source;\n          }\n        },\n\n        getMetadata: getMetadata,\n        setMetadata: function setMetadata(key, value, silent) {\n          if (isObject(key)) {\n            var data = key;\n            Object.keys(data).forEach(function(key) {\n              _setMetadata(key, data[key], value);\n            });\n            return key;\n          }\n          _setMetadata(key, value, silent);\n          return value;\n        },\n\n        extend: function extend(name, handler) {\n          return (itemAPI[name] = handler);\n        },\n\n        abortLoad: abortLoad,\n        retryLoad: retryLoad,\n        requestProcessing: requestProcessing,\n        abortProcessing: abortProcessing,\n\n        load: load,\n        process: process,\n        revert: revert\n      },\n\n      on(),\n      {\n        freeze: function freeze() {\n          return (state.frozen = true);\n        },\n\n        release: function release() {\n          return (state.released = true);\n        },\n        released: {\n          get: function get() {\n            return state.released;\n          }\n        },\n\n        archive: function archive() {\n          return (state.archived = true);\n        },\n        archived: {\n          get: function get() {\n            return state.archived;\n          }\n        }\n      }\n    );\n\n    // create it here instead of returning it instantly so we can extend it later\n    var itemAPI = createObject(api);\n\n    return itemAPI;\n  };\n\n  var getItemIndexByQuery = function getItemIndexByQuery(items, query) {\n    // just return first index\n    if (isEmpty(query)) {\n      return 0;\n    }\n\n    // invalid queries\n    if (!isString(query)) {\n      return -1;\n    }\n\n    // return item by id (or -1 if not found)\n    return items.findIndex(function(item) {\n      return item.id === query;\n    });\n  };\n\n  var getItemById = function getItemById(items, itemId) {\n    var index = getItemIndexByQuery(items, itemId);\n    if (index < 0) {\n      return;\n    }\n    return items[index] || null;\n  };\n\n  var fetchBlob = function fetchBlob(\n    url,\n    load,\n    error,\n    progress,\n    abort,\n    headers\n  ) {\n    var request = sendRequest(null, url, {\n      method: 'GET',\n      responseType: 'blob'\n    });\n\n    request.onload = function(xhr) {\n      // get headers\n      var headers = xhr.getAllResponseHeaders();\n\n      // get filename\n      var filename =\n        getFileInfoFromHeaders(headers).name || getFilenameFromURL(url);\n\n      // create response\n      load(\n        createResponse(\n          'load',\n          xhr.status,\n          getFileFromBlob(xhr.response, filename),\n          headers\n        )\n      );\n    };\n\n    request.onerror = function(xhr) {\n      error(\n        createResponse(\n          'error',\n          xhr.status,\n          xhr.statusText,\n          xhr.getAllResponseHeaders()\n        )\n      );\n    };\n\n    request.onheaders = function(xhr) {\n      headers(\n        createResponse('headers', xhr.status, null, xhr.getAllResponseHeaders())\n      );\n    };\n\n    request.ontimeout = createTimeoutResponse(error);\n    request.onprogress = progress;\n    request.onabort = abort;\n\n    // should return request\n    return request;\n  };\n\n  var getDomainFromURL = function getDomainFromURL(url) {\n    if (url.indexOf('//') === 0) {\n      url = location.protocol + url;\n    }\n    return url\n      .toLowerCase()\n      .replace('blob:', '')\n      .replace(/([a-z])?:\\/\\//, '$1')\n      .split('/')[0];\n  };\n\n  var isExternalURL = function isExternalURL(url) {\n    return (\n      (url.indexOf(':') > -1 || url.indexOf('//') > -1) &&\n      getDomainFromURL(location.href) !== getDomainFromURL(url)\n    );\n  };\n\n  var dynamicLabel = function dynamicLabel(label) {\n    return function() {\n      return isFunction(label) ? label.apply(void 0, arguments) : label;\n    };\n  };\n\n  var isMockItem = function isMockItem(item) {\n    return !isFile(item.file);\n  };\n\n  var listUpdated = function listUpdated(dispatch, state) {\n    clearTimeout(state.listUpdateTimeout);\n    state.listUpdateTimeout = setTimeout(function() {\n      dispatch('DID_UPDATE_ITEMS', { items: getActiveItems(state.items) });\n    }, 0);\n  };\n\n  var optionalPromise = function optionalPromise(fn) {\n    for (\n      var _len = arguments.length,\n        params = new Array(_len > 1 ? _len - 1 : 0),\n        _key = 1;\n      _key < _len;\n      _key++\n    ) {\n      params[_key - 1] = arguments[_key];\n    }\n    return new Promise(function(resolve) {\n      if (!fn) {\n        return resolve(true);\n      }\n\n      var result = fn.apply(void 0, params);\n\n      if (result == null) {\n        return resolve(true);\n      }\n\n      if (typeof result === 'boolean') {\n        return resolve(result);\n      }\n\n      if (typeof result.then === 'function') {\n        result.then(resolve);\n      }\n    });\n  };\n\n  var sortItems = function sortItems(state, compare) {\n    state.items.sort(function(a, b) {\n      return compare(createItemAPI(a), createItemAPI(b));\n    });\n  };\n\n  // returns item based on state\n  var getItemByQueryFromState = function getItemByQueryFromState(\n    state,\n    itemHandler\n  ) {\n    return function() {\n      var _ref =\n        arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var query = _ref.query,\n        _ref$success = _ref.success,\n        success = _ref$success === void 0 ? function() {} : _ref$success,\n        _ref$failure = _ref.failure,\n        failure = _ref$failure === void 0 ? function() {} : _ref$failure,\n        options = _objectWithoutProperties(_ref, [\n          'query',\n          'success',\n          'failure'\n        ]);\n      var item = getItemByQuery(state.items, query);\n      if (!item) {\n        failure({\n          error: createResponse('error', 0, 'Item not found'),\n\n          file: null\n        });\n\n        return;\n      }\n      itemHandler(item, success, failure, options || {});\n    };\n  };\n\n  var actions = function actions(dispatch, query, state) {\n    return {\n      /**\n       * Aborts all ongoing processes\n       */\n      ABORT_ALL: function ABORT_ALL() {\n        getActiveItems(state.items).forEach(function(item) {\n          item.freeze();\n          item.abortLoad();\n          item.abortProcessing();\n        });\n      },\n\n      /**\n       * Sets initial files\n       */\n      DID_SET_FILES: function DID_SET_FILES(_ref2) {\n        var _ref2$value = _ref2.value,\n          value = _ref2$value === void 0 ? [] : _ref2$value;\n\n        // map values to file objects\n        var files = value.map(function(file) {\n          return {\n            source: file.source ? file.source : file,\n            options: file.options\n          };\n        });\n\n        // loop over files, if file is in list, leave it be, if not, remove\n        // test if items should be moved\n        var activeItems = getActiveItems(state.items);\n\n        activeItems.forEach(function(item) {\n          // if item not is in new value, remove\n          if (\n            !files.find(function(file) {\n              return file.source === item.source || file.source === item.file;\n            })\n          ) {\n            dispatch('REMOVE_ITEM', { query: item, remove: false });\n          }\n        });\n\n        // add new files\n        activeItems = getActiveItems(state.items);\n        files.forEach(function(file, index) {\n          // if file is already in list\n          if (\n            activeItems.find(function(item) {\n              return item.source === file.source || item.file === file.source;\n            })\n          )\n            return;\n\n          // not in list, add\n          dispatch(\n            'ADD_ITEM',\n            Object.assign({}, file, {\n              interactionMethod: InteractionMethod.NONE,\n              index: index\n            })\n          );\n        });\n      },\n\n      DID_UPDATE_ITEM_METADATA: function DID_UPDATE_ITEM_METADATA(_ref3) {\n        var id = _ref3.id;\n\n        // if is called multiple times in close succession we combined all calls together to save resources\n        clearTimeout(state.itemUpdateTimeout);\n        state.itemUpdateTimeout = setTimeout(function() {\n          var item = getItemById(state.items, id);\n\n          // only revert and attempt to upload when we're uploading to a server\n          if (!query('IS_ASYNC')) {\n            // should we update the output data\n            applyFilterChain('SHOULD_PREPARE_OUTPUT', false, {\n              item: item,\n              query: query\n            }).then(function(shouldPrepareOutput) {\n              if (!shouldPrepareOutput) {\n                return;\n              }\n              dispatch(\n                'REQUEST_PREPARE_OUTPUT',\n                {\n                  query: id,\n                  item: item,\n                  success: function success(file) {\n                    dispatch('DID_PREPARE_OUTPUT', { id: id, file: file });\n                  }\n                },\n                true\n              );\n            });\n\n            return;\n          }\n\n          // for async scenarios\n          var upload = function upload() {\n            // we push this forward a bit so the interface is updated correctly\n            setTimeout(function() {\n              dispatch('REQUEST_ITEM_PROCESSING', { query: id });\n            }, 32);\n          };\n\n          var revert = function revert(doUpload) {\n            item\n              .revert(\n                createRevertFunction(\n                  state.options.server.url,\n                  state.options.server.revert\n                ),\n                query('GET_FORCE_REVERT')\n              )\n              .then(doUpload ? upload : function() {})\n              .catch(function() {});\n          };\n\n          var abort = function abort(doUpload) {\n            item.abortProcessing().then(doUpload ? upload : function() {});\n          };\n\n          // if we should re-upload the file immediately\n          if (item.status === ItemStatus.PROCESSING_COMPLETE) {\n            return revert(state.options.instantUpload);\n          }\n\n          // if currently uploading, cancel upload\n          if (item.status === ItemStatus.PROCESSING) {\n            return abort(state.options.instantUpload);\n          }\n\n          if (state.options.instantUpload) {\n            upload();\n          }\n        }, 0);\n      },\n\n      MOVE_ITEM: function MOVE_ITEM(_ref4) {\n        var query = _ref4.query,\n          index = _ref4.index;\n        var item = getItemByQuery(state.items, query);\n        if (!item) return;\n        var currentIndex = state.items.indexOf(item);\n        index = limit(index, 0, state.items.length - 1);\n        if (currentIndex === index) return;\n        state.items.splice(index, 0, state.items.splice(currentIndex, 1)[0]);\n      },\n\n      SORT: function SORT(_ref5) {\n        var compare = _ref5.compare;\n        sortItems(state, compare);\n        dispatch('DID_SORT_ITEMS', {\n          items: query('GET_ACTIVE_ITEMS')\n        });\n      },\n\n      ADD_ITEMS: function ADD_ITEMS(_ref6) {\n        var items = _ref6.items,\n          index = _ref6.index,\n          interactionMethod = _ref6.interactionMethod,\n          _ref6$success = _ref6.success,\n          success = _ref6$success === void 0 ? function() {} : _ref6$success,\n          _ref6$failure = _ref6.failure,\n          failure = _ref6$failure === void 0 ? function() {} : _ref6$failure;\n\n        var currentIndex = index;\n\n        if (index === -1 || typeof index === 'undefined') {\n          var insertLocation = query('GET_ITEM_INSERT_LOCATION');\n          var totalItems = query('GET_TOTAL_ITEMS');\n          currentIndex = insertLocation === 'before' ? 0 : totalItems;\n        }\n\n        var ignoredFiles = query('GET_IGNORED_FILES');\n        var isValidFile = function isValidFile(source) {\n          return isFile(source)\n            ? !ignoredFiles.includes(source.name.toLowerCase())\n            : !isEmpty(source);\n        };\n        var validItems = items.filter(isValidFile);\n\n        var promises = validItems.map(function(source) {\n          return new Promise(function(resolve, reject) {\n            dispatch('ADD_ITEM', {\n              interactionMethod: interactionMethod,\n              source: source.source || source,\n              success: resolve,\n              failure: reject,\n              index: currentIndex++,\n              options: source.options || {}\n            });\n          });\n        });\n\n        Promise.all(promises)\n          .then(success)\n          .catch(failure);\n      },\n\n      /**\n       * @param source\n       * @param index\n       * @param interactionMethod\n       */\n      ADD_ITEM: function ADD_ITEM(_ref7) {\n        var source = _ref7.source,\n          _ref7$index = _ref7.index,\n          index = _ref7$index === void 0 ? -1 : _ref7$index,\n          interactionMethod = _ref7.interactionMethod,\n          _ref7$success = _ref7.success,\n          success = _ref7$success === void 0 ? function() {} : _ref7$success,\n          _ref7$failure = _ref7.failure,\n          failure = _ref7$failure === void 0 ? function() {} : _ref7$failure,\n          _ref7$options = _ref7.options,\n          options = _ref7$options === void 0 ? {} : _ref7$options;\n\n        // if no source supplied\n        if (isEmpty(source)) {\n          failure({\n            error: createResponse('error', 0, 'No source'),\n\n            file: null\n          });\n\n          return;\n        }\n\n        // filter out invalid file items, used to filter dropped directory contents\n        if (\n          isFile(source) &&\n          state.options.ignoredFiles.includes(source.name.toLowerCase())\n        ) {\n          // fail silently\n          return;\n        }\n\n        // test if there's still room in the list of files\n        if (!hasRoomForItem(state)) {\n          // if multiple allowed, we can't replace\n          // or if only a single item is allowed but we're not allowed to replace it we exit\n          if (\n            state.options.allowMultiple ||\n            (!state.options.allowMultiple && !state.options.allowReplace)\n          ) {\n            var error = createResponse('warning', 0, 'Max files');\n\n            dispatch('DID_THROW_MAX_FILES', {\n              source: source,\n              error: error\n            });\n\n            failure({ error: error, file: null });\n\n            return;\n          }\n\n          // let's replace the item\n          // id of first item we're about to remove\n          var _item = getActiveItems(state.items)[0];\n\n          // if has been processed remove it from the server as well\n          if (\n            _item.status === ItemStatus.PROCESSING_COMPLETE ||\n            _item.status === ItemStatus.PROCESSING_REVERT_ERROR\n          ) {\n            var forceRevert = query('GET_FORCE_REVERT');\n            _item\n              .revert(\n                createRevertFunction(\n                  state.options.server.url,\n                  state.options.server.revert\n                ),\n                forceRevert\n              )\n              .then(function() {\n                if (!forceRevert) return;\n\n                // try to add now\n                dispatch('ADD_ITEM', {\n                  source: source,\n                  index: index,\n                  interactionMethod: interactionMethod,\n                  success: success,\n                  failure: failure,\n                  options: options\n                });\n              })\n              .catch(function() {}); // no need to handle this catch state for now\n\n            if (forceRevert) return;\n          }\n\n          // remove first item as it will be replaced by this item\n          dispatch('REMOVE_ITEM', { query: _item.id });\n        }\n\n        // where did the file originate\n        var origin =\n          options.type === 'local'\n            ? FileOrigin.LOCAL\n            : options.type === 'limbo'\n            ? FileOrigin.LIMBO\n            : FileOrigin.INPUT;\n\n        // create a new blank item\n        var item = createItem(\n          // where did this file come from\n          origin,\n\n          // an input file never has a server file reference\n          origin === FileOrigin.INPUT ? null : source,\n\n          // file mock data, if defined\n          options.file\n        );\n\n        // set initial meta data\n        Object.keys(options.metadata || {}).forEach(function(key) {\n          item.setMetadata(key, options.metadata[key]);\n        });\n\n        // created the item, let plugins add methods\n        applyFilters('DID_CREATE_ITEM', item, {\n          query: query,\n          dispatch: dispatch\n        });\n\n        // where to insert new items\n        var itemInsertLocation = query('GET_ITEM_INSERT_LOCATION');\n\n        // adjust index if is not allowed to pick location\n        if (!state.options.itemInsertLocationFreedom) {\n          index = itemInsertLocation === 'before' ? -1 : state.items.length;\n        }\n\n        // add item to list\n        insertItem(state.items, item, index);\n\n        // sort items in list\n        if (isFunction(itemInsertLocation) && source) {\n          sortItems(state, itemInsertLocation);\n        }\n\n        // get a quick reference to the item id\n        var id = item.id;\n\n        // observe item events\n        item.on('init', function() {\n          dispatch('DID_INIT_ITEM', { id: id });\n        });\n\n        item.on('load-init', function() {\n          dispatch('DID_START_ITEM_LOAD', { id: id });\n        });\n\n        item.on('load-meta', function() {\n          dispatch('DID_UPDATE_ITEM_META', { id: id });\n        });\n\n        item.on('load-progress', function(progress) {\n          dispatch('DID_UPDATE_ITEM_LOAD_PROGRESS', {\n            id: id,\n            progress: progress\n          });\n        });\n\n        item.on('load-request-error', function(error) {\n          var mainStatus = dynamicLabel(state.options.labelFileLoadError)(\n            error\n          );\n\n          // is client error, no way to recover\n          if (error.code >= 400 && error.code < 500) {\n            dispatch('DID_THROW_ITEM_INVALID', {\n              id: id,\n              error: error,\n              status: {\n                main: mainStatus,\n                sub: error.code + ' (' + error.body + ')'\n              }\n            });\n\n            // reject the file so can be dealt with through API\n            failure({ error: error, file: createItemAPI(item) });\n            return;\n          }\n\n          // is possible server error, so might be possible to retry\n          dispatch('DID_THROW_ITEM_LOAD_ERROR', {\n            id: id,\n            error: error,\n            status: {\n              main: mainStatus,\n              sub: state.options.labelTapToRetry\n            }\n          });\n        });\n\n        item.on('load-file-error', function(error) {\n          dispatch('DID_THROW_ITEM_INVALID', {\n            id: id,\n            error: error.status,\n            status: error.status\n          });\n\n          failure({ error: error.status, file: createItemAPI(item) });\n        });\n\n        item.on('load-abort', function() {\n          dispatch('REMOVE_ITEM', { query: id });\n        });\n\n        item.on('load-skip', function() {\n          dispatch('COMPLETE_LOAD_ITEM', {\n            query: id,\n            item: item,\n            data: {\n              source: source,\n              success: success\n            }\n          });\n        });\n\n        item.on('load', function() {\n          var handleAdd = function handleAdd(shouldAdd) {\n            // no should not add this file\n            if (!shouldAdd) {\n              dispatch('REMOVE_ITEM', {\n                query: id\n              });\n\n              return;\n            }\n\n            // now interested in metadata updates\n            item.on('metadata-update', function(change) {\n              dispatch('DID_UPDATE_ITEM_METADATA', { id: id, change: change });\n            });\n\n            // let plugins decide if the output data should be prepared at this point\n            // means we'll do this and wait for idle state\n            applyFilterChain('SHOULD_PREPARE_OUTPUT', false, {\n              item: item,\n              query: query\n            }).then(function(shouldPrepareOutput) {\n              var loadComplete = function loadComplete() {\n                dispatch('COMPLETE_LOAD_ITEM', {\n                  query: id,\n                  item: item,\n                  data: {\n                    source: source,\n                    success: success\n                  }\n                });\n\n                listUpdated(dispatch, state);\n              };\n\n              // exit\n              if (shouldPrepareOutput) {\n                // wait for idle state and then run PREPARE_OUTPUT\n                dispatch(\n                  'REQUEST_PREPARE_OUTPUT',\n                  {\n                    query: id,\n                    item: item,\n                    success: function success(file) {\n                      dispatch('DID_PREPARE_OUTPUT', { id: id, file: file });\n                      loadComplete();\n                    }\n                  },\n                  true\n                );\n\n                return;\n              }\n\n              loadComplete();\n            });\n          };\n\n          // item loaded, allow plugins to\n          // - read data (quickly)\n          // - add metadata\n          applyFilterChain('DID_LOAD_ITEM', item, {\n            query: query,\n            dispatch: dispatch\n          })\n            .then(function() {\n              optionalPromise(\n                query('GET_BEFORE_ADD_FILE'),\n                createItemAPI(item)\n              ).then(handleAdd);\n            })\n            .catch(function() {\n              handleAdd(false);\n            });\n        });\n\n        item.on('process-start', function() {\n          dispatch('DID_START_ITEM_PROCESSING', { id: id });\n        });\n\n        item.on('process-progress', function(progress) {\n          dispatch('DID_UPDATE_ITEM_PROCESS_PROGRESS', {\n            id: id,\n            progress: progress\n          });\n        });\n\n        item.on('process-error', function(error) {\n          dispatch('DID_THROW_ITEM_PROCESSING_ERROR', {\n            id: id,\n            error: error,\n            status: {\n              main: dynamicLabel(state.options.labelFileProcessingError)(error),\n              sub: state.options.labelTapToRetry\n            }\n          });\n        });\n\n        item.on('process-revert-error', function(error) {\n          dispatch('DID_THROW_ITEM_PROCESSING_REVERT_ERROR', {\n            id: id,\n            error: error,\n            status: {\n              main: dynamicLabel(state.options.labelFileProcessingRevertError)(\n                error\n              ),\n              sub: state.options.labelTapToRetry\n            }\n          });\n        });\n\n        item.on('process-complete', function(serverFileReference) {\n          dispatch('DID_COMPLETE_ITEM_PROCESSING', {\n            id: id,\n            error: null,\n            serverFileReference: serverFileReference\n          });\n\n          dispatch('DID_DEFINE_VALUE', { id: id, value: serverFileReference });\n        });\n\n        item.on('process-abort', function() {\n          dispatch('DID_ABORT_ITEM_PROCESSING', { id: id });\n        });\n\n        item.on('process-revert', function() {\n          dispatch('DID_REVERT_ITEM_PROCESSING', { id: id });\n          dispatch('DID_DEFINE_VALUE', { id: id, value: null });\n        });\n\n        // let view know the item has been inserted\n        dispatch('DID_ADD_ITEM', {\n          id: id,\n          index: index,\n          interactionMethod: interactionMethod\n        });\n\n        listUpdated(dispatch, state);\n\n        // start loading the source\n        var _ref8 = state.options.server || {},\n          url = _ref8.url,\n          load = _ref8.load,\n          restore = _ref8.restore,\n          fetch = _ref8.fetch;\n\n        item.load(\n          source,\n\n          // this creates a function that loads the file based on the type of file (string, base64, blob, file) and location of file (local, remote, limbo)\n          createFileLoader(\n            origin === FileOrigin.INPUT\n              ? // input, if is remote, see if should use custom fetch, else use default fetchBlob\n                isString(source) && isExternalURL(source)\n                ? fetch\n                  ? createFetchFunction(url, fetch)\n                  : fetchBlob // remote url\n                : fetchBlob // try to fetch url\n              : // limbo or local\n              origin === FileOrigin.LIMBO\n              ? createFetchFunction(url, restore) // limbo\n              : createFetchFunction(url, load) // local\n          ),\n\n          // called when the file is loaded so it can be piped through the filters\n          function(file, success, error) {\n            // let's process the file\n            applyFilterChain('LOAD_FILE', file, { query: query })\n              .then(success)\n              .catch(error);\n          }\n        );\n      },\n\n      REQUEST_PREPARE_OUTPUT: function REQUEST_PREPARE_OUTPUT(_ref9) {\n        var item = _ref9.item,\n          success = _ref9.success,\n          _ref9$failure = _ref9.failure,\n          failure = _ref9$failure === void 0 ? function() {} : _ref9$failure;\n\n        // error response if item archived\n        var err = {\n          error: createResponse('error', 0, 'Item not found'),\n\n          file: null\n        };\n\n        // don't handle archived items, an item could have been archived (load aborted) while waiting to be prepared\n        if (item.archived) return failure(err);\n\n        // allow plugins to alter the file data\n        applyFilterChain('PREPARE_OUTPUT', item.file, {\n          query: query,\n          item: item\n        }).then(function(result) {\n          applyFilterChain('COMPLETE_PREPARE_OUTPUT', result, {\n            query: query,\n            item: item\n          }).then(function(result) {\n            // don't handle archived items, an item could have been archived (load aborted) while being prepared\n            if (item.archived) return failure(err);\n\n            // we done!\n            success(result);\n          });\n        });\n      },\n\n      COMPLETE_LOAD_ITEM: function COMPLETE_LOAD_ITEM(_ref10) {\n        var item = _ref10.item,\n          data = _ref10.data;\n        var success = data.success,\n          source = data.source;\n\n        // sort items in list\n        var itemInsertLocation = query('GET_ITEM_INSERT_LOCATION');\n        if (isFunction(itemInsertLocation) && source) {\n          sortItems(state, itemInsertLocation);\n        }\n\n        // let interface know the item has loaded\n        dispatch('DID_LOAD_ITEM', {\n          id: item.id,\n          error: null,\n          serverFileReference: item.origin === FileOrigin.INPUT ? null : source\n        });\n\n        // item has been successfully loaded and added to the\n        // list of items so can now be safely returned for use\n        success(createItemAPI(item));\n\n        // if this is a local server file we need to show a different state\n        if (item.origin === FileOrigin.LOCAL) {\n          dispatch('DID_LOAD_LOCAL_ITEM', { id: item.id });\n          return;\n        }\n\n        // if is a temp server file we prevent async upload call here (as the file is already on the server)\n        if (item.origin === FileOrigin.LIMBO) {\n          dispatch('DID_COMPLETE_ITEM_PROCESSING', {\n            id: item.id,\n            error: null,\n            serverFileReference: source\n          });\n\n          dispatch('DID_DEFINE_VALUE', {\n            id: item.id,\n            value: source\n          });\n\n          return;\n        }\n\n        // id we are allowed to upload the file immediately, lets do it\n        if (query('IS_ASYNC') && state.options.instantUpload) {\n          dispatch('REQUEST_ITEM_PROCESSING', { query: item.id });\n        }\n      },\n\n      RETRY_ITEM_LOAD: getItemByQueryFromState(state, function(item) {\n        // try loading the source one more time\n        item.retryLoad();\n      }),\n\n      REQUEST_ITEM_PREPARE: getItemByQueryFromState(state, function(\n        item,\n        _success,\n        failure\n      ) {\n        dispatch(\n          'REQUEST_PREPARE_OUTPUT',\n          {\n            query: item.id,\n            item: item,\n            success: function success(file) {\n              dispatch('DID_PREPARE_OUTPUT', { id: item.id, file: file });\n              _success({\n                file: item,\n                output: file\n              });\n            },\n            failure: failure\n          },\n          true\n        );\n      }),\n\n      REQUEST_ITEM_PROCESSING: getItemByQueryFromState(state, function(\n        item,\n        success,\n        failure\n      ) {\n        // cannot be queued (or is already queued)\n        var itemCanBeQueuedForProcessing =\n          // waiting for something\n          item.status === ItemStatus.IDLE ||\n          // processing went wrong earlier\n          item.status === ItemStatus.PROCESSING_ERROR;\n\n        // not ready to be processed\n        if (!itemCanBeQueuedForProcessing) {\n          var processNow = function processNow() {\n            return dispatch('REQUEST_ITEM_PROCESSING', {\n              query: item,\n              success: success,\n              failure: failure\n            });\n          };\n\n          var process = function process() {\n            return document.hidden ? processNow() : setTimeout(processNow, 32);\n          };\n\n          // if already done processing or tried to revert but didn't work, try again\n          if (\n            item.status === ItemStatus.PROCESSING_COMPLETE ||\n            item.status === ItemStatus.PROCESSING_REVERT_ERROR\n          ) {\n            item\n              .revert(\n                createRevertFunction(\n                  state.options.server.url,\n                  state.options.server.revert\n                ),\n                query('GET_FORCE_REVERT')\n              )\n              .then(process)\n              .catch(function() {}); // don't continue with processing if something went wrong\n          } else if (item.status === ItemStatus.PROCESSING) {\n            item.abortProcessing().then(process);\n          }\n\n          return;\n        }\n\n        // already queued for processing\n        if (item.status === ItemStatus.PROCESSING_QUEUED) return;\n\n        item.requestProcessing();\n\n        dispatch('DID_REQUEST_ITEM_PROCESSING', { id: item.id });\n\n        dispatch(\n          'PROCESS_ITEM',\n          { query: item, success: success, failure: failure },\n          true\n        );\n      }),\n\n      PROCESS_ITEM: getItemByQueryFromState(state, function(\n        item,\n        success,\n        failure\n      ) {\n        var maxParallelUploads = query('GET_MAX_PARALLEL_UPLOADS');\n        var totalCurrentUploads = query(\n          'GET_ITEMS_BY_STATUS',\n          ItemStatus.PROCESSING\n        ).length;\n\n        // queue and wait till queue is freed up\n        if (totalCurrentUploads === maxParallelUploads) {\n          // queue for later processing\n          state.processingQueue.push({\n            id: item.id,\n            success: success,\n            failure: failure\n          });\n\n          // stop it!\n          return;\n        }\n\n        // if was not queued or is already processing exit here\n        if (item.status === ItemStatus.PROCESSING) return;\n\n        var processNext = function processNext() {\n          // process queueud items\n          var queueEntry = state.processingQueue.shift();\n\n          // no items left\n          if (!queueEntry) return;\n\n          // get item reference\n          var id = queueEntry.id,\n            success = queueEntry.success,\n            failure = queueEntry.failure;\n          var itemReference = getItemByQuery(state.items, id);\n\n          // if item was archived while in queue, jump to next\n          if (!itemReference || itemReference.archived) {\n            processNext();\n            return;\n          }\n\n          // process queued item\n          dispatch(\n            'PROCESS_ITEM',\n            { query: id, success: success, failure: failure },\n            true\n          );\n        };\n\n        // we done function\n        item.onOnce('process-complete', function() {\n          success(createItemAPI(item));\n          processNext();\n\n          // All items processed? No errors?\n          var allItemsProcessed =\n            query('GET_ITEMS_BY_STATUS', ItemStatus.PROCESSING_COMPLETE)\n              .length === state.items.length;\n          if (allItemsProcessed) {\n            dispatch('DID_COMPLETE_ITEM_PROCESSING_ALL');\n          }\n        });\n\n        // we error function\n        item.onOnce('process-error', function(error) {\n          failure({ error: error, file: createItemAPI(item) });\n          processNext();\n        });\n\n        // start file processing\n        var options = state.options;\n        item.process(\n          createFileProcessor(\n            createProcessorFunction(\n              options.server.url,\n              options.server.process,\n              options.name,\n              {\n                chunkTransferId: item.transferId,\n                chunkServer: options.server.patch,\n                chunkUploads: options.chunkUploads,\n                chunkForce: options.chunkForce,\n                chunkSize: options.chunkSize,\n                chunkRetryDelays: options.chunkRetryDelays\n              }\n            )\n          ),\n\n          // called when the file is about to be processed so it can be piped through the transform filters\n          function(file, success, error) {\n            // allow plugins to alter the file data\n            applyFilterChain('PREPARE_OUTPUT', file, {\n              query: query,\n              item: item\n            })\n              .then(function(file) {\n                dispatch('DID_PREPARE_OUTPUT', { id: item.id, file: file });\n\n                success(file);\n              })\n              .catch(error);\n          }\n        );\n      }),\n\n      RETRY_ITEM_PROCESSING: getItemByQueryFromState(state, function(item) {\n        dispatch('REQUEST_ITEM_PROCESSING', { query: item });\n      }),\n\n      REQUEST_REMOVE_ITEM: getItemByQueryFromState(state, function(item) {\n        optionalPromise(\n          query('GET_BEFORE_REMOVE_FILE'),\n          createItemAPI(item)\n        ).then(function(shouldRemove) {\n          if (!shouldRemove) {\n            return;\n          }\n          dispatch('REMOVE_ITEM', { query: item });\n        });\n      }),\n\n      RELEASE_ITEM: getItemByQueryFromState(state, function(item) {\n        item.release();\n      }),\n\n      REMOVE_ITEM: getItemByQueryFromState(state, function(\n        item,\n        success,\n        failure,\n        options\n      ) {\n        var removeFromView = function removeFromView() {\n          // get id reference\n          var id = item.id;\n\n          // archive the item, this does not remove it from the list\n          getItemById(state.items, id).archive();\n\n          // tell the view the item has been removed\n          dispatch('DID_REMOVE_ITEM', { error: null, id: id, item: item });\n\n          // now the list has been modified\n          listUpdated(dispatch, state);\n\n          // correctly removed\n          success(createItemAPI(item));\n        };\n\n        // if this is a local file and the server.remove function has been configured, send source there so dev can remove file from server\n        var server = state.options.server;\n        if (\n          item.origin === FileOrigin.LOCAL &&\n          server &&\n          isFunction(server.remove) &&\n          options.remove !== false\n        ) {\n          dispatch('DID_START_ITEM_REMOVE', { id: item.id });\n\n          server.remove(\n            item.source,\n            function() {\n              return removeFromView();\n            },\n            function(status) {\n              dispatch('DID_THROW_ITEM_REMOVE_ERROR', {\n                id: item.id,\n                error: createResponse('error', 0, status, null),\n                status: {\n                  main: dynamicLabel(state.options.labelFileRemoveError)(\n                    status\n                  ),\n                  sub: state.options.labelTapToRetry\n                }\n              });\n            }\n          );\n        } else {\n          // if is requesting revert and can revert need to call revert handler (not calling request_ because that would also trigger beforeRemoveHook)\n          if (\n            options.revert &&\n            item.origin !== FileOrigin.LOCAL &&\n            item.serverId !== null\n          ) {\n            item.revert(\n              createRevertFunction(\n                state.options.server.url,\n                state.options.server.revert\n              ),\n              query('GET_FORCE_REVERT')\n            );\n          }\n\n          // can now safely remove from view\n          removeFromView();\n        }\n      }),\n\n      ABORT_ITEM_LOAD: getItemByQueryFromState(state, function(item) {\n        item.abortLoad();\n      }),\n\n      ABORT_ITEM_PROCESSING: getItemByQueryFromState(state, function(item) {\n        // test if is already processed\n        if (item.serverId) {\n          dispatch('REVERT_ITEM_PROCESSING', { id: item.id });\n          return;\n        }\n\n        // abort\n        item.abortProcessing().then(function() {\n          var shouldRemove = state.options.instantUpload;\n          if (shouldRemove) {\n            dispatch('REMOVE_ITEM', { query: item.id });\n          }\n        });\n      }),\n\n      REQUEST_REVERT_ITEM_PROCESSING: getItemByQueryFromState(state, function(\n        item\n      ) {\n        // not instant uploading, revert immediately\n        if (!state.options.instantUpload) {\n          dispatch('REVERT_ITEM_PROCESSING', { query: item });\n          return;\n        }\n\n        // if we're instant uploading the file will also be removed if we revert,\n        // so if a before remove file hook is defined we need to run it now\n        var handleRevert = function handleRevert(shouldRevert) {\n          if (!shouldRevert) return;\n          dispatch('REVERT_ITEM_PROCESSING', { query: item });\n        };\n\n        var fn = query('GET_BEFORE_REMOVE_FILE');\n        if (!fn) {\n          return handleRevert(true);\n        }\n\n        var requestRemoveResult = fn(createItemAPI(item));\n        if (requestRemoveResult == null) {\n          // undefined or null\n          return handleRevert(true);\n        }\n\n        if (typeof requestRemoveResult === 'boolean') {\n          return handleRevert(requestRemoveResult);\n        }\n\n        if (typeof requestRemoveResult.then === 'function') {\n          requestRemoveResult.then(handleRevert);\n        }\n      }),\n\n      REVERT_ITEM_PROCESSING: getItemByQueryFromState(state, function(item) {\n        item\n          .revert(\n            createRevertFunction(\n              state.options.server.url,\n              state.options.server.revert\n            ),\n            query('GET_FORCE_REVERT')\n          )\n          .then(function() {\n            var shouldRemove = state.options.instantUpload || isMockItem(item);\n            if (shouldRemove) {\n              dispatch('REMOVE_ITEM', { query: item.id });\n            }\n          })\n          .catch(function() {});\n      }),\n\n      SET_OPTIONS: function SET_OPTIONS(_ref11) {\n        var options = _ref11.options;\n        forin(options, function(key, value) {\n          dispatch('SET_' + fromCamels(key, '_').toUpperCase(), {\n            value: value\n          });\n        });\n      }\n    };\n  };\n\n  var formatFilename = function formatFilename(name) {\n    return name;\n  };\n\n  var createElement$1 = function createElement(tagName) {\n    return document.createElement(tagName);\n  };\n\n  var text = function text(node, value) {\n    var textNode = node.childNodes[0];\n    if (!textNode) {\n      textNode = document.createTextNode(value);\n      node.appendChild(textNode);\n    } else if (value !== textNode.nodeValue) {\n      textNode.nodeValue = value;\n    }\n  };\n\n  var polarToCartesian = function polarToCartesian(\n    centerX,\n    centerY,\n    radius,\n    angleInDegrees\n  ) {\n    var angleInRadians = (((angleInDegrees % 360) - 90) * Math.PI) / 180.0;\n    return {\n      x: centerX + radius * Math.cos(angleInRadians),\n      y: centerY + radius * Math.sin(angleInRadians)\n    };\n  };\n\n  var describeArc = function describeArc(\n    x,\n    y,\n    radius,\n    startAngle,\n    endAngle,\n    arcSweep\n  ) {\n    var start = polarToCartesian(x, y, radius, endAngle);\n    var end = polarToCartesian(x, y, radius, startAngle);\n    return [\n      'M',\n      start.x,\n      start.y,\n      'A',\n      radius,\n      radius,\n      0,\n      arcSweep,\n      0,\n      end.x,\n      end.y\n    ].join(' ');\n  };\n\n  var percentageArc = function percentageArc(x, y, radius, from, to) {\n    var arcSweep = 1;\n    if (to > from && to - from <= 0.5) {\n      arcSweep = 0;\n    }\n    if (from > to && from - to >= 0.5) {\n      arcSweep = 0;\n    }\n    return describeArc(\n      x,\n      y,\n      radius,\n      Math.min(0.9999, from) * 360,\n      Math.min(0.9999, to) * 360,\n      arcSweep\n    );\n  };\n\n  var create = function create(_ref) {\n    var root = _ref.root,\n      props = _ref.props;\n    // start at 0\n    props.spin = false;\n    props.progress = 0;\n    props.opacity = 0;\n\n    // svg\n    var svg = createElement('svg');\n    root.ref.path = createElement('path', {\n      'stroke-width': 2,\n      'stroke-linecap': 'round'\n    });\n\n    svg.appendChild(root.ref.path);\n\n    root.ref.svg = svg;\n\n    root.appendChild(svg);\n  };\n\n  var write = function write(_ref2) {\n    var root = _ref2.root,\n      props = _ref2.props;\n\n    if (props.opacity === 0) {\n      return;\n    }\n\n    if (props.align) {\n      root.element.dataset.align = props.align;\n    }\n\n    // get width of stroke\n    var ringStrokeWidth = parseInt(attr(root.ref.path, 'stroke-width'), 10);\n\n    // calculate size of ring\n    var size = root.rect.element.width * 0.5;\n\n    // ring state\n    var ringFrom = 0;\n    var ringTo = 0;\n\n    // now in busy mode\n    if (props.spin) {\n      ringFrom = 0;\n      ringTo = 0.5;\n    } else {\n      ringFrom = 0;\n      ringTo = props.progress;\n    }\n\n    // get arc path\n    var coordinates = percentageArc(\n      size,\n      size,\n      size - ringStrokeWidth,\n      ringFrom,\n      ringTo\n    );\n\n    // update progress bar\n    attr(root.ref.path, 'd', coordinates);\n\n    // hide while contains 0 value\n    attr(\n      root.ref.path,\n      'stroke-opacity',\n      props.spin || props.progress > 0 ? 1 : 0\n    );\n  };\n\n  var progressIndicator = createView({\n    tag: 'div',\n    name: 'progress-indicator',\n    ignoreRectUpdate: true,\n    ignoreRect: true,\n    create: create,\n    write: write,\n    mixins: {\n      apis: ['progress', 'spin', 'align'],\n      styles: ['opacity'],\n      animations: {\n        opacity: { type: 'tween', duration: 500 },\n        progress: {\n          type: 'spring',\n          stiffness: 0.95,\n          damping: 0.65,\n          mass: 10\n        }\n      }\n    }\n  });\n\n  var create$1 = function create(_ref) {\n    var root = _ref.root,\n      props = _ref.props;\n    root.element.innerHTML =\n      (props.icon || '') + ('<span>' + props.label + '</span>');\n\n    props.isDisabled = false;\n  };\n\n  var write$1 = function write(_ref2) {\n    var root = _ref2.root,\n      props = _ref2.props;\n    var isDisabled = props.isDisabled;\n    var shouldDisable = root.query('GET_DISABLED') || props.opacity === 0;\n\n    if (shouldDisable && !isDisabled) {\n      props.isDisabled = true;\n      attr(root.element, 'disabled', 'disabled');\n    } else if (!shouldDisable && isDisabled) {\n      props.isDisabled = false;\n      root.element.removeAttribute('disabled');\n    }\n  };\n\n  var fileActionButton = createView({\n    tag: 'button',\n    attributes: {\n      type: 'button'\n    },\n\n    ignoreRect: true,\n    ignoreRectUpdate: true,\n    name: 'file-action-button',\n    mixins: {\n      apis: ['label'],\n      styles: ['translateX', 'translateY', 'scaleX', 'scaleY', 'opacity'],\n      animations: {\n        scaleX: 'spring',\n        scaleY: 'spring',\n        translateX: 'spring',\n        translateY: 'spring',\n        opacity: { type: 'tween', duration: 250 }\n      },\n\n      listeners: true\n    },\n\n    create: create$1,\n    write: write$1\n  });\n\n  var toNaturalFileSize = function toNaturalFileSize(bytes) {\n    var decimalSeparator =\n      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '.';\n    var base =\n      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1000;\n    // no negative byte sizes\n    bytes = Math.round(Math.abs(bytes));\n\n    var KB = base;\n    var MB = base * base;\n    var GB = base * base * base;\n\n    // just bytes\n    if (bytes < KB) {\n      return bytes + ' bytes';\n    }\n\n    // kilobytes\n    if (bytes < MB) {\n      return Math.floor(bytes / KB) + ' KB';\n    }\n\n    // megabytes\n    if (bytes < GB) {\n      return removeDecimalsWhenZero(bytes / MB, 1, decimalSeparator) + ' MB';\n    }\n\n    // gigabytes\n    return removeDecimalsWhenZero(bytes / GB, 2, decimalSeparator) + ' GB';\n  };\n\n  var removeDecimalsWhenZero = function removeDecimalsWhenZero(\n    value,\n    decimalCount,\n    separator\n  ) {\n    return value\n      .toFixed(decimalCount)\n      .split('.')\n      .filter(function(part) {\n        return part !== '0';\n      })\n      .join(separator);\n  };\n\n  var create$2 = function create(_ref) {\n    var root = _ref.root,\n      props = _ref.props;\n    // filename\n    var fileName = createElement$1('span');\n    fileName.className = 'filepond--file-info-main';\n    // hide for screenreaders\n    // the file is contained in a fieldset with legend that contains the filename\n    // no need to read it twice\n    attr(fileName, 'aria-hidden', 'true');\n    root.appendChild(fileName);\n    root.ref.fileName = fileName;\n\n    // filesize\n    var fileSize = createElement$1('span');\n    fileSize.className = 'filepond--file-info-sub';\n    root.appendChild(fileSize);\n    root.ref.fileSize = fileSize;\n\n    // set initial values\n    text(fileSize, root.query('GET_LABEL_FILE_WAITING_FOR_SIZE'));\n    text(fileName, formatFilename(root.query('GET_ITEM_NAME', props.id)));\n  };\n\n  var updateFile = function updateFile(_ref2) {\n    var root = _ref2.root,\n      props = _ref2.props;\n    text(\n      root.ref.fileSize,\n      toNaturalFileSize(\n        root.query('GET_ITEM_SIZE', props.id),\n        '.',\n        root.query('GET_FILE_SIZE_BASE')\n      )\n    );\n\n    text(\n      root.ref.fileName,\n      formatFilename(root.query('GET_ITEM_NAME', props.id))\n    );\n  };\n\n  var updateFileSizeOnError = function updateFileSizeOnError(_ref3) {\n    var root = _ref3.root,\n      props = _ref3.props;\n    // if size is available don't fallback to unknown size message\n    if (isInt(root.query('GET_ITEM_SIZE', props.id))) {\n      return;\n    }\n\n    text(root.ref.fileSize, root.query('GET_LABEL_FILE_SIZE_NOT_AVAILABLE'));\n  };\n\n  var fileInfo = createView({\n    name: 'file-info',\n    ignoreRect: true,\n    ignoreRectUpdate: true,\n    write: createRoute({\n      DID_LOAD_ITEM: updateFile,\n      DID_UPDATE_ITEM_META: updateFile,\n      DID_THROW_ITEM_LOAD_ERROR: updateFileSizeOnError,\n      DID_THROW_ITEM_INVALID: updateFileSizeOnError\n    }),\n\n    didCreateView: function didCreateView(root) {\n      applyFilters('CREATE_VIEW', Object.assign({}, root, { view: root }));\n    },\n    create: create$2,\n    mixins: {\n      styles: ['translateX', 'translateY'],\n      animations: {\n        translateX: 'spring',\n        translateY: 'spring'\n      }\n    }\n  });\n\n  var toPercentage = function toPercentage(value) {\n    return Math.round(value * 100);\n  };\n\n  var create$3 = function create(_ref) {\n    var root = _ref.root;\n\n    // main status\n    var main = createElement$1('span');\n    main.className = 'filepond--file-status-main';\n    root.appendChild(main);\n    root.ref.main = main;\n\n    // sub status\n    var sub = createElement$1('span');\n    sub.className = 'filepond--file-status-sub';\n    root.appendChild(sub);\n    root.ref.sub = sub;\n\n    didSetItemLoadProgress({ root: root, action: { progress: null } });\n  };\n\n  var didSetItemLoadProgress = function didSetItemLoadProgress(_ref2) {\n    var root = _ref2.root,\n      action = _ref2.action;\n    var title =\n      action.progress === null\n        ? root.query('GET_LABEL_FILE_LOADING')\n        : root.query('GET_LABEL_FILE_LOADING') +\n          ' ' +\n          toPercentage(action.progress) +\n          '%';\n\n    text(root.ref.main, title);\n    text(root.ref.sub, root.query('GET_LABEL_TAP_TO_CANCEL'));\n  };\n\n  var didSetItemProcessProgress = function didSetItemProcessProgress(_ref3) {\n    var root = _ref3.root,\n      action = _ref3.action;\n    var title =\n      action.progress === null\n        ? root.query('GET_LABEL_FILE_PROCESSING')\n        : root.query('GET_LABEL_FILE_PROCESSING') +\n          ' ' +\n          toPercentage(action.progress) +\n          '%';\n\n    text(root.ref.main, title);\n    text(root.ref.sub, root.query('GET_LABEL_TAP_TO_CANCEL'));\n  };\n\n  var didRequestItemProcessing = function didRequestItemProcessing(_ref4) {\n    var root = _ref4.root;\n    text(root.ref.main, root.query('GET_LABEL_FILE_PROCESSING'));\n    text(root.ref.sub, root.query('GET_LABEL_TAP_TO_CANCEL'));\n  };\n\n  var didAbortItemProcessing = function didAbortItemProcessing(_ref5) {\n    var root = _ref5.root;\n    text(root.ref.main, root.query('GET_LABEL_FILE_PROCESSING_ABORTED'));\n    text(root.ref.sub, root.query('GET_LABEL_TAP_TO_RETRY'));\n  };\n\n  var didCompleteItemProcessing = function didCompleteItemProcessing(_ref6) {\n    var root = _ref6.root;\n    text(root.ref.main, root.query('GET_LABEL_FILE_PROCESSING_COMPLETE'));\n    text(root.ref.sub, root.query('GET_LABEL_TAP_TO_UNDO'));\n  };\n\n  var clear = function clear(_ref7) {\n    var root = _ref7.root;\n    text(root.ref.main, '');\n    text(root.ref.sub, '');\n  };\n\n  var error = function error(_ref8) {\n    var root = _ref8.root,\n      action = _ref8.action;\n    text(root.ref.main, action.status.main);\n    text(root.ref.sub, action.status.sub);\n  };\n\n  var fileStatus = createView({\n    name: 'file-status',\n    ignoreRect: true,\n    ignoreRectUpdate: true,\n    write: createRoute({\n      DID_LOAD_ITEM: clear,\n      DID_REVERT_ITEM_PROCESSING: clear,\n      DID_REQUEST_ITEM_PROCESSING: didRequestItemProcessing,\n      DID_ABORT_ITEM_PROCESSING: didAbortItemProcessing,\n      DID_COMPLETE_ITEM_PROCESSING: didCompleteItemProcessing,\n      DID_UPDATE_ITEM_PROCESS_PROGRESS: didSetItemProcessProgress,\n      DID_UPDATE_ITEM_LOAD_PROGRESS: didSetItemLoadProgress,\n      DID_THROW_ITEM_LOAD_ERROR: error,\n      DID_THROW_ITEM_INVALID: error,\n      DID_THROW_ITEM_PROCESSING_ERROR: error,\n      DID_THROW_ITEM_PROCESSING_REVERT_ERROR: error,\n      DID_THROW_ITEM_REMOVE_ERROR: error\n    }),\n\n    didCreateView: function didCreateView(root) {\n      applyFilters('CREATE_VIEW', Object.assign({}, root, { view: root }));\n    },\n    create: create$3,\n    mixins: {\n      styles: ['translateX', 'translateY', 'opacity'],\n      animations: {\n        opacity: { type: 'tween', duration: 250 },\n        translateX: 'spring',\n        translateY: 'spring'\n      }\n    }\n  });\n\n  /**\n   * Button definitions for the file view\n   */\n\n  var Buttons = {\n    AbortItemLoad: {\n      label: 'GET_LABEL_BUTTON_ABORT_ITEM_LOAD',\n      action: 'ABORT_ITEM_LOAD',\n      className: 'filepond--action-abort-item-load',\n      align: 'LOAD_INDICATOR_POSITION' // right\n    },\n    RetryItemLoad: {\n      label: 'GET_LABEL_BUTTON_RETRY_ITEM_LOAD',\n      action: 'RETRY_ITEM_LOAD',\n      icon: 'GET_ICON_RETRY',\n      className: 'filepond--action-retry-item-load',\n      align: 'BUTTON_PROCESS_ITEM_POSITION' // right\n    },\n    RemoveItem: {\n      label: 'GET_LABEL_BUTTON_REMOVE_ITEM',\n      action: 'REQUEST_REMOVE_ITEM',\n      icon: 'GET_ICON_REMOVE',\n      className: 'filepond--action-remove-item',\n      align: 'BUTTON_REMOVE_ITEM_POSITION' // left\n    },\n    ProcessItem: {\n      label: 'GET_LABEL_BUTTON_PROCESS_ITEM',\n      action: 'REQUEST_ITEM_PROCESSING',\n      icon: 'GET_ICON_PROCESS',\n      className: 'filepond--action-process-item',\n      align: 'BUTTON_PROCESS_ITEM_POSITION' // right\n    },\n    AbortItemProcessing: {\n      label: 'GET_LABEL_BUTTON_ABORT_ITEM_PROCESSING',\n      action: 'ABORT_ITEM_PROCESSING',\n      className: 'filepond--action-abort-item-processing',\n      align: 'BUTTON_PROCESS_ITEM_POSITION' // right\n    },\n    RetryItemProcessing: {\n      label: 'GET_LABEL_BUTTON_RETRY_ITEM_PROCESSING',\n      action: 'RETRY_ITEM_PROCESSING',\n      icon: 'GET_ICON_RETRY',\n      className: 'filepond--action-retry-item-processing',\n      align: 'BUTTON_PROCESS_ITEM_POSITION' // right\n    },\n    RevertItemProcessing: {\n      label: 'GET_LABEL_BUTTON_UNDO_ITEM_PROCESSING',\n      action: 'REQUEST_REVERT_ITEM_PROCESSING',\n      icon: 'GET_ICON_UNDO',\n      className: 'filepond--action-revert-item-processing',\n      align: 'BUTTON_PROCESS_ITEM_POSITION' // right\n    }\n  };\n\n  // make a list of buttons, we can then remove buttons from this list if they're disabled\n  var ButtonKeys = [];\n  forin(Buttons, function(key) {\n    ButtonKeys.push(key);\n  });\n\n  var calculateFileInfoOffset = function calculateFileInfoOffset(root) {\n    var buttonRect = root.ref.buttonRemoveItem.rect.element;\n    return buttonRect.hidden ? null : buttonRect.width + buttonRect.left;\n  };\n\n  var calculateButtonWidth = function calculateButtonWidth(root) {\n    var buttonRect = root.ref.buttonAbortItemLoad.rect.element;\n    return buttonRect.width;\n  };\n\n  // Force on full pixels so text stays crips\n  var calculateFileVerticalCenterOffset = function calculateFileVerticalCenterOffset(\n    root\n  ) {\n    return Math.floor(root.ref.buttonRemoveItem.rect.element.height / 4);\n  };\n  var calculateFileHorizontalCenterOffset = function calculateFileHorizontalCenterOffset(\n    root\n  ) {\n    return Math.floor(root.ref.buttonRemoveItem.rect.element.left / 2);\n  };\n\n  var getLoadIndicatorAlignment = function getLoadIndicatorAlignment(root) {\n    return root.query('GET_STYLE_LOAD_INDICATOR_POSITION');\n  };\n  var getProcessIndicatorAlignment = function getProcessIndicatorAlignment(\n    root\n  ) {\n    return root.query('GET_STYLE_PROGRESS_INDICATOR_POSITION');\n  };\n  var getRemoveIndicatorAligment = function getRemoveIndicatorAligment(root) {\n    return root.query('GET_STYLE_BUTTON_REMOVE_ITEM_POSITION');\n  };\n\n  var DefaultStyle = {\n    buttonAbortItemLoad: { opacity: 0 },\n    buttonRetryItemLoad: { opacity: 0 },\n    buttonRemoveItem: { opacity: 0 },\n    buttonProcessItem: { opacity: 0 },\n    buttonAbortItemProcessing: { opacity: 0 },\n    buttonRetryItemProcessing: { opacity: 0 },\n    buttonRevertItemProcessing: { opacity: 0 },\n    loadProgressIndicator: { opacity: 0, align: getLoadIndicatorAlignment },\n    processProgressIndicator: {\n      opacity: 0,\n      align: getProcessIndicatorAlignment\n    },\n    processingCompleteIndicator: { opacity: 0, scaleX: 0.75, scaleY: 0.75 },\n    info: { translateX: 0, translateY: 0, opacity: 0 },\n    status: { translateX: 0, translateY: 0, opacity: 0 }\n  };\n\n  var IdleStyle = {\n    buttonRemoveItem: { opacity: 1 },\n    buttonProcessItem: { opacity: 1 },\n    info: { translateX: calculateFileInfoOffset },\n    status: { translateX: calculateFileInfoOffset }\n  };\n\n  var ProcessingStyle = {\n    buttonAbortItemProcessing: { opacity: 1 },\n    processProgressIndicator: { opacity: 1 },\n    status: { opacity: 1 }\n  };\n\n  var StyleMap = {\n    DID_THROW_ITEM_INVALID: {\n      buttonRemoveItem: { opacity: 1 },\n      info: { translateX: calculateFileInfoOffset },\n      status: { translateX: calculateFileInfoOffset, opacity: 1 }\n    },\n\n    DID_START_ITEM_LOAD: {\n      buttonAbortItemLoad: { opacity: 1 },\n      loadProgressIndicator: { opacity: 1 },\n      status: { opacity: 1 }\n    },\n\n    DID_THROW_ITEM_LOAD_ERROR: {\n      buttonRetryItemLoad: { opacity: 1 },\n      buttonRemoveItem: { opacity: 1 },\n      info: { translateX: calculateFileInfoOffset },\n      status: { opacity: 1 }\n    },\n\n    DID_START_ITEM_REMOVE: {\n      processProgressIndicator: {\n        opacity: 1,\n        align: getRemoveIndicatorAligment\n      },\n      info: { translateX: calculateFileInfoOffset },\n      status: { opacity: 0 }\n    },\n\n    DID_THROW_ITEM_REMOVE_ERROR: {\n      processProgressIndicator: {\n        opacity: 0,\n        align: getRemoveIndicatorAligment\n      },\n      buttonRemoveItem: { opacity: 1 },\n      info: { translateX: calculateFileInfoOffset },\n      status: { opacity: 1, translateX: calculateFileInfoOffset }\n    },\n\n    DID_LOAD_ITEM: IdleStyle,\n    DID_LOAD_LOCAL_ITEM: {\n      buttonRemoveItem: { opacity: 1 },\n      info: { translateX: calculateFileInfoOffset },\n      status: { translateX: calculateFileInfoOffset }\n    },\n\n    DID_START_ITEM_PROCESSING: ProcessingStyle,\n    DID_REQUEST_ITEM_PROCESSING: ProcessingStyle,\n    DID_UPDATE_ITEM_PROCESS_PROGRESS: ProcessingStyle,\n    DID_COMPLETE_ITEM_PROCESSING: {\n      buttonRevertItemProcessing: { opacity: 1 },\n      info: { opacity: 1 },\n      status: { opacity: 1 }\n    },\n\n    DID_THROW_ITEM_PROCESSING_ERROR: {\n      buttonRemoveItem: { opacity: 1 },\n      buttonRetryItemProcessing: { opacity: 1 },\n      status: { opacity: 1 },\n      info: { translateX: calculateFileInfoOffset }\n    },\n\n    DID_THROW_ITEM_PROCESSING_REVERT_ERROR: {\n      buttonRevertItemProcessing: { opacity: 1 },\n      status: { opacity: 1 },\n      info: { opacity: 1 }\n    },\n\n    DID_ABORT_ITEM_PROCESSING: {\n      buttonRemoveItem: { opacity: 1 },\n      buttonProcessItem: { opacity: 1 },\n      info: { translateX: calculateFileInfoOffset },\n      status: { opacity: 1 }\n    },\n\n    DID_REVERT_ITEM_PROCESSING: IdleStyle\n  };\n\n  // complete indicator view\n  var processingCompleteIndicatorView = createView({\n    create: function create(_ref) {\n      var root = _ref.root;\n      root.element.innerHTML = root.query('GET_ICON_DONE');\n    },\n    name: 'processing-complete-indicator',\n    ignoreRect: true,\n    mixins: {\n      styles: ['scaleX', 'scaleY', 'opacity'],\n      animations: {\n        scaleX: 'spring',\n        scaleY: 'spring',\n        opacity: { type: 'tween', duration: 250 }\n      }\n    }\n  });\n\n  /**\n   * Creates the file view\n   */\n  var create$4 = function create(_ref2) {\n    var root = _ref2.root,\n      props = _ref2.props;\n    var id = props.id;\n\n    // allow reverting upload\n    var allowRevert = root.query('GET_ALLOW_REVERT');\n\n    // allow remove file\n    var allowRemove = root.query('GET_ALLOW_REMOVE');\n\n    // allow processing upload\n    var allowProcess = root.query('GET_ALLOW_PROCESS');\n\n    // is instant uploading, need this to determine the icon of the undo button\n    var instantUpload = root.query('GET_INSTANT_UPLOAD');\n\n    // is async set up\n    var isAsync = root.query('IS_ASYNC');\n\n    // should align remove item buttons\n    var alignRemoveItemButton = root.query(\n      'GET_STYLE_BUTTON_REMOVE_ITEM_ALIGN'\n    );\n\n    // enabled buttons array\n    var buttonFilter;\n    if (isAsync) {\n      if (allowProcess && !allowRevert) {\n        // only remove revert button\n        buttonFilter = function buttonFilter(key) {\n          return !/RevertItemProcessing/.test(key);\n        };\n      } else if (!allowProcess && allowRevert) {\n        // only remove process button\n        buttonFilter = function buttonFilter(key) {\n          return !/ProcessItem|RetryItemProcessing|AbortItemProcessing/.test(\n            key\n          );\n        };\n      } else if (!allowProcess && !allowRevert) {\n        // remove all process buttons\n        buttonFilter = function buttonFilter(key) {\n          return !/Process/.test(key);\n        };\n      }\n    } else {\n      // no process controls available\n      buttonFilter = function buttonFilter(key) {\n        return !/Process/.test(key);\n      };\n    }\n\n    var enabledButtons = buttonFilter\n      ? ButtonKeys.filter(buttonFilter)\n      : ButtonKeys.concat();\n\n    // update icon and label for revert button when instant uploading\n    if (instantUpload && allowRevert) {\n      Buttons['RevertItemProcessing'].label = 'GET_LABEL_BUTTON_REMOVE_ITEM';\n      Buttons['RevertItemProcessing'].icon = 'GET_ICON_REMOVE';\n    }\n\n    // remove last button (revert) if not allowed\n    if (isAsync && !allowRevert) {\n      var map = StyleMap['DID_COMPLETE_ITEM_PROCESSING'];\n      map.info.translateX = calculateFileHorizontalCenterOffset;\n      map.info.translateY = calculateFileVerticalCenterOffset;\n      map.status.translateY = calculateFileVerticalCenterOffset;\n      map.processingCompleteIndicator = { opacity: 1, scaleX: 1, scaleY: 1 };\n    }\n\n    // should align center\n    if (isAsync && !allowProcess) {\n      [\n        'DID_START_ITEM_PROCESSING',\n        'DID_REQUEST_ITEM_PROCESSING',\n        'DID_UPDATE_ITEM_PROCESS_PROGRESS',\n        'DID_THROW_ITEM_PROCESSING_ERROR'\n      ].forEach(function(key) {\n        StyleMap[key].status.translateY = calculateFileVerticalCenterOffset;\n      });\n      StyleMap[\n        'DID_THROW_ITEM_PROCESSING_ERROR'\n      ].status.translateX = calculateButtonWidth;\n    }\n\n    // move remove button to right\n    if (alignRemoveItemButton && allowRevert) {\n      Buttons['RevertItemProcessing'].align = 'BUTTON_REMOVE_ITEM_POSITION';\n      var _map = StyleMap['DID_COMPLETE_ITEM_PROCESSING'];\n      _map.info.translateX = calculateFileInfoOffset;\n      _map.status.translateY = calculateFileVerticalCenterOffset;\n      _map.processingCompleteIndicator = { opacity: 1, scaleX: 1, scaleY: 1 };\n    }\n\n    if (!allowRemove) {\n      Buttons['RemoveItem'].disabled = true;\n    }\n\n    // create the button views\n    forin(Buttons, function(key, definition) {\n      // create button\n      var buttonView = root.createChildView(fileActionButton, {\n        label: root.query(definition.label),\n        icon: root.query(definition.icon),\n        opacity: 0\n      });\n\n      // should be appended?\n      if (enabledButtons.includes(key)) {\n        root.appendChildView(buttonView);\n      }\n\n      // toggle\n      if (definition.disabled) {\n        buttonView.element.setAttribute('disabled', 'disabled');\n        buttonView.element.setAttribute('hidden', 'hidden');\n      }\n\n      // add position attribute\n      buttonView.element.dataset.align = root.query(\n        'GET_STYLE_' + definition.align\n      );\n\n      // add class\n      buttonView.element.classList.add(definition.className);\n\n      // handle interactions\n      buttonView.on('click', function(e) {\n        e.stopPropagation();\n        if (definition.disabled) return;\n        root.dispatch(definition.action, { query: id });\n      });\n\n      // set reference\n      root.ref['button' + key] = buttonView;\n    });\n\n    // checkmark\n    root.ref.processingCompleteIndicator = root.appendChildView(\n      root.createChildView(processingCompleteIndicatorView)\n    );\n    root.ref.processingCompleteIndicator.element.dataset.align = root.query(\n      'GET_STYLE_BUTTON_PROCESS_ITEM_POSITION'\n    );\n\n    // create file info view\n    root.ref.info = root.appendChildView(\n      root.createChildView(fileInfo, { id: id })\n    );\n\n    // create file status view\n    root.ref.status = root.appendChildView(\n      root.createChildView(fileStatus, { id: id })\n    );\n\n    // add progress indicators\n    var loadIndicatorView = root.appendChildView(\n      root.createChildView(progressIndicator, {\n        opacity: 0,\n        align: root.query('GET_STYLE_LOAD_INDICATOR_POSITION')\n      })\n    );\n\n    loadIndicatorView.element.classList.add('filepond--load-indicator');\n    root.ref.loadProgressIndicator = loadIndicatorView;\n\n    var progressIndicatorView = root.appendChildView(\n      root.createChildView(progressIndicator, {\n        opacity: 0,\n        align: root.query('GET_STYLE_PROGRESS_INDICATOR_POSITION')\n      })\n    );\n\n    progressIndicatorView.element.classList.add('filepond--process-indicator');\n    root.ref.processProgressIndicator = progressIndicatorView;\n\n    // current active styles\n    root.ref.activeStyles = [];\n  };\n\n  var write$2 = function write(_ref3) {\n    var root = _ref3.root,\n      actions = _ref3.actions,\n      props = _ref3.props;\n\n    // route actions\n    route({ root: root, actions: actions, props: props });\n\n    // select last state change action\n    var action = actions\n      .concat()\n      .filter(function(action) {\n        return /^DID_/.test(action.type);\n      })\n      .reverse()\n      .find(function(action) {\n        return StyleMap[action.type];\n      });\n\n    // a new action happened, let's get the matching styles\n    if (action) {\n      // define new active styles\n      root.ref.activeStyles = [];\n\n      var stylesToApply = StyleMap[action.type];\n      forin(DefaultStyle, function(name, defaultStyles) {\n        // get reference to control\n        var control = root.ref[name];\n\n        // loop over all styles for this control\n        forin(defaultStyles, function(key, defaultValue) {\n          var value =\n            stylesToApply[name] &&\n            typeof stylesToApply[name][key] !== 'undefined'\n              ? stylesToApply[name][key]\n              : defaultValue;\n          root.ref.activeStyles.push({\n            control: control,\n            key: key,\n            value: value\n          });\n        });\n      });\n    }\n\n    // apply active styles to element\n    root.ref.activeStyles.forEach(function(_ref4) {\n      var control = _ref4.control,\n        key = _ref4.key,\n        value = _ref4.value;\n      control[key] = typeof value === 'function' ? value(root) : value;\n    });\n  };\n\n  var route = createRoute({\n    DID_SET_LABEL_BUTTON_ABORT_ITEM_PROCESSING: function DID_SET_LABEL_BUTTON_ABORT_ITEM_PROCESSING(\n      _ref5\n    ) {\n      var root = _ref5.root,\n        action = _ref5.action;\n      root.ref.buttonAbortItemProcessing.label = action.value;\n    },\n    DID_SET_LABEL_BUTTON_ABORT_ITEM_LOAD: function DID_SET_LABEL_BUTTON_ABORT_ITEM_LOAD(\n      _ref6\n    ) {\n      var root = _ref6.root,\n        action = _ref6.action;\n      root.ref.buttonAbortItemLoad.label = action.value;\n    },\n    DID_SET_LABEL_BUTTON_ABORT_ITEM_REMOVAL: function DID_SET_LABEL_BUTTON_ABORT_ITEM_REMOVAL(\n      _ref7\n    ) {\n      var root = _ref7.root,\n        action = _ref7.action;\n      root.ref.buttonAbortItemRemoval.label = action.value;\n    },\n    DID_REQUEST_ITEM_PROCESSING: function DID_REQUEST_ITEM_PROCESSING(_ref8) {\n      var root = _ref8.root;\n      root.ref.processProgressIndicator.spin = true;\n      root.ref.processProgressIndicator.progress = 0;\n    },\n    DID_START_ITEM_LOAD: function DID_START_ITEM_LOAD(_ref9) {\n      var root = _ref9.root;\n      root.ref.loadProgressIndicator.spin = true;\n      root.ref.loadProgressIndicator.progress = 0;\n    },\n    DID_START_ITEM_REMOVE: function DID_START_ITEM_REMOVE(_ref10) {\n      var root = _ref10.root;\n      root.ref.processProgressIndicator.spin = true;\n      root.ref.processProgressIndicator.progress = 0;\n    },\n    DID_UPDATE_ITEM_LOAD_PROGRESS: function DID_UPDATE_ITEM_LOAD_PROGRESS(\n      _ref11\n    ) {\n      var root = _ref11.root,\n        action = _ref11.action;\n      root.ref.loadProgressIndicator.spin = false;\n      root.ref.loadProgressIndicator.progress = action.progress;\n    },\n    DID_UPDATE_ITEM_PROCESS_PROGRESS: function DID_UPDATE_ITEM_PROCESS_PROGRESS(\n      _ref12\n    ) {\n      var root = _ref12.root,\n        action = _ref12.action;\n      root.ref.processProgressIndicator.spin = false;\n      root.ref.processProgressIndicator.progress = action.progress;\n    }\n  });\n\n  var file = createView({\n    create: create$4,\n    write: write$2,\n    didCreateView: function didCreateView(root) {\n      applyFilters('CREATE_VIEW', Object.assign({}, root, { view: root }));\n    },\n    name: 'file'\n  });\n\n  /**\n   * Creates the file view\n   */\n  var create$5 = function create(_ref) {\n    var root = _ref.root,\n      props = _ref.props;\n\n    // filename\n    root.ref.fileName = createElement$1('legend');\n    root.appendChild(root.ref.fileName);\n\n    // file appended\n    root.ref.file = root.appendChildView(\n      root.createChildView(file, { id: props.id })\n    );\n\n    // data has moved to data.js\n    root.ref.data = false;\n  };\n\n  /**\n   * Data storage\n   */\n  var didLoadItem = function didLoadItem(_ref2) {\n    var root = _ref2.root,\n      props = _ref2.props;\n    // updates the legend of the fieldset so screenreaders can better group buttons\n    text(\n      root.ref.fileName,\n      formatFilename(root.query('GET_ITEM_NAME', props.id))\n    );\n  };\n\n  var fileWrapper = createView({\n    create: create$5,\n    ignoreRect: true,\n    write: createRoute({\n      DID_LOAD_ITEM: didLoadItem\n    }),\n\n    didCreateView: function didCreateView(root) {\n      applyFilters('CREATE_VIEW', Object.assign({}, root, { view: root }));\n    },\n    tag: 'fieldset',\n    name: 'file-wrapper'\n  });\n\n  var PANEL_SPRING_PROPS = { type: 'spring', damping: 0.6, mass: 7 };\n\n  var create$6 = function create(_ref) {\n    var root = _ref.root,\n      props = _ref.props;\n    [\n      {\n        name: 'top'\n      },\n\n      {\n        name: 'center',\n        props: {\n          translateY: null,\n          scaleY: null\n        },\n\n        mixins: {\n          animations: {\n            scaleY: PANEL_SPRING_PROPS\n          },\n\n          styles: ['translateY', 'scaleY']\n        }\n      },\n\n      {\n        name: 'bottom',\n        props: {\n          translateY: null\n        },\n\n        mixins: {\n          animations: {\n            translateY: PANEL_SPRING_PROPS\n          },\n\n          styles: ['translateY']\n        }\n      }\n    ].forEach(function(section) {\n      createSection(root, section, props.name);\n    });\n\n    root.element.classList.add('filepond--' + props.name);\n\n    root.ref.scalable = null;\n  };\n\n  var createSection = function createSection(root, section, className) {\n    var viewConstructor = createView({\n      name: 'panel-' + section.name + ' filepond--' + className,\n      mixins: section.mixins,\n      ignoreRectUpdate: true\n    });\n\n    var view = root.createChildView(viewConstructor, section.props);\n\n    root.ref[section.name] = root.appendChildView(view);\n  };\n\n  var write$3 = function write(_ref2) {\n    var root = _ref2.root,\n      props = _ref2.props;\n\n    // update scalable state\n    if (root.ref.scalable === null || props.scalable !== root.ref.scalable) {\n      root.ref.scalable = isBoolean(props.scalable) ? props.scalable : true;\n      root.element.dataset.scalable = root.ref.scalable;\n    }\n\n    // no height, can't set\n    if (!props.height) return;\n\n    // get child rects\n    var topRect = root.ref.top.rect.element;\n    var bottomRect = root.ref.bottom.rect.element;\n\n    // make sure height never is smaller than bottom and top seciton heights combined (will probably never happen, but who knows)\n    var height = Math.max(topRect.height + bottomRect.height, props.height);\n\n    // offset center part\n    root.ref.center.translateY = topRect.height;\n\n    // scale center part\n    // use math ceil to prevent transparent lines because of rounding errors\n    root.ref.center.scaleY =\n      (height - topRect.height - bottomRect.height) / 100;\n\n    // offset bottom part\n    root.ref.bottom.translateY = height - bottomRect.height;\n  };\n\n  var panel = createView({\n    name: 'panel',\n    read: function read(_ref3) {\n      var root = _ref3.root,\n        props = _ref3.props;\n      return (props.heightCurrent = root.ref.bottom.translateY);\n    },\n    write: write$3,\n    create: create$6,\n    ignoreRect: true,\n    mixins: {\n      apis: ['height', 'heightCurrent', 'scalable']\n    }\n  });\n\n  var createDragHelper = function createDragHelper(items) {\n    var itemIds = items.map(function(item) {\n      return item.id;\n    });\n    var prevIndex = undefined;\n    return {\n      setIndex: function setIndex(index) {\n        prevIndex = index;\n      },\n      getIndex: function getIndex() {\n        return prevIndex;\n      },\n      getItemIndex: function getItemIndex(item) {\n        return itemIds.indexOf(item.id);\n      }\n    };\n  };\n\n  var ITEM_TRANSLATE_SPRING = {\n    type: 'spring',\n    stiffness: 0.75,\n    damping: 0.45,\n    mass: 10\n  };\n\n  var ITEM_SCALE_SPRING = 'spring';\n\n  var StateMap = {\n    DID_START_ITEM_LOAD: 'busy',\n    DID_UPDATE_ITEM_LOAD_PROGRESS: 'loading',\n    DID_THROW_ITEM_INVALID: 'load-invalid',\n    DID_THROW_ITEM_LOAD_ERROR: 'load-error',\n    DID_LOAD_ITEM: 'idle',\n    DID_THROW_ITEM_REMOVE_ERROR: 'remove-error',\n    DID_START_ITEM_REMOVE: 'busy',\n    DID_START_ITEM_PROCESSING: 'busy processing',\n    DID_REQUEST_ITEM_PROCESSING: 'busy processing',\n    DID_UPDATE_ITEM_PROCESS_PROGRESS: 'processing',\n    DID_COMPLETE_ITEM_PROCESSING: 'processing-complete',\n    DID_THROW_ITEM_PROCESSING_ERROR: 'processing-error',\n    DID_THROW_ITEM_PROCESSING_REVERT_ERROR: 'processing-revert-error',\n    DID_ABORT_ITEM_PROCESSING: 'cancelled',\n    DID_REVERT_ITEM_PROCESSING: 'idle'\n  };\n\n  /**\n   * Creates the file view\n   */\n  var create$7 = function create(_ref) {\n    var root = _ref.root,\n      props = _ref.props;\n\n    // select\n    root.ref.handleClick = function(e) {\n      return root.dispatch('DID_ACTIVATE_ITEM', { id: props.id });\n    };\n\n    // set id\n    root.element.id = 'filepond--item-' + props.id;\n    root.element.addEventListener('click', root.ref.handleClick);\n\n    // file view\n    root.ref.container = root.appendChildView(\n      root.createChildView(fileWrapper, { id: props.id })\n    );\n\n    // file panel\n    root.ref.panel = root.appendChildView(\n      root.createChildView(panel, { name: 'item-panel' })\n    );\n\n    // default start height\n    root.ref.panel.height = null;\n\n    // by default not marked for removal\n    props.markedForRemoval = false;\n\n    // if not allowed to reorder file items, exit here\n    if (!root.query('GET_ALLOW_REORDER')) return;\n\n    // set to idle so shows grab cursor\n    root.element.dataset.dragState = 'idle';\n\n    var grab = function grab(e) {\n      if (!e.isPrimary) return;\n\n      var removedActivateListener = false;\n\n      var origin = {\n        x: e.pageX,\n        y: e.pageY\n      };\n\n      props.dragOrigin = {\n        x: root.translateX,\n        y: root.translateY\n      };\n\n      props.dragCenter = {\n        x: e.offsetX,\n        y: e.offsetY\n      };\n\n      var dragState = createDragHelper(root.query('GET_ACTIVE_ITEMS'));\n\n      root.dispatch('DID_GRAB_ITEM', { id: props.id, dragState: dragState });\n\n      var drag = function drag(e) {\n        if (!e.isPrimary) return;\n\n        e.stopPropagation();\n        e.preventDefault();\n\n        props.dragOffset = {\n          x: e.pageX - origin.x,\n          y: e.pageY - origin.y\n        };\n\n        // if dragged stop listening to clicks, will re-add when done dragging\n        var dist =\n          props.dragOffset.x * props.dragOffset.x +\n          props.dragOffset.y * props.dragOffset.y;\n        if (dist > 16 && !removedActivateListener) {\n          removedActivateListener = true;\n          root.element.removeEventListener('click', root.ref.handleClick);\n        }\n\n        root.dispatch('DID_DRAG_ITEM', { id: props.id, dragState: dragState });\n      };\n\n      var drop = function drop(e) {\n        if (!e.isPrimary) return;\n\n        document.removeEventListener('pointermove', drag);\n        document.removeEventListener('pointerup', drop);\n\n        props.dragOffset = {\n          x: e.pageX - origin.x,\n          y: e.pageY - origin.y\n        };\n\n        root.dispatch('DID_DROP_ITEM', { id: props.id, dragState: dragState });\n\n        // start listening to clicks again\n        if (removedActivateListener) {\n          setTimeout(function() {\n            return root.element.addEventListener('click', root.ref.handleClick);\n          }, 0);\n        }\n      };\n\n      document.addEventListener('pointermove', drag);\n      document.addEventListener('pointerup', drop);\n    };\n\n    root.element.addEventListener('pointerdown', grab);\n  };\n\n  var route$1 = createRoute({\n    DID_UPDATE_PANEL_HEIGHT: function DID_UPDATE_PANEL_HEIGHT(_ref2) {\n      var root = _ref2.root,\n        action = _ref2.action;\n      root.height = action.height;\n    }\n  });\n\n  var write$4 = createRoute(\n    {\n      DID_GRAB_ITEM: function DID_GRAB_ITEM(_ref3) {\n        var root = _ref3.root,\n          props = _ref3.props;\n        props.dragOrigin = {\n          x: root.translateX,\n          y: root.translateY\n        };\n      },\n      DID_DRAG_ITEM: function DID_DRAG_ITEM(_ref4) {\n        var root = _ref4.root;\n        root.element.dataset.dragState = 'drag';\n      },\n      DID_DROP_ITEM: function DID_DROP_ITEM(_ref5) {\n        var root = _ref5.root,\n          props = _ref5.props;\n        props.dragOffset = null;\n        props.dragOrigin = null;\n        root.element.dataset.dragState = 'drop';\n      }\n    },\n    function(_ref6) {\n      var root = _ref6.root,\n        actions = _ref6.actions,\n        props = _ref6.props,\n        shouldOptimize = _ref6.shouldOptimize;\n\n      if (root.element.dataset.dragState === 'drop') {\n        if (root.scaleX <= 1) {\n          root.element.dataset.dragState = 'idle';\n        }\n      }\n\n      // select last state change action\n      var action = actions\n        .concat()\n        .filter(function(action) {\n          return /^DID_/.test(action.type);\n        })\n        .reverse()\n        .find(function(action) {\n          return StateMap[action.type];\n        });\n\n      // no need to set same state twice\n      if (action && action.type !== props.currentState) {\n        // set current state\n        props.currentState = action.type;\n\n        // set state\n        root.element.dataset.filepondItemState =\n          StateMap[props.currentState] || '';\n      }\n\n      // route actions\n      var aspectRatio =\n        root.query('GET_ITEM_PANEL_ASPECT_RATIO') ||\n        root.query('GET_PANEL_ASPECT_RATIO');\n      if (!aspectRatio) {\n        route$1({ root: root, actions: actions, props: props });\n        if (!root.height && root.ref.container.rect.element.height > 0) {\n          root.height = root.ref.container.rect.element.height;\n        }\n      } else if (!shouldOptimize) {\n        root.height = root.rect.element.width * aspectRatio;\n      }\n\n      // sync panel height with item height\n      if (shouldOptimize) {\n        root.ref.panel.height = null;\n      }\n\n      root.ref.panel.height = root.height;\n    }\n  );\n\n  var item = createView({\n    create: create$7,\n    write: write$4,\n    destroy: function destroy(_ref7) {\n      var root = _ref7.root,\n        props = _ref7.props;\n      root.element.removeEventListener('click', root.ref.handleClick);\n      root.dispatch('RELEASE_ITEM', { query: props.id });\n    },\n    tag: 'li',\n    name: 'item',\n    mixins: {\n      apis: [\n        'id',\n        'interactionMethod',\n        'markedForRemoval',\n        'spawnDate',\n        'dragCenter',\n        'dragOrigin',\n        'dragOffset'\n      ],\n      styles: [\n        'translateX',\n        'translateY',\n        'scaleX',\n        'scaleY',\n        'opacity',\n        'height'\n      ],\n\n      animations: {\n        scaleX: ITEM_SCALE_SPRING,\n        scaleY: ITEM_SCALE_SPRING,\n        translateX: ITEM_TRANSLATE_SPRING,\n        translateY: ITEM_TRANSLATE_SPRING,\n        opacity: { type: 'tween', duration: 150 }\n      }\n    }\n  });\n\n  var getItemIndexByPosition = function getItemIndexByPosition(\n    view,\n    children,\n    positionInView\n  ) {\n    if (!positionInView) return;\n\n    var horizontalSpace = view.rect.element.width;\n    // const children = view.childViews;\n    var l = children.length;\n    var last = null;\n\n    // -1, don't move items to accomodate (either add to top or bottom)\n    if (l === 0 || positionInView.top < children[0].rect.element.top) return -1;\n\n    // let's get the item width\n    var item = children[0];\n    var itemRect = item.rect.element;\n    var itemHorizontalMargin = itemRect.marginLeft + itemRect.marginRight;\n    var itemWidth = itemRect.width + itemHorizontalMargin;\n    var itemsPerRow = Math.round(horizontalSpace / itemWidth);\n\n    // stack\n    if (itemsPerRow === 1) {\n      for (var index = 0; index < l; index++) {\n        var child = children[index];\n        var childMid = child.rect.outer.top + child.rect.element.height * 0.5;\n        if (positionInView.top < childMid) {\n          return index;\n        }\n      }\n      return l;\n    }\n\n    // grid\n    var itemVerticalMargin = itemRect.marginTop + itemRect.marginBottom;\n    var itemHeight = itemRect.height + itemVerticalMargin;\n    for (var _index = 0; _index < l; _index++) {\n      var indexX = _index % itemsPerRow;\n      var indexY = Math.floor(_index / itemsPerRow);\n\n      var offsetX = indexX * itemWidth;\n      var offsetY = indexY * itemHeight;\n\n      var itemTop = offsetY - itemRect.marginTop;\n      var itemRight = offsetX + itemWidth;\n      var itemBottom = offsetY + itemHeight + itemRect.marginBottom;\n\n      if (positionInView.top < itemBottom && positionInView.top > itemTop) {\n        if (positionInView.left < itemRight) {\n          return _index;\n        } else if (_index !== l - 1) {\n          last = _index;\n        } else {\n          last = null;\n        }\n      }\n    }\n\n    if (last !== null) {\n      return last;\n    }\n\n    return l;\n  };\n\n  var dropAreaDimensions = {\n    height: 0,\n    width: 0,\n    get getHeight() {\n      return this.height;\n    },\n    set setHeight(val) {\n      if (this.height === 0 || val === 0) this.height = val;\n    },\n    get getWidth() {\n      return this.width;\n    },\n    set setWidth(val) {\n      if (this.width === 0 || val === 0) this.width = val;\n    },\n    setDimensions: function setDimensions(height, width) {\n      if (this.height === 0 || height === 0) this.height = height;\n      if (this.width === 0 || width === 0) this.width = width;\n    }\n  };\n\n  var create$8 = function create(_ref) {\n    var root = _ref.root;\n    // need to set role to list as otherwise it won't be read as a list by VoiceOver\n    attr(root.element, 'role', 'list');\n\n    root.ref.lastItemSpanwDate = Date.now();\n  };\n\n  /**\n   * Inserts a new item\n   * @param root\n   * @param action\n   */\n  var addItemView = function addItemView(_ref2) {\n    var root = _ref2.root,\n      action = _ref2.action;\n    var id = action.id,\n      index = action.index,\n      interactionMethod = action.interactionMethod;\n\n    root.ref.addIndex = index;\n\n    var now = Date.now();\n    var spawnDate = now;\n    var opacity = 1;\n\n    if (interactionMethod !== InteractionMethod.NONE) {\n      opacity = 0;\n      var cooldown = root.query('GET_ITEM_INSERT_INTERVAL');\n      var dist = now - root.ref.lastItemSpanwDate;\n      spawnDate = dist < cooldown ? now + (cooldown - dist) : now;\n    }\n\n    root.ref.lastItemSpanwDate = spawnDate;\n\n    root.appendChildView(\n      root.createChildView(\n        // view type\n        item,\n\n        // props\n        {\n          spawnDate: spawnDate,\n          id: id,\n          opacity: opacity,\n          interactionMethod: interactionMethod\n        }\n      ),\n\n      index\n    );\n  };\n\n  var moveItem = function moveItem(item, x, y) {\n    var vx =\n      arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    var vy =\n      arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;\n\n    // set to null to remove animation while dragging\n    if (item.dragOffset) {\n      item.translateX = null;\n      item.translateY = null;\n      item.translateX = item.dragOrigin.x + item.dragOffset.x;\n      item.translateY = item.dragOrigin.y + item.dragOffset.y;\n      item.scaleX = 1.025;\n      item.scaleY = 1.025;\n    } else {\n      item.translateX = x;\n      item.translateY = y;\n\n      if (Date.now() > item.spawnDate) {\n        // reveal element\n        if (item.opacity === 0) {\n          introItemView(item, x, y, vx, vy);\n        }\n\n        // make sure is default scale every frame\n        item.scaleX = 1;\n        item.scaleY = 1;\n        item.opacity = 1;\n      }\n    }\n  };\n\n  var introItemView = function introItemView(item, x, y, vx, vy) {\n    if (item.interactionMethod === InteractionMethod.NONE) {\n      item.translateX = null;\n      item.translateX = x;\n      item.translateY = null;\n      item.translateY = y;\n    } else if (item.interactionMethod === InteractionMethod.DROP) {\n      item.translateX = null;\n      item.translateX = x - vx * 20;\n\n      item.translateY = null;\n      item.translateY = y - vy * 10;\n\n      item.scaleX = 0.8;\n      item.scaleY = 0.8;\n    } else if (item.interactionMethod === InteractionMethod.BROWSE) {\n      item.translateY = null;\n      item.translateY = y - 30;\n    } else if (item.interactionMethod === InteractionMethod.API) {\n      item.translateX = null;\n      item.translateX = x - 30;\n      item.translateY = null;\n    }\n  };\n\n  /**\n   * Removes an existing item\n   * @param root\n   * @param action\n   */\n  var removeItemView = function removeItemView(_ref3) {\n    var root = _ref3.root,\n      action = _ref3.action;\n    var id = action.id;\n\n    // get the view matching the given id\n    var view = root.childViews.find(function(child) {\n      return child.id === id;\n    });\n\n    // if no view found, exit\n    if (!view) {\n      return;\n    }\n\n    // animate view out of view\n    view.scaleX = 0.9;\n    view.scaleY = 0.9;\n    view.opacity = 0;\n\n    // mark for removal\n    view.markedForRemoval = true;\n  };\n\n  var getItemHeight = function getItemHeight(child) {\n    return (\n      child.rect.element.height +\n      child.rect.element.marginBottom * 0.5 +\n      child.rect.element.marginTop * 0.5\n    );\n  };\n  var getItemWidth = function getItemWidth(child) {\n    return (\n      child.rect.element.width +\n      child.rect.element.marginLeft * 0.5 +\n      child.rect.element.marginRight * 0.5\n    );\n  };\n\n  var dragItem = function dragItem(_ref4) {\n    var root = _ref4.root,\n      action = _ref4.action;\n    var id = action.id,\n      dragState = action.dragState;\n\n    // reference to item\n    var item = root.query('GET_ITEM', { id: id });\n\n    // get the view matching the given id\n    var view = root.childViews.find(function(child) {\n      return child.id === id;\n    });\n\n    var numItems = root.childViews.length;\n    var oldIndex = dragState.getItemIndex(item);\n\n    // if no view found, exit\n    if (!view) return;\n\n    var dragPosition = {\n      x: view.dragOrigin.x + view.dragOffset.x + view.dragCenter.x,\n      y: view.dragOrigin.y + view.dragOffset.y + view.dragCenter.y\n\n      // get drag area dimensions\n    };\n    var dragHeight = getItemHeight(view);\n    var dragWidth = getItemWidth(view);\n\n    // get rows and columns (There will always be at least one row and one column if a file is present)\n    var cols = Math.floor(root.rect.outer.width / dragWidth);\n    if (cols > numItems) cols = numItems;\n\n    // rows are used to find when we have left the preview area bounding box\n    var rows = Math.floor(numItems / cols + 1);\n\n    dropAreaDimensions.setHeight = dragHeight * rows;\n    dropAreaDimensions.setWidth = dragWidth * cols;\n\n    // get new index of dragged item\n    var location = {\n      y: Math.floor(dragPosition.y / dragHeight),\n      x: Math.floor(dragPosition.x / dragWidth),\n      getGridIndex: function getGridIndex() {\n        if (\n          dragPosition.y > dropAreaDimensions.getHeight ||\n          dragPosition.y < 0 ||\n          dragPosition.x > dropAreaDimensions.getWidth ||\n          dragPosition.x < 0\n        )\n          return oldIndex;\n        return this.y * cols + this.x;\n      },\n      getColIndex: function getColIndex() {\n        var items = root.query('GET_ACTIVE_ITEMS');\n        var visibleChildren = root.childViews.filter(function(child) {\n          return child.rect.element.height;\n        });\n        var children = items.map(function(item) {\n          return visibleChildren.find(function(childView) {\n            return childView.id === item.id;\n          });\n        });\n        var currentIndex = children.findIndex(function(child) {\n          return child === view;\n        });\n        var dragHeight = getItemHeight(view);\n        var l = children.length;\n        var idx = l;\n        var childHeight = 0;\n        var childBottom = 0;\n        var childTop = 0;\n        for (var i = 0; i < l; i++) {\n          childHeight = getItemHeight(children[i]);\n          childTop = childBottom;\n          childBottom = childTop + childHeight;\n          if (dragPosition.y < childBottom) {\n            if (currentIndex > i) {\n              if (dragPosition.y < childTop + dragHeight) {\n                idx = i;\n                break;\n              }\n              continue;\n            }\n            idx = i;\n            break;\n          }\n        }\n        return idx;\n      }\n\n      // get new index\n    };\n    var index = cols > 1 ? location.getGridIndex() : location.getColIndex();\n    root.dispatch('MOVE_ITEM', { query: view, index: index });\n\n    // if the index of the item changed, dispatch reorder action\n    var currentIndex = dragState.getIndex();\n\n    if (currentIndex === undefined || currentIndex !== index) {\n      dragState.setIndex(index);\n\n      if (currentIndex === undefined) return;\n\n      root.dispatch('DID_REORDER_ITEMS', {\n        items: root.query('GET_ACTIVE_ITEMS'),\n        origin: oldIndex,\n        target: index\n      });\n    }\n  };\n\n  /**\n   * Setup action routes\n   */\n  var route$2 = createRoute({\n    DID_ADD_ITEM: addItemView,\n    DID_REMOVE_ITEM: removeItemView,\n    DID_DRAG_ITEM: dragItem\n  });\n\n  /**\n   * Write to view\n   * @param root\n   * @param actions\n   * @param props\n   */\n  var write$5 = function write(_ref5) {\n    var root = _ref5.root,\n      props = _ref5.props,\n      actions = _ref5.actions,\n      shouldOptimize = _ref5.shouldOptimize;\n\n    // route actions\n    route$2({ root: root, props: props, actions: actions });\n    var dragCoordinates = props.dragCoordinates;\n\n    // available space on horizontal axis\n    var horizontalSpace = root.rect.element.width;\n\n    // only draw children that have dimensions\n    var visibleChildren = root.childViews.filter(function(child) {\n      return child.rect.element.height;\n    });\n\n    // sort based on current active items\n    var children = root\n      .query('GET_ACTIVE_ITEMS')\n      .map(function(item) {\n        return visibleChildren.find(function(child) {\n          return child.id === item.id;\n        });\n      })\n      .filter(function(item) {\n        return item;\n      });\n\n    // get index\n    var dragIndex = dragCoordinates\n      ? getItemIndexByPosition(root, children, dragCoordinates)\n      : null;\n\n    // add index is used to reserve the dropped/added item index till the actual item is rendered\n    var addIndex = root.ref.addIndex || null;\n\n    // add index no longer needed till possibly next draw\n    root.ref.addIndex = null;\n\n    var dragIndexOffset = 0;\n    var removeIndexOffset = 0;\n    var addIndexOffset = 0;\n\n    if (children.length === 0) return;\n\n    var childRect = children[0].rect.element;\n    var itemVerticalMargin = childRect.marginTop + childRect.marginBottom;\n    var itemHorizontalMargin = childRect.marginLeft + childRect.marginRight;\n    var itemWidth = childRect.width + itemHorizontalMargin;\n    var itemHeight = childRect.height + itemVerticalMargin;\n    var itemsPerRow = Math.round(horizontalSpace / itemWidth);\n\n    // stack\n    if (itemsPerRow === 1) {\n      var offsetY = 0;\n      var dragOffset = 0;\n\n      children.forEach(function(child, index) {\n        if (dragIndex) {\n          var dist = index - dragIndex;\n          if (dist === -2) {\n            dragOffset = -itemVerticalMargin * 0.25;\n          } else if (dist === -1) {\n            dragOffset = -itemVerticalMargin * 0.75;\n          } else if (dist === 0) {\n            dragOffset = itemVerticalMargin * 0.75;\n          } else if (dist === 1) {\n            dragOffset = itemVerticalMargin * 0.25;\n          } else {\n            dragOffset = 0;\n          }\n        }\n\n        if (shouldOptimize) {\n          child.translateX = null;\n          child.translateY = null;\n        }\n\n        if (!child.markedForRemoval) {\n          moveItem(child, 0, offsetY + dragOffset);\n        }\n\n        var itemHeight = child.rect.element.height + itemVerticalMargin;\n\n        var visualHeight =\n          itemHeight * (child.markedForRemoval ? child.opacity : 1);\n\n        offsetY += visualHeight;\n      });\n    }\n    // grid\n    else {\n      var prevX = 0;\n      var prevY = 0;\n\n      children.forEach(function(child, index) {\n        if (index === dragIndex) {\n          dragIndexOffset = 1;\n        }\n\n        if (index === addIndex) {\n          addIndexOffset += 1;\n        }\n\n        if (child.markedForRemoval && child.opacity < 0.5) {\n          removeIndexOffset -= 1;\n        }\n\n        var visualIndex =\n          index + addIndexOffset + dragIndexOffset + removeIndexOffset;\n\n        var indexX = visualIndex % itemsPerRow;\n        var indexY = Math.floor(visualIndex / itemsPerRow);\n\n        var offsetX = indexX * itemWidth;\n        var offsetY = indexY * itemHeight;\n\n        var vectorX = Math.sign(offsetX - prevX);\n        var vectorY = Math.sign(offsetY - prevY);\n\n        prevX = offsetX;\n        prevY = offsetY;\n\n        if (child.markedForRemoval) return;\n\n        if (shouldOptimize) {\n          child.translateX = null;\n          child.translateY = null;\n        }\n\n        moveItem(child, offsetX, offsetY, vectorX, vectorY);\n      });\n    }\n  };\n\n  /**\n   * Filters actions that are meant specifically for a certain child of the list\n   * @param child\n   * @param actions\n   */\n  var filterSetItemActions = function filterSetItemActions(child, actions) {\n    return actions.filter(function(action) {\n      // if action has an id, filter out actions that don't have this child id\n      if (action.data && action.data.id) {\n        return child.id === action.data.id;\n      }\n\n      // allow all other actions\n      return true;\n    });\n  };\n\n  var list = createView({\n    create: create$8,\n    write: write$5,\n    tag: 'ul',\n    name: 'list',\n    didWriteView: function didWriteView(_ref6) {\n      var root = _ref6.root;\n      root.childViews\n        .filter(function(view) {\n          return view.markedForRemoval && view.opacity === 0 && view.resting;\n        })\n        .forEach(function(view) {\n          view._destroy();\n          root.removeChildView(view);\n        });\n    },\n    filterFrameActionsForChild: filterSetItemActions,\n    mixins: {\n      apis: ['dragCoordinates']\n    }\n  });\n\n  var create$9 = function create(_ref) {\n    var root = _ref.root,\n      props = _ref.props;\n    root.ref.list = root.appendChildView(root.createChildView(list));\n    props.dragCoordinates = null;\n    props.overflowing = false;\n  };\n\n  var storeDragCoordinates = function storeDragCoordinates(_ref2) {\n    var root = _ref2.root,\n      props = _ref2.props,\n      action = _ref2.action;\n    if (!root.query('GET_ITEM_INSERT_LOCATION_FREEDOM')) return;\n    props.dragCoordinates = {\n      left: action.position.scopeLeft - root.ref.list.rect.element.left,\n      top:\n        action.position.scopeTop -\n        (root.rect.outer.top +\n          root.rect.element.marginTop +\n          root.rect.element.scrollTop)\n    };\n  };\n\n  var clearDragCoordinates = function clearDragCoordinates(_ref3) {\n    var props = _ref3.props;\n    props.dragCoordinates = null;\n  };\n\n  var route$3 = createRoute({\n    DID_DRAG: storeDragCoordinates,\n    DID_END_DRAG: clearDragCoordinates\n  });\n\n  var write$6 = function write(_ref4) {\n    var root = _ref4.root,\n      props = _ref4.props,\n      actions = _ref4.actions;\n\n    // route actions\n    route$3({ root: root, props: props, actions: actions });\n\n    // current drag position\n    root.ref.list.dragCoordinates = props.dragCoordinates;\n\n    // if currently overflowing but no longer received overflow\n    if (props.overflowing && !props.overflow) {\n      props.overflowing = false;\n\n      // reset overflow state\n      root.element.dataset.state = '';\n      root.height = null;\n    }\n\n    // if is not overflowing currently but does receive overflow value\n    if (props.overflow) {\n      var newHeight = Math.round(props.overflow);\n      if (newHeight !== root.height) {\n        props.overflowing = true;\n        root.element.dataset.state = 'overflow';\n        root.height = newHeight;\n      }\n    }\n  };\n\n  var listScroller = createView({\n    create: create$9,\n    write: write$6,\n    name: 'list-scroller',\n    mixins: {\n      apis: ['overflow', 'dragCoordinates'],\n      styles: ['height', 'translateY'],\n      animations: {\n        translateY: 'spring'\n      }\n    }\n  });\n\n  var attrToggle = function attrToggle(element, name, state) {\n    var enabledValue =\n      arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';\n    if (state) {\n      attr(element, name, enabledValue);\n    } else {\n      element.removeAttribute(name);\n    }\n  };\n\n  var resetFileInput = function resetFileInput(input) {\n    // no value, no need to reset\n    if (!input || input.value === '') {\n      return;\n    }\n\n    try {\n      // for modern browsers\n      input.value = '';\n    } catch (err) {}\n\n    // for IE10\n    if (input.value) {\n      // quickly append input to temp form and reset form\n      var form = createElement$1('form');\n      var parentNode = input.parentNode;\n      var ref = input.nextSibling;\n      form.appendChild(input);\n      form.reset();\n\n      // re-inject input where it originally was\n      if (ref) {\n        parentNode.insertBefore(input, ref);\n      } else {\n        parentNode.appendChild(input);\n      }\n    }\n  };\n\n  var create$a = function create(_ref) {\n    var root = _ref.root,\n      props = _ref.props;\n\n    // set id so can be referenced from outside labels\n    root.element.id = 'filepond--browser-' + props.id;\n\n    // set name of element (is removed when a value is set)\n    attr(root.element, 'name', root.query('GET_NAME'));\n\n    // we have to link this element to the status element\n    attr(root.element, 'aria-controls', 'filepond--assistant-' + props.id);\n\n    // set label, we use labelled by as otherwise the screenreader does not read the \"browse\" text in the label (as it has tabindex: 0)\n    attr(root.element, 'aria-labelledby', 'filepond--drop-label-' + props.id);\n\n    // set configurable props\n    setAcceptedFileTypes({\n      root: root,\n      action: { value: root.query('GET_ACCEPTED_FILE_TYPES') }\n    });\n    toggleAllowMultiple({\n      root: root,\n      action: { value: root.query('GET_ALLOW_MULTIPLE') }\n    });\n    toggleDirectoryFilter({\n      root: root,\n      action: { value: root.query('GET_ALLOW_DIRECTORIES_ONLY') }\n    });\n    toggleDisabled({ root: root });\n    toggleRequired({\n      root: root,\n      action: { value: root.query('GET_REQUIRED') }\n    });\n    setCaptureMethod({\n      root: root,\n      action: { value: root.query('GET_CAPTURE_METHOD') }\n    });\n\n    // handle changes to the input field\n    root.ref.handleChange = function(e) {\n      if (!root.element.value) {\n        return;\n      }\n\n      // extract files and move value of webkitRelativePath path to _relativePath\n      var files = Array.from(root.element.files).map(function(file) {\n        file._relativePath = file.webkitRelativePath;\n        return file;\n      });\n\n      // we add a little delay so the OS file select window can move out of the way before we add our file\n      setTimeout(function() {\n        // load files\n        props.onload(files);\n\n        // reset input, it's just for exposing a method to drop files, should not retain any state\n        resetFileInput(root.element);\n      }, 250);\n    };\n\n    root.element.addEventListener('change', root.ref.handleChange);\n  };\n\n  var setAcceptedFileTypes = function setAcceptedFileTypes(_ref2) {\n    var root = _ref2.root,\n      action = _ref2.action;\n    if (!root.query('GET_ALLOW_SYNC_ACCEPT_ATTRIBUTE')) return;\n    attrToggle(\n      root.element,\n      'accept',\n      !!action.value,\n      action.value ? action.value.join(',') : ''\n    );\n  };\n\n  var toggleAllowMultiple = function toggleAllowMultiple(_ref3) {\n    var root = _ref3.root,\n      action = _ref3.action;\n    attrToggle(root.element, 'multiple', action.value);\n  };\n\n  var toggleDirectoryFilter = function toggleDirectoryFilter(_ref4) {\n    var root = _ref4.root,\n      action = _ref4.action;\n    attrToggle(root.element, 'webkitdirectory', action.value);\n  };\n\n  var toggleDisabled = function toggleDisabled(_ref5) {\n    var root = _ref5.root;\n    var isDisabled = root.query('GET_DISABLED');\n    var doesAllowBrowse = root.query('GET_ALLOW_BROWSE');\n    var disableField = isDisabled || !doesAllowBrowse;\n    attrToggle(root.element, 'disabled', disableField);\n  };\n\n  var toggleRequired = function toggleRequired(_ref6) {\n    var root = _ref6.root,\n      action = _ref6.action;\n    // want to remove required, always possible\n    if (!action.value) {\n      attrToggle(root.element, 'required', false);\n    }\n    // if want to make required, only possible when zero items\n    else if (root.query('GET_TOTAL_ITEMS') === 0) {\n      attrToggle(root.element, 'required', true);\n    }\n  };\n\n  var setCaptureMethod = function setCaptureMethod(_ref7) {\n    var root = _ref7.root,\n      action = _ref7.action;\n    attrToggle(\n      root.element,\n      'capture',\n      !!action.value,\n      action.value === true ? '' : action.value\n    );\n  };\n\n  var updateRequiredStatus = function updateRequiredStatus(_ref8) {\n    var root = _ref8.root;\n    var element = root.element;\n    // always remove the required attribute when more than zero items\n    if (root.query('GET_TOTAL_ITEMS') > 0) {\n      attrToggle(element, 'required', false);\n      attrToggle(element, 'name', false);\n    } else {\n      // add name attribute\n      attrToggle(element, 'name', true, root.query('GET_NAME'));\n\n      // remove any validation messages\n      var shouldCheckValidity = root.query('GET_CHECK_VALIDITY');\n      if (shouldCheckValidity) {\n        element.setCustomValidity('');\n      }\n\n      // we only add required if the field has been deemed required\n      if (root.query('GET_REQUIRED')) {\n        attrToggle(element, 'required', true);\n      }\n    }\n  };\n\n  var updateFieldValidityStatus = function updateFieldValidityStatus(_ref9) {\n    var root = _ref9.root;\n    var shouldCheckValidity = root.query('GET_CHECK_VALIDITY');\n    if (!shouldCheckValidity) return;\n    root.element.setCustomValidity(root.query('GET_LABEL_INVALID_FIELD'));\n  };\n\n  var browser = createView({\n    tag: 'input',\n    name: 'browser',\n    ignoreRect: true,\n    ignoreRectUpdate: true,\n    attributes: {\n      type: 'file'\n    },\n\n    create: create$a,\n    destroy: function destroy(_ref10) {\n      var root = _ref10.root;\n      root.element.removeEventListener('change', root.ref.handleChange);\n    },\n    write: createRoute({\n      DID_LOAD_ITEM: updateRequiredStatus,\n      DID_REMOVE_ITEM: updateRequiredStatus,\n      DID_THROW_ITEM_INVALID: updateFieldValidityStatus,\n\n      DID_SET_DISABLED: toggleDisabled,\n      DID_SET_ALLOW_BROWSE: toggleDisabled,\n      DID_SET_ALLOW_DIRECTORIES_ONLY: toggleDirectoryFilter,\n      DID_SET_ALLOW_MULTIPLE: toggleAllowMultiple,\n      DID_SET_ACCEPTED_FILE_TYPES: setAcceptedFileTypes,\n      DID_SET_CAPTURE_METHOD: setCaptureMethod,\n      DID_SET_REQUIRED: toggleRequired\n    })\n  });\n\n  var Key = {\n    ENTER: 13,\n    SPACE: 32\n  };\n\n  var create$b = function create(_ref) {\n    var root = _ref.root,\n      props = _ref.props;\n\n    // create the label and link it to the file browser\n    var label = createElement$1('label');\n    attr(label, 'for', 'filepond--browser-' + props.id);\n\n    // use for labeling file input (aria-labelledby on file input)\n    attr(label, 'id', 'filepond--drop-label-' + props.id);\n\n    // hide the label for screenreaders, the input element will read the contents of the label when it's focussed. If we don't set aria-hidden the screenreader will also navigate the contents of the label separately from the input.\n    attr(label, 'aria-hidden', 'true');\n\n    // handle keys\n    root.ref.handleKeyDown = function(e) {\n      var isActivationKey = e.keyCode === Key.ENTER || e.keyCode === Key.SPACE;\n      if (!isActivationKey) return;\n      // stops from triggering the element a second time\n      e.preventDefault();\n\n      // click link (will then in turn activate file input)\n      root.ref.label.click();\n    };\n\n    root.ref.handleClick = function(e) {\n      var isLabelClick = e.target === label || label.contains(e.target);\n\n      // don't want to click twice\n      if (isLabelClick) return;\n\n      // click link (will then in turn activate file input)\n      root.ref.label.click();\n    };\n\n    // attach events\n    label.addEventListener('keydown', root.ref.handleKeyDown);\n    root.element.addEventListener('click', root.ref.handleClick);\n\n    // update\n    updateLabelValue(label, props.caption);\n\n    // add!\n    root.appendChild(label);\n    root.ref.label = label;\n  };\n\n  var updateLabelValue = function updateLabelValue(label, value) {\n    label.innerHTML = value;\n    var clickable = label.querySelector('.filepond--label-action');\n    if (clickable) {\n      attr(clickable, 'tabindex', '0');\n    }\n    return value;\n  };\n\n  var dropLabel = createView({\n    name: 'drop-label',\n    ignoreRect: true,\n    create: create$b,\n    destroy: function destroy(_ref2) {\n      var root = _ref2.root;\n      root.ref.label.addEventListener('keydown', root.ref.handleKeyDown);\n      root.element.removeEventListener('click', root.ref.handleClick);\n    },\n    write: createRoute({\n      DID_SET_LABEL_IDLE: function DID_SET_LABEL_IDLE(_ref3) {\n        var root = _ref3.root,\n          action = _ref3.action;\n        updateLabelValue(root.ref.label, action.value);\n      }\n    }),\n\n    mixins: {\n      styles: ['opacity', 'translateX', 'translateY'],\n      animations: {\n        opacity: { type: 'tween', duration: 150 },\n        translateX: 'spring',\n        translateY: 'spring'\n      }\n    }\n  });\n\n  var blob = createView({\n    name: 'drip-blob',\n    ignoreRect: true,\n    mixins: {\n      styles: ['translateX', 'translateY', 'scaleX', 'scaleY', 'opacity'],\n      animations: {\n        scaleX: 'spring',\n        scaleY: 'spring',\n        translateX: 'spring',\n        translateY: 'spring',\n        opacity: { type: 'tween', duration: 250 }\n      }\n    }\n  });\n\n  var addBlob = function addBlob(_ref) {\n    var root = _ref.root;\n    var centerX = root.rect.element.width * 0.5;\n    var centerY = root.rect.element.height * 0.5;\n\n    root.ref.blob = root.appendChildView(\n      root.createChildView(blob, {\n        opacity: 0,\n        scaleX: 2.5,\n        scaleY: 2.5,\n        translateX: centerX,\n        translateY: centerY\n      })\n    );\n  };\n\n  var moveBlob = function moveBlob(_ref2) {\n    var root = _ref2.root,\n      action = _ref2.action;\n    if (!root.ref.blob) {\n      addBlob({ root: root });\n      return;\n    }\n\n    root.ref.blob.translateX = action.position.scopeLeft;\n    root.ref.blob.translateY = action.position.scopeTop;\n    root.ref.blob.scaleX = 1;\n    root.ref.blob.scaleY = 1;\n    root.ref.blob.opacity = 1;\n  };\n\n  var hideBlob = function hideBlob(_ref3) {\n    var root = _ref3.root;\n    if (!root.ref.blob) {\n      return;\n    }\n    root.ref.blob.opacity = 0;\n  };\n\n  var explodeBlob = function explodeBlob(_ref4) {\n    var root = _ref4.root;\n    if (!root.ref.blob) {\n      return;\n    }\n    root.ref.blob.scaleX = 2.5;\n    root.ref.blob.scaleY = 2.5;\n    root.ref.blob.opacity = 0;\n  };\n\n  var write$7 = function write(_ref5) {\n    var root = _ref5.root,\n      props = _ref5.props,\n      actions = _ref5.actions;\n    route$4({ root: root, props: props, actions: actions });\n    var blob = root.ref.blob;\n\n    if (actions.length === 0 && blob && blob.opacity === 0) {\n      root.removeChildView(blob);\n      root.ref.blob = null;\n    }\n  };\n\n  var route$4 = createRoute({\n    DID_DRAG: moveBlob,\n    DID_DROP: explodeBlob,\n    DID_END_DRAG: hideBlob\n  });\n\n  var drip = createView({\n    ignoreRect: true,\n    ignoreRectUpdate: true,\n    name: 'drip',\n    write: write$7\n  });\n\n  var create$c = function create(_ref) {\n    var root = _ref.root;\n    return (root.ref.fields = {});\n  };\n\n  var getField = function getField(root, id) {\n    return root.ref.fields[id];\n  };\n\n  var syncFieldPositionsWithItems = function syncFieldPositionsWithItems(root) {\n    root.query('GET_ACTIVE_ITEMS').forEach(function(item) {\n      if (!root.ref.fields[item.id]) return;\n      root.element.appendChild(root.ref.fields[item.id]);\n    });\n  };\n\n  var didReorderItems = function didReorderItems(_ref2) {\n    var root = _ref2.root;\n    return syncFieldPositionsWithItems(root);\n  };\n\n  var didAddItem = function didAddItem(_ref3) {\n    var root = _ref3.root,\n      action = _ref3.action;\n    var dataContainer = createElement$1('input');\n    dataContainer.type = 'hidden';\n    dataContainer.name = root.query('GET_NAME');\n    dataContainer.disabled = root.query('GET_DISABLED');\n    root.ref.fields[action.id] = dataContainer;\n    syncFieldPositionsWithItems(root);\n  };\n\n  var didLoadItem$1 = function didLoadItem(_ref4) {\n    var root = _ref4.root,\n      action = _ref4.action;\n    var field = getField(root, action.id);\n    if (!field || action.serverFileReference === null) return;\n    field.value = action.serverFileReference;\n  };\n\n  var didSetDisabled = function didSetDisabled(_ref5) {\n    var root = _ref5.root;\n    root.element.disabled = root.query('GET_DISABLED');\n  };\n\n  var didRemoveItem = function didRemoveItem(_ref6) {\n    var root = _ref6.root,\n      action = _ref6.action;\n    var field = getField(root, action.id);\n    if (!field) return;\n    if (field.parentNode) field.parentNode.removeChild(field);\n    delete root.ref.fields[action.id];\n  };\n\n  var didDefineValue = function didDefineValue(_ref7) {\n    var root = _ref7.root,\n      action = _ref7.action;\n    var field = getField(root, action.id);\n    if (!field) return;\n    if (action.value === null) {\n      field.removeAttribute('value');\n    } else {\n      field.value = action.value;\n    }\n    syncFieldPositionsWithItems(root);\n  };\n\n  var write$8 = createRoute({\n    DID_SET_DISABLED: didSetDisabled,\n    DID_ADD_ITEM: didAddItem,\n    DID_LOAD_ITEM: didLoadItem$1,\n    DID_REMOVE_ITEM: didRemoveItem,\n    DID_DEFINE_VALUE: didDefineValue,\n    DID_REORDER_ITEMS: didReorderItems,\n    DID_SORT_ITEMS: didReorderItems\n  });\n\n  var data = createView({\n    tag: 'fieldset',\n    name: 'data',\n    create: create$c,\n    write: write$8,\n    ignoreRect: true\n  });\n\n  var getRootNode = function getRootNode(element) {\n    return 'getRootNode' in element ? element.getRootNode() : document;\n  };\n\n  var images = ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'webp', 'svg', 'tiff'];\n  var text$1 = ['css', 'csv', 'html', 'txt'];\n  var map = {\n    zip: 'zip|compressed',\n    epub: 'application/epub+zip'\n  };\n\n  var guesstimateMimeType = function guesstimateMimeType() {\n    var extension =\n      arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    extension = extension.toLowerCase();\n    if (images.includes(extension)) {\n      return (\n        'image/' +\n        (extension === 'jpg'\n          ? 'jpeg'\n          : extension === 'svg'\n          ? 'svg+xml'\n          : extension)\n      );\n    }\n    if (text$1.includes(extension)) {\n      return 'text/' + extension;\n    }\n\n    return map[extension] || '';\n  };\n\n  var requestDataTransferItems = function requestDataTransferItems(\n    dataTransfer\n  ) {\n    return new Promise(function(resolve, reject) {\n      // try to get links from transfer, if found we'll exit immediately (unless a file is in the dataTransfer as well, this is because Firefox could represent the file as a URL and a file object at the same time)\n      var links = getLinks(dataTransfer);\n      if (links.length && !hasFiles(dataTransfer)) {\n        return resolve(links);\n      }\n      // try to get files from the transfer\n      getFiles(dataTransfer).then(resolve);\n    });\n  };\n\n  /**\n   * Test if datatransfer has files\n   */\n  var hasFiles = function hasFiles(dataTransfer) {\n    if (dataTransfer.files) return dataTransfer.files.length > 0;\n    return false;\n  };\n\n  /**\n   * Extracts files from a DataTransfer object\n   */\n  var getFiles = function getFiles(dataTransfer) {\n    return new Promise(function(resolve, reject) {\n      // get the transfer items as promises\n      var promisedFiles = (dataTransfer.items\n        ? Array.from(dataTransfer.items)\n        : []\n      )\n        // only keep file system items (files and directories)\n        .filter(function(item) {\n          return isFileSystemItem(item);\n        })\n\n        // map each item to promise\n        .map(function(item) {\n          return getFilesFromItem(item);\n        });\n\n      // if is empty, see if we can extract some info from the files property as a fallback\n      if (!promisedFiles.length) {\n        // TODO: test for directories (should not be allowed)\n        // Use FileReader, problem is that the files property gets lost in the process\n        resolve(dataTransfer.files ? Array.from(dataTransfer.files) : []);\n        return;\n      }\n\n      // done!\n      Promise.all(promisedFiles)\n        .then(function(returnedFileGroups) {\n          // flatten groups\n          var files = [];\n          returnedFileGroups.forEach(function(group) {\n            files.push.apply(files, group);\n          });\n\n          // done (filter out empty files)!\n          resolve(\n            files\n              .filter(function(file) {\n                return file;\n              })\n              .map(function(file) {\n                if (!file._relativePath)\n                  file._relativePath = file.webkitRelativePath;\n                return file;\n              })\n          );\n        })\n        .catch(console.error);\n    });\n  };\n\n  var isFileSystemItem = function isFileSystemItem(item) {\n    if (isEntry(item)) {\n      var entry = getAsEntry(item);\n      if (entry) {\n        return entry.isFile || entry.isDirectory;\n      }\n    }\n    return item.kind === 'file';\n  };\n\n  var getFilesFromItem = function getFilesFromItem(item) {\n    return new Promise(function(resolve, reject) {\n      if (isDirectoryEntry(item)) {\n        getFilesInDirectory(getAsEntry(item))\n          .then(resolve)\n          .catch(reject);\n        return;\n      }\n\n      resolve([item.getAsFile()]);\n    });\n  };\n\n  var getFilesInDirectory = function getFilesInDirectory(entry) {\n    return new Promise(function(resolve, reject) {\n      var files = [];\n\n      // the total entries to read\n      var dirCounter = 0;\n      var fileCounter = 0;\n\n      var resolveIfDone = function resolveIfDone() {\n        if (fileCounter === 0 && dirCounter === 0) {\n          resolve(files);\n        }\n      };\n\n      // the recursive function\n      var readEntries = function readEntries(dirEntry) {\n        dirCounter++;\n\n        var directoryReader = dirEntry.createReader();\n\n        // directories are returned in batches, we need to process all batches before we're done\n        var readBatch = function readBatch() {\n          directoryReader.readEntries(function(entries) {\n            if (entries.length === 0) {\n              dirCounter--;\n              resolveIfDone();\n              return;\n            }\n\n            entries.forEach(function(entry) {\n              // recursively read more directories\n              if (entry.isDirectory) {\n                readEntries(entry);\n              } else {\n                // read as file\n                fileCounter++;\n\n                entry.file(function(file) {\n                  var correctedFile = correctMissingFileType(file);\n                  if (entry.fullPath)\n                    correctedFile._relativePath = entry.fullPath;\n                  files.push(correctedFile);\n                  fileCounter--;\n                  resolveIfDone();\n                });\n              }\n            });\n\n            // try to get next batch of files\n            readBatch();\n          }, reject);\n        };\n\n        // read first batch of files\n        readBatch();\n      };\n\n      // go!\n      readEntries(entry);\n    });\n  };\n\n  var correctMissingFileType = function correctMissingFileType(file) {\n    if (file.type.length) return file;\n    var date = file.lastModifiedDate;\n    var name = file.name;\n    var type = guesstimateMimeType(getExtensionFromFilename(file.name));\n    if (!type.length) return file;\n    file = file.slice(0, file.size, type);\n    file.name = name;\n    file.lastModifiedDate = date;\n    return file;\n  };\n\n  var isDirectoryEntry = function isDirectoryEntry(item) {\n    return isEntry(item) && (getAsEntry(item) || {}).isDirectory;\n  };\n\n  var isEntry = function isEntry(item) {\n    return 'webkitGetAsEntry' in item;\n  };\n\n  var getAsEntry = function getAsEntry(item) {\n    return item.webkitGetAsEntry();\n  };\n\n  /**\n   * Extracts links from a DataTransfer object\n   */\n  var getLinks = function getLinks(dataTransfer) {\n    var links = [];\n    try {\n      // look in meta data property\n      links = getLinksFromTransferMetaData(dataTransfer);\n      if (links.length) {\n        return links;\n      }\n      links = getLinksFromTransferURLData(dataTransfer);\n    } catch (e) {\n      // nope nope nope (probably IE trouble)\n    }\n    return links;\n  };\n\n  var getLinksFromTransferURLData = function getLinksFromTransferURLData(\n    dataTransfer\n  ) {\n    var data = dataTransfer.getData('url');\n    if (typeof data === 'string' && data.length) {\n      return [data];\n    }\n    return [];\n  };\n\n  var getLinksFromTransferMetaData = function getLinksFromTransferMetaData(\n    dataTransfer\n  ) {\n    var data = dataTransfer.getData('text/html');\n    if (typeof data === 'string' && data.length) {\n      var matches = data.match(/src\\s*=\\s*\"(.+?)\"/);\n      if (matches) {\n        return [matches[1]];\n      }\n    }\n    return [];\n  };\n\n  var dragNDropObservers = [];\n\n  var eventPosition = function eventPosition(e) {\n    return {\n      pageLeft: e.pageX,\n      pageTop: e.pageY,\n      scopeLeft: e.offsetX || e.layerX,\n      scopeTop: e.offsetY || e.layerY\n    };\n  };\n\n  var createDragNDropClient = function createDragNDropClient(\n    element,\n    scopeToObserve,\n    filterElement\n  ) {\n    var observer = getDragNDropObserver(scopeToObserve);\n\n    var client = {\n      element: element,\n      filterElement: filterElement,\n      state: null,\n      ondrop: function ondrop() {},\n      onenter: function onenter() {},\n      ondrag: function ondrag() {},\n      onexit: function onexit() {},\n      onload: function onload() {},\n      allowdrop: function allowdrop() {}\n    };\n\n    client.destroy = observer.addListener(client);\n\n    return client;\n  };\n\n  var getDragNDropObserver = function getDragNDropObserver(element) {\n    // see if already exists, if so, return\n    var observer = dragNDropObservers.find(function(item) {\n      return item.element === element;\n    });\n    if (observer) {\n      return observer;\n    }\n\n    // create new observer, does not yet exist for this element\n    var newObserver = createDragNDropObserver(element);\n    dragNDropObservers.push(newObserver);\n    return newObserver;\n  };\n\n  var createDragNDropObserver = function createDragNDropObserver(element) {\n    var clients = [];\n\n    var routes = {\n      dragenter: dragenter,\n      dragover: dragover,\n      dragleave: dragleave,\n      drop: drop\n    };\n\n    var handlers = {};\n\n    forin(routes, function(event, createHandler) {\n      handlers[event] = createHandler(element, clients);\n      element.addEventListener(event, handlers[event], false);\n    });\n\n    var observer = {\n      element: element,\n      addListener: function addListener(client) {\n        // add as client\n        clients.push(client);\n\n        // return removeListener function\n        return function() {\n          // remove client\n          clients.splice(clients.indexOf(client), 1);\n\n          // if no more clients, clean up observer\n          if (clients.length === 0) {\n            dragNDropObservers.splice(dragNDropObservers.indexOf(observer), 1);\n\n            forin(routes, function(event) {\n              element.removeEventListener(event, handlers[event], false);\n            });\n          }\n        };\n      }\n    };\n\n    return observer;\n  };\n\n  var elementFromPoint = function elementFromPoint(root, point) {\n    if (!('elementFromPoint' in root)) {\n      root = document;\n    }\n    return root.elementFromPoint(point.x, point.y);\n  };\n\n  var isEventTarget = function isEventTarget(e, target) {\n    // get root\n    var root = getRootNode(target);\n\n    // get element at position\n    // if root is not actual shadow DOM and does not have elementFromPoint method, use the one on document\n    var elementAtPosition = elementFromPoint(root, {\n      x: e.pageX - window.pageXOffset,\n      y: e.pageY - window.pageYOffset\n    });\n\n    // test if target is the element or if one of its children is\n    return elementAtPosition === target || target.contains(elementAtPosition);\n  };\n\n  var initialTarget = null;\n\n  var setDropEffect = function setDropEffect(dataTransfer, effect) {\n    // is in try catch as IE11 will throw error if not\n    try {\n      dataTransfer.dropEffect = effect;\n    } catch (e) {}\n  };\n\n  var dragenter = function dragenter(root, clients) {\n    return function(e) {\n      e.preventDefault();\n\n      initialTarget = e.target;\n\n      clients.forEach(function(client) {\n        var element = client.element,\n          onenter = client.onenter;\n\n        if (isEventTarget(e, element)) {\n          client.state = 'enter';\n\n          // fire enter event\n          onenter(eventPosition(e));\n        }\n      });\n    };\n  };\n\n  var dragover = function dragover(root, clients) {\n    return function(e) {\n      e.preventDefault();\n\n      var dataTransfer = e.dataTransfer;\n\n      requestDataTransferItems(dataTransfer).then(function(items) {\n        var overDropTarget = false;\n\n        clients.some(function(client) {\n          var filterElement = client.filterElement,\n            element = client.element,\n            onenter = client.onenter,\n            onexit = client.onexit,\n            ondrag = client.ondrag,\n            allowdrop = client.allowdrop;\n\n          // by default we can drop\n          setDropEffect(dataTransfer, 'copy');\n\n          // allow transfer of these items\n          var allowsTransfer = allowdrop(items);\n\n          // only used when can be dropped on page\n          if (!allowsTransfer) {\n            setDropEffect(dataTransfer, 'none');\n            return;\n          }\n\n          // targetting this client\n          if (isEventTarget(e, element)) {\n            overDropTarget = true;\n\n            // had no previous state, means we are entering this client\n            if (client.state === null) {\n              client.state = 'enter';\n              onenter(eventPosition(e));\n              return;\n            }\n\n            // now over element (no matter if it allows the drop or not)\n            client.state = 'over';\n\n            // needs to allow transfer\n            if (filterElement && !allowsTransfer) {\n              setDropEffect(dataTransfer, 'none');\n              return;\n            }\n\n            // dragging\n            ondrag(eventPosition(e));\n          } else {\n            // should be over an element to drop\n            if (filterElement && !overDropTarget) {\n              setDropEffect(dataTransfer, 'none');\n            }\n\n            // might have just left this client?\n            if (client.state) {\n              client.state = null;\n              onexit(eventPosition(e));\n            }\n          }\n        });\n      });\n    };\n  };\n\n  var drop = function drop(root, clients) {\n    return function(e) {\n      e.preventDefault();\n\n      var dataTransfer = e.dataTransfer;\n\n      requestDataTransferItems(dataTransfer).then(function(items) {\n        clients.forEach(function(client) {\n          var filterElement = client.filterElement,\n            element = client.element,\n            ondrop = client.ondrop,\n            onexit = client.onexit,\n            allowdrop = client.allowdrop;\n\n          client.state = null;\n\n          // if we're filtering on element we need to be over the element to drop\n          if (filterElement && !isEventTarget(e, element)) return;\n\n          // no transfer for this client\n          if (!allowdrop(items)) return onexit(eventPosition(e));\n\n          // we can drop these items on this client\n          ondrop(eventPosition(e), items);\n        });\n      });\n    };\n  };\n\n  var dragleave = function dragleave(root, clients) {\n    return function(e) {\n      if (initialTarget !== e.target) {\n        return;\n      }\n\n      clients.forEach(function(client) {\n        var onexit = client.onexit;\n\n        client.state = null;\n\n        onexit(eventPosition(e));\n      });\n    };\n  };\n\n  var createHopper = function createHopper(scope, validateItems, options) {\n    // is now hopper scope\n    scope.classList.add('filepond--hopper');\n\n    // shortcuts\n    var catchesDropsOnPage = options.catchesDropsOnPage,\n      requiresDropOnElement = options.requiresDropOnElement,\n      _options$filterItems = options.filterItems,\n      filterItems =\n        _options$filterItems === void 0\n          ? function(items) {\n              return items;\n            }\n          : _options$filterItems;\n\n    // create a dnd client\n    var client = createDragNDropClient(\n      scope,\n      catchesDropsOnPage ? document.documentElement : scope,\n      requiresDropOnElement\n    );\n\n    // current client state\n    var lastState = '';\n    var currentState = '';\n\n    // determines if a file may be dropped\n    client.allowdrop = function(items) {\n      // TODO: if we can, throw error to indicate the items cannot by dropped\n\n      return validateItems(filterItems(items));\n    };\n\n    client.ondrop = function(position, items) {\n      var filteredItems = filterItems(items);\n\n      if (!validateItems(filteredItems)) {\n        api.ondragend(position);\n        return;\n      }\n\n      currentState = 'drag-drop';\n\n      api.onload(filteredItems, position);\n    };\n\n    client.ondrag = function(position) {\n      api.ondrag(position);\n    };\n\n    client.onenter = function(position) {\n      currentState = 'drag-over';\n\n      api.ondragstart(position);\n    };\n\n    client.onexit = function(position) {\n      currentState = 'drag-exit';\n\n      api.ondragend(position);\n    };\n\n    var api = {\n      updateHopperState: function updateHopperState() {\n        if (lastState !== currentState) {\n          scope.dataset.hopperState = currentState;\n          lastState = currentState;\n        }\n      },\n      onload: function onload() {},\n      ondragstart: function ondragstart() {},\n      ondrag: function ondrag() {},\n      ondragend: function ondragend() {},\n      destroy: function destroy() {\n        // destroy client\n        client.destroy();\n      }\n    };\n\n    return api;\n  };\n\n  var listening = false;\n  var listeners$1 = [];\n\n  var handlePaste = function handlePaste(e) {\n    // if is pasting in input or textarea and the target is outside of a filepond scope, ignore\n    var activeEl = document.activeElement;\n    if (activeEl && /textarea|input/i.test(activeEl.nodeName)) {\n      // test textarea or input is contained in filepond root\n      var inScope = false;\n      var element = activeEl;\n      while (element !== document.body) {\n        if (element.classList.contains('filepond--root')) {\n          inScope = true;\n          break;\n        }\n        element = element.parentNode;\n      }\n\n      if (!inScope) return;\n    }\n\n    requestDataTransferItems(e.clipboardData).then(function(files) {\n      // no files received\n      if (!files.length) {\n        return;\n      }\n\n      // notify listeners of received files\n      listeners$1.forEach(function(listener) {\n        return listener(files);\n      });\n    });\n  };\n\n  var listen = function listen(cb) {\n    // can't add twice\n    if (listeners$1.includes(cb)) {\n      return;\n    }\n\n    // add initial listener\n    listeners$1.push(cb);\n\n    // setup paste listener for entire page\n    if (listening) {\n      return;\n    }\n\n    listening = true;\n    document.addEventListener('paste', handlePaste);\n  };\n\n  var unlisten = function unlisten(listener) {\n    arrayRemove(listeners$1, listeners$1.indexOf(listener));\n\n    // clean up\n    if (listeners$1.length === 0) {\n      document.removeEventListener('paste', handlePaste);\n      listening = false;\n    }\n  };\n\n  var createPaster = function createPaster() {\n    var cb = function cb(files) {\n      api.onload(files);\n    };\n\n    var api = {\n      destroy: function destroy() {\n        unlisten(cb);\n      },\n      onload: function onload() {}\n    };\n\n    listen(cb);\n\n    return api;\n  };\n\n  /**\n   * Creates the file view\n   */\n  var create$d = function create(_ref) {\n    var root = _ref.root,\n      props = _ref.props;\n    root.element.id = 'filepond--assistant-' + props.id;\n    attr(root.element, 'role', 'status');\n    attr(root.element, 'aria-live', 'polite');\n    attr(root.element, 'aria-relevant', 'additions');\n  };\n\n  var addFilesNotificationTimeout = null;\n  var notificationClearTimeout = null;\n\n  var filenames = [];\n\n  var assist = function assist(root, message) {\n    root.element.textContent = message;\n  };\n\n  var clear$1 = function clear(root) {\n    root.element.textContent = '';\n  };\n\n  var listModified = function listModified(root, filename, label) {\n    var total = root.query('GET_TOTAL_ITEMS');\n    assist(\n      root,\n      label +\n        ' ' +\n        filename +\n        ', ' +\n        total +\n        ' ' +\n        (total === 1\n          ? root.query('GET_LABEL_FILE_COUNT_SINGULAR')\n          : root.query('GET_LABEL_FILE_COUNT_PLURAL'))\n    );\n\n    // clear group after set amount of time so the status is not read twice\n    clearTimeout(notificationClearTimeout);\n    notificationClearTimeout = setTimeout(function() {\n      clear$1(root);\n    }, 1500);\n  };\n\n  var isUsingFilePond = function isUsingFilePond(root) {\n    return root.element.parentNode.contains(document.activeElement);\n  };\n\n  var itemAdded = function itemAdded(_ref2) {\n    var root = _ref2.root,\n      action = _ref2.action;\n    if (!isUsingFilePond(root)) {\n      return;\n    }\n\n    root.element.textContent = '';\n    var item = root.query('GET_ITEM', action.id);\n    filenames.push(item.filename);\n\n    clearTimeout(addFilesNotificationTimeout);\n    addFilesNotificationTimeout = setTimeout(function() {\n      listModified(\n        root,\n        filenames.join(', '),\n        root.query('GET_LABEL_FILE_ADDED')\n      );\n\n      filenames.length = 0;\n    }, 750);\n  };\n\n  var itemRemoved = function itemRemoved(_ref3) {\n    var root = _ref3.root,\n      action = _ref3.action;\n    if (!isUsingFilePond(root)) {\n      return;\n    }\n\n    var item = action.item;\n    listModified(root, item.filename, root.query('GET_LABEL_FILE_REMOVED'));\n  };\n\n  var itemProcessed = function itemProcessed(_ref4) {\n    var root = _ref4.root,\n      action = _ref4.action;\n    // will also notify the user when FilePond is not being used, as the user might be occupied with other activities while uploading a file\n\n    var item = root.query('GET_ITEM', action.id);\n    var filename = item.filename;\n    var label = root.query('GET_LABEL_FILE_PROCESSING_COMPLETE');\n\n    assist(root, filename + ' ' + label);\n  };\n\n  var itemProcessedUndo = function itemProcessedUndo(_ref5) {\n    var root = _ref5.root,\n      action = _ref5.action;\n    var item = root.query('GET_ITEM', action.id);\n    var filename = item.filename;\n    var label = root.query('GET_LABEL_FILE_PROCESSING_ABORTED');\n\n    assist(root, filename + ' ' + label);\n  };\n\n  var itemError = function itemError(_ref6) {\n    var root = _ref6.root,\n      action = _ref6.action;\n    var item = root.query('GET_ITEM', action.id);\n    var filename = item.filename;\n\n    // will also notify the user when FilePond is not being used, as the user might be occupied with other activities while uploading a file\n\n    assist(root, action.status.main + ' ' + filename + ' ' + action.status.sub);\n  };\n\n  var assistant = createView({\n    create: create$d,\n    ignoreRect: true,\n    ignoreRectUpdate: true,\n    write: createRoute({\n      DID_LOAD_ITEM: itemAdded,\n      DID_REMOVE_ITEM: itemRemoved,\n      DID_COMPLETE_ITEM_PROCESSING: itemProcessed,\n\n      DID_ABORT_ITEM_PROCESSING: itemProcessedUndo,\n      DID_REVERT_ITEM_PROCESSING: itemProcessedUndo,\n\n      DID_THROW_ITEM_REMOVE_ERROR: itemError,\n      DID_THROW_ITEM_LOAD_ERROR: itemError,\n      DID_THROW_ITEM_INVALID: itemError,\n      DID_THROW_ITEM_PROCESSING_ERROR: itemError\n    }),\n\n    tag: 'span',\n    name: 'assistant'\n  });\n\n  var toCamels = function toCamels(string) {\n    var separator =\n      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '-';\n    return string.replace(new RegExp(separator + '.', 'g'), function(sub) {\n      return sub.charAt(1).toUpperCase();\n    });\n  };\n\n  var debounce = function debounce(func) {\n    var interval =\n      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 16;\n    var immidiateOnly =\n      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    var last = Date.now();\n    var timeout = null;\n\n    return function() {\n      for (\n        var _len = arguments.length, args = new Array(_len), _key = 0;\n        _key < _len;\n        _key++\n      ) {\n        args[_key] = arguments[_key];\n      }\n      clearTimeout(timeout);\n\n      var dist = Date.now() - last;\n\n      var fn = function fn() {\n        last = Date.now();\n        func.apply(void 0, args);\n      };\n\n      if (dist < interval) {\n        // we need to delay by the difference between interval and dist\n        // for example: if distance is 10 ms and interval is 16 ms,\n        // we need to wait an additional 6ms before calling the function)\n        if (!immidiateOnly) {\n          timeout = setTimeout(fn, interval - dist);\n        }\n      } else {\n        // go!\n        fn();\n      }\n    };\n  };\n\n  var MAX_FILES_LIMIT = 1000000;\n\n  var prevent = function prevent(e) {\n    return e.preventDefault();\n  };\n\n  var create$e = function create(_ref) {\n    var root = _ref.root,\n      props = _ref.props;\n\n    // Add id\n    var id = root.query('GET_ID');\n    if (id) {\n      root.element.id = id;\n    }\n\n    // Add className\n    var className = root.query('GET_CLASS_NAME');\n    if (className) {\n      className\n        .split(' ')\n        .filter(function(name) {\n          return name.length;\n        })\n        .forEach(function(name) {\n          root.element.classList.add(name);\n        });\n    }\n\n    // Field label\n    root.ref.label = root.appendChildView(\n      root.createChildView(\n        dropLabel,\n        Object.assign({}, props, {\n          translateY: null,\n          caption: root.query('GET_LABEL_IDLE')\n        })\n      )\n    );\n\n    // List of items\n    root.ref.list = root.appendChildView(\n      root.createChildView(listScroller, { translateY: null })\n    );\n\n    // Background panel\n    root.ref.panel = root.appendChildView(\n      root.createChildView(panel, { name: 'panel-root' })\n    );\n\n    // Assistant notifies assistive tech when content changes\n    root.ref.assistant = root.appendChildView(\n      root.createChildView(assistant, Object.assign({}, props))\n    );\n\n    // Data\n    root.ref.data = root.appendChildView(\n      root.createChildView(data, Object.assign({}, props))\n    );\n\n    // Measure (tests if fixed height was set)\n    // DOCTYPE needs to be set for this to work\n    root.ref.measure = createElement$1('div');\n    root.ref.measure.style.height = '100%';\n    root.element.appendChild(root.ref.measure);\n\n    // information on the root height or fixed height status\n    root.ref.bounds = null;\n\n    // apply initial style properties\n    root\n      .query('GET_STYLES')\n      .filter(function(style) {\n        return !isEmpty(style.value);\n      })\n      .map(function(_ref2) {\n        var name = _ref2.name,\n          value = _ref2.value;\n        root.element.dataset[name] = value;\n      });\n\n    // determine if width changed\n    root.ref.widthPrevious = null;\n    root.ref.widthUpdated = debounce(function() {\n      root.ref.updateHistory = [];\n      root.dispatch('DID_RESIZE_ROOT');\n    }, 250);\n\n    // history of updates\n    root.ref.previousAspectRatio = null;\n    root.ref.updateHistory = [];\n\n    // prevent scrolling and zooming on iOS (only if supports pointer events, for then we can enable reorder)\n    var canHover = window.matchMedia('(pointer: fine) and (hover: hover)')\n      .matches;\n    var hasPointerEvents = 'PointerEvent' in window;\n    if (root.query('GET_ALLOW_REORDER') && hasPointerEvents && !canHover) {\n      root.element.addEventListener('touchmove', prevent, { passive: false });\n      root.element.addEventListener('gesturestart', prevent);\n    }\n\n    // add credits\n    var credits = root.query('GET_CREDITS');\n    var hasCredits = credits.length === 2;\n    if (hasCredits) {\n      var frag = document.createElement('a');\n      frag.className = 'filepond--credits';\n      frag.setAttribute('aria-hidden', 'true');\n      frag.href = credits[0];\n      frag.tabindex = -1;\n      frag.target = '_blank';\n      frag.rel = 'noopener noreferrer';\n      frag.textContent = credits[1];\n      root.element.appendChild(frag);\n      root.ref.credits = frag;\n    }\n  };\n\n  var write$9 = function write(_ref3) {\n    var root = _ref3.root,\n      props = _ref3.props,\n      actions = _ref3.actions;\n\n    // route actions\n    route$5({ root: root, props: props, actions: actions });\n\n    // apply style properties\n    actions\n      .filter(function(action) {\n        return /^DID_SET_STYLE_/.test(action.type);\n      })\n      .filter(function(action) {\n        return !isEmpty(action.data.value);\n      })\n      .map(function(_ref4) {\n        var type = _ref4.type,\n          data = _ref4.data;\n        var name = toCamels(type.substr(8).toLowerCase(), '_');\n        root.element.dataset[name] = data.value;\n        root.invalidateLayout();\n      });\n\n    if (root.rect.element.hidden) return;\n\n    if (root.rect.element.width !== root.ref.widthPrevious) {\n      root.ref.widthPrevious = root.rect.element.width;\n      root.ref.widthUpdated();\n    }\n\n    // get box bounds, we do this only once\n    var bounds = root.ref.bounds;\n    if (!bounds) {\n      bounds = root.ref.bounds = calculateRootBoundingBoxHeight(root);\n\n      // destroy measure element\n      root.element.removeChild(root.ref.measure);\n      root.ref.measure = null;\n    }\n\n    // get quick references to various high level parts of the upload tool\n    var _root$ref = root.ref,\n      hopper = _root$ref.hopper,\n      label = _root$ref.label,\n      list = _root$ref.list,\n      panel = _root$ref.panel;\n\n    // sets correct state to hopper scope\n    if (hopper) {\n      hopper.updateHopperState();\n    }\n\n    // bool to indicate if we're full or not\n    var aspectRatio = root.query('GET_PANEL_ASPECT_RATIO');\n    var isMultiItem = root.query('GET_ALLOW_MULTIPLE');\n    var totalItems = root.query('GET_TOTAL_ITEMS');\n    var maxItems = isMultiItem\n      ? root.query('GET_MAX_FILES') || MAX_FILES_LIMIT\n      : 1;\n    var atMaxCapacity = totalItems === maxItems;\n\n    // action used to add item\n    var addAction = actions.find(function(action) {\n      return action.type === 'DID_ADD_ITEM';\n    });\n\n    // if reached max capacity and we've just reached it\n    if (atMaxCapacity && addAction) {\n      // get interaction type\n      var interactionMethod = addAction.data.interactionMethod;\n\n      // hide label\n      label.opacity = 0;\n\n      if (isMultiItem) {\n        label.translateY = -40;\n      } else {\n        if (interactionMethod === InteractionMethod.API) {\n          label.translateX = 40;\n        } else if (interactionMethod === InteractionMethod.BROWSE) {\n          label.translateY = 40;\n        } else {\n          label.translateY = 30;\n        }\n      }\n    } else if (!atMaxCapacity) {\n      label.opacity = 1;\n      label.translateX = 0;\n      label.translateY = 0;\n    }\n\n    var listItemMargin = calculateListItemMargin(root);\n\n    var listHeight = calculateListHeight(root);\n\n    var labelHeight = label.rect.element.height;\n    var currentLabelHeight = !isMultiItem || atMaxCapacity ? 0 : labelHeight;\n\n    var listMarginTop = atMaxCapacity ? list.rect.element.marginTop : 0;\n    var listMarginBottom =\n      totalItems === 0 ? 0 : list.rect.element.marginBottom;\n\n    var visualHeight =\n      currentLabelHeight + listMarginTop + listHeight.visual + listMarginBottom;\n    var boundsHeight =\n      currentLabelHeight + listMarginTop + listHeight.bounds + listMarginBottom;\n\n    // link list to label bottom position\n    list.translateY =\n      Math.max(0, currentLabelHeight - list.rect.element.marginTop) -\n      listItemMargin.top;\n\n    if (aspectRatio) {\n      // fixed aspect ratio\n\n      // calculate height based on width\n      var width = root.rect.element.width;\n      var height = width * aspectRatio;\n\n      // clear history if aspect ratio has changed\n      if (aspectRatio !== root.ref.previousAspectRatio) {\n        root.ref.previousAspectRatio = aspectRatio;\n        root.ref.updateHistory = [];\n      }\n\n      // remember this width\n      var history = root.ref.updateHistory;\n      history.push(width);\n\n      var MAX_BOUNCES = 2;\n      if (history.length > MAX_BOUNCES * 2) {\n        var l = history.length;\n        var bottom = l - 10;\n        var bounces = 0;\n        for (var i = l; i >= bottom; i--) {\n          if (history[i] === history[i - 2]) {\n            bounces++;\n          }\n\n          if (bounces >= MAX_BOUNCES) {\n            // dont adjust height\n            return;\n          }\n        }\n      }\n\n      // fix height of panel so it adheres to aspect ratio\n      panel.scalable = false;\n      panel.height = height;\n\n      // available height for list\n      var listAvailableHeight =\n        // the height of the panel minus the label height\n        height -\n        currentLabelHeight -\n        // the room we leave open between the end of the list and the panel bottom\n        (listMarginBottom - listItemMargin.bottom) -\n        // if we're full we need to leave some room between the top of the panel and the list\n        (atMaxCapacity ? listMarginTop : 0);\n\n      if (listHeight.visual > listAvailableHeight) {\n        list.overflow = listAvailableHeight;\n      } else {\n        list.overflow = null;\n      }\n\n      // set container bounds (so pushes siblings downwards)\n      root.height = height;\n    } else if (bounds.fixedHeight) {\n      // fixed height\n\n      // fix height of panel\n      panel.scalable = false;\n\n      // available height for list\n      var _listAvailableHeight =\n        // the height of the panel minus the label height\n        bounds.fixedHeight -\n        currentLabelHeight -\n        // the room we leave open between the end of the list and the panel bottom\n        (listMarginBottom - listItemMargin.bottom) -\n        // if we're full we need to leave some room between the top of the panel and the list\n        (atMaxCapacity ? listMarginTop : 0);\n\n      // set list height\n      if (listHeight.visual > _listAvailableHeight) {\n        list.overflow = _listAvailableHeight;\n      } else {\n        list.overflow = null;\n      }\n\n      // no need to set container bounds as these are handles by CSS fixed height\n    } else if (bounds.cappedHeight) {\n      // max-height\n\n      // not a fixed height panel\n      var isCappedHeight = visualHeight >= bounds.cappedHeight;\n      var panelHeight = Math.min(bounds.cappedHeight, visualHeight);\n      panel.scalable = true;\n      panel.height = isCappedHeight\n        ? panelHeight\n        : panelHeight - listItemMargin.top - listItemMargin.bottom;\n\n      // available height for list\n      var _listAvailableHeight2 =\n        // the height of the panel minus the label height\n        panelHeight -\n        currentLabelHeight -\n        // the room we leave open between the end of the list and the panel bottom\n        (listMarginBottom - listItemMargin.bottom) -\n        // if we're full we need to leave some room between the top of the panel and the list\n        (atMaxCapacity ? listMarginTop : 0);\n\n      // set list height (if is overflowing)\n      if (\n        visualHeight > bounds.cappedHeight &&\n        listHeight.visual > _listAvailableHeight2\n      ) {\n        list.overflow = _listAvailableHeight2;\n      } else {\n        list.overflow = null;\n      }\n\n      // set container bounds (so pushes siblings downwards)\n      root.height = Math.min(\n        bounds.cappedHeight,\n        boundsHeight - listItemMargin.top - listItemMargin.bottom\n      );\n    } else {\n      // flexible height\n\n      // not a fixed height panel\n      var itemMargin =\n        totalItems > 0 ? listItemMargin.top + listItemMargin.bottom : 0;\n      panel.scalable = true;\n      panel.height = Math.max(labelHeight, visualHeight - itemMargin);\n\n      // set container bounds (so pushes siblings downwards)\n      root.height = Math.max(labelHeight, boundsHeight - itemMargin);\n    }\n\n    // move credits to bottom\n    if (root.ref.credits && panel.heightCurrent)\n      root.ref.credits.style.transform =\n        'translateY(' + panel.heightCurrent + 'px)';\n  };\n\n  var calculateListItemMargin = function calculateListItemMargin(root) {\n    var item = root.ref.list.childViews[0].childViews[0];\n    return item\n      ? {\n          top: item.rect.element.marginTop,\n          bottom: item.rect.element.marginBottom\n        }\n      : {\n          top: 0,\n          bottom: 0\n        };\n  };\n\n  var calculateListHeight = function calculateListHeight(root) {\n    var visual = 0;\n    var bounds = 0;\n\n    // get file list reference\n    var scrollList = root.ref.list;\n    var itemList = scrollList.childViews[0];\n    var visibleChildren = itemList.childViews.filter(function(child) {\n      return child.rect.element.height;\n    });\n    var children = root\n      .query('GET_ACTIVE_ITEMS')\n      .map(function(item) {\n        return visibleChildren.find(function(child) {\n          return child.id === item.id;\n        });\n      })\n      .filter(function(item) {\n        return item;\n      });\n\n    // no children, done!\n    if (children.length === 0) return { visual: visual, bounds: bounds };\n\n    var horizontalSpace = itemList.rect.element.width;\n    var dragIndex = getItemIndexByPosition(\n      itemList,\n      children,\n      scrollList.dragCoordinates\n    );\n\n    var childRect = children[0].rect.element;\n\n    var itemVerticalMargin = childRect.marginTop + childRect.marginBottom;\n    var itemHorizontalMargin = childRect.marginLeft + childRect.marginRight;\n\n    var itemWidth = childRect.width + itemHorizontalMargin;\n    var itemHeight = childRect.height + itemVerticalMargin;\n\n    var newItem = typeof dragIndex !== 'undefined' && dragIndex >= 0 ? 1 : 0;\n    var removedItem = children.find(function(child) {\n      return child.markedForRemoval && child.opacity < 0.45;\n    })\n      ? -1\n      : 0;\n    var verticalItemCount = children.length + newItem + removedItem;\n    var itemsPerRow = Math.round(horizontalSpace / itemWidth);\n\n    // stack\n    if (itemsPerRow === 1) {\n      children.forEach(function(item) {\n        var height = item.rect.element.height + itemVerticalMargin;\n        bounds += height;\n        visual += height * item.opacity;\n      });\n    }\n    // grid\n    else {\n      bounds = Math.ceil(verticalItemCount / itemsPerRow) * itemHeight;\n      visual = bounds;\n    }\n\n    return { visual: visual, bounds: bounds };\n  };\n\n  var calculateRootBoundingBoxHeight = function calculateRootBoundingBoxHeight(\n    root\n  ) {\n    var height = root.ref.measureHeight || null;\n    var cappedHeight = parseInt(root.style.maxHeight, 10) || null;\n    var fixedHeight = height === 0 ? null : height;\n\n    return {\n      cappedHeight: cappedHeight,\n      fixedHeight: fixedHeight\n    };\n  };\n\n  var exceedsMaxFiles = function exceedsMaxFiles(root, items) {\n    var allowReplace = root.query('GET_ALLOW_REPLACE');\n    var allowMultiple = root.query('GET_ALLOW_MULTIPLE');\n    var totalItems = root.query('GET_TOTAL_ITEMS');\n    var maxItems = root.query('GET_MAX_FILES');\n\n    // total amount of items being dragged\n    var totalBrowseItems = items.length;\n\n    // if does not allow multiple items and dragging more than one item\n    if (!allowMultiple && totalBrowseItems > 1) {\n      return true;\n    }\n\n    // limit max items to one if not allowed to drop multiple items\n    maxItems = allowMultiple ? maxItems : allowReplace ? maxItems : 1;\n\n    // no more room?\n    var hasMaxItems = isInt(maxItems);\n    if (hasMaxItems && totalItems + totalBrowseItems > maxItems) {\n      root.dispatch('DID_THROW_MAX_FILES', {\n        source: items,\n        error: createResponse('warning', 0, 'Max files')\n      });\n\n      return true;\n    }\n\n    return false;\n  };\n\n  var getDragIndex = function getDragIndex(list, children, position) {\n    var itemList = list.childViews[0];\n    return getItemIndexByPosition(itemList, children, {\n      left: position.scopeLeft - itemList.rect.element.left,\n      top:\n        position.scopeTop -\n        (list.rect.outer.top +\n          list.rect.element.marginTop +\n          list.rect.element.scrollTop)\n    });\n  };\n\n  /**\n   * Enable or disable file drop functionality\n   */\n  var toggleDrop = function toggleDrop(root) {\n    var isAllowed = root.query('GET_ALLOW_DROP');\n    var isDisabled = root.query('GET_DISABLED');\n    var enabled = isAllowed && !isDisabled;\n    if (enabled && !root.ref.hopper) {\n      var hopper = createHopper(\n        root.element,\n        function(items) {\n          // allow quick validation of dropped items\n          var beforeDropFile =\n            root.query('GET_BEFORE_DROP_FILE') ||\n            function() {\n              return true;\n            };\n\n          // all items should be validated by all filters as valid\n          var dropValidation = root.query('GET_DROP_VALIDATION');\n          return dropValidation\n            ? items.every(function(item) {\n                return (\n                  applyFilters('ALLOW_HOPPER_ITEM', item, {\n                    query: root.query\n                  }).every(function(result) {\n                    return result === true;\n                  }) && beforeDropFile(item)\n                );\n              })\n            : true;\n        },\n        {\n          filterItems: function filterItems(items) {\n            var ignoredFiles = root.query('GET_IGNORED_FILES');\n            return items.filter(function(item) {\n              if (isFile(item)) {\n                return !ignoredFiles.includes(item.name.toLowerCase());\n              }\n              return true;\n            });\n          },\n          catchesDropsOnPage: root.query('GET_DROP_ON_PAGE'),\n          requiresDropOnElement: root.query('GET_DROP_ON_ELEMENT')\n        }\n      );\n\n      hopper.onload = function(items, position) {\n        // get item children elements and sort based on list sort\n        var list = root.ref.list.childViews[0];\n        var visibleChildren = list.childViews.filter(function(child) {\n          return child.rect.element.height;\n        });\n        var children = root\n          .query('GET_ACTIVE_ITEMS')\n          .map(function(item) {\n            return visibleChildren.find(function(child) {\n              return child.id === item.id;\n            });\n          })\n          .filter(function(item) {\n            return item;\n          });\n\n        applyFilterChain('ADD_ITEMS', items, { dispatch: root.dispatch }).then(\n          function(queue) {\n            // these files don't fit so stop here\n            if (exceedsMaxFiles(root, queue)) return false;\n\n            // go\n            root.dispatch('ADD_ITEMS', {\n              items: queue,\n              index: getDragIndex(root.ref.list, children, position),\n              interactionMethod: InteractionMethod.DROP\n            });\n          }\n        );\n\n        root.dispatch('DID_DROP', { position: position });\n\n        root.dispatch('DID_END_DRAG', { position: position });\n      };\n\n      hopper.ondragstart = function(position) {\n        root.dispatch('DID_START_DRAG', { position: position });\n      };\n\n      hopper.ondrag = debounce(function(position) {\n        root.dispatch('DID_DRAG', { position: position });\n      });\n\n      hopper.ondragend = function(position) {\n        root.dispatch('DID_END_DRAG', { position: position });\n      };\n\n      root.ref.hopper = hopper;\n\n      root.ref.drip = root.appendChildView(root.createChildView(drip));\n    } else if (!enabled && root.ref.hopper) {\n      root.ref.hopper.destroy();\n      root.ref.hopper = null;\n      root.removeChildView(root.ref.drip);\n    }\n  };\n\n  /**\n   * Enable or disable browse functionality\n   */\n  var toggleBrowse = function toggleBrowse(root, props) {\n    var isAllowed = root.query('GET_ALLOW_BROWSE');\n    var isDisabled = root.query('GET_DISABLED');\n    var enabled = isAllowed && !isDisabled;\n    if (enabled && !root.ref.browser) {\n      root.ref.browser = root.appendChildView(\n        root.createChildView(\n          browser,\n          Object.assign({}, props, {\n            onload: function onload(items) {\n              applyFilterChain('ADD_ITEMS', items, {\n                dispatch: root.dispatch\n              }).then(function(queue) {\n                // these files don't fit so stop here\n                if (exceedsMaxFiles(root, queue)) return false;\n\n                // add items!\n                root.dispatch('ADD_ITEMS', {\n                  items: queue,\n                  index: -1,\n                  interactionMethod: InteractionMethod.BROWSE\n                });\n              });\n            }\n          })\n        ),\n\n        0\n      );\n    } else if (!enabled && root.ref.browser) {\n      root.removeChildView(root.ref.browser);\n      root.ref.browser = null;\n    }\n  };\n\n  /**\n   * Enable or disable paste functionality\n   */\n  var togglePaste = function togglePaste(root) {\n    var isAllowed = root.query('GET_ALLOW_PASTE');\n    var isDisabled = root.query('GET_DISABLED');\n    var enabled = isAllowed && !isDisabled;\n    if (enabled && !root.ref.paster) {\n      root.ref.paster = createPaster();\n      root.ref.paster.onload = function(items) {\n        applyFilterChain('ADD_ITEMS', items, { dispatch: root.dispatch }).then(\n          function(queue) {\n            // these files don't fit so stop here\n            if (exceedsMaxFiles(root, queue)) return false;\n\n            // add items!\n            root.dispatch('ADD_ITEMS', {\n              items: queue,\n              index: -1,\n              interactionMethod: InteractionMethod.PASTE\n            });\n          }\n        );\n      };\n    } else if (!enabled && root.ref.paster) {\n      root.ref.paster.destroy();\n      root.ref.paster = null;\n    }\n  };\n\n  /**\n   * Route actions\n   */\n  var route$5 = createRoute({\n    DID_SET_ALLOW_BROWSE: function DID_SET_ALLOW_BROWSE(_ref5) {\n      var root = _ref5.root,\n        props = _ref5.props;\n      toggleBrowse(root, props);\n    },\n    DID_SET_ALLOW_DROP: function DID_SET_ALLOW_DROP(_ref6) {\n      var root = _ref6.root;\n      toggleDrop(root);\n    },\n    DID_SET_ALLOW_PASTE: function DID_SET_ALLOW_PASTE(_ref7) {\n      var root = _ref7.root;\n      togglePaste(root);\n    },\n    DID_SET_DISABLED: function DID_SET_DISABLED(_ref8) {\n      var root = _ref8.root,\n        props = _ref8.props;\n      toggleDrop(root);\n      togglePaste(root);\n      toggleBrowse(root, props);\n      var isDisabled = root.query('GET_DISABLED');\n      if (isDisabled) {\n        root.element.dataset.disabled = 'disabled';\n      } else {\n        // delete root.element.dataset.disabled; <= this does not work on iOS 10\n        root.element.removeAttribute('data-disabled');\n      }\n    }\n  });\n\n  var root = createView({\n    name: 'root',\n    read: function read(_ref9) {\n      var root = _ref9.root;\n      if (root.ref.measure) {\n        root.ref.measureHeight = root.ref.measure.offsetHeight;\n      }\n    },\n    create: create$e,\n    write: write$9,\n    destroy: function destroy(_ref10) {\n      var root = _ref10.root;\n      if (root.ref.paster) {\n        root.ref.paster.destroy();\n      }\n      if (root.ref.hopper) {\n        root.ref.hopper.destroy();\n      }\n      root.element.removeEventListener('touchmove', prevent);\n      root.element.removeEventListener('gesturestart', prevent);\n    },\n    mixins: {\n      styles: ['height']\n    }\n  });\n\n  // creates the app\n  var createApp = function createApp() {\n    var initialOptions =\n      arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    // let element\n    var originalElement = null;\n\n    // get default options\n    var defaultOptions = getOptions();\n\n    // create the data store, this will contain all our app info\n    var store = createStore(\n      // initial state (should be serializable)\n      createInitialState(defaultOptions),\n\n      // queries\n      [queries, createOptionQueries(defaultOptions)],\n\n      // action handlers\n      [actions, createOptionActions(defaultOptions)]\n    );\n\n    // set initial options\n    store.dispatch('SET_OPTIONS', { options: initialOptions });\n\n    // kick thread if visibility changes\n    var visibilityHandler = function visibilityHandler() {\n      if (document.hidden) return;\n      store.dispatch('KICK');\n    };\n    document.addEventListener('visibilitychange', visibilityHandler);\n\n    // re-render on window resize start and finish\n    var resizeDoneTimer = null;\n    var isResizing = false;\n    var isResizingHorizontally = false;\n    var initialWindowWidth = null;\n    var currentWindowWidth = null;\n    var resizeHandler = function resizeHandler() {\n      if (!isResizing) {\n        isResizing = true;\n      }\n      clearTimeout(resizeDoneTimer);\n      resizeDoneTimer = setTimeout(function() {\n        isResizing = false;\n        initialWindowWidth = null;\n        currentWindowWidth = null;\n        if (isResizingHorizontally) {\n          isResizingHorizontally = false;\n          store.dispatch('DID_STOP_RESIZE');\n        }\n      }, 500);\n    };\n    window.addEventListener('resize', resizeHandler);\n\n    // render initial view\n    var view = root(store, { id: getUniqueId() });\n\n    //\n    // PRIVATE API -------------------------------------------------------------------------------------\n    //\n    var isResting = false;\n    var isHidden = false;\n\n    var readWriteApi = {\n      // necessary for update loop\n\n      /**\n       * Reads from dom (never call manually)\n       * @private\n       */\n      _read: function _read() {\n        // test if we're resizing horizontally\n        // TODO: see if we can optimize this by measuring root rect\n        if (isResizing) {\n          currentWindowWidth = window.innerWidth;\n          if (!initialWindowWidth) {\n            initialWindowWidth = currentWindowWidth;\n          }\n\n          if (\n            !isResizingHorizontally &&\n            currentWindowWidth !== initialWindowWidth\n          ) {\n            store.dispatch('DID_START_RESIZE');\n            isResizingHorizontally = true;\n          }\n        }\n\n        if (isHidden && isResting) {\n          // test if is no longer hidden\n          isResting = view.element.offsetParent === null;\n        }\n\n        // if resting, no need to read as numbers will still all be correct\n        if (isResting) return;\n\n        // read view data\n        view._read();\n\n        // if is hidden we need to know so we exit rest mode when revealed\n        isHidden = view.rect.element.hidden;\n      },\n\n      /**\n       * Writes to dom (never call manually)\n       * @private\n       */\n      _write: function _write(ts) {\n        // get all actions from store\n        var actions = store\n          .processActionQueue()\n\n          // filter out set actions (these will automatically trigger DID_SET)\n          .filter(function(action) {\n            return !/^SET_/.test(action.type);\n          });\n\n        // if was idling and no actions stop here\n        if (isResting && !actions.length) return;\n\n        // some actions might trigger events\n        routeActionsToEvents(actions);\n\n        // update the view\n        isResting = view._write(ts, actions, isResizingHorizontally);\n\n        // will clean up all archived items\n        removeReleasedItems(store.query('GET_ITEMS'));\n\n        // now idling\n        if (isResting) {\n          store.processDispatchQueue();\n        }\n      }\n    };\n\n    //\n    // EXPOSE EVENTS -------------------------------------------------------------------------------------\n    //\n    var createEvent = function createEvent(name) {\n      return function(data) {\n        // create default event\n        var event = {\n          type: name\n        };\n\n        // no data to add\n        if (!data) {\n          return event;\n        }\n\n        // copy relevant props\n        if (data.hasOwnProperty('error')) {\n          event.error = data.error ? Object.assign({}, data.error) : null;\n        }\n\n        if (data.status) {\n          event.status = Object.assign({}, data.status);\n        }\n\n        if (data.file) {\n          event.output = data.file;\n        }\n\n        // only source is available, else add item if possible\n        if (data.source) {\n          event.file = data.source;\n        } else if (data.item || data.id) {\n          var item = data.item ? data.item : store.query('GET_ITEM', data.id);\n          event.file = item ? createItemAPI(item) : null;\n        }\n\n        // map all items in a possible items array\n        if (data.items) {\n          event.items = data.items.map(createItemAPI);\n        }\n\n        // if this is a progress event add the progress amount\n        if (/progress/.test(name)) {\n          event.progress = data.progress;\n        }\n\n        // copy relevant props\n        if (data.hasOwnProperty('origin') && data.hasOwnProperty('target')) {\n          event.origin = data.origin;\n          event.target = data.target;\n        }\n\n        return event;\n      };\n    };\n\n    var eventRoutes = {\n      DID_DESTROY: createEvent('destroy'),\n\n      DID_INIT: createEvent('init'),\n\n      DID_THROW_MAX_FILES: createEvent('warning'),\n\n      DID_INIT_ITEM: createEvent('initfile'),\n      DID_START_ITEM_LOAD: createEvent('addfilestart'),\n      DID_UPDATE_ITEM_LOAD_PROGRESS: createEvent('addfileprogress'),\n      DID_LOAD_ITEM: createEvent('addfile'),\n\n      DID_THROW_ITEM_INVALID: [createEvent('error'), createEvent('addfile')],\n\n      DID_THROW_ITEM_LOAD_ERROR: [createEvent('error'), createEvent('addfile')],\n\n      DID_THROW_ITEM_REMOVE_ERROR: [\n        createEvent('error'),\n        createEvent('removefile')\n      ],\n\n      DID_PREPARE_OUTPUT: createEvent('preparefile'),\n\n      DID_START_ITEM_PROCESSING: createEvent('processfilestart'),\n      DID_UPDATE_ITEM_PROCESS_PROGRESS: createEvent('processfileprogress'),\n      DID_ABORT_ITEM_PROCESSING: createEvent('processfileabort'),\n      DID_COMPLETE_ITEM_PROCESSING: createEvent('processfile'),\n      DID_COMPLETE_ITEM_PROCESSING_ALL: createEvent('processfiles'),\n      DID_REVERT_ITEM_PROCESSING: createEvent('processfilerevert'),\n\n      DID_THROW_ITEM_PROCESSING_ERROR: [\n        createEvent('error'),\n        createEvent('processfile')\n      ],\n\n      DID_REMOVE_ITEM: createEvent('removefile'),\n\n      DID_UPDATE_ITEMS: createEvent('updatefiles'),\n\n      DID_ACTIVATE_ITEM: createEvent('activatefile'),\n\n      DID_REORDER_ITEMS: createEvent('reorderfiles')\n    };\n\n    var exposeEvent = function exposeEvent(event) {\n      // create event object to be dispatched\n      var detail = Object.assign({ pond: exports }, event);\n      delete detail.type;\n      view.element.dispatchEvent(\n        new CustomEvent('FilePond:' + event.type, {\n          // event info\n          detail: detail,\n\n          // event behaviour\n          bubbles: true,\n          cancelable: true,\n          composed: true // triggers listeners outside of shadow root\n        })\n      );\n\n      // event object to params used for `on()` event handlers and callbacks `oninit()`\n      var params = [];\n\n      // if is possible error event, make it the first param\n      if (event.hasOwnProperty('error')) {\n        params.push(event.error);\n      }\n\n      // file is always section\n      if (event.hasOwnProperty('file')) {\n        params.push(event.file);\n      }\n\n      // append other props\n      var filtered = ['type', 'error', 'file'];\n      Object.keys(event)\n        .filter(function(key) {\n          return !filtered.includes(key);\n        })\n        .forEach(function(key) {\n          return params.push(event[key]);\n        });\n\n      // on(type, () => { })\n      exports.fire.apply(exports, [event.type].concat(params));\n\n      // oninit = () => {}\n      var handler = store.query('GET_ON' + event.type.toUpperCase());\n      if (handler) {\n        handler.apply(void 0, params);\n      }\n    };\n\n    var routeActionsToEvents = function routeActionsToEvents(actions) {\n      if (!actions.length) return;\n      actions\n        .filter(function(action) {\n          return eventRoutes[action.type];\n        })\n        .forEach(function(action) {\n          var routes = eventRoutes[action.type];\n          (Array.isArray(routes) ? routes : [routes]).forEach(function(route) {\n            // this isn't fantastic, but because of the stacking of settimeouts plugins can handle the did_load before the did_init\n            if (action.type === 'DID_INIT_ITEM') {\n              exposeEvent(route(action.data));\n            } else {\n              setTimeout(function() {\n                exposeEvent(route(action.data));\n              }, 0);\n            }\n          });\n        });\n    };\n\n    //\n    // PUBLIC API -------------------------------------------------------------------------------------\n    //\n    var setOptions = function setOptions(options) {\n      return store.dispatch('SET_OPTIONS', { options: options });\n    };\n\n    var getFile = function getFile(query) {\n      return store.query('GET_ACTIVE_ITEM', query);\n    };\n\n    var prepareFile = function prepareFile(query) {\n      return new Promise(function(resolve, reject) {\n        store.dispatch('REQUEST_ITEM_PREPARE', {\n          query: query,\n          success: function success(item) {\n            resolve(item);\n          },\n          failure: function failure(error) {\n            reject(error);\n          }\n        });\n      });\n    };\n\n    var addFile = function addFile(source) {\n      var options =\n        arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return new Promise(function(resolve, reject) {\n        addFiles([{ source: source, options: options }], {\n          index: options.index\n        })\n          .then(function(items) {\n            return resolve(items && items[0]);\n          })\n          .catch(reject);\n      });\n    };\n\n    var isFilePondFile = function isFilePondFile(obj) {\n      return obj.file && obj.id;\n    };\n\n    var removeFile = function removeFile(query, options) {\n      // if only passed options\n      if (typeof query === 'object' && !isFilePondFile(query) && !options) {\n        options = query;\n        query = undefined;\n      }\n\n      // request item removal\n      store.dispatch(\n        'REMOVE_ITEM',\n        Object.assign({}, options, { query: query })\n      );\n\n      // see if item has been removed\n      return store.query('GET_ACTIVE_ITEM', query) === null;\n    };\n\n    var addFiles = function addFiles() {\n      for (\n        var _len = arguments.length, args = new Array(_len), _key = 0;\n        _key < _len;\n        _key++\n      ) {\n        args[_key] = arguments[_key];\n      }\n      return new Promise(function(resolve, reject) {\n        var sources = [];\n        var options = {};\n\n        // user passed a sources array\n        if (isArray(args[0])) {\n          sources.push.apply(sources, args[0]);\n          Object.assign(options, args[1] || {});\n        } else {\n          // user passed sources as arguments, last one might be options object\n          var lastArgument = args[args.length - 1];\n          if (\n            typeof lastArgument === 'object' &&\n            !(lastArgument instanceof Blob)\n          ) {\n            Object.assign(options, args.pop());\n          }\n\n          // add rest to sources\n          sources.push.apply(sources, args);\n        }\n\n        store.dispatch('ADD_ITEMS', {\n          items: sources,\n          index: options.index,\n          interactionMethod: InteractionMethod.API,\n          success: resolve,\n          failure: reject\n        });\n      });\n    };\n\n    var getFiles = function getFiles() {\n      return store.query('GET_ACTIVE_ITEMS');\n    };\n\n    var processFile = function processFile(query) {\n      return new Promise(function(resolve, reject) {\n        store.dispatch('REQUEST_ITEM_PROCESSING', {\n          query: query,\n          success: function success(item) {\n            resolve(item);\n          },\n          failure: function failure(error) {\n            reject(error);\n          }\n        });\n      });\n    };\n\n    var prepareFiles = function prepareFiles() {\n      for (\n        var _len2 = arguments.length, args = new Array(_len2), _key2 = 0;\n        _key2 < _len2;\n        _key2++\n      ) {\n        args[_key2] = arguments[_key2];\n      }\n      var queries = Array.isArray(args[0]) ? args[0] : args;\n      var items = queries.length ? queries : getFiles();\n      return Promise.all(items.map(prepareFile));\n    };\n\n    var processFiles = function processFiles() {\n      for (\n        var _len3 = arguments.length, args = new Array(_len3), _key3 = 0;\n        _key3 < _len3;\n        _key3++\n      ) {\n        args[_key3] = arguments[_key3];\n      }\n      var queries = Array.isArray(args[0]) ? args[0] : args;\n      if (!queries.length) {\n        var files = getFiles().filter(function(item) {\n          return (\n            !(\n              item.status === ItemStatus.IDLE &&\n              item.origin === FileOrigin.LOCAL\n            ) &&\n            item.status !== ItemStatus.PROCESSING &&\n            item.status !== ItemStatus.PROCESSING_COMPLETE &&\n            item.status !== ItemStatus.PROCESSING_REVERT_ERROR\n          );\n        });\n\n        return Promise.all(files.map(processFile));\n      }\n      return Promise.all(queries.map(processFile));\n    };\n\n    var removeFiles = function removeFiles() {\n      for (\n        var _len4 = arguments.length, args = new Array(_len4), _key4 = 0;\n        _key4 < _len4;\n        _key4++\n      ) {\n        args[_key4] = arguments[_key4];\n      }\n\n      var queries = Array.isArray(args[0]) ? args[0] : args;\n\n      var options;\n      if (typeof queries[queries.length - 1] === 'object') {\n        options = queries.pop();\n      } else if (Array.isArray(args[0])) {\n        options = args[1];\n      }\n\n      var files = getFiles();\n\n      if (!queries.length)\n        return Promise.all(\n          files.map(function(file) {\n            return removeFile(file, options);\n          })\n        );\n\n      // when removing by index the indexes shift after each file removal so we need to convert indexes to ids\n      var mappedQueries = queries\n        .map(function(query) {\n          return isNumber(query)\n            ? files[query]\n              ? files[query].id\n              : null\n            : query;\n        })\n        .filter(function(query) {\n          return query;\n        });\n\n      return mappedQueries.map(function(q) {\n        return removeFile(q, options);\n      });\n    };\n\n    var exports = Object.assign(\n      {},\n\n      on(),\n      {},\n\n      readWriteApi,\n      {},\n\n      createOptionAPI(store, defaultOptions),\n      {\n        /**\n         * Override options defined in options object\n         * @param options\n         */\n        setOptions: setOptions,\n\n        /**\n         * Load the given file\n         * @param source - the source of the file (either a File, base64 data uri or url)\n         * @param options - object, { index: 0 }\n         */\n        addFile: addFile,\n\n        /**\n         * Load the given files\n         * @param sources - the sources of the files to load\n         * @param options - object, { index: 0 }\n         */\n        addFiles: addFiles,\n\n        /**\n         * Returns the file objects matching the given query\n         * @param query { string, number, null }\n         */\n        getFile: getFile,\n\n        /**\n         * Upload file with given name\n         * @param query { string, number, null  }\n         */\n        processFile: processFile,\n\n        /**\n         * Request prepare output for file with given name\n         * @param query { string, number, null  }\n         */\n        prepareFile: prepareFile,\n\n        /**\n         * Removes a file by its name\n         * @param query { string, number, null  }\n         */\n        removeFile: removeFile,\n\n        /**\n         * Moves a file to a new location in the files list\n         */\n        moveFile: function moveFile(query, index) {\n          return store.dispatch('MOVE_ITEM', { query: query, index: index });\n        },\n\n        /**\n         * Returns all files (wrapped in public api)\n         */\n        getFiles: getFiles,\n\n        /**\n         * Starts uploading all files\n         */\n        processFiles: processFiles,\n\n        /**\n         * Clears all files from the files list\n         */\n        removeFiles: removeFiles,\n\n        /**\n         * Starts preparing output of all files\n         */\n        prepareFiles: prepareFiles,\n\n        /**\n         * Sort list of files\n         */\n        sort: function sort(compare) {\n          return store.dispatch('SORT', { compare: compare });\n        },\n\n        /**\n         * Browse the file system for a file\n         */\n        browse: function browse() {\n          // needs to be trigger directly as user action needs to be traceable (is not traceable in requestAnimationFrame)\n          var input = view.element.querySelector('input[type=file]');\n          if (input) {\n            input.click();\n          }\n        },\n\n        /**\n         * Destroys the app\n         */\n        destroy: function destroy() {\n          // request destruction\n          exports.fire('destroy', view.element);\n\n          // stop active processes (file uploads, fetches, stuff like that)\n          // loop over items and depending on states call abort for ongoing processes\n          store.dispatch('ABORT_ALL');\n\n          // destroy view\n          view._destroy();\n\n          // stop listening to resize\n          window.removeEventListener('resize', resizeHandler);\n\n          // stop listening to the visiblitychange event\n          document.removeEventListener('visibilitychange', visibilityHandler);\n\n          // dispatch destroy\n          store.dispatch('DID_DESTROY');\n        },\n\n        /**\n         * Inserts the plugin before the target element\n         */\n        insertBefore: function insertBefore$1(element) {\n          return insertBefore(view.element, element);\n        },\n\n        /**\n         * Inserts the plugin after the target element\n         */\n        insertAfter: function insertAfter$1(element) {\n          return insertAfter(view.element, element);\n        },\n\n        /**\n         * Appends the plugin to the target element\n         */\n        appendTo: function appendTo(element) {\n          return element.appendChild(view.element);\n        },\n\n        /**\n         * Replaces an element with the app\n         */\n        replaceElement: function replaceElement(element) {\n          // insert the app before the element\n          insertBefore(view.element, element);\n\n          // remove the original element\n          element.parentNode.removeChild(element);\n\n          // remember original element\n          originalElement = element;\n        },\n\n        /**\n         * Restores the original element\n         */\n        restoreElement: function restoreElement() {\n          if (!originalElement) {\n            return; // no element to restore\n          }\n\n          // restore original element\n          insertAfter(originalElement, view.element);\n\n          // remove our element\n          view.element.parentNode.removeChild(view.element);\n\n          // remove reference\n          originalElement = null;\n        },\n\n        /**\n         * Returns true if the app root is attached to given element\n         * @param element\n         */\n        isAttachedTo: function isAttachedTo(element) {\n          return view.element === element || originalElement === element;\n        },\n\n        /**\n         * Returns the root element\n         */\n        element: {\n          get: function get() {\n            return view.element;\n          }\n        },\n\n        /**\n         * Returns the current pond status\n         */\n        status: {\n          get: function get() {\n            return store.query('GET_STATUS');\n          }\n        }\n      }\n    );\n\n    // Done!\n    store.dispatch('DID_INIT');\n\n    // create actual api object\n    return createObject(exports);\n  };\n\n  var createAppObject = function createAppObject() {\n    var customOptions =\n      arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    // default options\n    var defaultOptions = {};\n    forin(getOptions(), function(key, value) {\n      defaultOptions[key] = value[0];\n    });\n\n    // set app options\n    var app = createApp(\n      Object.assign(\n        {},\n\n        defaultOptions,\n        {},\n\n        customOptions\n      )\n    );\n\n    // return the plugin instance\n    return app;\n  };\n\n  var lowerCaseFirstLetter = function lowerCaseFirstLetter(string) {\n    return string.charAt(0).toLowerCase() + string.slice(1);\n  };\n\n  var attributeNameToPropertyName = function attributeNameToPropertyName(\n    attributeName\n  ) {\n    return toCamels(attributeName.replace(/^data-/, ''));\n  };\n\n  var mapObject = function mapObject(object, propertyMap) {\n    // remove unwanted\n    forin(propertyMap, function(selector, mapping) {\n      forin(object, function(property, value) {\n        // create regexp shortcut\n        var selectorRegExp = new RegExp(selector);\n\n        // tests if\n        var matches = selectorRegExp.test(property);\n\n        // no match, skip\n        if (!matches) {\n          return;\n        }\n\n        // if there's a mapping, the original property is always removed\n        delete object[property];\n\n        // should only remove, we done!\n        if (mapping === false) {\n          return;\n        }\n\n        // move value to new property\n        if (isString(mapping)) {\n          object[mapping] = value;\n          return;\n        }\n\n        // move to group\n        var group = mapping.group;\n        if (isObject(mapping) && !object[group]) {\n          object[group] = {};\n        }\n\n        object[group][\n          lowerCaseFirstLetter(property.replace(selectorRegExp, ''))\n        ] = value;\n      });\n\n      // do submapping\n      if (mapping.mapping) {\n        mapObject(object[mapping.group], mapping.mapping);\n      }\n    });\n  };\n\n  var getAttributesAsObject = function getAttributesAsObject(node) {\n    var attributeMapping =\n      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    // turn attributes into object\n    var attributes = [];\n    forin(node.attributes, function(index) {\n      attributes.push(node.attributes[index]);\n    });\n\n    var output = attributes\n      .filter(function(attribute) {\n        return attribute.name;\n      })\n      .reduce(function(obj, attribute) {\n        var value = attr(node, attribute.name);\n\n        obj[attributeNameToPropertyName(attribute.name)] =\n          value === attribute.name ? true : value;\n        return obj;\n      }, {});\n\n    // do mapping of object properties\n    mapObject(output, attributeMapping);\n\n    return output;\n  };\n\n  var createAppAtElement = function createAppAtElement(element) {\n    var options =\n      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    // how attributes of the input element are mapped to the options for the plugin\n    var attributeMapping = {\n      // translate to other name\n      '^class$': 'className',\n      '^multiple$': 'allowMultiple',\n      '^capture$': 'captureMethod',\n      '^webkitdirectory$': 'allowDirectoriesOnly',\n\n      // group under single property\n      '^server': {\n        group: 'server',\n        mapping: {\n          '^process': {\n            group: 'process'\n          },\n\n          '^revert': {\n            group: 'revert'\n          },\n\n          '^fetch': {\n            group: 'fetch'\n          },\n\n          '^restore': {\n            group: 'restore'\n          },\n\n          '^load': {\n            group: 'load'\n          }\n        }\n      },\n\n      // don't include in object\n      '^type$': false,\n      '^files$': false\n    };\n\n    // add additional option translators\n    applyFilters('SET_ATTRIBUTE_TO_OPTION_MAP', attributeMapping);\n\n    // create final options object by setting options object and then overriding options supplied on element\n    var mergedOptions = Object.assign({}, options);\n\n    var attributeOptions = getAttributesAsObject(\n      element.nodeName === 'FIELDSET'\n        ? element.querySelector('input[type=file]')\n        : element,\n      attributeMapping\n    );\n\n    // merge with options object\n    Object.keys(attributeOptions).forEach(function(key) {\n      if (isObject(attributeOptions[key])) {\n        if (!isObject(mergedOptions[key])) {\n          mergedOptions[key] = {};\n        }\n        Object.assign(mergedOptions[key], attributeOptions[key]);\n      } else {\n        mergedOptions[key] = attributeOptions[key];\n      }\n    });\n\n    // if parent is a fieldset, get files from parent by selecting all input fields that are not file upload fields\n    // these will then be automatically set to the initial files\n    mergedOptions.files = (options.files || []).concat(\n      Array.from(element.querySelectorAll('input:not([type=file])')).map(\n        function(input) {\n          return {\n            source: input.value,\n            options: {\n              type: input.dataset.type\n            }\n          };\n        }\n      )\n    );\n\n    // build plugin\n    var app = createAppObject(mergedOptions);\n\n    // add already selected files\n    if (element.files) {\n      Array.from(element.files).forEach(function(file) {\n        app.addFile(file);\n      });\n    }\n\n    // replace the target element\n    app.replaceElement(element);\n\n    // expose\n    return app;\n  };\n\n  // if an element is passed, we create the instance at that element, if not, we just create an up object\n  var createApp$1 = function createApp() {\n    return isNode(arguments.length <= 0 ? undefined : arguments[0])\n      ? createAppAtElement.apply(void 0, arguments)\n      : createAppObject.apply(void 0, arguments);\n  };\n\n  var PRIVATE_METHODS = ['fire', '_read', '_write'];\n\n  var createAppAPI = function createAppAPI(app) {\n    var api = {};\n\n    copyObjectPropertiesToObject(app, api, PRIVATE_METHODS);\n\n    return api;\n  };\n\n  /**\n   * Replaces placeholders in given string with replacements\n   * @param string - \"Foo {bar}\"\"\n   * @param replacements - { \"bar\": 10 }\n   */\n  var replaceInString = function replaceInString(string, replacements) {\n    return string.replace(/(?:{([a-zA-Z]+)})/g, function(match, group) {\n      return replacements[group];\n    });\n  };\n\n  var createWorker = function createWorker(fn) {\n    var workerBlob = new Blob(['(', fn.toString(), ')()'], {\n      type: 'application/javascript'\n    });\n\n    var workerURL = URL.createObjectURL(workerBlob);\n    var worker = new Worker(workerURL);\n\n    return {\n      transfer: function transfer(message, cb) {},\n      post: function post(message, cb, transferList) {\n        var id = getUniqueId();\n\n        worker.onmessage = function(e) {\n          if (e.data.id === id) {\n            cb(e.data.message);\n          }\n        };\n\n        worker.postMessage(\n          {\n            id: id,\n            message: message\n          },\n\n          transferList\n        );\n      },\n      terminate: function terminate() {\n        worker.terminate();\n        URL.revokeObjectURL(workerURL);\n      }\n    };\n  };\n\n  var loadImage = function loadImage(url) {\n    return new Promise(function(resolve, reject) {\n      var img = new Image();\n      img.onload = function() {\n        resolve(img);\n      };\n      img.onerror = function(e) {\n        reject(e);\n      };\n      img.src = url;\n    });\n  };\n\n  var renameFile = function renameFile(file, name) {\n    var renamedFile = file.slice(0, file.size, file.type);\n    renamedFile.lastModifiedDate = file.lastModifiedDate;\n    renamedFile.name = name;\n    return renamedFile;\n  };\n\n  var copyFile = function copyFile(file) {\n    return renameFile(file, file.name);\n  };\n\n  // already registered plugins (can't register twice)\n  var registeredPlugins = [];\n\n  // pass utils to plugin\n  var createAppPlugin = function createAppPlugin(plugin) {\n    // already registered\n    if (registeredPlugins.includes(plugin)) {\n      return;\n    }\n\n    // remember this plugin\n    registeredPlugins.push(plugin);\n\n    // setup!\n    var pluginOutline = plugin({\n      addFilter: addFilter,\n      utils: {\n        Type: Type,\n        forin: forin,\n        isString: isString,\n        isFile: isFile,\n        toNaturalFileSize: toNaturalFileSize,\n        replaceInString: replaceInString,\n        getExtensionFromFilename: getExtensionFromFilename,\n        getFilenameWithoutExtension: getFilenameWithoutExtension,\n        guesstimateMimeType: guesstimateMimeType,\n        getFileFromBlob: getFileFromBlob,\n        getFilenameFromURL: getFilenameFromURL,\n        createRoute: createRoute,\n        createWorker: createWorker,\n        createView: createView,\n        createItemAPI: createItemAPI,\n        loadImage: loadImage,\n        copyFile: copyFile,\n        renameFile: renameFile,\n        createBlob: createBlob,\n        applyFilterChain: applyFilterChain,\n        text: text,\n        getNumericAspectRatioFromString: getNumericAspectRatioFromString\n      },\n\n      views: {\n        fileActionButton: fileActionButton\n      }\n    });\n\n    // add plugin options to default options\n    extendDefaultOptions(pluginOutline.options);\n  };\n\n  // feature detection used by supported() method\n  var isOperaMini = function isOperaMini() {\n    return (\n      Object.prototype.toString.call(window.operamini) === '[object OperaMini]'\n    );\n  };\n  var hasPromises = function hasPromises() {\n    return 'Promise' in window;\n  };\n  var hasBlobSlice = function hasBlobSlice() {\n    return 'slice' in Blob.prototype;\n  };\n  var hasCreateObjectURL = function hasCreateObjectURL() {\n    return 'URL' in window && 'createObjectURL' in window.URL;\n  };\n  var hasVisibility = function hasVisibility() {\n    return 'visibilityState' in document;\n  };\n  var hasTiming = function hasTiming() {\n    return 'performance' in window;\n  }; // iOS 8.x\n  var hasCSSSupports = function hasCSSSupports() {\n    return 'supports' in (window.CSS || {});\n  }; // use to detect Safari 9+\n  var isIE11 = function isIE11() {\n    return /MSIE|Trident/.test(window.navigator.userAgent);\n  };\n\n  var supported = (function() {\n    // Runs immediately and then remembers result for subsequent calls\n    var isSupported =\n      // Has to be a browser\n      isBrowser() &&\n      // Can't run on Opera Mini due to lack of everything\n      !isOperaMini() &&\n      // Require these APIs to feature detect a modern browser\n      hasVisibility() &&\n      hasPromises() &&\n      hasBlobSlice() &&\n      hasCreateObjectURL() &&\n      hasTiming() &&\n      // doesn't need CSSSupports but is a good way to detect Safari 9+ (we do want to support IE11 though)\n      (hasCSSSupports() || isIE11());\n\n    return function() {\n      return isSupported;\n    };\n  })();\n\n  /**\n   * Plugin internal state (over all instances)\n   */\n  var state = {\n    // active app instances, used to redraw the apps and to find the later\n    apps: []\n  };\n\n  // plugin name\n  var name = 'filepond';\n\n  /**\n   * Public Plugin methods\n   */\n  var fn = function fn() {};\n  exports.Status = {};\n  exports.FileStatus = {};\n  exports.FileOrigin = {};\n  exports.OptionTypes = {};\n  exports.create = fn;\n  exports.destroy = fn;\n  exports.parse = fn;\n  exports.find = fn;\n  exports.registerPlugin = fn;\n  exports.getOptions = fn;\n  exports.setOptions = fn;\n\n  // if not supported, no API\n  if (supported()) {\n    // start painter and fire load event\n    createPainter(\n      function() {\n        state.apps.forEach(function(app) {\n          return app._read();\n        });\n      },\n      function(ts) {\n        state.apps.forEach(function(app) {\n          return app._write(ts);\n        });\n      }\n    );\n\n    // fire loaded event so we know when FilePond is available\n    var dispatch = function dispatch() {\n      // let others know we have area ready\n      document.dispatchEvent(\n        new CustomEvent('FilePond:loaded', {\n          detail: {\n            supported: supported,\n            create: exports.create,\n            destroy: exports.destroy,\n            parse: exports.parse,\n            find: exports.find,\n            registerPlugin: exports.registerPlugin,\n            setOptions: exports.setOptions\n          }\n        })\n      );\n\n      // clean up event\n      document.removeEventListener('DOMContentLoaded', dispatch);\n    };\n\n    if (document.readyState !== 'loading') {\n      // move to back of execution queue, FilePond should have been exported by then\n      setTimeout(function() {\n        return dispatch();\n      }, 0);\n    } else {\n      document.addEventListener('DOMContentLoaded', dispatch);\n    }\n\n    // updates the OptionTypes object based on the current options\n    var updateOptionTypes = function updateOptionTypes() {\n      return forin(getOptions(), function(key, value) {\n        exports.OptionTypes[key] = value[1];\n      });\n    };\n\n    exports.Status = Object.assign({}, Status);\n    exports.FileOrigin = Object.assign({}, FileOrigin);\n    exports.FileStatus = Object.assign({}, ItemStatus);\n\n    exports.OptionTypes = {};\n    updateOptionTypes();\n\n    // create method, creates apps and adds them to the app array\n    exports.create = function create() {\n      var app = createApp$1.apply(void 0, arguments);\n      app.on('destroy', exports.destroy);\n      state.apps.push(app);\n      return createAppAPI(app);\n    };\n\n    // destroys apps and removes them from the app array\n    exports.destroy = function destroy(hook) {\n      // returns true if the app was destroyed successfully\n      var indexToRemove = state.apps.findIndex(function(app) {\n        return app.isAttachedTo(hook);\n      });\n      if (indexToRemove >= 0) {\n        // remove from apps\n        var app = state.apps.splice(indexToRemove, 1)[0];\n\n        // restore original dom element\n        app.restoreElement();\n\n        return true;\n      }\n\n      return false;\n    };\n\n    // parses the given context for plugins (does not include the context element itself)\n    exports.parse = function parse(context) {\n      // get all possible hooks\n      var matchedHooks = Array.from(context.querySelectorAll('.' + name));\n\n      // filter out already active hooks\n      var newHooks = matchedHooks.filter(function(newHook) {\n        return !state.apps.find(function(app) {\n          return app.isAttachedTo(newHook);\n        });\n      });\n\n      // create new instance for each hook\n      return newHooks.map(function(hook) {\n        return exports.create(hook);\n      });\n    };\n\n    // returns an app based on the given element hook\n    exports.find = function find(hook) {\n      var app = state.apps.find(function(app) {\n        return app.isAttachedTo(hook);\n      });\n      if (!app) {\n        return null;\n      }\n      return createAppAPI(app);\n    };\n\n    // adds a plugin extension\n    exports.registerPlugin = function registerPlugin() {\n      for (\n        var _len = arguments.length, plugins = new Array(_len), _key = 0;\n        _key < _len;\n        _key++\n      ) {\n        plugins[_key] = arguments[_key];\n      }\n\n      // register plugins\n      plugins.forEach(createAppPlugin);\n\n      // update OptionTypes, each plugin might have extended the default options\n      updateOptionTypes();\n    };\n\n    exports.getOptions = function getOptions$1() {\n      var opts = {};\n      forin(getOptions(), function(key, value) {\n        opts[key] = value[0];\n      });\n      return opts;\n    };\n\n    exports.setOptions = function setOptions$1(opts) {\n      if (isObject(opts)) {\n        // update existing plugins\n        state.apps.forEach(function(app) {\n          app.setOptions(opts);\n        });\n\n        // override defaults\n        setOptions(opts);\n      }\n\n      // return new options\n      return exports.getOptions();\n    };\n  }\n\n  exports.supported = supported;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmlsZXBvbmQvZGlzdC9maWxlcG9uZC5qcz9jMDYyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxFQUFFLEtBQTREO0FBQzlEO0FBQ0EsTUFBTSxTQUU0RDtBQUNsRSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix5QkFBeUI7QUFDckQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFDQUFxQyxrQkFBa0I7QUFDdkQsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQzs7QUFFcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsK0NBQStDO0FBQy9DLCtDQUErQztBQUMvQyxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVCw2Q0FBNkM7QUFDN0M7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVCw2Q0FBNkM7QUFDN0M7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0I7QUFDeEIsd0JBQXdCLGVBQWUsc0JBQXNCO0FBQzdELHdCQUF3QixlQUFlLEtBQUssc0JBQXNCLEVBQUU7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBEQUEwRDs7QUFFMUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDOztBQUV2QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1Qiw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9EQUFvRDs7QUFFcEQ7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFO0FBQzdFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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OztBQUVYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixVQUFVO0FBQzNCLHFCQUFxQixPQUFPO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTs7QUFFeEI7QUFDQSx1Q0FBdUMsNEJBQTRCO0FBQ25FO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEscUJBQXFCLG9CQUFvQjtBQUN6QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxQkFBcUIsMEJBQTBCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsdUJBQXVCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQiw2QkFBNkI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbURBQW1ELGdCQUFnQjtBQUNuRTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsbUJBQW1CO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDJCQUEyQixzQkFBc0I7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBLDJDQUEyQyxRQUFRO0FBQ25EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDJCQUEyQix5QkFBeUI7QUFDcEQsaUNBQWlDLHFCQUFxQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0MsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVzs7QUFFWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QixtQkFBbUI7QUFDNUM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNENBQTRDLHdCQUF3QiwyQkFBMkI7QUFDL0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQix1QkFBdUI7QUFDMUM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxJQUFJLElBQUk7QUFDcEQsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QztBQUN4QywwQ0FBMEM7QUFDMUMsa0NBQWtDO0FBQ2xDLHdDQUF3QztBQUN4QyxvQ0FBb0M7QUFDcEMsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSxhQUFhOztBQUViLDBDQUEwQztBQUMxQztBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQyx5QkFBeUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNGQUFzRjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0RBQWdEO0FBQ2hEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsd0JBQXdCLHdCQUF3QjtBQUNoRCxtQkFBbUIsbUJBQW1CO0FBQ3RDLG1CQUFtQixtQkFBbUI7QUFDdEMsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHFDQUFxQztBQUN6RSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0Esa0RBQWtELFNBQVMsYUFBYTtBQUN4RSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0QixzQkFBc0IsaUJBQWlCLEVBQUU7QUFDckU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGtEQUFrRCxTQUFTLGFBQWE7QUFDeEUsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLCtCQUErQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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UDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFlBQVk7QUFDdEQsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDLFNBQVM7QUFDL0M7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QyxTQUFTO0FBQ2pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsNkNBQTZDOztBQUV4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFD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QUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUIsV0FBVztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUF1QyxTQUFTOztBQUVoRDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLE9BQU87QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsNEJBQTRCOztBQUU1RDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsNkNBQTZDO0FBQzFEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSw2Q0FBNkM7O0FBRTFEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsS0FBSztBQUNMO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsS0FBSztBQUNMO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsS0FBSztBQUNMLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsS0FBSztBQUNMO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsK0JBQStCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNkNBQTZDO0FBQzFEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtREFBbUQ7QUFDbkQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyxvQ0FBb0M7QUFDcEMsa0NBQWtDO0FBQ2xDLGtDQUFrQztBQUNsQyxrQ0FBa0M7QUFDbEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxrQ0FBa0M7QUFDbEMsNENBQTRDO0FBQzVDLGtDQUFrQztBQUNsQyx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEMsbUJBQW1CO0FBQzdEOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUMscUJBQXFCO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7O0FBRUE7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsaUJBQWlCO0FBQzVFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLDZDQUE2Qzs7QUFFMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsYUFBYTtBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQSx1Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTyxJQUFJOztBQUVYO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHdDQUF3Qzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkIsSUFBSTtBQUMvQiw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLCtCQUErQixZQUFZO0FBQzNDO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsMENBQTBDO0FBQzFDLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBLHFDQUFxQztBQUNyQyx5Q0FBeUM7QUFDekMseUNBQXlDOztBQUV6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdEQUFnRCxjQUFjO0FBQzlELENBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmlsZXBvbmQvZGlzdC9maWxlcG9uZC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogRmlsZVBvbmQgNC4yMy4xXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQsIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUL1xuICogUGxlYXNlIHZpc2l0IGh0dHBzOi8vcHFpbmEubmwvZmlsZXBvbmQvIGZvciBkZXRhaWxzLlxuICovXG5cbi8qIGVzbGludC1kaXNhYmxlICovXG5cbihmdW5jdGlvbihnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXG4gICAgPyBmYWN0b3J5KGV4cG9ydHMpXG4gICAgOiB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWRcbiAgICA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSlcbiAgICA6ICgoZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYpLCBmYWN0b3J5KChnbG9iYWwuRmlsZVBvbmQgPSB7fSkpKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBpc05vZGUgPSBmdW5jdGlvbiBpc05vZGUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcbiAgfTtcblxuICB2YXIgY3JlYXRlU3RvcmUgPSBmdW5jdGlvbiBjcmVhdGVTdG9yZShpbml0aWFsU3RhdGUpIHtcbiAgICB2YXIgcXVlcmllcyA9XG4gICAgICBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFtdO1xuICAgIHZhciBhY3Rpb25zID1cbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogW107XG4gICAgLy8gaW50ZXJuYWwgc3RhdGVcbiAgICB2YXIgc3RhdGUgPSBPYmplY3QuYXNzaWduKHt9LCBpbml0aWFsU3RhdGUpO1xuXG4gICAgLy8gY29udGFpbnMgYWxsIGFjdGlvbnMgZm9yIG5leHQgZnJhbWUsIGlzIGNsZWFyIHdoZW4gYWN0aW9ucyBhcmUgcmVxdWVzdGVkXG4gICAgdmFyIGFjdGlvblF1ZXVlID0gW107XG4gICAgdmFyIGRpc3BhdGNoUXVldWUgPSBbXTtcblxuICAgIC8vIHJldHVybnMgYSBkdXBsaWNhdGUgb2YgdGhlIGN1cnJlbnQgc3RhdGVcbiAgICB2YXIgZ2V0U3RhdGUgPSBmdW5jdGlvbiBnZXRTdGF0ZSgpIHtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSk7XG4gICAgfTtcblxuICAgIC8vIHJldHVybnMgYSBkdXBsaWNhdGUgb2YgdGhlIGFjdGlvbnMgYXJyYXkgYW5kIGNsZWFycyB0aGUgYWN0aW9ucyBhcnJheVxuICAgIHZhciBwcm9jZXNzQWN0aW9uUXVldWUgPSBmdW5jdGlvbiBwcm9jZXNzQWN0aW9uUXVldWUoKSB7XG4gICAgICAvLyBjcmVhdGUgY29weSBvZiBhY3Rpb25zIHF1ZXVlXG4gICAgICB2YXIgcXVldWUgPSBbXS5jb25jYXQoYWN0aW9uUXVldWUpO1xuXG4gICAgICAvLyBjbGVhciBhY3Rpb25zIHF1ZXVlICh3ZSBkb24ndCB3YW50IG5vIGRvdWJsZSBhY3Rpb25zKVxuICAgICAgYWN0aW9uUXVldWUubGVuZ3RoID0gMDtcblxuICAgICAgcmV0dXJuIHF1ZXVlO1xuICAgIH07XG5cbiAgICAvLyBwcm9jZXNzZXMgYWN0aW9ucyB0aGF0IG1pZ2h0IGJsb2NrIHRoZSBtYWluIFVJIHRocmVhZFxuICAgIHZhciBwcm9jZXNzRGlzcGF0Y2hRdWV1ZSA9IGZ1bmN0aW9uIHByb2Nlc3NEaXNwYXRjaFF1ZXVlKCkge1xuICAgICAgLy8gY3JlYXRlIGNvcHkgb2YgYWN0aW9ucyBxdWV1ZVxuICAgICAgdmFyIHF1ZXVlID0gW10uY29uY2F0KGRpc3BhdGNoUXVldWUpO1xuXG4gICAgICAvLyBjbGVhciBhY3Rpb25zIHF1ZXVlICh3ZSBkb24ndCB3YW50IG5vIGRvdWJsZSBhY3Rpb25zKVxuICAgICAgZGlzcGF0Y2hRdWV1ZS5sZW5ndGggPSAwO1xuXG4gICAgICAvLyBub3cgZGlzcGF0Y2ggdGhlc2UgYWN0aW9uc1xuICAgICAgcXVldWUuZm9yRWFjaChmdW5jdGlvbihfcmVmKSB7XG4gICAgICAgIHZhciB0eXBlID0gX3JlZi50eXBlLFxuICAgICAgICAgIGRhdGEgPSBfcmVmLmRhdGE7XG4gICAgICAgIGRpc3BhdGNoKHR5cGUsIGRhdGEpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIGFkZHMgYSBuZXcgYWN0aW9uLCBjYWxscyBpdHMgaGFuZGxlciBhbmRcbiAgICB2YXIgZGlzcGF0Y2ggPSBmdW5jdGlvbiBkaXNwYXRjaCh0eXBlLCBkYXRhLCBpc0Jsb2NraW5nKSB7XG4gICAgICAvLyBpcyBibG9ja2luZyBhY3Rpb24gKHNob3VsZCBuZXZlciBibG9jayBpZiBkb2N1bWVudCBpcyBoaWRkZW4pXG4gICAgICBpZiAoaXNCbG9ja2luZyAmJiAhZG9jdW1lbnQuaGlkZGVuKSB7XG4gICAgICAgIGRpc3BhdGNoUXVldWUucHVzaCh7IHR5cGU6IHR5cGUsIGRhdGE6IGRhdGEgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gaWYgdGhpcyBhY3Rpb24gaGFzIGEgaGFuZGxlciwgaGFuZGxlIHRoZSBhY3Rpb25cbiAgICAgIGlmIChhY3Rpb25IYW5kbGVyc1t0eXBlXSkge1xuICAgICAgICBhY3Rpb25IYW5kbGVyc1t0eXBlXShkYXRhKTtcbiAgICAgIH1cblxuICAgICAgLy8gbm93IGFkZCBhY3Rpb25cbiAgICAgIGFjdGlvblF1ZXVlLnB1c2goe1xuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBkYXRhOiBkYXRhXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIHF1ZXJ5ID0gZnVuY3Rpb24gcXVlcnkoc3RyKSB7XG4gICAgICB2YXIgX3F1ZXJ5SGFuZGxlcztcbiAgICAgIGZvciAoXG4gICAgICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSxcbiAgICAgICAgICBfa2V5ID0gMTtcbiAgICAgICAgX2tleSA8IF9sZW47XG4gICAgICAgIF9rZXkrK1xuICAgICAgKSB7XG4gICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHF1ZXJ5SGFuZGxlc1tzdHJdXG4gICAgICAgID8gKF9xdWVyeUhhbmRsZXMgPSBxdWVyeUhhbmRsZXMpW3N0cl0uYXBwbHkoX3F1ZXJ5SGFuZGxlcywgYXJncylcbiAgICAgICAgOiBudWxsO1xuICAgIH07XG5cbiAgICB2YXIgYXBpID0ge1xuICAgICAgZ2V0U3RhdGU6IGdldFN0YXRlLFxuICAgICAgcHJvY2Vzc0FjdGlvblF1ZXVlOiBwcm9jZXNzQWN0aW9uUXVldWUsXG4gICAgICBwcm9jZXNzRGlzcGF0Y2hRdWV1ZTogcHJvY2Vzc0Rpc3BhdGNoUXVldWUsXG4gICAgICBkaXNwYXRjaDogZGlzcGF0Y2gsXG4gICAgICBxdWVyeTogcXVlcnlcbiAgICB9O1xuXG4gICAgdmFyIHF1ZXJ5SGFuZGxlcyA9IHt9O1xuICAgIHF1ZXJpZXMuZm9yRWFjaChmdW5jdGlvbihxdWVyeSkge1xuICAgICAgcXVlcnlIYW5kbGVzID0gT2JqZWN0LmFzc2lnbih7fSwgcXVlcnkoc3RhdGUpLCB7fSwgcXVlcnlIYW5kbGVzKTtcbiAgICB9KTtcblxuICAgIHZhciBhY3Rpb25IYW5kbGVycyA9IHt9O1xuICAgIGFjdGlvbnMuZm9yRWFjaChmdW5jdGlvbihhY3Rpb24pIHtcbiAgICAgIGFjdGlvbkhhbmRsZXJzID0gT2JqZWN0LmFzc2lnbihcbiAgICAgICAge30sXG4gICAgICAgIGFjdGlvbihkaXNwYXRjaCwgcXVlcnksIHN0YXRlKSxcbiAgICAgICAge30sXG4gICAgICAgIGFjdGlvbkhhbmRsZXJzXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGFwaTtcbiAgfTtcblxuICB2YXIgZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShvYmosIHByb3BlcnR5LCBkZWZpbml0aW9uKSB7XG4gICAgaWYgKHR5cGVvZiBkZWZpbml0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBvYmpbcHJvcGVydHldID0gZGVmaW5pdGlvbjtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgcHJvcGVydHksIE9iamVjdC5hc3NpZ24oe30sIGRlZmluaXRpb24pKTtcbiAgfTtcblxuICB2YXIgZm9yaW4gPSBmdW5jdGlvbiBmb3JpbihvYmosIGNiKSB7XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgaWYgKCFvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY2Ioa2V5LCBvYmpba2V5XSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBjcmVhdGVPYmplY3QgPSBmdW5jdGlvbiBjcmVhdGVPYmplY3QoZGVmaW5pdGlvbikge1xuICAgIHZhciBvYmogPSB7fTtcbiAgICBmb3JpbihkZWZpbml0aW9uLCBmdW5jdGlvbihwcm9wZXJ0eSkge1xuICAgICAgZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wZXJ0eSwgZGVmaW5pdGlvbltwcm9wZXJ0eV0pO1xuICAgIH0pO1xuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgdmFyIGF0dHIgPSBmdW5jdGlvbiBhdHRyKG5vZGUsIG5hbWUpIHtcbiAgICB2YXIgdmFsdWUgPVxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBudWxsO1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG5vZGUuZ2V0QXR0cmlidXRlKG5hbWUpIHx8IG5vZGUuaGFzQXR0cmlidXRlKG5hbWUpO1xuICAgIH1cbiAgICBub2RlLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gIH07XG5cbiAgdmFyIG5zID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcbiAgdmFyIHN2Z0VsZW1lbnRzID0gWydzdmcnLCAncGF0aCddOyAvLyBvbmx5IHN2ZyBlbGVtZW50cyB1c2VkXG5cbiAgdmFyIGlzU1ZHRWxlbWVudCA9IGZ1bmN0aW9uIGlzU1ZHRWxlbWVudCh0YWcpIHtcbiAgICByZXR1cm4gc3ZnRWxlbWVudHMuaW5jbHVkZXModGFnKTtcbiAgfTtcblxuICB2YXIgY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodGFnLCBjbGFzc05hbWUpIHtcbiAgICB2YXIgYXR0cmlidXRlcyA9XG4gICAgICBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIGlmICh0eXBlb2YgY2xhc3NOYW1lID09PSAnb2JqZWN0Jykge1xuICAgICAgYXR0cmlidXRlcyA9IGNsYXNzTmFtZTtcbiAgICAgIGNsYXNzTmFtZSA9IG51bGw7XG4gICAgfVxuICAgIHZhciBlbGVtZW50ID0gaXNTVkdFbGVtZW50KHRhZylcbiAgICAgID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5zLCB0YWcpXG4gICAgICA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICBpZiAoaXNTVkdFbGVtZW50KHRhZykpIHtcbiAgICAgICAgYXR0cihlbGVtZW50LCAnY2xhc3MnLCBjbGFzc05hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgICB9XG4gICAgfVxuICAgIGZvcmluKGF0dHJpYnV0ZXMsIGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICBhdHRyKGVsZW1lbnQsIG5hbWUsIHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfTtcblxuICB2YXIgYXBwZW5kQ2hpbGQgPSBmdW5jdGlvbiBhcHBlbmRDaGlsZChwYXJlbnQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oY2hpbGQsIGluZGV4KSB7XG4gICAgICBpZiAodHlwZW9mIGluZGV4ICE9PSAndW5kZWZpbmVkJyAmJiBwYXJlbnQuY2hpbGRyZW5baW5kZXhdKSB7XG4gICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQsIHBhcmVudC5jaGlsZHJlbltpbmRleF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIHZhciBhcHBlbmRDaGlsZFZpZXcgPSBmdW5jdGlvbiBhcHBlbmRDaGlsZFZpZXcocGFyZW50LCBjaGlsZFZpZXdzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHZpZXcsIGluZGV4KSB7XG4gICAgICBpZiAodHlwZW9mIGluZGV4ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjaGlsZFZpZXdzLnNwbGljZShpbmRleCwgMCwgdmlldyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGlsZFZpZXdzLnB1c2godmlldyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2aWV3O1xuICAgIH07XG4gIH07XG5cbiAgdmFyIHJlbW92ZUNoaWxkVmlldyA9IGZ1bmN0aW9uIHJlbW92ZUNoaWxkVmlldyhwYXJlbnQsIGNoaWxkVmlld3MpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odmlldykge1xuICAgICAgLy8gcmVtb3ZlIGZyb20gY2hpbGQgdmlld3NcbiAgICAgIGNoaWxkVmlld3Muc3BsaWNlKGNoaWxkVmlld3MuaW5kZXhPZih2aWV3KSwgMSk7XG5cbiAgICAgIC8vIHJlbW92ZSB0aGUgZWxlbWVudFxuICAgICAgaWYgKHZpZXcuZWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZCh2aWV3LmVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmlldztcbiAgICB9O1xuICB9O1xuXG4gIHZhciBJU19CUk9XU0VSID0gKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAoXG4gICAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSAndW5kZWZpbmVkJ1xuICAgICk7XG4gIH0pKCk7XG4gIHZhciBpc0Jyb3dzZXIgPSBmdW5jdGlvbiBpc0Jyb3dzZXIoKSB7XG4gICAgcmV0dXJuIElTX0JST1dTRVI7XG4gIH07XG5cbiAgdmFyIHRlc3RFbGVtZW50ID0gaXNCcm93c2VyKCkgPyBjcmVhdGVFbGVtZW50KCdzdmcnKSA6IHt9O1xuICB2YXIgZ2V0Q2hpbGRDb3VudCA9XG4gICAgJ2NoaWxkcmVuJyBpbiB0ZXN0RWxlbWVudFxuICAgICAgPyBmdW5jdGlvbihlbCkge1xuICAgICAgICAgIHJldHVybiBlbC5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIDogZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICByZXR1cm4gZWwuY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgICAgIH07XG5cbiAgdmFyIGdldFZpZXdSZWN0ID0gZnVuY3Rpb24gZ2V0Vmlld1JlY3QoXG4gICAgZWxlbWVudFJlY3QsXG4gICAgY2hpbGRWaWV3cyxcbiAgICBvZmZzZXQsXG4gICAgc2NhbGVcbiAgKSB7XG4gICAgdmFyIGxlZnQgPSBvZmZzZXRbMF0gfHwgZWxlbWVudFJlY3QubGVmdDtcbiAgICB2YXIgdG9wID0gb2Zmc2V0WzFdIHx8IGVsZW1lbnRSZWN0LnRvcDtcbiAgICB2YXIgcmlnaHQgPSBsZWZ0ICsgZWxlbWVudFJlY3Qud2lkdGg7XG4gICAgdmFyIGJvdHRvbSA9IHRvcCArIGVsZW1lbnRSZWN0LmhlaWdodCAqIChzY2FsZVsxXSB8fCAxKTtcblxuICAgIHZhciByZWN0ID0ge1xuICAgICAgLy8gdGhlIHJlY3RhbmdsZSBvZiB0aGUgZWxlbWVudCBpdHNlbGZcbiAgICAgIGVsZW1lbnQ6IE9iamVjdC5hc3NpZ24oe30sIGVsZW1lbnRSZWN0KSxcblxuICAgICAgLy8gdGhlIHJlY3RhbmdsZSBvZiB0aGUgZWxlbWVudCBleHBhbmRlZCB0byBjb250YWluIGl0cyBjaGlsZHJlbiwgZG9lcyBub3QgaW5jbHVkZSBhbnkgbWFyZ2luc1xuICAgICAgaW5uZXI6IHtcbiAgICAgICAgbGVmdDogZWxlbWVudFJlY3QubGVmdCxcbiAgICAgICAgdG9wOiBlbGVtZW50UmVjdC50b3AsXG4gICAgICAgIHJpZ2h0OiBlbGVtZW50UmVjdC5yaWdodCxcbiAgICAgICAgYm90dG9tOiBlbGVtZW50UmVjdC5ib3R0b21cbiAgICAgIH0sXG5cbiAgICAgIC8vIHRoZSByZWN0YW5nbGUgb2YgdGhlIGVsZW1lbnQgZXhwYW5kZWQgdG8gY29udGFpbiBpdHMgY2hpbGRyZW4gaW5jbHVkaW5nIG93biBtYXJnaW4gYW5kIGNoaWxkIG1hcmdpbnNcbiAgICAgIC8vIG1hcmdpbnMgd2lsbCBiZSBhZGRlZCBhZnRlciB3ZSd2ZSByZWNhbGN1bGF0ZWQgdGhlIHNpemVcbiAgICAgIG91dGVyOiB7XG4gICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgIHRvcDogdG9wLFxuICAgICAgICByaWdodDogcmlnaHQsXG4gICAgICAgIGJvdHRvbTogYm90dG9tXG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIGV4cGFuZCByZWN0IHRvIGZpdCBhbGwgY2hpbGQgcmVjdGFuZ2xlc1xuICAgIGNoaWxkVmlld3NcbiAgICAgIC5maWx0ZXIoZnVuY3Rpb24oY2hpbGRWaWV3KSB7XG4gICAgICAgIHJldHVybiAhY2hpbGRWaWV3LmlzUmVjdElnbm9yZWQoKTtcbiAgICAgIH0pXG4gICAgICAubWFwKGZ1bmN0aW9uKGNoaWxkVmlldykge1xuICAgICAgICByZXR1cm4gY2hpbGRWaWV3LnJlY3Q7XG4gICAgICB9KVxuICAgICAgLmZvckVhY2goZnVuY3Rpb24oY2hpbGRWaWV3UmVjdCkge1xuICAgICAgICBleHBhbmRSZWN0KHJlY3QuaW5uZXIsIE9iamVjdC5hc3NpZ24oe30sIGNoaWxkVmlld1JlY3QuaW5uZXIpKTtcbiAgICAgICAgZXhwYW5kUmVjdChyZWN0Lm91dGVyLCBPYmplY3QuYXNzaWduKHt9LCBjaGlsZFZpZXdSZWN0Lm91dGVyKSk7XG4gICAgICB9KTtcblxuICAgIC8vIGNhbGN1bGF0ZSBpbm5lciB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgY2FsY3VsYXRlUmVjdFNpemUocmVjdC5pbm5lcik7XG5cbiAgICAvLyBhcHBlbmQgYWRkaXRpb25hbCBtYXJnaW4gKHRvcCBhbmQgbGVmdCBtYXJnaW5zIGFyZSBpbmNsdWRlZCBpbiB0b3AgYW5kIGxlZnQgYXV0b21hdGljYWxseSlcbiAgICByZWN0Lm91dGVyLmJvdHRvbSArPSByZWN0LmVsZW1lbnQubWFyZ2luQm90dG9tO1xuICAgIHJlY3Qub3V0ZXIucmlnaHQgKz0gcmVjdC5lbGVtZW50Lm1hcmdpblJpZ2h0O1xuXG4gICAgLy8gY2FsY3VsYXRlIG91dGVyIHdpZHRoIGFuZCBoZWlnaHRcbiAgICBjYWxjdWxhdGVSZWN0U2l6ZShyZWN0Lm91dGVyKTtcblxuICAgIHJldHVybiByZWN0O1xuICB9O1xuXG4gIHZhciBleHBhbmRSZWN0ID0gZnVuY3Rpb24gZXhwYW5kUmVjdChwYXJlbnQsIGNoaWxkKSB7XG4gICAgLy8gYWRqdXN0IGZvciBwYXJlbnQgb2Zmc2V0XG4gICAgY2hpbGQudG9wICs9IHBhcmVudC50b3A7XG4gICAgY2hpbGQucmlnaHQgKz0gcGFyZW50LmxlZnQ7XG4gICAgY2hpbGQuYm90dG9tICs9IHBhcmVudC50b3A7XG4gICAgY2hpbGQubGVmdCArPSBwYXJlbnQubGVmdDtcblxuICAgIGlmIChjaGlsZC5ib3R0b20gPiBwYXJlbnQuYm90dG9tKSB7XG4gICAgICBwYXJlbnQuYm90dG9tID0gY2hpbGQuYm90dG9tO1xuICAgIH1cblxuICAgIGlmIChjaGlsZC5yaWdodCA+IHBhcmVudC5yaWdodCkge1xuICAgICAgcGFyZW50LnJpZ2h0ID0gY2hpbGQucmlnaHQ7XG4gICAgfVxuICB9O1xuXG4gIHZhciBjYWxjdWxhdGVSZWN0U2l6ZSA9IGZ1bmN0aW9uIGNhbGN1bGF0ZVJlY3RTaXplKHJlY3QpIHtcbiAgICByZWN0LndpZHRoID0gcmVjdC5yaWdodCAtIHJlY3QubGVmdDtcbiAgICByZWN0LmhlaWdodCA9IHJlY3QuYm90dG9tIC0gcmVjdC50b3A7XG4gIH07XG5cbiAgdmFyIGlzTnVtYmVyID0gZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJztcbiAgfTtcblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyBpZiBwb3NpdGlvbiBpcyBhdCBkZXN0aW5hdGlvblxuICAgKiBAcGFyYW0gcG9zaXRpb25cbiAgICogQHBhcmFtIGRlc3RpbmF0aW9uXG4gICAqIEBwYXJhbSB2ZWxvY2l0eVxuICAgKiBAcGFyYW0gZXJyb3JNYXJnaW5cbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICB2YXIgdGhlcmVZZXQgPSBmdW5jdGlvbiB0aGVyZVlldChwb3NpdGlvbiwgZGVzdGluYXRpb24sIHZlbG9jaXR5KSB7XG4gICAgdmFyIGVycm9yTWFyZ2luID1cbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogMC4wMDE7XG4gICAgcmV0dXJuIChcbiAgICAgIE1hdGguYWJzKHBvc2l0aW9uIC0gZGVzdGluYXRpb24pIDwgZXJyb3JNYXJnaW4gJiZcbiAgICAgIE1hdGguYWJzKHZlbG9jaXR5KSA8IGVycm9yTWFyZ2luXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogU3ByaW5nIGFuaW1hdGlvblxuICAgKi9cbiAgdmFyIHNwcmluZyA9XG4gICAgLy8gZGVmYXVsdCBvcHRpb25zXG4gICAgZnVuY3Rpb24gc3ByaW5nKCkgLy8gbWV0aG9kIGRlZmluaXRpb25cbiAgICB7XG4gICAgICB2YXIgX3JlZiA9XG4gICAgICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gYXJndW1lbnRzWzBdXG4gICAgICAgICAgICA6IHt9LFxuICAgICAgICBfcmVmJHN0aWZmbmVzcyA9IF9yZWYuc3RpZmZuZXNzLFxuICAgICAgICBzdGlmZm5lc3MgPSBfcmVmJHN0aWZmbmVzcyA9PT0gdm9pZCAwID8gMC41IDogX3JlZiRzdGlmZm5lc3MsXG4gICAgICAgIF9yZWYkZGFtcGluZyA9IF9yZWYuZGFtcGluZyxcbiAgICAgICAgZGFtcGluZyA9IF9yZWYkZGFtcGluZyA9PT0gdm9pZCAwID8gMC43NSA6IF9yZWYkZGFtcGluZyxcbiAgICAgICAgX3JlZiRtYXNzID0gX3JlZi5tYXNzLFxuICAgICAgICBtYXNzID0gX3JlZiRtYXNzID09PSB2b2lkIDAgPyAxMCA6IF9yZWYkbWFzcztcbiAgICAgIHZhciB0YXJnZXQgPSBudWxsO1xuICAgICAgdmFyIHBvc2l0aW9uID0gbnVsbDtcbiAgICAgIHZhciB2ZWxvY2l0eSA9IDA7XG4gICAgICB2YXIgcmVzdGluZyA9IGZhbHNlO1xuXG4gICAgICAvLyB1cGRhdGVzIHNwcmluZyBzdGF0ZVxuICAgICAgdmFyIGludGVycG9sYXRlID0gZnVuY3Rpb24gaW50ZXJwb2xhdGUodHMsIHNraXBUb0VuZFN0YXRlKSB7XG4gICAgICAgIC8vIGluIHJlc3QsIGRvbid0IGFuaW1hdGVcbiAgICAgICAgaWYgKHJlc3RpbmcpIHJldHVybjtcblxuICAgICAgICAvLyBuZWVkIGF0IGxlYXN0IGEgdGFyZ2V0IG9yIHBvc2l0aW9uIHRvIGRvIHNwcmluZ3kgdGhpbmdzXG4gICAgICAgIGlmICghKGlzTnVtYmVyKHRhcmdldCkgJiYgaXNOdW1iZXIocG9zaXRpb24pKSkge1xuICAgICAgICAgIHJlc3RpbmcgPSB0cnVlO1xuICAgICAgICAgIHZlbG9jaXR5ID0gMDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjYWxjdWxhdGUgc3ByaW5nIGZvcmNlXG4gICAgICAgIHZhciBmID0gLShwb3NpdGlvbiAtIHRhcmdldCkgKiBzdGlmZm5lc3M7XG5cbiAgICAgICAgLy8gdXBkYXRlIHZlbG9jaXR5IGJ5IGFkZGluZyBmb3JjZSBiYXNlZCBvbiBtYXNzXG4gICAgICAgIHZlbG9jaXR5ICs9IGYgLyBtYXNzO1xuXG4gICAgICAgIC8vIHVwZGF0ZSBwb3NpdGlvbiBieSBhZGRpbmcgdmVsb2NpdHlcbiAgICAgICAgcG9zaXRpb24gKz0gdmVsb2NpdHk7XG5cbiAgICAgICAgLy8gc2xvdyBkb3duIGJhc2VkIG9uIGFtb3VudCBvZiBkYW1waW5nXG4gICAgICAgIHZlbG9jaXR5ICo9IGRhbXBpbmc7XG5cbiAgICAgICAgLy8gd2UndmUgYXJyaXZlZCBpZiB3ZSdyZSBuZWFyIHRhcmdldCBhbmQgb3VyIHZlbG9jaXR5IGlzIG5lYXIgemVyb1xuICAgICAgICBpZiAodGhlcmVZZXQocG9zaXRpb24sIHRhcmdldCwgdmVsb2NpdHkpIHx8IHNraXBUb0VuZFN0YXRlKSB7XG4gICAgICAgICAgcG9zaXRpb24gPSB0YXJnZXQ7XG4gICAgICAgICAgdmVsb2NpdHkgPSAwO1xuICAgICAgICAgIHJlc3RpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgLy8gd2UgZG9uZVxuICAgICAgICAgIGFwaS5vbnVwZGF0ZShwb3NpdGlvbik7XG4gICAgICAgICAgYXBpLm9uY29tcGxldGUocG9zaXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHByb2dyZXNzIHVwZGF0ZVxuICAgICAgICAgIGFwaS5vbnVwZGF0ZShwb3NpdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0IG5ldyB0YXJnZXQgdmFsdWVcbiAgICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAgICovXG4gICAgICB2YXIgc2V0VGFyZ2V0ID0gZnVuY3Rpb24gc2V0VGFyZ2V0KHZhbHVlKSB7XG4gICAgICAgIC8vIGlmIGN1cnJlbnRseSBoYXMgbm8gcG9zaXRpb24sIHNldCB0YXJnZXQgYW5kIHBvc2l0aW9uIHRvIHRoaXMgdmFsdWVcbiAgICAgICAgaWYgKGlzTnVtYmVyKHZhbHVlKSAmJiAhaXNOdW1iZXIocG9zaXRpb24pKSB7XG4gICAgICAgICAgcG9zaXRpb24gPSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5leHQgdGFyZ2V0IHZhbHVlIHdpbGwgbm90IGJlIGFuaW1hdGVkIHRvXG4gICAgICAgIGlmICh0YXJnZXQgPT09IG51bGwpIHtcbiAgICAgICAgICB0YXJnZXQgPSB2YWx1ZTtcbiAgICAgICAgICBwb3NpdGlvbiA9IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbGV0IHN0YXJ0IG1vdmluZyB0byB0YXJnZXRcbiAgICAgICAgdGFyZ2V0ID0gdmFsdWU7XG5cbiAgICAgICAgLy8gYWxyZWFkeSBhdCB0YXJnZXRcbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSB0YXJnZXQgfHwgdHlwZW9mIHRhcmdldCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAvLyBub3cgcmVzdGluZyBhcyB0YXJnZXQgaXMgY3VycmVudCBwb3NpdGlvbiwgc3RvcCBtb3ZpbmdcbiAgICAgICAgICByZXN0aW5nID0gdHJ1ZTtcbiAgICAgICAgICB2ZWxvY2l0eSA9IDA7XG5cbiAgICAgICAgICAvLyBkb25lIVxuICAgICAgICAgIGFwaS5vbnVwZGF0ZShwb3NpdGlvbik7XG4gICAgICAgICAgYXBpLm9uY29tcGxldGUocG9zaXRpb24pO1xuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdGluZyA9IGZhbHNlO1xuICAgICAgfTtcblxuICAgICAgLy8gbmVlZCAnYXBpJyB0byBjYWxsIG9udXBkYXRlIGNhbGxiYWNrXG4gICAgICB2YXIgYXBpID0gY3JlYXRlT2JqZWN0KHtcbiAgICAgICAgaW50ZXJwb2xhdGU6IGludGVycG9sYXRlLFxuICAgICAgICB0YXJnZXQ6IHtcbiAgICAgICAgICBzZXQ6IHNldFRhcmdldCxcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHJlc3Rpbmc6IHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN0aW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBvbnVwZGF0ZTogZnVuY3Rpb24gb251cGRhdGUodmFsdWUpIHt9LFxuICAgICAgICBvbmNvbXBsZXRlOiBmdW5jdGlvbiBvbmNvbXBsZXRlKHZhbHVlKSB7fVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBhcGk7XG4gICAgfTtcblxuICB2YXIgZWFzZUxpbmVhciA9IGZ1bmN0aW9uIGVhc2VMaW5lYXIodCkge1xuICAgIHJldHVybiB0O1xuICB9O1xuICB2YXIgZWFzZUluT3V0UXVhZCA9IGZ1bmN0aW9uIGVhc2VJbk91dFF1YWQodCkge1xuICAgIHJldHVybiB0IDwgMC41ID8gMiAqIHQgKiB0IDogLTEgKyAoNCAtIDIgKiB0KSAqIHQ7XG4gIH07XG5cbiAgdmFyIHR3ZWVuID1cbiAgICAvLyBkZWZhdWx0IHZhbHVlc1xuICAgIGZ1bmN0aW9uIHR3ZWVuKCkgLy8gbWV0aG9kIGRlZmluaXRpb25cbiAgICB7XG4gICAgICB2YXIgX3JlZiA9XG4gICAgICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gYXJndW1lbnRzWzBdXG4gICAgICAgICAgICA6IHt9LFxuICAgICAgICBfcmVmJGR1cmF0aW9uID0gX3JlZi5kdXJhdGlvbixcbiAgICAgICAgZHVyYXRpb24gPSBfcmVmJGR1cmF0aW9uID09PSB2b2lkIDAgPyA1MDAgOiBfcmVmJGR1cmF0aW9uLFxuICAgICAgICBfcmVmJGVhc2luZyA9IF9yZWYuZWFzaW5nLFxuICAgICAgICBlYXNpbmcgPSBfcmVmJGVhc2luZyA9PT0gdm9pZCAwID8gZWFzZUluT3V0UXVhZCA6IF9yZWYkZWFzaW5nLFxuICAgICAgICBfcmVmJGRlbGF5ID0gX3JlZi5kZWxheSxcbiAgICAgICAgZGVsYXkgPSBfcmVmJGRlbGF5ID09PSB2b2lkIDAgPyAwIDogX3JlZiRkZWxheTtcbiAgICAgIHZhciBzdGFydCA9IG51bGw7XG4gICAgICB2YXIgdDtcbiAgICAgIHZhciBwO1xuICAgICAgdmFyIHJlc3RpbmcgPSB0cnVlO1xuICAgICAgdmFyIHJldmVyc2UgPSBmYWxzZTtcbiAgICAgIHZhciB0YXJnZXQgPSBudWxsO1xuXG4gICAgICB2YXIgaW50ZXJwb2xhdGUgPSBmdW5jdGlvbiBpbnRlcnBvbGF0ZSh0cywgc2tpcFRvRW5kU3RhdGUpIHtcbiAgICAgICAgaWYgKHJlc3RpbmcgfHwgdGFyZ2V0ID09PSBudWxsKSByZXR1cm47XG5cbiAgICAgICAgaWYgKHN0YXJ0ID09PSBudWxsKSB7XG4gICAgICAgICAgc3RhcnQgPSB0cztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0cyAtIHN0YXJ0IDwgZGVsYXkpIHJldHVybjtcblxuICAgICAgICB0ID0gdHMgLSBzdGFydCAtIGRlbGF5O1xuXG4gICAgICAgIGlmICh0ID49IGR1cmF0aW9uIHx8IHNraXBUb0VuZFN0YXRlKSB7XG4gICAgICAgICAgdCA9IDE7XG4gICAgICAgICAgcCA9IHJldmVyc2UgPyAwIDogMTtcbiAgICAgICAgICBhcGkub251cGRhdGUocCAqIHRhcmdldCk7XG4gICAgICAgICAgYXBpLm9uY29tcGxldGUocCAqIHRhcmdldCk7XG4gICAgICAgICAgcmVzdGluZyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcCA9IHQgLyBkdXJhdGlvbjtcbiAgICAgICAgICBhcGkub251cGRhdGUoKHQgPj0gMCA/IGVhc2luZyhyZXZlcnNlID8gMSAtIHAgOiBwKSA6IDApICogdGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gbmVlZCAnYXBpJyB0byBjYWxsIG9udXBkYXRlIGNhbGxiYWNrXG4gICAgICB2YXIgYXBpID0gY3JlYXRlT2JqZWN0KHtcbiAgICAgICAgaW50ZXJwb2xhdGU6IGludGVycG9sYXRlLFxuICAgICAgICB0YXJnZXQ6IHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiByZXZlcnNlID8gMCA6IHRhcmdldDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBpcyBpbml0aWFsIHZhbHVlXG4gICAgICAgICAgICBpZiAodGFyZ2V0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHRhcmdldCA9IHZhbHVlO1xuICAgICAgICAgICAgICBhcGkub251cGRhdGUodmFsdWUpO1xuICAgICAgICAgICAgICBhcGkub25jb21wbGV0ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gd2FudCB0byB0d2VlbiB0byBhIHNtYWxsZXIgdmFsdWUgYW5kIGhhdmUgYSBjdXJyZW50IHZhbHVlXG4gICAgICAgICAgICBpZiAodmFsdWUgPCB0YXJnZXQpIHtcbiAgICAgICAgICAgICAgdGFyZ2V0ID0gMTtcbiAgICAgICAgICAgICAgcmV2ZXJzZSA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBub3QgdHdlZW5pbmcgdG8gYSBzbWFsbGVyIHZhbHVlXG4gICAgICAgICAgICAgIHJldmVyc2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgdGFyZ2V0ID0gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGxldCdzIGdvIVxuICAgICAgICAgICAgcmVzdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgc3RhcnQgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICByZXN0aW5nOiB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdGluZztcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgb251cGRhdGU6IGZ1bmN0aW9uIG9udXBkYXRlKHZhbHVlKSB7fSxcbiAgICAgICAgb25jb21wbGV0ZTogZnVuY3Rpb24gb25jb21wbGV0ZSh2YWx1ZSkge31cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gYXBpO1xuICAgIH07XG5cbiAgdmFyIGFuaW1hdG9yID0ge1xuICAgIHNwcmluZzogc3ByaW5nLFxuICAgIHR3ZWVuOiB0d2VlblxuICB9O1xuXG4gIC8qXG4gICAgICAgICAgICAgICAgICAgICAgIHsgdHlwZTogJ3NwcmluZycsIHN0aWZmbmVzczogLjUsIGRhbXBpbmc6IC43NSwgbWFzczogMTAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgeyB0cmFuc2xhdGlvbjogeyB0eXBlOiAnc3ByaW5nJywgLi4uIH0sIC4uLiB9XG4gICAgICAgICAgICAgICAgICAgICAgIHsgdHJhbnNsYXRpb246IHsgeDogeyB0eXBlOiAnc3ByaW5nJywgLi4uIH0gfSB9XG4gICAgICAgICAgICAgICAgICAgICAgKi9cbiAgdmFyIGNyZWF0ZUFuaW1hdG9yID0gZnVuY3Rpb24gY3JlYXRlQW5pbWF0b3IoZGVmaW5pdGlvbiwgY2F0ZWdvcnksIHByb3BlcnR5KSB7XG4gICAgLy8gZGVmYXVsdCBpcyBzaW5nbGUgZGVmaW5pdGlvblxuICAgIC8vIHdlIGNoZWNrIGlmIHRyYW5zZm9ybSBpcyBzZXQsIGlmIHNvLCB3ZSBjaGVjayBpZiBwcm9wZXJ0eSBpcyBzZXRcbiAgICB2YXIgZGVmID1cbiAgICAgIGRlZmluaXRpb25bY2F0ZWdvcnldICYmIHR5cGVvZiBkZWZpbml0aW9uW2NhdGVnb3J5XVtwcm9wZXJ0eV0gPT09ICdvYmplY3QnXG4gICAgICAgID8gZGVmaW5pdGlvbltjYXRlZ29yeV1bcHJvcGVydHldXG4gICAgICAgIDogZGVmaW5pdGlvbltjYXRlZ29yeV0gfHwgZGVmaW5pdGlvbjtcblxuICAgIHZhciB0eXBlID0gdHlwZW9mIGRlZiA9PT0gJ3N0cmluZycgPyBkZWYgOiBkZWYudHlwZTtcbiAgICB2YXIgcHJvcHMgPSB0eXBlb2YgZGVmID09PSAnb2JqZWN0JyA/IE9iamVjdC5hc3NpZ24oe30sIGRlZikgOiB7fTtcblxuICAgIHJldHVybiBhbmltYXRvclt0eXBlXSA/IGFuaW1hdG9yW3R5cGVdKHByb3BzKSA6IG51bGw7XG4gIH07XG5cbiAgdmFyIGFkZEdldFNldCA9IGZ1bmN0aW9uIGFkZEdldFNldChrZXlzLCBvYmosIHByb3BzKSB7XG4gICAgdmFyIG92ZXJ3cml0ZSA9XG4gICAgICBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IGZhbHNlO1xuICAgIG9iaiA9IEFycmF5LmlzQXJyYXkob2JqKSA/IG9iaiA6IFtvYmpdO1xuICAgIG9iai5mb3JFYWNoKGZ1bmN0aW9uKG8pIHtcbiAgICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBrZXk7XG4gICAgICAgIHZhciBnZXR0ZXIgPSBmdW5jdGlvbiBnZXR0ZXIoKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BzW2tleV07XG4gICAgICAgIH07XG4gICAgICAgIHZhciBzZXR0ZXIgPSBmdW5jdGlvbiBzZXR0ZXIodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gKHByb3BzW2tleV0gPSB2YWx1ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgbmFtZSA9IGtleS5rZXk7XG4gICAgICAgICAgZ2V0dGVyID0ga2V5LmdldHRlciB8fCBnZXR0ZXI7XG4gICAgICAgICAgc2V0dGVyID0ga2V5LnNldHRlciB8fCBzZXR0ZXI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob1tuYW1lXSAmJiAhb3ZlcndyaXRlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgb1tuYW1lXSA9IHtcbiAgICAgICAgICBnZXQ6IGdldHRlcixcbiAgICAgICAgICBzZXQ6IHNldHRlclxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gYWRkIHRvIHN0YXRlLFxuICAvLyBhZGQgZ2V0dGVycyBhbmQgc2V0dGVycyB0byBpbnRlcm5hbCBhbmQgZXh0ZXJuYWwgYXBpIChpZiBub3Qgc2V0KVxuICAvLyBzZXR1cCBhbmltYXRvcnNcblxuICB2YXIgYW5pbWF0aW9ucyA9IGZ1bmN0aW9uIGFuaW1hdGlvbnMoX3JlZikge1xuICAgIHZhciBtaXhpbkNvbmZpZyA9IF9yZWYubWl4aW5Db25maWcsXG4gICAgICB2aWV3UHJvcHMgPSBfcmVmLnZpZXdQcm9wcyxcbiAgICAgIHZpZXdJbnRlcm5hbEFQSSA9IF9yZWYudmlld0ludGVybmFsQVBJLFxuICAgICAgdmlld0V4dGVybmFsQVBJID0gX3JlZi52aWV3RXh0ZXJuYWxBUEk7XG4gICAgLy8gaW5pdGlhbCBwcm9wZXJ0aWVzXG4gICAgdmFyIGluaXRpYWxQcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIHZpZXdQcm9wcyk7XG5cbiAgICAvLyBsaXN0IG9mIGFsbCBhY3RpdmUgYW5pbWF0aW9uc1xuICAgIHZhciBhbmltYXRpb25zID0gW107XG5cbiAgICAvLyBzZXR1cCBhbmltYXRvcnNcbiAgICBmb3JpbihtaXhpbkNvbmZpZywgZnVuY3Rpb24ocHJvcGVydHksIGFuaW1hdGlvbikge1xuICAgICAgdmFyIGFuaW1hdG9yID0gY3JlYXRlQW5pbWF0b3IoYW5pbWF0aW9uKTtcbiAgICAgIGlmICghYW5pbWF0b3IpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyB3aGVuIHRoZSBhbmltYXRvciB1cGRhdGVzLCB1cGRhdGUgdGhlIHZpZXcgc3RhdGUgdmFsdWVcbiAgICAgIGFuaW1hdG9yLm9udXBkYXRlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmlld1Byb3BzW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgfTtcblxuICAgICAgLy8gc2V0IGFuaW1hdG9yIHRhcmdldFxuICAgICAgYW5pbWF0b3IudGFyZ2V0ID0gaW5pdGlhbFByb3BzW3Byb3BlcnR5XTtcblxuICAgICAgLy8gd2hlbiB2YWx1ZSBpcyBzZXQsIHNldCB0aGUgYW5pbWF0b3IgdGFyZ2V0IHZhbHVlXG4gICAgICB2YXIgcHJvcCA9IHtcbiAgICAgICAga2V5OiBwcm9wZXJ0eSxcbiAgICAgICAgc2V0dGVyOiBmdW5jdGlvbiBzZXR0ZXIodmFsdWUpIHtcbiAgICAgICAgICAvLyBpZiBhbHJlYWR5IGF0IHRhcmdldCwgd2UgZG9uZSFcbiAgICAgICAgICBpZiAoYW5pbWF0b3IudGFyZ2V0ID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGFuaW1hdG9yLnRhcmdldCA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBnZXR0ZXI6IGZ1bmN0aW9uIGdldHRlcigpIHtcbiAgICAgICAgICByZXR1cm4gdmlld1Byb3BzW3Byb3BlcnR5XTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gYWRkIGdldHRlcnMgYW5kIHNldHRlcnNcbiAgICAgIGFkZEdldFNldChbcHJvcF0sIFt2aWV3SW50ZXJuYWxBUEksIHZpZXdFeHRlcm5hbEFQSV0sIHZpZXdQcm9wcywgdHJ1ZSk7XG5cbiAgICAgIC8vIGFkZCBpdCB0byB0aGUgbGlzdCBmb3IgZWFzeSB1cGRhdGluZyBmcm9tIHRoZSBfd3JpdGUgbWV0aG9kXG4gICAgICBhbmltYXRpb25zLnB1c2goYW5pbWF0b3IpO1xuICAgIH0pO1xuXG4gICAgLy8gZXhwb3NlIGludGVybmFsIHdyaXRlIGFwaVxuICAgIHJldHVybiB7XG4gICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUodHMpIHtcbiAgICAgICAgdmFyIHNraXBUb0VuZFN0YXRlID0gZG9jdW1lbnQuaGlkZGVuO1xuICAgICAgICB2YXIgcmVzdGluZyA9IHRydWU7XG4gICAgICAgIGFuaW1hdGlvbnMuZm9yRWFjaChmdW5jdGlvbihhbmltYXRpb24pIHtcbiAgICAgICAgICBpZiAoIWFuaW1hdGlvbi5yZXN0aW5nKSByZXN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgYW5pbWF0aW9uLmludGVycG9sYXRlKHRzLCBza2lwVG9FbmRTdGF0ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdGluZztcbiAgICAgIH0sXG4gICAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge31cbiAgICB9O1xuICB9O1xuXG4gIHZhciBhZGRFdmVudCA9IGZ1bmN0aW9uIGFkZEV2ZW50KGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odHlwZSwgZm4pIHtcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBmbik7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgcmVtb3ZlRXZlbnQgPSBmdW5jdGlvbiByZW1vdmVFdmVudChlbGVtZW50KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHR5cGUsIGZuKSB7XG4gICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgZm4pO1xuICAgIH07XG4gIH07XG5cbiAgLy8gbWl4aW5cbiAgdmFyIGxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyhfcmVmKSB7XG4gICAgdmFyIG1peGluQ29uZmlnID0gX3JlZi5taXhpbkNvbmZpZyxcbiAgICAgIHZpZXdQcm9wcyA9IF9yZWYudmlld1Byb3BzLFxuICAgICAgdmlld0ludGVybmFsQVBJID0gX3JlZi52aWV3SW50ZXJuYWxBUEksXG4gICAgICB2aWV3RXh0ZXJuYWxBUEkgPSBfcmVmLnZpZXdFeHRlcm5hbEFQSSxcbiAgICAgIHZpZXdTdGF0ZSA9IF9yZWYudmlld1N0YXRlLFxuICAgICAgdmlldyA9IF9yZWYudmlldztcbiAgICB2YXIgZXZlbnRzID0gW107XG5cbiAgICB2YXIgYWRkID0gYWRkRXZlbnQodmlldy5lbGVtZW50KTtcbiAgICB2YXIgcmVtb3ZlID0gcmVtb3ZlRXZlbnQodmlldy5lbGVtZW50KTtcblxuICAgIHZpZXdFeHRlcm5hbEFQSS5vbiA9IGZ1bmN0aW9uKHR5cGUsIGZuKSB7XG4gICAgICBldmVudHMucHVzaCh7XG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIGZuOiBmblxuICAgICAgfSk7XG5cbiAgICAgIGFkZCh0eXBlLCBmbik7XG4gICAgfTtcblxuICAgIHZpZXdFeHRlcm5hbEFQSS5vZmYgPSBmdW5jdGlvbih0eXBlLCBmbikge1xuICAgICAgZXZlbnRzLnNwbGljZShcbiAgICAgICAgZXZlbnRzLmZpbmRJbmRleChmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgIHJldHVybiBldmVudC50eXBlID09PSB0eXBlICYmIGV2ZW50LmZuID09PSBmbjtcbiAgICAgICAgfSksXG4gICAgICAgIDFcbiAgICAgICk7XG5cbiAgICAgIHJlbW92ZSh0eXBlLCBmbik7XG4gICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUoKSB7XG4gICAgICAgIC8vIG5vdCBidXN5XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSxcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIGV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgcmVtb3ZlKGV2ZW50LnR5cGUsIGV2ZW50LmZuKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICAvLyBhZGQgdG8gZXh0ZXJuYWwgYXBpIGFuZCBsaW5rIHRvIHByb3BzXG5cbiAgdmFyIGFwaXMgPSBmdW5jdGlvbiBhcGlzKF9yZWYpIHtcbiAgICB2YXIgbWl4aW5Db25maWcgPSBfcmVmLm1peGluQ29uZmlnLFxuICAgICAgdmlld1Byb3BzID0gX3JlZi52aWV3UHJvcHMsXG4gICAgICB2aWV3RXh0ZXJuYWxBUEkgPSBfcmVmLnZpZXdFeHRlcm5hbEFQSTtcbiAgICBhZGRHZXRTZXQobWl4aW5Db25maWcsIHZpZXdFeHRlcm5hbEFQSSwgdmlld1Byb3BzKTtcbiAgfTtcblxuICB2YXIgaXNEZWZpbmVkID0gZnVuY3Rpb24gaXNEZWZpbmVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9IG51bGw7XG4gIH07XG5cbiAgLy8gYWRkIHRvIHN0YXRlLFxuICAvLyBhZGQgZ2V0dGVycyBhbmQgc2V0dGVycyB0byBpbnRlcm5hbCBhbmQgZXh0ZXJuYWwgYXBpIChpZiBub3Qgc2V0KVxuICAvLyBzZXQgaW5pdGlhbCBzdGF0ZSBiYXNlZCBvbiBwcm9wcyBpbiB2aWV3UHJvcHNcbiAgLy8gYXBwbHkgYXMgdHJhbnNmb3JtcyBlYWNoIGZyYW1lXG5cbiAgdmFyIGRlZmF1bHRzID0ge1xuICAgIG9wYWNpdHk6IDEsXG4gICAgc2NhbGVYOiAxLFxuICAgIHNjYWxlWTogMSxcbiAgICB0cmFuc2xhdGVYOiAwLFxuICAgIHRyYW5zbGF0ZVk6IDAsXG4gICAgcm90YXRlWDogMCxcbiAgICByb3RhdGVZOiAwLFxuICAgIHJvdGF0ZVo6IDAsXG4gICAgb3JpZ2luWDogMCxcbiAgICBvcmlnaW5ZOiAwXG4gIH07XG5cbiAgdmFyIHN0eWxlcyA9IGZ1bmN0aW9uIHN0eWxlcyhfcmVmKSB7XG4gICAgdmFyIG1peGluQ29uZmlnID0gX3JlZi5taXhpbkNvbmZpZyxcbiAgICAgIHZpZXdQcm9wcyA9IF9yZWYudmlld1Byb3BzLFxuICAgICAgdmlld0ludGVybmFsQVBJID0gX3JlZi52aWV3SW50ZXJuYWxBUEksXG4gICAgICB2aWV3RXh0ZXJuYWxBUEkgPSBfcmVmLnZpZXdFeHRlcm5hbEFQSSxcbiAgICAgIHZpZXcgPSBfcmVmLnZpZXc7XG4gICAgLy8gaW5pdGlhbCBwcm9wc1xuICAgIHZhciBpbml0aWFsUHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCB2aWV3UHJvcHMpO1xuXG4gICAgLy8gY3VycmVudCBwcm9wc1xuICAgIHZhciBjdXJyZW50UHJvcHMgPSB7fTtcblxuICAgIC8vIHdlIHdpbGwgYWRkIHRob3NlIHByb3BlcnRpZXMgdG8gdGhlIGV4dGVybmFsIEFQSSBhbmQgbGluayB0aGVtIHRvIHRoZSB2aWV3U3RhdGVcbiAgICBhZGRHZXRTZXQobWl4aW5Db25maWcsIFt2aWV3SW50ZXJuYWxBUEksIHZpZXdFeHRlcm5hbEFQSV0sIHZpZXdQcm9wcyk7XG5cbiAgICAvLyBvdmVycmlkZSByZWN0IG9uIGludGVybmFsIGFuZCBleHRlcm5hbCByZWN0IGdldHRlciBzbyBpdCB0YWtlcyBpbiBhY2NvdW50IHRyYW5zZm9ybXNcbiAgICB2YXIgZ2V0T2Zmc2V0ID0gZnVuY3Rpb24gZ2V0T2Zmc2V0KCkge1xuICAgICAgcmV0dXJuIFt2aWV3UHJvcHNbJ3RyYW5zbGF0ZVgnXSB8fCAwLCB2aWV3UHJvcHNbJ3RyYW5zbGF0ZVknXSB8fCAwXTtcbiAgICB9O1xuXG4gICAgdmFyIGdldFNjYWxlID0gZnVuY3Rpb24gZ2V0U2NhbGUoKSB7XG4gICAgICByZXR1cm4gW3ZpZXdQcm9wc1snc2NhbGVYJ10gfHwgMCwgdmlld1Byb3BzWydzY2FsZVknXSB8fCAwXTtcbiAgICB9O1xuICAgIHZhciBnZXRSZWN0ID0gZnVuY3Rpb24gZ2V0UmVjdCgpIHtcbiAgICAgIHJldHVybiB2aWV3LnJlY3RcbiAgICAgICAgPyBnZXRWaWV3UmVjdCh2aWV3LnJlY3QsIHZpZXcuY2hpbGRWaWV3cywgZ2V0T2Zmc2V0KCksIGdldFNjYWxlKCkpXG4gICAgICAgIDogbnVsbDtcbiAgICB9O1xuICAgIHZpZXdJbnRlcm5hbEFQSS5yZWN0ID0geyBnZXQ6IGdldFJlY3QgfTtcbiAgICB2aWV3RXh0ZXJuYWxBUEkucmVjdCA9IHsgZ2V0OiBnZXRSZWN0IH07XG5cbiAgICAvLyBhcHBseSB2aWV3IHByb3BzXG4gICAgbWl4aW5Db25maWcuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHZpZXdQcm9wc1trZXldID1cbiAgICAgICAgdHlwZW9mIGluaXRpYWxQcm9wc1trZXldID09PSAndW5kZWZpbmVkJ1xuICAgICAgICAgID8gZGVmYXVsdHNba2V5XVxuICAgICAgICAgIDogaW5pdGlhbFByb3BzW2tleV07XG4gICAgfSk7XG5cbiAgICAvLyBleHBvc2UgYXBpXG4gICAgcmV0dXJuIHtcbiAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZSgpIHtcbiAgICAgICAgLy8gc2VlIGlmIHByb3BzIGhhdmUgY2hhbmdlZFxuICAgICAgICBpZiAoIXByb3BzSGF2ZUNoYW5nZWQoY3VycmVudFByb3BzLCB2aWV3UHJvcHMpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbW92ZXMgZWxlbWVudCB0byBjb3JyZWN0IHBvc2l0aW9uIG9uIHNjcmVlblxuICAgICAgICBhcHBseVN0eWxlcyh2aWV3LmVsZW1lbnQsIHZpZXdQcm9wcyk7XG5cbiAgICAgICAgLy8gc3RvcmUgbmV3IHRyYW5zZm9ybXNcbiAgICAgICAgT2JqZWN0LmFzc2lnbihjdXJyZW50UHJvcHMsIE9iamVjdC5hc3NpZ24oe30sIHZpZXdQcm9wcykpO1xuXG4gICAgICAgIC8vIG5vIGxvbmdlciBidXN5XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSxcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7fVxuICAgIH07XG4gIH07XG5cbiAgdmFyIHByb3BzSGF2ZUNoYW5nZWQgPSBmdW5jdGlvbiBwcm9wc0hhdmVDaGFuZ2VkKGN1cnJlbnRQcm9wcywgbmV3UHJvcHMpIHtcbiAgICAvLyBkaWZmZXJlbnQgYW1vdW50IG9mIGtleXNcbiAgICBpZiAoT2JqZWN0LmtleXMoY3VycmVudFByb3BzKS5sZW5ndGggIT09IE9iamVjdC5rZXlzKG5ld1Byb3BzKS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIGxldHMgYW5hbHl6ZSB0aGUgaW5kaXZpZHVhbCBwcm9wc1xuICAgIGZvciAodmFyIHByb3AgaW4gbmV3UHJvcHMpIHtcbiAgICAgIGlmIChuZXdQcm9wc1twcm9wXSAhPT0gY3VycmVudFByb3BzW3Byb3BdKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICB2YXIgYXBwbHlTdHlsZXMgPSBmdW5jdGlvbiBhcHBseVN0eWxlcyhlbGVtZW50LCBfcmVmMikge1xuICAgIHZhciBvcGFjaXR5ID0gX3JlZjIub3BhY2l0eSxcbiAgICAgIHBlcnNwZWN0aXZlID0gX3JlZjIucGVyc3BlY3RpdmUsXG4gICAgICB0cmFuc2xhdGVYID0gX3JlZjIudHJhbnNsYXRlWCxcbiAgICAgIHRyYW5zbGF0ZVkgPSBfcmVmMi50cmFuc2xhdGVZLFxuICAgICAgc2NhbGVYID0gX3JlZjIuc2NhbGVYLFxuICAgICAgc2NhbGVZID0gX3JlZjIuc2NhbGVZLFxuICAgICAgcm90YXRlWCA9IF9yZWYyLnJvdGF0ZVgsXG4gICAgICByb3RhdGVZID0gX3JlZjIucm90YXRlWSxcbiAgICAgIHJvdGF0ZVogPSBfcmVmMi5yb3RhdGVaLFxuICAgICAgb3JpZ2luWCA9IF9yZWYyLm9yaWdpblgsXG4gICAgICBvcmlnaW5ZID0gX3JlZjIub3JpZ2luWSxcbiAgICAgIHdpZHRoID0gX3JlZjIud2lkdGgsXG4gICAgICBoZWlnaHQgPSBfcmVmMi5oZWlnaHQ7XG5cbiAgICB2YXIgdHJhbnNmb3JtcyA9ICcnO1xuICAgIHZhciBzdHlsZXMgPSAnJztcblxuICAgIC8vIGhhbmRsZSB0cmFuc2Zvcm0gb3JpZ2luXG4gICAgaWYgKGlzRGVmaW5lZChvcmlnaW5YKSB8fCBpc0RlZmluZWQob3JpZ2luWSkpIHtcbiAgICAgIHN0eWxlcyArPVxuICAgICAgICAndHJhbnNmb3JtLW9yaWdpbjogJyArIChvcmlnaW5YIHx8IDApICsgJ3B4ICcgKyAob3JpZ2luWSB8fCAwKSArICdweDsnO1xuICAgIH1cblxuICAgIC8vIHRyYW5zZm9ybSBvcmRlciBpcyByZWxldmFudFxuICAgIC8vIDAuIHBlcnNwZWN0aXZlXG4gICAgaWYgKGlzRGVmaW5lZChwZXJzcGVjdGl2ZSkpIHtcbiAgICAgIHRyYW5zZm9ybXMgKz0gJ3BlcnNwZWN0aXZlKCcgKyBwZXJzcGVjdGl2ZSArICdweCkgJztcbiAgICB9XG5cbiAgICAvLyAxLiB0cmFuc2xhdGVcbiAgICBpZiAoaXNEZWZpbmVkKHRyYW5zbGF0ZVgpIHx8IGlzRGVmaW5lZCh0cmFuc2xhdGVZKSkge1xuICAgICAgdHJhbnNmb3JtcyArPVxuICAgICAgICAndHJhbnNsYXRlM2QoJyArXG4gICAgICAgICh0cmFuc2xhdGVYIHx8IDApICtcbiAgICAgICAgJ3B4LCAnICtcbiAgICAgICAgKHRyYW5zbGF0ZVkgfHwgMCkgK1xuICAgICAgICAncHgsIDApICc7XG4gICAgfVxuXG4gICAgLy8gMi4gc2NhbGVcbiAgICBpZiAoaXNEZWZpbmVkKHNjYWxlWCkgfHwgaXNEZWZpbmVkKHNjYWxlWSkpIHtcbiAgICAgIHRyYW5zZm9ybXMgKz1cbiAgICAgICAgJ3NjYWxlM2QoJyArXG4gICAgICAgIChpc0RlZmluZWQoc2NhbGVYKSA/IHNjYWxlWCA6IDEpICtcbiAgICAgICAgJywgJyArXG4gICAgICAgIChpc0RlZmluZWQoc2NhbGVZKSA/IHNjYWxlWSA6IDEpICtcbiAgICAgICAgJywgMSkgJztcbiAgICB9XG5cbiAgICAvLyAzLiByb3RhdGVcbiAgICBpZiAoaXNEZWZpbmVkKHJvdGF0ZVopKSB7XG4gICAgICB0cmFuc2Zvcm1zICs9ICdyb3RhdGVaKCcgKyByb3RhdGVaICsgJ3JhZCkgJztcbiAgICB9XG5cbiAgICBpZiAoaXNEZWZpbmVkKHJvdGF0ZVgpKSB7XG4gICAgICB0cmFuc2Zvcm1zICs9ICdyb3RhdGVYKCcgKyByb3RhdGVYICsgJ3JhZCkgJztcbiAgICB9XG5cbiAgICBpZiAoaXNEZWZpbmVkKHJvdGF0ZVkpKSB7XG4gICAgICB0cmFuc2Zvcm1zICs9ICdyb3RhdGVZKCcgKyByb3RhdGVZICsgJ3JhZCkgJztcbiAgICB9XG5cbiAgICAvLyBhZGQgdHJhbnNmb3Jtc1xuICAgIGlmICh0cmFuc2Zvcm1zLmxlbmd0aCkge1xuICAgICAgc3R5bGVzICs9ICd0cmFuc2Zvcm06JyArIHRyYW5zZm9ybXMgKyAnOyc7XG4gICAgfVxuXG4gICAgLy8gYWRkIG9wYWNpdHlcbiAgICBpZiAoaXNEZWZpbmVkKG9wYWNpdHkpKSB7XG4gICAgICBzdHlsZXMgKz0gJ29wYWNpdHk6JyArIG9wYWNpdHkgKyAnOyc7XG5cbiAgICAgIC8vIGlmIHdlIHJlYWNoIHplcm8sIHdlIG1ha2UgdGhlIGVsZW1lbnQgaW5hY2Nlc3NpYmxlXG4gICAgICBpZiAob3BhY2l0eSA9PT0gMCkge1xuICAgICAgICBzdHlsZXMgKz0gJ3Zpc2liaWxpdHk6aGlkZGVuOyc7XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIHdlJ3JlIGJlbG93IDEwMCUgb3BhY2l0eSB0aGlzIGVsZW1lbnQgY2FuJ3QgYmUgY2xpY2tlZFxuICAgICAgaWYgKG9wYWNpdHkgPCAxKSB7XG4gICAgICAgIHN0eWxlcyArPSAncG9pbnRlci1ldmVudHM6bm9uZTsnO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFkZCBoZWlnaHRcbiAgICBpZiAoaXNEZWZpbmVkKGhlaWdodCkpIHtcbiAgICAgIHN0eWxlcyArPSAnaGVpZ2h0OicgKyBoZWlnaHQgKyAncHg7JztcbiAgICB9XG5cbiAgICAvLyBhZGQgd2lkdGhcbiAgICBpZiAoaXNEZWZpbmVkKHdpZHRoKSkge1xuICAgICAgc3R5bGVzICs9ICd3aWR0aDonICsgd2lkdGggKyAncHg7JztcbiAgICB9XG5cbiAgICAvLyBhcHBseSBzdHlsZXNcbiAgICB2YXIgZWxlbWVudEN1cnJlbnRTdHlsZSA9IGVsZW1lbnQuZWxlbWVudEN1cnJlbnRTdHlsZSB8fCAnJztcblxuICAgIC8vIGlmIG5ldyBzdHlsZXMgZG9lcyBub3QgbWF0Y2ggY3VycmVudCBzdHlsZXMsIGxldHMgdXBkYXRlIVxuICAgIGlmIChcbiAgICAgIHN0eWxlcy5sZW5ndGggIT09IGVsZW1lbnRDdXJyZW50U3R5bGUubGVuZ3RoIHx8XG4gICAgICBzdHlsZXMgIT09IGVsZW1lbnRDdXJyZW50U3R5bGVcbiAgICApIHtcbiAgICAgIGVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IHN0eWxlcztcbiAgICAgIC8vIHN0b3JlIGN1cnJlbnQgc3R5bGVzIHNvIHdlIGNhbiBjb21wYXJlIHRoZW0gdG8gbmV3IHN0eWxlcyBsYXRlciBvblxuICAgICAgLy8gX25vdF8gZ2V0dGluZyB0aGUgc3R5bGUgdmFsdWUgaXMgZmFzdGVyXG4gICAgICBlbGVtZW50LmVsZW1lbnRDdXJyZW50U3R5bGUgPSBzdHlsZXM7XG4gICAgfVxuICB9O1xuXG4gIHZhciBNaXhpbnMgPSB7XG4gICAgc3R5bGVzOiBzdHlsZXMsXG4gICAgbGlzdGVuZXJzOiBsaXN0ZW5lcnMsXG4gICAgYW5pbWF0aW9uczogYW5pbWF0aW9ucyxcbiAgICBhcGlzOiBhcGlzXG4gIH07XG5cbiAgdmFyIHVwZGF0ZVJlY3QgPSBmdW5jdGlvbiB1cGRhdGVSZWN0KCkge1xuICAgIHZhciByZWN0ID1cbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgdmFyIGVsZW1lbnQgPVxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIgc3R5bGUgPVxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgIGlmICghZWxlbWVudC5sYXlvdXRDYWxjdWxhdGVkKSB7XG4gICAgICByZWN0LnBhZGRpbmdUb3AgPSBwYXJzZUludChzdHlsZS5wYWRkaW5nVG9wLCAxMCkgfHwgMDtcbiAgICAgIHJlY3QubWFyZ2luVG9wID0gcGFyc2VJbnQoc3R5bGUubWFyZ2luVG9wLCAxMCkgfHwgMDtcbiAgICAgIHJlY3QubWFyZ2luUmlnaHQgPSBwYXJzZUludChzdHlsZS5tYXJnaW5SaWdodCwgMTApIHx8IDA7XG4gICAgICByZWN0Lm1hcmdpbkJvdHRvbSA9IHBhcnNlSW50KHN0eWxlLm1hcmdpbkJvdHRvbSwgMTApIHx8IDA7XG4gICAgICByZWN0Lm1hcmdpbkxlZnQgPSBwYXJzZUludChzdHlsZS5tYXJnaW5MZWZ0LCAxMCkgfHwgMDtcbiAgICAgIGVsZW1lbnQubGF5b3V0Q2FsY3VsYXRlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmVjdC5sZWZ0ID0gZWxlbWVudC5vZmZzZXRMZWZ0IHx8IDA7XG4gICAgcmVjdC50b3AgPSBlbGVtZW50Lm9mZnNldFRvcCB8fCAwO1xuICAgIHJlY3Qud2lkdGggPSBlbGVtZW50Lm9mZnNldFdpZHRoIHx8IDA7XG4gICAgcmVjdC5oZWlnaHQgPSBlbGVtZW50Lm9mZnNldEhlaWdodCB8fCAwO1xuXG4gICAgcmVjdC5yaWdodCA9IHJlY3QubGVmdCArIHJlY3Qud2lkdGg7XG4gICAgcmVjdC5ib3R0b20gPSByZWN0LnRvcCArIHJlY3QuaGVpZ2h0O1xuXG4gICAgcmVjdC5zY3JvbGxUb3AgPSBlbGVtZW50LnNjcm9sbFRvcDtcblxuICAgIHJlY3QuaGlkZGVuID0gZWxlbWVudC5vZmZzZXRQYXJlbnQgPT09IG51bGw7XG5cbiAgICByZXR1cm4gcmVjdDtcbiAgfTtcblxuICB2YXIgY3JlYXRlVmlldyA9XG4gICAgLy8gZGVmYXVsdCB2aWV3IGRlZmluaXRpb25cbiAgICBmdW5jdGlvbiBjcmVhdGVWaWV3KCkge1xuICAgICAgdmFyIF9yZWYgPVxuICAgICAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IGFyZ3VtZW50c1swXVxuICAgICAgICAgICAgOiB7fSxcbiAgICAgICAgX3JlZiR0YWcgPSBfcmVmLnRhZyxcbiAgICAgICAgdGFnID0gX3JlZiR0YWcgPT09IHZvaWQgMCA/ICdkaXYnIDogX3JlZiR0YWcsXG4gICAgICAgIF9yZWYkbmFtZSA9IF9yZWYubmFtZSxcbiAgICAgICAgbmFtZSA9IF9yZWYkbmFtZSA9PT0gdm9pZCAwID8gbnVsbCA6IF9yZWYkbmFtZSxcbiAgICAgICAgX3JlZiRhdHRyaWJ1dGVzID0gX3JlZi5hdHRyaWJ1dGVzLFxuICAgICAgICBhdHRyaWJ1dGVzID0gX3JlZiRhdHRyaWJ1dGVzID09PSB2b2lkIDAgPyB7fSA6IF9yZWYkYXR0cmlidXRlcyxcbiAgICAgICAgX3JlZiRyZWFkID0gX3JlZi5yZWFkLFxuICAgICAgICByZWFkID0gX3JlZiRyZWFkID09PSB2b2lkIDAgPyBmdW5jdGlvbigpIHt9IDogX3JlZiRyZWFkLFxuICAgICAgICBfcmVmJHdyaXRlID0gX3JlZi53cml0ZSxcbiAgICAgICAgd3JpdGUgPSBfcmVmJHdyaXRlID09PSB2b2lkIDAgPyBmdW5jdGlvbigpIHt9IDogX3JlZiR3cml0ZSxcbiAgICAgICAgX3JlZiRjcmVhdGUgPSBfcmVmLmNyZWF0ZSxcbiAgICAgICAgY3JlYXRlID0gX3JlZiRjcmVhdGUgPT09IHZvaWQgMCA/IGZ1bmN0aW9uKCkge30gOiBfcmVmJGNyZWF0ZSxcbiAgICAgICAgX3JlZiRkZXN0cm95ID0gX3JlZi5kZXN0cm95LFxuICAgICAgICBkZXN0cm95ID0gX3JlZiRkZXN0cm95ID09PSB2b2lkIDAgPyBmdW5jdGlvbigpIHt9IDogX3JlZiRkZXN0cm95LFxuICAgICAgICBfcmVmJGZpbHRlckZyYW1lQWN0aW8gPSBfcmVmLmZpbHRlckZyYW1lQWN0aW9uc0ZvckNoaWxkLFxuICAgICAgICBmaWx0ZXJGcmFtZUFjdGlvbnNGb3JDaGlsZCA9XG4gICAgICAgICAgX3JlZiRmaWx0ZXJGcmFtZUFjdGlvID09PSB2b2lkIDBcbiAgICAgICAgICAgID8gZnVuY3Rpb24oY2hpbGQsIGFjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWN0aW9ucztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiBfcmVmJGZpbHRlckZyYW1lQWN0aW8sXG4gICAgICAgIF9yZWYkZGlkQ3JlYXRlVmlldyA9IF9yZWYuZGlkQ3JlYXRlVmlldyxcbiAgICAgICAgZGlkQ3JlYXRlVmlldyA9XG4gICAgICAgICAgX3JlZiRkaWRDcmVhdGVWaWV3ID09PSB2b2lkIDAgPyBmdW5jdGlvbigpIHt9IDogX3JlZiRkaWRDcmVhdGVWaWV3LFxuICAgICAgICBfcmVmJGRpZFdyaXRlVmlldyA9IF9yZWYuZGlkV3JpdGVWaWV3LFxuICAgICAgICBkaWRXcml0ZVZpZXcgPVxuICAgICAgICAgIF9yZWYkZGlkV3JpdGVWaWV3ID09PSB2b2lkIDAgPyBmdW5jdGlvbigpIHt9IDogX3JlZiRkaWRXcml0ZVZpZXcsXG4gICAgICAgIF9yZWYkaWdub3JlUmVjdCA9IF9yZWYuaWdub3JlUmVjdCxcbiAgICAgICAgaWdub3JlUmVjdCA9IF9yZWYkaWdub3JlUmVjdCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmJGlnbm9yZVJlY3QsXG4gICAgICAgIF9yZWYkaWdub3JlUmVjdFVwZGF0ZSA9IF9yZWYuaWdub3JlUmVjdFVwZGF0ZSxcbiAgICAgICAgaWdub3JlUmVjdFVwZGF0ZSA9XG4gICAgICAgICAgX3JlZiRpZ25vcmVSZWN0VXBkYXRlID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYkaWdub3JlUmVjdFVwZGF0ZSxcbiAgICAgICAgX3JlZiRtaXhpbnMgPSBfcmVmLm1peGlucyxcbiAgICAgICAgbWl4aW5zID0gX3JlZiRtaXhpbnMgPT09IHZvaWQgMCA/IFtdIDogX3JlZiRtaXhpbnM7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oXG4gICAgICAgIC8vIGVhY2ggdmlldyByZXF1aXJlcyByZWZlcmVuY2UgdG8gc3RvcmVcbiAgICAgICAgc3RvcmVcbiAgICAgICkge1xuICAgICAgICB2YXIgcHJvcHMgPVxuICAgICAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IGFyZ3VtZW50c1sxXVxuICAgICAgICAgICAgOiB7fTtcbiAgICAgICAgLy8gcm9vdCBlbGVtZW50IHNob3VsZCBub3QgYmUgY2hhbmdlZFxuICAgICAgICB2YXIgZWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQodGFnLCAnZmlsZXBvbmQtLScgKyBuYW1lLCBhdHRyaWJ1dGVzKTtcblxuICAgICAgICAvLyBzdHlsZSByZWZlcmVuY2Ugc2hvdWxkIGFsc28gbm90IGJlIGNoYW5nZWRcbiAgICAgICAgdmFyIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgbnVsbCk7XG5cbiAgICAgICAgLy8gZWxlbWVudCByZWN0YW5nbGVcbiAgICAgICAgdmFyIHJlY3QgPSB1cGRhdGVSZWN0KCk7XG4gICAgICAgIHZhciBmcmFtZVJlY3QgPSBudWxsO1xuXG4gICAgICAgIC8vIHJlc3Qgc3RhdGVcbiAgICAgICAgdmFyIGlzUmVzdGluZyA9IGZhbHNlO1xuXG4gICAgICAgIC8vIHByZXR0eSBzZWxmIGV4cGxhbmF0b3J5XG4gICAgICAgIHZhciBjaGlsZFZpZXdzID0gW107XG5cbiAgICAgICAgLy8gbG9hZGVkIG1peGluc1xuICAgICAgICB2YXIgYWN0aXZlTWl4aW5zID0gW107XG5cbiAgICAgICAgLy8gcmVmZXJlbmNlcyB0byBjcmVhdGVkIGNoaWxkcmVuXG4gICAgICAgIHZhciByZWYgPSB7fTtcblxuICAgICAgICAvLyBzdGF0ZSB1c2VkIGZvciBlYWNoIGluc3RhbmNlXG4gICAgICAgIHZhciBzdGF0ZSA9IHt9O1xuXG4gICAgICAgIC8vIGxpc3Qgb2Ygd3JpdGVycyB0aGF0IHdpbGwgYmUgY2FsbGVkIHRvIHVwZGF0ZSB0aGlzIHZpZXdcbiAgICAgICAgdmFyIHdyaXRlcnMgPSBbXG4gICAgICAgICAgd3JpdGUgLy8gZGVmYXVsdCB3cml0ZXJcbiAgICAgICAgXTtcblxuICAgICAgICB2YXIgcmVhZGVycyA9IFtcbiAgICAgICAgICByZWFkIC8vIGRlZmF1bHQgcmVhZGVyXG4gICAgICAgIF07XG5cbiAgICAgICAgdmFyIGRlc3Ryb3llcnMgPSBbXG4gICAgICAgICAgZGVzdHJveSAvLyBkZWZhdWx0IGRlc3Ryb3lcbiAgICAgICAgXTtcblxuICAgICAgICAvLyBjb3JlIHZpZXcgbWV0aG9kc1xuICAgICAgICB2YXIgZ2V0RWxlbWVudCA9IGZ1bmN0aW9uIGdldEVsZW1lbnQoKSB7XG4gICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBnZXRDaGlsZFZpZXdzID0gZnVuY3Rpb24gZ2V0Q2hpbGRWaWV3cygpIHtcbiAgICAgICAgICByZXR1cm4gY2hpbGRWaWV3cy5jb25jYXQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGdldFJlZmVyZW5jZSA9IGZ1bmN0aW9uIGdldFJlZmVyZW5jZSgpIHtcbiAgICAgICAgICByZXR1cm4gcmVmO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgY3JlYXRlQ2hpbGRWaWV3ID0gZnVuY3Rpb24gY3JlYXRlQ2hpbGRWaWV3KHN0b3JlKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZpZXcsIHByb3BzKSB7XG4gICAgICAgICAgICByZXR1cm4gdmlldyhzdG9yZSwgcHJvcHMpO1xuICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIHZhciBnZXRSZWN0ID0gZnVuY3Rpb24gZ2V0UmVjdCgpIHtcbiAgICAgICAgICBpZiAoZnJhbWVSZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gZnJhbWVSZWN0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBmcmFtZVJlY3QgPSBnZXRWaWV3UmVjdChyZWN0LCBjaGlsZFZpZXdzLCBbMCwgMF0sIFsxLCAxXSk7XG4gICAgICAgICAgcmV0dXJuIGZyYW1lUmVjdDtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGdldFN0eWxlID0gZnVuY3Rpb24gZ2V0U3R5bGUoKSB7XG4gICAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWFkIGRhdGEgZnJvbSBET01cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHZhciBfcmVhZCA9IGZ1bmN0aW9uIF9yZWFkKCkge1xuICAgICAgICAgIGZyYW1lUmVjdCA9IG51bGw7XG5cbiAgICAgICAgICAvLyByZWFkIGNoaWxkIHZpZXdzXG4gICAgICAgICAgY2hpbGRWaWV3cy5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGQuX3JlYWQoKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBzaG91bGRVcGRhdGUgPSAhKGlnbm9yZVJlY3RVcGRhdGUgJiYgcmVjdC53aWR0aCAmJiByZWN0LmhlaWdodCk7XG4gICAgICAgICAgaWYgKHNob3VsZFVwZGF0ZSkge1xuICAgICAgICAgICAgdXBkYXRlUmVjdChyZWN0LCBlbGVtZW50LCBzdHlsZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gcmVhZGVyc1xuICAgICAgICAgIHZhciBhcGkgPSB7IHJvb3Q6IGludGVybmFsQVBJLCBwcm9wczogcHJvcHMsIHJlY3Q6IHJlY3QgfTtcbiAgICAgICAgICByZWFkZXJzLmZvckVhY2goZnVuY3Rpb24ocmVhZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVhZGVyKGFwaSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdyaXRlIGRhdGEgdG8gRE9NXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgX3dyaXRlID0gZnVuY3Rpb24gX3dyaXRlKHRzLCBmcmFtZUFjdGlvbnMsIHNob3VsZE9wdGltaXplKSB7XG4gICAgICAgICAgLy8gaWYgbm8gYWN0aW9ucywgd2UgYXNzdW1lIHRoYXQgdGhlIHZpZXcgaXMgcmVzdGluZ1xuICAgICAgICAgIHZhciByZXN0aW5nID0gZnJhbWVBY3Rpb25zLmxlbmd0aCA9PT0gMDtcblxuICAgICAgICAgIC8vIHdyaXRlcnNcbiAgICAgICAgICB3cml0ZXJzLmZvckVhY2goZnVuY3Rpb24od3JpdGVyKSB7XG4gICAgICAgICAgICB2YXIgd3JpdGVyUmVzdGluZyA9IHdyaXRlcih7XG4gICAgICAgICAgICAgIHByb3BzOiBwcm9wcyxcbiAgICAgICAgICAgICAgcm9vdDogaW50ZXJuYWxBUEksXG4gICAgICAgICAgICAgIGFjdGlvbnM6IGZyYW1lQWN0aW9ucyxcbiAgICAgICAgICAgICAgdGltZXN0YW1wOiB0cyxcbiAgICAgICAgICAgICAgc2hvdWxkT3B0aW1pemU6IHNob3VsZE9wdGltaXplXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKHdyaXRlclJlc3RpbmcgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIHJlc3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIHJ1biBtaXhpbnNcbiAgICAgICAgICBhY3RpdmVNaXhpbnMuZm9yRWFjaChmdW5jdGlvbihtaXhpbikge1xuICAgICAgICAgICAgLy8gaWYgb25lIG9mIHRoZSBtaXhpbnMgaXMgc3RpbGwgYnVzeSBhZnRlciB3cml0ZSBvcGVyYXRpb24sIHdlIGFyZSBub3QgcmVzdGluZ1xuICAgICAgICAgICAgdmFyIG1peGluUmVzdGluZyA9IG1peGluLndyaXRlKHRzKTtcbiAgICAgICAgICAgIGlmIChtaXhpblJlc3RpbmcgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIHJlc3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIHVwZGF0ZXMgY2hpbGQgdmlld3MgdGhhdCBhcmUgY3VycmVudGx5IGF0dGFjaGVkIHRvIHRoZSBET01cbiAgICAgICAgICBjaGlsZFZpZXdzXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICAgIHJldHVybiAhIWNoaWxkLmVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgICAvLyBpZiBhIGNoaWxkIHZpZXcgaXMgbm90IHJlc3RpbmcsIHdlIGFyZSBub3QgcmVzdGluZ1xuICAgICAgICAgICAgICB2YXIgY2hpbGRSZXN0aW5nID0gY2hpbGQuX3dyaXRlKFxuICAgICAgICAgICAgICAgIHRzLFxuICAgICAgICAgICAgICAgIGZpbHRlckZyYW1lQWN0aW9uc0ZvckNoaWxkKGNoaWxkLCBmcmFtZUFjdGlvbnMpLFxuICAgICAgICAgICAgICAgIHNob3VsZE9wdGltaXplXG4gICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgaWYgKCFjaGlsZFJlc3RpbmcpIHtcbiAgICAgICAgICAgICAgICByZXN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gYXBwZW5kIG5ldyBlbGVtZW50cyB0byBET00gYW5kIHVwZGF0ZSB0aG9zZVxuICAgICAgICAgIGNoaWxkVmlld3NcbiAgICAgICAgICAgIC8vLmZpbHRlcihjaGlsZCA9PiAhY2hpbGQuZWxlbWVudC5wYXJlbnROb2RlKVxuICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24oY2hpbGQsIGluZGV4KSB7XG4gICAgICAgICAgICAgIC8vIHNraXBcbiAgICAgICAgICAgICAgaWYgKGNoaWxkLmVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIGFwcGVuZCB0byBET01cbiAgICAgICAgICAgICAgaW50ZXJuYWxBUEkuYXBwZW5kQ2hpbGQoY2hpbGQuZWxlbWVudCwgaW5kZXgpO1xuXG4gICAgICAgICAgICAgIC8vIGNhbGwgcmVhZCAobmVlZCB0byBrbm93IHRoZSBzaXplIG9mIHRoZXNlIGVsZW1lbnRzKVxuICAgICAgICAgICAgICBjaGlsZC5fcmVhZCgpO1xuXG4gICAgICAgICAgICAgIC8vIHJlLWNhbGwgd3JpdGVcbiAgICAgICAgICAgICAgY2hpbGQuX3dyaXRlKFxuICAgICAgICAgICAgICAgIHRzLFxuICAgICAgICAgICAgICAgIGZpbHRlckZyYW1lQWN0aW9uc0ZvckNoaWxkKGNoaWxkLCBmcmFtZUFjdGlvbnMpLFxuICAgICAgICAgICAgICAgIHNob3VsZE9wdGltaXplXG4gICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgLy8gd2UganVzdCBhZGRlZCBzb210aGluZyB0byB0aGUgZG9tLCBubyByZXN0XG4gICAgICAgICAgICAgIHJlc3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gdXBkYXRlIHJlc3Rpbmcgc3RhdGVcbiAgICAgICAgICBpc1Jlc3RpbmcgPSByZXN0aW5nO1xuXG4gICAgICAgICAgZGlkV3JpdGVWaWV3KHtcbiAgICAgICAgICAgIHByb3BzOiBwcm9wcyxcbiAgICAgICAgICAgIHJvb3Q6IGludGVybmFsQVBJLFxuICAgICAgICAgICAgYWN0aW9uczogZnJhbWVBY3Rpb25zLFxuICAgICAgICAgICAgdGltZXN0YW1wOiB0c1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gbGV0IHBhcmVudCBrbm93IGlmIHdlIGFyZSByZXN0aW5nXG4gICAgICAgICAgcmV0dXJuIHJlc3Rpbmc7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIF9kZXN0cm95ID0gZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XG4gICAgICAgICAgYWN0aXZlTWl4aW5zLmZvckVhY2goZnVuY3Rpb24obWl4aW4pIHtcbiAgICAgICAgICAgIHJldHVybiBtaXhpbi5kZXN0cm95KCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZGVzdHJveWVycy5mb3JFYWNoKGZ1bmN0aW9uKGRlc3Ryb3llcikge1xuICAgICAgICAgICAgZGVzdHJveWVyKHsgcm9vdDogaW50ZXJuYWxBUEksIHByb3BzOiBwcm9wcyB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjaGlsZFZpZXdzLmZvckVhY2goZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZC5fZGVzdHJveSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHNoYXJlZEFQSVxuICAgICAgICB2YXIgc2hhcmVkQVBJRGVmaW5pdGlvbiA9IHtcbiAgICAgICAgICBlbGVtZW50OiB7XG4gICAgICAgICAgICBnZXQ6IGdldEVsZW1lbnRcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIGdldDogZ2V0U3R5bGVcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgY2hpbGRWaWV3czoge1xuICAgICAgICAgICAgZ2V0OiBnZXRDaGlsZFZpZXdzXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHByaXZhdGUgQVBJIGRlZmluaXRpb25cbiAgICAgICAgdmFyIGludGVybmFsQVBJRGVmaW5pdGlvbiA9IE9iamVjdC5hc3NpZ24oe30sIHNoYXJlZEFQSURlZmluaXRpb24sIHtcbiAgICAgICAgICByZWN0OiB7XG4gICAgICAgICAgICBnZXQ6IGdldFJlY3RcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgLy8gYWNjZXNzIHRvIGN1c3RvbSBjaGlsZHJlbiByZWZlcmVuY2VzXG4gICAgICAgICAgcmVmOiB7XG4gICAgICAgICAgICBnZXQ6IGdldFJlZmVyZW5jZVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvLyBkb20gbW9kaWZpZXJzXG4gICAgICAgICAgaXM6IGZ1bmN0aW9uIGlzKG5lZWRsZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5hbWUgPT09IG5lZWRsZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGFwcGVuZENoaWxkOiBhcHBlbmRDaGlsZChlbGVtZW50KSxcbiAgICAgICAgICBjcmVhdGVDaGlsZFZpZXc6IGNyZWF0ZUNoaWxkVmlldyhzdG9yZSksXG4gICAgICAgICAgbGlua1ZpZXc6IGZ1bmN0aW9uIGxpbmtWaWV3KHZpZXcpIHtcbiAgICAgICAgICAgIGNoaWxkVmlld3MucHVzaCh2aWV3KTtcbiAgICAgICAgICAgIHJldHVybiB2aWV3O1xuICAgICAgICAgIH0sXG4gICAgICAgICAgdW5saW5rVmlldzogZnVuY3Rpb24gdW5saW5rVmlldyh2aWV3KSB7XG4gICAgICAgICAgICBjaGlsZFZpZXdzLnNwbGljZShjaGlsZFZpZXdzLmluZGV4T2YodmlldyksIDEpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgYXBwZW5kQ2hpbGRWaWV3OiBhcHBlbmRDaGlsZFZpZXcoZWxlbWVudCwgY2hpbGRWaWV3cyksXG4gICAgICAgICAgcmVtb3ZlQ2hpbGRWaWV3OiByZW1vdmVDaGlsZFZpZXcoZWxlbWVudCwgY2hpbGRWaWV3cyksXG4gICAgICAgICAgcmVnaXN0ZXJXcml0ZXI6IGZ1bmN0aW9uIHJlZ2lzdGVyV3JpdGVyKHdyaXRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHdyaXRlcnMucHVzaCh3cml0ZXIpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVnaXN0ZXJSZWFkZXI6IGZ1bmN0aW9uIHJlZ2lzdGVyUmVhZGVyKHJlYWRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHJlYWRlcnMucHVzaChyZWFkZXIpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVnaXN0ZXJEZXN0cm95ZXI6IGZ1bmN0aW9uIHJlZ2lzdGVyRGVzdHJveWVyKGRlc3Ryb3llcikge1xuICAgICAgICAgICAgcmV0dXJuIGRlc3Ryb3llcnMucHVzaChkZXN0cm95ZXIpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgaW52YWxpZGF0ZUxheW91dDogZnVuY3Rpb24gaW52YWxpZGF0ZUxheW91dCgpIHtcbiAgICAgICAgICAgIHJldHVybiAoZWxlbWVudC5sYXlvdXRDYWxjdWxhdGVkID0gZmFsc2UpO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvLyBhY2Nlc3MgdG8gZGF0YSBzdG9yZVxuICAgICAgICAgIGRpc3BhdGNoOiBzdG9yZS5kaXNwYXRjaCxcbiAgICAgICAgICBxdWVyeTogc3RvcmUucXVlcnlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gcHVibGljIHZpZXcgQVBJIG1ldGhvZHNcbiAgICAgICAgdmFyIGV4dGVybmFsQVBJRGVmaW5pdGlvbiA9IHtcbiAgICAgICAgICBlbGVtZW50OiB7XG4gICAgICAgICAgICBnZXQ6IGdldEVsZW1lbnRcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgY2hpbGRWaWV3czoge1xuICAgICAgICAgICAgZ2V0OiBnZXRDaGlsZFZpZXdzXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHJlY3Q6IHtcbiAgICAgICAgICAgIGdldDogZ2V0UmVjdFxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICByZXN0aW5nOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGlzUmVzdGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgaXNSZWN0SWdub3JlZDogZnVuY3Rpb24gaXNSZWN0SWdub3JlZCgpIHtcbiAgICAgICAgICAgIHJldHVybiBpZ25vcmVSZWN0O1xuICAgICAgICAgIH0sXG4gICAgICAgICAgX3JlYWQ6IF9yZWFkLFxuICAgICAgICAgIF93cml0ZTogX3dyaXRlLFxuICAgICAgICAgIF9kZXN0cm95OiBfZGVzdHJveVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIG1peGluIEFQSSBtZXRob2RzXG4gICAgICAgIHZhciBtaXhpbkFQSURlZmluaXRpb24gPSBPYmplY3QuYXNzaWduKHt9LCBzaGFyZWRBUElEZWZpbml0aW9uLCB7XG4gICAgICAgICAgcmVjdDoge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiByZWN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gYWRkIG1peGluIGZ1bmN0aW9uYWxpdHlcbiAgICAgICAgT2JqZWN0LmtleXMobWl4aW5zKVxuICAgICAgICAgIC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgIC8vIG1vdmUgc3R5bGVzIHRvIHRoZSBiYWNrIG9mIHRoZSBtaXhpbiBsaXN0IChzbyBhZGp1c3RtZW50cyBvZiBvdGhlciBtaXhpbnMgYXJlIGFwcGxpZWQgdG8gdGhlIHByb3BzIGNvcnJlY3RseSlcbiAgICAgICAgICAgIGlmIChhID09PSAnc3R5bGVzJykge1xuICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gJ3N0eWxlcycpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIHZhciBtaXhpbkFQSSA9IE1peGluc1trZXldKHtcbiAgICAgICAgICAgICAgbWl4aW5Db25maWc6IG1peGluc1trZXldLFxuICAgICAgICAgICAgICB2aWV3UHJvcHM6IHByb3BzLFxuICAgICAgICAgICAgICB2aWV3U3RhdGU6IHN0YXRlLFxuICAgICAgICAgICAgICB2aWV3SW50ZXJuYWxBUEk6IGludGVybmFsQVBJRGVmaW5pdGlvbixcbiAgICAgICAgICAgICAgdmlld0V4dGVybmFsQVBJOiBleHRlcm5hbEFQSURlZmluaXRpb24sXG4gICAgICAgICAgICAgIHZpZXc6IGNyZWF0ZU9iamVjdChtaXhpbkFQSURlZmluaXRpb24pXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKG1peGluQVBJKSB7XG4gICAgICAgICAgICAgIGFjdGl2ZU1peGlucy5wdXNoKG1peGluQVBJKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAvLyBjb25zdHJ1Y3QgcHJpdmF0ZSBhcGlcbiAgICAgICAgdmFyIGludGVybmFsQVBJID0gY3JlYXRlT2JqZWN0KGludGVybmFsQVBJRGVmaW5pdGlvbik7XG5cbiAgICAgICAgLy8gY3JlYXRlIHRoZSB2aWV3XG4gICAgICAgIGNyZWF0ZSh7XG4gICAgICAgICAgcm9vdDogaW50ZXJuYWxBUEksXG4gICAgICAgICAgcHJvcHM6IHByb3BzXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGFwcGVuZCBjcmVhdGVkIGNoaWxkIHZpZXdzIHRvIHJvb3Qgbm9kZVxuICAgICAgICB2YXIgY2hpbGRDb3VudCA9IGdldENoaWxkQ291bnQoZWxlbWVudCk7IC8vIG5lZWQgdG8ga25vdyB0aGUgY3VycmVudCBjaGlsZCBjb3VudCBzbyBhcHBlbmRpbmcgaGFwcGVucyBpbiBjb3JyZWN0IG9yZGVyXG4gICAgICAgIGNoaWxkVmlld3MuZm9yRWFjaChmdW5jdGlvbihjaGlsZCwgaW5kZXgpIHtcbiAgICAgICAgICBpbnRlcm5hbEFQSS5hcHBlbmRDaGlsZChjaGlsZC5lbGVtZW50LCBjaGlsZENvdW50ICsgaW5kZXgpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBjYWxsIGRpZCBjcmVhdGVcbiAgICAgICAgZGlkQ3JlYXRlVmlldyhpbnRlcm5hbEFQSSk7XG5cbiAgICAgICAgLy8gZXhwb3NlIHB1YmxpYyBhcGlcbiAgICAgICAgcmV0dXJuIGNyZWF0ZU9iamVjdChleHRlcm5hbEFQSURlZmluaXRpb24pO1xuICAgICAgfTtcbiAgICB9O1xuXG4gIHZhciBjcmVhdGVQYWludGVyID0gZnVuY3Rpb24gY3JlYXRlUGFpbnRlcihyZWFkLCB3cml0ZSkge1xuICAgIHZhciBmcHMgPVxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiA2MDtcblxuICAgIHZhciBuYW1lID0gJ19fZnJhbWVQYWludGVyJztcblxuICAgIC8vIHNldCBnbG9iYWwgcGFpbnRlclxuICAgIGlmICh3aW5kb3dbbmFtZV0pIHtcbiAgICAgIHdpbmRvd1tuYW1lXS5yZWFkZXJzLnB1c2gocmVhZCk7XG4gICAgICB3aW5kb3dbbmFtZV0ud3JpdGVycy5wdXNoKHdyaXRlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3aW5kb3dbbmFtZV0gPSB7XG4gICAgICByZWFkZXJzOiBbcmVhZF0sXG4gICAgICB3cml0ZXJzOiBbd3JpdGVdXG4gICAgfTtcblxuICAgIHZhciBwYWludGVyID0gd2luZG93W25hbWVdO1xuXG4gICAgdmFyIGludGVydmFsID0gMTAwMCAvIGZwcztcbiAgICB2YXIgbGFzdCA9IG51bGw7XG4gICAgdmFyIGlkID0gbnVsbDtcbiAgICB2YXIgcmVxdWVzdFRpY2sgPSBudWxsO1xuICAgIHZhciBjYW5jZWxUaWNrID0gbnVsbDtcblxuICAgIHZhciBzZXRUaW1lclR5cGUgPSBmdW5jdGlvbiBzZXRUaW1lclR5cGUoKSB7XG4gICAgICBpZiAoZG9jdW1lbnQuaGlkZGVuKSB7XG4gICAgICAgIHJlcXVlc3RUaWNrID0gZnVuY3Rpb24gcmVxdWVzdFRpY2soKSB7XG4gICAgICAgICAgcmV0dXJuIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRpY2socGVyZm9ybWFuY2Uubm93KCkpO1xuICAgICAgICAgIH0sIGludGVydmFsKTtcbiAgICAgICAgfTtcbiAgICAgICAgY2FuY2VsVGljayA9IGZ1bmN0aW9uIGNhbmNlbFRpY2soKSB7XG4gICAgICAgICAgcmV0dXJuIHdpbmRvdy5jbGVhclRpbWVvdXQoaWQpO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVxdWVzdFRpY2sgPSBmdW5jdGlvbiByZXF1ZXN0VGljaygpIHtcbiAgICAgICAgICByZXR1cm4gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aWNrKTtcbiAgICAgICAgfTtcbiAgICAgICAgY2FuY2VsVGljayA9IGZ1bmN0aW9uIGNhbmNlbFRpY2soKSB7XG4gICAgICAgICAgcmV0dXJuIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShpZCk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChjYW5jZWxUaWNrKSBjYW5jZWxUaWNrKCk7XG4gICAgICBzZXRUaW1lclR5cGUoKTtcbiAgICAgIHRpY2socGVyZm9ybWFuY2Uubm93KCkpO1xuICAgIH0pO1xuXG4gICAgdmFyIHRpY2sgPSBmdW5jdGlvbiB0aWNrKHRzKSB7XG4gICAgICAvLyBxdWV1ZSBuZXh0IHRpY2tcbiAgICAgIGlkID0gcmVxdWVzdFRpY2sodGljayk7XG5cbiAgICAgIC8vIGxpbWl0IGZwc1xuICAgICAgaWYgKCFsYXN0KSB7XG4gICAgICAgIGxhc3QgPSB0cztcbiAgICAgIH1cblxuICAgICAgdmFyIGRlbHRhID0gdHMgLSBsYXN0O1xuXG4gICAgICBpZiAoZGVsdGEgPD0gaW50ZXJ2YWwpIHtcbiAgICAgICAgLy8gc2tpcCBmcmFtZVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGFsaWduIG5leHQgZnJhbWVcbiAgICAgIGxhc3QgPSB0cyAtIChkZWx0YSAlIGludGVydmFsKTtcblxuICAgICAgLy8gdXBkYXRlIHZpZXdcbiAgICAgIHBhaW50ZXIucmVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHJlYWQpIHtcbiAgICAgICAgcmV0dXJuIHJlYWQoKTtcbiAgICAgIH0pO1xuICAgICAgcGFpbnRlci53cml0ZXJzLmZvckVhY2goZnVuY3Rpb24od3JpdGUpIHtcbiAgICAgICAgcmV0dXJuIHdyaXRlKHRzKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBzZXRUaW1lclR5cGUoKTtcbiAgICB0aWNrKHBlcmZvcm1hbmNlLm5vdygpKTtcblxuICAgIHJldHVybiB7XG4gICAgICBwYXVzZTogZnVuY3Rpb24gcGF1c2UoKSB7XG4gICAgICAgIGNhbmNlbFRpY2soaWQpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgdmFyIGNyZWF0ZVJvdXRlID0gZnVuY3Rpb24gY3JlYXRlUm91dGUocm91dGVzLCBmbikge1xuICAgIHJldHVybiBmdW5jdGlvbihfcmVmKSB7XG4gICAgICB2YXIgcm9vdCA9IF9yZWYucm9vdCxcbiAgICAgICAgcHJvcHMgPSBfcmVmLnByb3BzLFxuICAgICAgICBfcmVmJGFjdGlvbnMgPSBfcmVmLmFjdGlvbnMsXG4gICAgICAgIGFjdGlvbnMgPSBfcmVmJGFjdGlvbnMgPT09IHZvaWQgMCA/IFtdIDogX3JlZiRhY3Rpb25zLFxuICAgICAgICB0aW1lc3RhbXAgPSBfcmVmLnRpbWVzdGFtcCxcbiAgICAgICAgc2hvdWxkT3B0aW1pemUgPSBfcmVmLnNob3VsZE9wdGltaXplO1xuICAgICAgYWN0aW9uc1xuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGFjdGlvbikge1xuICAgICAgICAgIHJldHVybiByb3V0ZXNbYWN0aW9uLnR5cGVdO1xuICAgICAgICB9KVxuICAgICAgICAuZm9yRWFjaChmdW5jdGlvbihhY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gcm91dGVzW2FjdGlvbi50eXBlXSh7XG4gICAgICAgICAgICByb290OiByb290LFxuICAgICAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICAgICAgYWN0aW9uOiBhY3Rpb24uZGF0YSxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogdGltZXN0YW1wLFxuICAgICAgICAgICAgc2hvdWxkT3B0aW1pemU6IHNob3VsZE9wdGltaXplXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICBpZiAoZm4pIHtcbiAgICAgICAgZm4oe1xuICAgICAgICAgIHJvb3Q6IHJvb3QsXG4gICAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICAgIGFjdGlvbnM6IGFjdGlvbnMsXG4gICAgICAgICAgdGltZXN0YW1wOiB0aW1lc3RhbXAsXG4gICAgICAgICAgc2hvdWxkT3B0aW1pemU6IHNob3VsZE9wdGltaXplXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgdmFyIGluc2VydEJlZm9yZSA9IGZ1bmN0aW9uIGluc2VydEJlZm9yZShuZXdOb2RlLCByZWZlcmVuY2VOb2RlKSB7XG4gICAgcmV0dXJuIHJlZmVyZW5jZU5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSk7XG4gIH07XG5cbiAgdmFyIGluc2VydEFmdGVyID0gZnVuY3Rpb24gaW5zZXJ0QWZ0ZXIobmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSkge1xuICAgIHJldHVybiByZWZlcmVuY2VOb2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKFxuICAgICAgbmV3Tm9kZSxcbiAgICAgIHJlZmVyZW5jZU5vZGUubmV4dFNpYmxpbmdcbiAgICApO1xuICB9O1xuXG4gIHZhciBpc0FycmF5ID0gZnVuY3Rpb24gaXNBcnJheSh2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKTtcbiAgfTtcblxuICB2YXIgaXNFbXB0eSA9IGZ1bmN0aW9uIGlzRW1wdHkodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT0gbnVsbDtcbiAgfTtcblxuICB2YXIgdHJpbSA9IGZ1bmN0aW9uIHRyaW0oc3RyKSB7XG4gICAgcmV0dXJuIHN0ci50cmltKCk7XG4gIH07XG5cbiAgdmFyIHRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gJycgKyB2YWx1ZTtcbiAgfTtcblxuICB2YXIgdG9BcnJheSA9IGZ1bmN0aW9uIHRvQXJyYXkodmFsdWUpIHtcbiAgICB2YXIgc3BsaXR0ZXIgPVxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnLCc7XG4gICAgaWYgKGlzRW1wdHkodmFsdWUpKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdG9TdHJpbmcodmFsdWUpXG4gICAgICAuc3BsaXQoc3BsaXR0ZXIpXG4gICAgICAubWFwKHRyaW0pXG4gICAgICAuZmlsdGVyKGZ1bmN0aW9uKHN0cikge1xuICAgICAgICByZXR1cm4gc3RyLmxlbmd0aDtcbiAgICAgIH0pO1xuICB9O1xuXG4gIHZhciBpc0Jvb2xlYW4gPSBmdW5jdGlvbiBpc0Jvb2xlYW4odmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbic7XG4gIH07XG5cbiAgdmFyIHRvQm9vbGVhbiA9IGZ1bmN0aW9uIHRvQm9vbGVhbih2YWx1ZSkge1xuICAgIHJldHVybiBpc0Jvb2xlYW4odmFsdWUpID8gdmFsdWUgOiB2YWx1ZSA9PT0gJ3RydWUnO1xuICB9O1xuXG4gIHZhciBpc1N0cmluZyA9IGZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG4gIH07XG5cbiAgdmFyIHRvTnVtYmVyID0gZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgICByZXR1cm4gaXNOdW1iZXIodmFsdWUpXG4gICAgICA/IHZhbHVlXG4gICAgICA6IGlzU3RyaW5nKHZhbHVlKVxuICAgICAgPyB0b1N0cmluZyh2YWx1ZSkucmVwbGFjZSgvW2Etel0rL2dpLCAnJylcbiAgICAgIDogMDtcbiAgfTtcblxuICB2YXIgdG9JbnQgPSBmdW5jdGlvbiB0b0ludCh2YWx1ZSkge1xuICAgIHJldHVybiBwYXJzZUludCh0b051bWJlcih2YWx1ZSksIDEwKTtcbiAgfTtcblxuICB2YXIgdG9GbG9hdCA9IGZ1bmN0aW9uIHRvRmxvYXQodmFsdWUpIHtcbiAgICByZXR1cm4gcGFyc2VGbG9hdCh0b051bWJlcih2YWx1ZSkpO1xuICB9O1xuXG4gIHZhciBpc0ludCA9IGZ1bmN0aW9uIGlzSW50KHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzTnVtYmVyKHZhbHVlKSAmJiBpc0Zpbml0ZSh2YWx1ZSkgJiYgTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlO1xuICB9O1xuXG4gIHZhciB0b0J5dGVzID0gZnVuY3Rpb24gdG9CeXRlcyh2YWx1ZSkge1xuICAgIHZhciBiYXNlID1cbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMTAwMDtcbiAgICAvLyBpcyBpbiBieXRlc1xuICAgIGlmIChpc0ludCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvLyBpcyBuYXR1cmFsIGZpbGUgc2l6ZVxuICAgIHZhciBuYXR1cmFsRmlsZVNpemUgPSB0b1N0cmluZyh2YWx1ZSkudHJpbSgpO1xuXG4gICAgLy8gaWYgaXMgdmFsdWUgaW4gbWVnYWJ5dGVzXG4gICAgaWYgKC9NQiQvaS50ZXN0KG5hdHVyYWxGaWxlU2l6ZSkpIHtcbiAgICAgIG5hdHVyYWxGaWxlU2l6ZSA9IG5hdHVyYWxGaWxlU2l6ZS5yZXBsYWNlKC9NQiRpLywgJycpLnRyaW0oKTtcbiAgICAgIHJldHVybiB0b0ludChuYXR1cmFsRmlsZVNpemUpICogYmFzZSAqIGJhc2U7XG4gICAgfVxuXG4gICAgLy8gaWYgaXMgdmFsdWUgaW4ga2lsb2J5dGVzXG4gICAgaWYgKC9LQi9pLnRlc3QobmF0dXJhbEZpbGVTaXplKSkge1xuICAgICAgbmF0dXJhbEZpbGVTaXplID0gbmF0dXJhbEZpbGVTaXplLnJlcGxhY2UoL0tCJGkvLCAnJykudHJpbSgpO1xuICAgICAgcmV0dXJuIHRvSW50KG5hdHVyYWxGaWxlU2l6ZSkgKiBiYXNlO1xuICAgIH1cblxuICAgIHJldHVybiB0b0ludChuYXR1cmFsRmlsZVNpemUpO1xuICB9O1xuXG4gIHZhciBpc0Z1bmN0aW9uID0gZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG4gIH07XG5cbiAgdmFyIHRvRnVuY3Rpb25SZWZlcmVuY2UgPSBmdW5jdGlvbiB0b0Z1bmN0aW9uUmVmZXJlbmNlKHN0cmluZykge1xuICAgIHZhciByZWYgPSBzZWxmO1xuICAgIHZhciBsZXZlbHMgPSBzdHJpbmcuc3BsaXQoJy4nKTtcbiAgICB2YXIgbGV2ZWwgPSBudWxsO1xuICAgIHdoaWxlICgobGV2ZWwgPSBsZXZlbHMuc2hpZnQoKSkpIHtcbiAgICAgIHJlZiA9IHJlZltsZXZlbF07XG4gICAgICBpZiAoIXJlZikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlZjtcbiAgfTtcblxuICB2YXIgbWV0aG9kcyA9IHtcbiAgICBwcm9jZXNzOiAnUE9TVCcsXG4gICAgcGF0Y2g6ICdQQVRDSCcsXG4gICAgcmV2ZXJ0OiAnREVMRVRFJyxcbiAgICBmZXRjaDogJ0dFVCcsXG4gICAgcmVzdG9yZTogJ0dFVCcsXG4gICAgbG9hZDogJ0dFVCdcbiAgfTtcblxuICB2YXIgY3JlYXRlU2VydmVyQVBJID0gZnVuY3Rpb24gY3JlYXRlU2VydmVyQVBJKG91dGxpbmUpIHtcbiAgICB2YXIgYXBpID0ge307XG5cbiAgICBhcGkudXJsID0gaXNTdHJpbmcob3V0bGluZSkgPyBvdXRsaW5lIDogb3V0bGluZS51cmwgfHwgJyc7XG4gICAgYXBpLnRpbWVvdXQgPSBvdXRsaW5lLnRpbWVvdXQgPyBwYXJzZUludChvdXRsaW5lLnRpbWVvdXQsIDEwKSA6IDA7XG4gICAgYXBpLmhlYWRlcnMgPSBvdXRsaW5lLmhlYWRlcnMgPyBvdXRsaW5lLmhlYWRlcnMgOiB7fTtcblxuICAgIGZvcmluKG1ldGhvZHMsIGZ1bmN0aW9uKGtleSkge1xuICAgICAgYXBpW2tleV0gPSBjcmVhdGVBY3Rpb24oXG4gICAgICAgIGtleSxcbiAgICAgICAgb3V0bGluZVtrZXldLFxuICAgICAgICBtZXRob2RzW2tleV0sXG4gICAgICAgIGFwaS50aW1lb3V0LFxuICAgICAgICBhcGkuaGVhZGVyc1xuICAgICAgKTtcbiAgICB9KTtcblxuICAgIC8vIHNwZWNpYWwgdHJlYXRtZW50IGZvciByZW1vdmVcbiAgICBhcGkucmVtb3ZlID0gb3V0bGluZS5yZW1vdmUgfHwgbnVsbDtcblxuICAgIC8vIHJlbW92ZSBnZW5lcmljIGhlYWRlcnMgZnJvbSBhcGkgb2JqZWN0XG4gICAgZGVsZXRlIGFwaS5oZWFkZXJzO1xuXG4gICAgcmV0dXJuIGFwaTtcbiAgfTtcblxuICB2YXIgY3JlYXRlQWN0aW9uID0gZnVuY3Rpb24gY3JlYXRlQWN0aW9uKFxuICAgIG5hbWUsXG4gICAgb3V0bGluZSxcbiAgICBtZXRob2QsXG4gICAgdGltZW91dCxcbiAgICBoZWFkZXJzXG4gICkge1xuICAgIC8vIGlzIGV4cGxpY2l0ZWx5IHNldCB0byBudWxsIHNvIGRpc2FibGVcbiAgICBpZiAob3V0bGluZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gaWYgaXMgY3VzdG9tIGZ1bmN0aW9uLCBkb25lISBEZXYgaGFuZGxlcyBldmVyeXRoaW5nLlxuICAgIGlmICh0eXBlb2Ygb3V0bGluZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIG91dGxpbmU7XG4gICAgfVxuXG4gICAgLy8gYnVpbGQgYWN0aW9uIG9iamVjdFxuICAgIHZhciBhY3Rpb24gPSB7XG4gICAgICB1cmw6IG1ldGhvZCA9PT0gJ0dFVCcgfHwgbWV0aG9kID09PSAnUEFUQ0gnID8gJz8nICsgbmFtZSArICc9JyA6ICcnLFxuICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgICAgd2l0aENyZWRlbnRpYWxzOiBmYWxzZSxcbiAgICAgIHRpbWVvdXQ6IHRpbWVvdXQsXG4gICAgICBvbmxvYWQ6IG51bGwsXG4gICAgICBvbmRhdGE6IG51bGwsXG4gICAgICBvbmVycm9yOiBudWxsXG4gICAgfTtcblxuICAgIC8vIGlzIGEgc2luZ2xlIHVybFxuICAgIGlmIChpc1N0cmluZyhvdXRsaW5lKSkge1xuICAgICAgYWN0aW9uLnVybCA9IG91dGxpbmU7XG4gICAgICByZXR1cm4gYWN0aW9uO1xuICAgIH1cblxuICAgIC8vIG92ZXJ3cml0ZVxuICAgIE9iamVjdC5hc3NpZ24oYWN0aW9uLCBvdXRsaW5lKTtcblxuICAgIC8vIHNlZSBpZiBzaG91bGQgcmVmb3JtYXQgaGVhZGVycztcbiAgICBpZiAoaXNTdHJpbmcoYWN0aW9uLmhlYWRlcnMpKSB7XG4gICAgICB2YXIgcGFydHMgPSBhY3Rpb24uaGVhZGVycy5zcGxpdCgvOiguKykvKTtcbiAgICAgIGFjdGlvbi5oZWFkZXJzID0ge1xuICAgICAgICBoZWFkZXI6IHBhcnRzWzBdLFxuICAgICAgICB2YWx1ZTogcGFydHNbMV1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gaWYgaXMgYm9vbCB3aXRoQ3JlZGVudGlhbHNcbiAgICBhY3Rpb24ud2l0aENyZWRlbnRpYWxzID0gdG9Cb29sZWFuKGFjdGlvbi53aXRoQ3JlZGVudGlhbHMpO1xuXG4gICAgcmV0dXJuIGFjdGlvbjtcbiAgfTtcblxuICB2YXIgdG9TZXJ2ZXJBUEkgPSBmdW5jdGlvbiB0b1NlcnZlckFQSSh2YWx1ZSkge1xuICAgIHJldHVybiBjcmVhdGVTZXJ2ZXJBUEkodmFsdWUpO1xuICB9O1xuXG4gIHZhciBpc051bGwgPSBmdW5jdGlvbiBpc051bGwodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGw7XG4gIH07XG5cbiAgdmFyIGlzT2JqZWN0ID0gZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbDtcbiAgfTtcblxuICB2YXIgaXNBUEkgPSBmdW5jdGlvbiBpc0FQSSh2YWx1ZSkge1xuICAgIHJldHVybiAoXG4gICAgICBpc09iamVjdCh2YWx1ZSkgJiZcbiAgICAgIGlzU3RyaW5nKHZhbHVlLnVybCkgJiZcbiAgICAgIGlzT2JqZWN0KHZhbHVlLnByb2Nlc3MpICYmXG4gICAgICBpc09iamVjdCh2YWx1ZS5yZXZlcnQpICYmXG4gICAgICBpc09iamVjdCh2YWx1ZS5yZXN0b3JlKSAmJlxuICAgICAgaXNPYmplY3QodmFsdWUuZmV0Y2gpXG4gICAgKTtcbiAgfTtcblxuICB2YXIgZ2V0VHlwZSA9IGZ1bmN0aW9uIGdldFR5cGUodmFsdWUpIHtcbiAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiAnYXJyYXknO1xuICAgIH1cblxuICAgIGlmIChpc051bGwodmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ251bGwnO1xuICAgIH1cblxuICAgIGlmIChpc0ludCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiAnaW50JztcbiAgICB9XG5cbiAgICBpZiAoL15bMC05XSsgPyg/OkdCfE1CfEtCKSQvZ2kudGVzdCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiAnYnl0ZXMnO1xuICAgIH1cblxuICAgIGlmIChpc0FQSSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiAnYXBpJztcbiAgICB9XG5cbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlO1xuICB9O1xuXG4gIHZhciByZXBsYWNlU2luZ2xlUXVvdGVzID0gZnVuY3Rpb24gcmVwbGFjZVNpbmdsZVF1b3RlcyhzdHIpIHtcbiAgICByZXR1cm4gc3RyXG4gICAgICAucmVwbGFjZSgve1xccyonL2csICd7XCInKVxuICAgICAgLnJlcGxhY2UoLydcXHMqfS9nLCAnXCJ9JylcbiAgICAgIC5yZXBsYWNlKC8nXFxzKjovZywgJ1wiOicpXG4gICAgICAucmVwbGFjZSgvOlxccyonL2csICc6XCInKVxuICAgICAgLnJlcGxhY2UoLyxcXHMqJy9nLCAnLFwiJylcbiAgICAgIC5yZXBsYWNlKC8nXFxzKiwvZywgJ1wiLCcpO1xuICB9O1xuXG4gIHZhciBjb252ZXJzaW9uVGFibGUgPSB7XG4gICAgYXJyYXk6IHRvQXJyYXksXG4gICAgYm9vbGVhbjogdG9Cb29sZWFuLFxuICAgIGludDogZnVuY3Rpb24gaW50KHZhbHVlKSB7XG4gICAgICByZXR1cm4gZ2V0VHlwZSh2YWx1ZSkgPT09ICdieXRlcycgPyB0b0J5dGVzKHZhbHVlKSA6IHRvSW50KHZhbHVlKTtcbiAgICB9LFxuICAgIG51bWJlcjogdG9GbG9hdCxcbiAgICBmbG9hdDogdG9GbG9hdCxcbiAgICBieXRlczogdG9CeXRlcyxcbiAgICBzdHJpbmc6IGZ1bmN0aW9uIHN0cmluZyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzRnVuY3Rpb24odmFsdWUpID8gdmFsdWUgOiB0b1N0cmluZyh2YWx1ZSk7XG4gICAgfSxcbiAgICBmdW5jdGlvbjogZnVuY3Rpb24gX2Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdG9GdW5jdGlvblJlZmVyZW5jZSh2YWx1ZSk7XG4gICAgfSxcbiAgICBzZXJ2ZXJhcGk6IHRvU2VydmVyQVBJLFxuICAgIG9iamVjdDogZnVuY3Rpb24gb2JqZWN0KHZhbHVlKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShyZXBsYWNlU2luZ2xlUXVvdGVzKHZhbHVlKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgY29udmVydFRvID0gZnVuY3Rpb24gY29udmVydFRvKHZhbHVlLCB0eXBlKSB7XG4gICAgcmV0dXJuIGNvbnZlcnNpb25UYWJsZVt0eXBlXSh2YWx1ZSk7XG4gIH07XG5cbiAgdmFyIGdldFZhbHVlQnlUeXBlID0gZnVuY3Rpb24gZ2V0VmFsdWVCeVR5cGUoXG4gICAgbmV3VmFsdWUsXG4gICAgZGVmYXVsdFZhbHVlLFxuICAgIHZhbHVlVHlwZVxuICApIHtcbiAgICAvLyBjYW4gYWx3YXlzIGFzc2lnbiBkZWZhdWx0IHZhbHVlXG4gICAgaWYgKG5ld1ZhbHVlID09PSBkZWZhdWx0VmFsdWUpIHtcbiAgICAgIHJldHVybiBuZXdWYWx1ZTtcbiAgICB9XG5cbiAgICAvLyBnZXQgdGhlIHR5cGUgb2YgdGhlIG5ldyB2YWx1ZVxuICAgIHZhciBuZXdWYWx1ZVR5cGUgPSBnZXRUeXBlKG5ld1ZhbHVlKTtcblxuICAgIC8vIGlzIHZhbGlkIHR5cGU/XG4gICAgaWYgKG5ld1ZhbHVlVHlwZSAhPT0gdmFsdWVUeXBlKSB7XG4gICAgICAvLyBpcyBzdHJpbmcgaW5wdXQsIGxldCdzIGF0dGVtcHQgdG8gY29udmVydFxuICAgICAgdmFyIGNvbnZlcnRlZFZhbHVlID0gY29udmVydFRvKG5ld1ZhbHVlLCB2YWx1ZVR5cGUpO1xuXG4gICAgICAvLyB3aGF0IGlzIHRoZSB0eXBlIG5vd1xuICAgICAgbmV3VmFsdWVUeXBlID0gZ2V0VHlwZShjb252ZXJ0ZWRWYWx1ZSk7XG5cbiAgICAgIC8vIG5vIHZhbGlkIGNvbnZlcnNpb25zIGZvdW5kXG4gICAgICBpZiAoY29udmVydGVkVmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgJ1RyeWluZyB0byBhc3NpZ24gdmFsdWUgd2l0aCBpbmNvcnJlY3QgdHlwZSB0byBcIicgK1xuICAgICAgICAgIG9wdGlvbiArXG4gICAgICAgICAgJ1wiLCBhbGxvd2VkIHR5cGU6IFwiJyArXG4gICAgICAgICAgdmFsdWVUeXBlICtcbiAgICAgICAgICAnXCInO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3VmFsdWUgPSBjb252ZXJ0ZWRWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhc3NpZ24gbmV3IHZhbHVlXG4gICAgcmV0dXJuIG5ld1ZhbHVlO1xuICB9O1xuXG4gIHZhciBjcmVhdGVPcHRpb24gPSBmdW5jdGlvbiBjcmVhdGVPcHRpb24oZGVmYXVsdFZhbHVlLCB2YWx1ZVR5cGUpIHtcbiAgICB2YXIgY3VycmVudFZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgIHJldHVybiB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50VmFsdWU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQobmV3VmFsdWUpIHtcbiAgICAgICAgY3VycmVudFZhbHVlID0gZ2V0VmFsdWVCeVR5cGUobmV3VmFsdWUsIGRlZmF1bHRWYWx1ZSwgdmFsdWVUeXBlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIHZhciBjcmVhdGVPcHRpb25zID0gZnVuY3Rpb24gY3JlYXRlT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgdmFyIG9iaiA9IHt9O1xuICAgIGZvcmluKG9wdGlvbnMsIGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgIHZhciBvcHRpb25EZWZpbml0aW9uID0gb3B0aW9uc1twcm9wXTtcbiAgICAgIG9ialtwcm9wXSA9IGNyZWF0ZU9wdGlvbihvcHRpb25EZWZpbml0aW9uWzBdLCBvcHRpb25EZWZpbml0aW9uWzFdKTtcbiAgICB9KTtcbiAgICByZXR1cm4gY3JlYXRlT2JqZWN0KG9iaik7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUluaXRpYWxTdGF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZUluaXRpYWxTdGF0ZShvcHRpb25zKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIG1vZGVsXG4gICAgICBpdGVtczogW10sXG5cbiAgICAgIC8vIHRpbWVvdXQgdXNlZCBmb3IgY2FsbGluZyB1cGRhdGUgaXRlbXNcbiAgICAgIGxpc3RVcGRhdGVUaW1lb3V0OiBudWxsLFxuXG4gICAgICAvLyB0aW1lb3V0IHVzZWQgZm9yIHN0YWNraW5nIG1ldGFkYXRhIHVwZGF0ZXNcbiAgICAgIGl0ZW1VcGRhdGVUaW1lb3V0OiBudWxsLFxuXG4gICAgICAvLyBxdWV1ZSBvZiBpdGVtcyB3YWl0aW5nIHRvIGJlIHByb2Nlc3NlZFxuICAgICAgcHJvY2Vzc2luZ1F1ZXVlOiBbXSxcblxuICAgICAgLy8gb3B0aW9uc1xuICAgICAgb3B0aW9uczogY3JlYXRlT3B0aW9ucyhvcHRpb25zKVxuICAgIH07XG4gIH07XG5cbiAgdmFyIGZyb21DYW1lbHMgPSBmdW5jdGlvbiBmcm9tQ2FtZWxzKHN0cmluZykge1xuICAgIHZhciBzZXBhcmF0b3IgPVxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnLSc7XG4gICAgcmV0dXJuIHN0cmluZ1xuICAgICAgLnNwbGl0KC8oPz1bQS1aXSkvKVxuICAgICAgLm1hcChmdW5jdGlvbihwYXJ0KSB7XG4gICAgICAgIHJldHVybiBwYXJ0LnRvTG93ZXJDYXNlKCk7XG4gICAgICB9KVxuICAgICAgLmpvaW4oc2VwYXJhdG9yKTtcbiAgfTtcblxuICB2YXIgY3JlYXRlT3B0aW9uQVBJID0gZnVuY3Rpb24gY3JlYXRlT3B0aW9uQVBJKHN0b3JlLCBvcHRpb25zKSB7XG4gICAgdmFyIG9iaiA9IHt9O1xuICAgIGZvcmluKG9wdGlvbnMsIGZ1bmN0aW9uKGtleSkge1xuICAgICAgb2JqW2tleV0gPSB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBzdG9yZS5nZXRTdGF0ZSgpLm9wdGlvbnNba2V5XTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgICBzdG9yZS5kaXNwYXRjaCgnU0VUXycgKyBmcm9tQ2FtZWxzKGtleSwgJ18nKS50b1VwcGVyQ2FzZSgpLCB7XG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIHZhciBjcmVhdGVPcHRpb25BY3Rpb25zID0gZnVuY3Rpb24gY3JlYXRlT3B0aW9uQWN0aW9ucyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGRpc3BhdGNoLCBxdWVyeSwgc3RhdGUpIHtcbiAgICAgIHZhciBvYmogPSB7fTtcbiAgICAgIGZvcmluKG9wdGlvbnMsIGZ1bmN0aW9uKGtleSkge1xuICAgICAgICB2YXIgbmFtZSA9IGZyb21DYW1lbHMoa2V5LCAnXycpLnRvVXBwZXJDYXNlKCk7XG5cbiAgICAgICAgb2JqWydTRVRfJyArIG5hbWVdID0gZnVuY3Rpb24oYWN0aW9uKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHN0YXRlLm9wdGlvbnNba2V5XSA9IGFjdGlvbi52YWx1ZTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7fSAvLyBub3BlLCBmYWlsZWRcblxuICAgICAgICAgIC8vIHdlIHN1Y2Nlc3NmdWxseSBzZXQgdGhlIHZhbHVlIG9mIHRoaXMgb3B0aW9uXG4gICAgICAgICAgZGlzcGF0Y2goJ0RJRF9TRVRfJyArIG5hbWUsIHsgdmFsdWU6IHN0YXRlLm9wdGlvbnNba2V5XSB9KTtcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBjcmVhdGVPcHRpb25RdWVyaWVzID0gZnVuY3Rpb24gY3JlYXRlT3B0aW9uUXVlcmllcyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICB2YXIgb2JqID0ge307XG4gICAgICBmb3JpbihvcHRpb25zLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgb2JqWydHRVRfJyArIGZyb21DYW1lbHMoa2V5LCAnXycpLnRvVXBwZXJDYXNlKCldID0gZnVuY3Rpb24oYWN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YXRlLm9wdGlvbnNba2V5XTtcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBJbnRlcmFjdGlvbk1ldGhvZCA9IHtcbiAgICBBUEk6IDEsXG4gICAgRFJPUDogMixcbiAgICBCUk9XU0U6IDMsXG4gICAgUEFTVEU6IDQsXG4gICAgTk9ORTogNVxuICB9O1xuXG4gIHZhciBnZXRVbmlxdWVJZCA9IGZ1bmN0aW9uIGdldFVuaXF1ZUlkKCkge1xuICAgIHJldHVybiBNYXRoLnJhbmRvbSgpXG4gICAgICAudG9TdHJpbmcoMzYpXG4gICAgICAuc3Vic3RyKDIsIDkpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgIF90eXBlb2YgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBfdHlwZW9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogJiZcbiAgICAgICAgICB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiZcbiAgICAgICAgICBvYmogIT09IFN5bWJvbC5wcm90b3R5cGVcbiAgICAgICAgICA/ICdzeW1ib2wnXG4gICAgICAgICAgOiB0eXBlb2Ygb2JqO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3R5cGVvZihvYmopO1xuICB9XG5cbiAgdmFyIFJFQUNUX0VMRU1FTlRfVFlQRTtcblxuICBmdW5jdGlvbiBfanN4KHR5cGUsIHByb3BzLCBrZXksIGNoaWxkcmVuKSB7XG4gICAgaWYgKCFSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgIFJFQUNUX0VMRU1FTlRfVFlQRSA9XG4gICAgICAgICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgU3ltYm9sWydmb3InXSAmJlxuICAgICAgICAgIFN5bWJvbFsnZm9yJ10oJ3JlYWN0LmVsZW1lbnQnKSkgfHxcbiAgICAgICAgMHhlYWM3O1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzO1xuICAgIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAzO1xuXG4gICAgaWYgKCFwcm9wcyAmJiBjaGlsZHJlbkxlbmd0aCAhPT0gMCkge1xuICAgICAgcHJvcHMgPSB7XG4gICAgICAgIGNoaWxkcmVuOiB2b2lkIDBcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHByb3BzICYmIGRlZmF1bHRQcm9wcykge1xuICAgICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHZvaWQgMCkge1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFwcm9wcykge1xuICAgICAgcHJvcHMgPSBkZWZhdWx0UHJvcHMgfHwge307XG4gICAgfVxuXG4gICAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgICB2YXIgY2hpbGRBcnJheSA9IG5ldyBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAzXTtcbiAgICAgIH1cblxuICAgICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgICAgdHlwZTogdHlwZSxcbiAgICAgIGtleToga2V5ID09PSB1bmRlZmluZWQgPyBudWxsIDogJycgKyBrZXksXG4gICAgICByZWY6IG51bGwsXG4gICAgICBwcm9wczogcHJvcHMsXG4gICAgICBfb3duZXI6IG51bGxcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gX2FzeW5jSXRlcmF0b3IoaXRlcmFibGUpIHtcbiAgICB2YXIgbWV0aG9kO1xuXG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBpZiAoU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHtcbiAgICAgICAgbWV0aG9kID0gaXRlcmFibGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdO1xuICAgICAgICBpZiAobWV0aG9kICE9IG51bGwpIHJldHVybiBtZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChTeW1ib2wuaXRlcmF0b3IpIHtcbiAgICAgICAgbWV0aG9kID0gaXRlcmFibGVbU3ltYm9sLml0ZXJhdG9yXTtcbiAgICAgICAgaWYgKG1ldGhvZCAhPSBudWxsKSByZXR1cm4gbWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdCBpcyBub3QgYXN5bmMgaXRlcmFibGUnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9Bd2FpdFZhbHVlKHZhbHVlKSB7XG4gICAgdGhpcy53cmFwcGVkID0gdmFsdWU7XG4gIH1cblxuICBmdW5jdGlvbiBfQXN5bmNHZW5lcmF0b3IoZ2VuKSB7XG4gICAgdmFyIGZyb250LCBiYWNrO1xuXG4gICAgZnVuY3Rpb24gc2VuZChrZXksIGFyZykge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgcmVxdWVzdCA9IHtcbiAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICBhcmc6IGFyZyxcbiAgICAgICAgICByZXNvbHZlOiByZXNvbHZlLFxuICAgICAgICAgIHJlamVjdDogcmVqZWN0LFxuICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoYmFjaykge1xuICAgICAgICAgIGJhY2sgPSBiYWNrLm5leHQgPSByZXF1ZXN0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZyb250ID0gYmFjayA9IHJlcXVlc3Q7XG4gICAgICAgICAgcmVzdW1lKGtleSwgYXJnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzdW1lKGtleSwgYXJnKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gZ2VuW2tleV0oYXJnKTtcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICB2YXIgd3JhcHBlZEF3YWl0ID0gdmFsdWUgaW5zdGFuY2VvZiBfQXdhaXRWYWx1ZTtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHdyYXBwZWRBd2FpdCA/IHZhbHVlLndyYXBwZWQgOiB2YWx1ZSkudGhlbihcbiAgICAgICAgICBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgICAgIGlmICh3cmFwcGVkQXdhaXQpIHtcbiAgICAgICAgICAgICAgcmVzdW1lKCduZXh0JywgYXJnKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZXR0bGUocmVzdWx0LmRvbmUgPyAncmV0dXJuJyA6ICdub3JtYWwnLCBhcmcpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICByZXN1bWUoJ3Rocm93JywgZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgc2V0dGxlKCd0aHJvdycsIGVycik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0dGxlKHR5cGUsIHZhbHVlKSB7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAncmV0dXJuJzpcbiAgICAgICAgICBmcm9udC5yZXNvbHZlKHtcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIGRvbmU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICd0aHJvdyc6XG4gICAgICAgICAgZnJvbnQucmVqZWN0KHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGZyb250LnJlc29sdmUoe1xuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgZnJvbnQgPSBmcm9udC5uZXh0O1xuXG4gICAgICBpZiAoZnJvbnQpIHtcbiAgICAgICAgcmVzdW1lKGZyb250LmtleSwgZnJvbnQuYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJhY2sgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX2ludm9rZSA9IHNlbmQ7XG5cbiAgICBpZiAodHlwZW9mIGdlbi5yZXR1cm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMucmV0dXJuID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5hc3luY0l0ZXJhdG9yKSB7XG4gICAgX0FzeW5jR2VuZXJhdG9yLnByb3RvdHlwZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gIH1cblxuICBfQXN5bmNHZW5lcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdGhpcy5faW52b2tlKCduZXh0JywgYXJnKTtcbiAgfTtcblxuICBfQXN5bmNHZW5lcmF0b3IucHJvdG90eXBlLnRocm93ID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ludm9rZSgndGhyb3cnLCBhcmcpO1xuICB9O1xuXG4gIF9Bc3luY0dlbmVyYXRvci5wcm90b3R5cGUucmV0dXJuID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ludm9rZSgncmV0dXJuJywgYXJnKTtcbiAgfTtcblxuICBmdW5jdGlvbiBfd3JhcEFzeW5jR2VuZXJhdG9yKGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBfQXN5bmNHZW5lcmF0b3IoZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9hd2FpdEFzeW5jR2VuZXJhdG9yKHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBfQXdhaXRWYWx1ZSh2YWx1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBfYXN5bmNHZW5lcmF0b3JEZWxlZ2F0ZShpbm5lciwgYXdhaXRXcmFwKSB7XG4gICAgdmFyIGl0ZXIgPSB7fSxcbiAgICAgIHdhaXRpbmcgPSBmYWxzZTtcblxuICAgIGZ1bmN0aW9uIHB1bXAoa2V5LCB2YWx1ZSkge1xuICAgICAgd2FpdGluZyA9IHRydWU7XG4gICAgICB2YWx1ZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgcmVzb2x2ZShpbm5lcltrZXldKHZhbHVlKSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICB2YWx1ZTogYXdhaXRXcmFwKHZhbHVlKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3IpIHtcbiAgICAgIGl0ZXJbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaXRlci5uZXh0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmICh3YWl0aW5nKSB7XG4gICAgICAgIHdhaXRpbmcgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHVtcCgnbmV4dCcsIHZhbHVlKTtcbiAgICB9O1xuXG4gICAgaWYgKHR5cGVvZiBpbm5lci50aHJvdyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaXRlci50aHJvdyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmICh3YWl0aW5nKSB7XG4gICAgICAgICAgd2FpdGluZyA9IGZhbHNlO1xuICAgICAgICAgIHRocm93IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHB1bXAoJ3Rocm93JywgdmFsdWUpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGlubmVyLnJldHVybiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaXRlci5yZXR1cm4gPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gcHVtcCgncmV0dXJuJywgdmFsdWUpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXRlcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywga2V5LCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpO1xuICAgICAgdmFyIHZhbHVlID0gaW5mby52YWx1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7XG5cbiAgICAgICAgZnVuY3Rpb24gX25leHQodmFsdWUpIHtcbiAgICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoXG4gICAgICAgICAgICBnZW4sXG4gICAgICAgICAgICByZXNvbHZlLFxuICAgICAgICAgICAgcmVqZWN0LFxuICAgICAgICAgICAgX25leHQsXG4gICAgICAgICAgICBfdGhyb3csXG4gICAgICAgICAgICAnbmV4dCcsXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBfdGhyb3coZXJyKSB7XG4gICAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCAndGhyb3cnLCBlcnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgX25leHQodW5kZWZpbmVkKTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH1cblxuICBmdW5jdGlvbiBfZGVmaW5lRW51bWVyYWJsZVByb3BlcnRpZXMob2JqLCBkZXNjcykge1xuICAgIGZvciAodmFyIGtleSBpbiBkZXNjcykge1xuICAgICAgdmFyIGRlc2MgPSBkZXNjc1trZXldO1xuICAgICAgZGVzYy5jb25maWd1cmFibGUgPSBkZXNjLmVudW1lcmFibGUgPSB0cnVlO1xuICAgICAgaWYgKCd2YWx1ZScgaW4gZGVzYykgZGVzYy53cml0YWJsZSA9IHRydWU7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIGRlc2MpO1xuICAgIH1cblxuICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICB2YXIgb2JqZWN0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZGVzY3MpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdFN5bWJvbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHN5bSA9IG9iamVjdFN5bWJvbHNbaV07XG4gICAgICAgIHZhciBkZXNjID0gZGVzY3Nbc3ltXTtcbiAgICAgICAgZGVzYy5jb25maWd1cmFibGUgPSBkZXNjLmVudW1lcmFibGUgPSB0cnVlO1xuICAgICAgICBpZiAoJ3ZhbHVlJyBpbiBkZXNjKSBkZXNjLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgc3ltLCBkZXNjKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgZnVuY3Rpb24gX2RlZmF1bHRzKG9iaiwgZGVmYXVsdHMpIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGRlZmF1bHRzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICB2YXIgdmFsdWUgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGRlZmF1bHRzLCBrZXkpO1xuXG4gICAgICBpZiAodmFsdWUgJiYgdmFsdWUuY29uZmlndXJhYmxlICYmIG9ialtrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5IGluIG9iaikge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICAgIF9leHRlbmRzID1cbiAgICAgIE9iamVjdC5hc3NpZ24gfHxcbiAgICAgIGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICB9O1xuXG4gICAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBmdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcbiAgICAgIHZhciBvd25LZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcblxuICAgICAgaWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG93bktleXMgPSBvd25LZXlzLmNvbmNhdChcbiAgICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSkuZmlsdGVyKGZ1bmN0aW9uKHN5bSkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBzeW0pLmVudW1lcmFibGU7XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgb3duS2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cblxuICBmdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG5cbiAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgICBpZiAoZW51bWVyYWJsZU9ubHkpXG4gICAgICAgIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbihzeW0pIHtcbiAgICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgICAgICAgfSk7XG4gICAgICBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGtleXM7XG4gIH1cblxuICBmdW5jdGlvbiBfb2JqZWN0U3ByZWFkMih0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307XG5cbiAgICAgIGlmIChpICUgMikge1xuICAgICAgICBvd25LZXlzKHNvdXJjZSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFxuICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvd25LZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KVxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cblxuICBmdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24nKTtcbiAgICB9XG5cbiAgICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xuICB9XG5cbiAgZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcbiAgICBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzcztcbiAgICBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xuICB9XG5cbiAgZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2ZcbiAgICAgID8gT2JqZWN0LmdldFByb3RvdHlwZU9mXG4gICAgICA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgICAgICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgICAgICAgfTtcbiAgICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xuICB9XG5cbiAgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBfc2V0UHJvdG90eXBlT2YgPVxuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgICAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgICAgIHJldHVybiBvO1xuICAgICAgfTtcblxuICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG4gIH1cblxuICBmdW5jdGlvbiBpc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAndW5kZWZpbmVkJyB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgUHJveHkgPT09ICdmdW5jdGlvbicpIHJldHVybiB0cnVlO1xuXG4gICAgdHJ5IHtcbiAgICAgIERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uKCkge30pKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcbiAgICBpZiAoaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkpIHtcbiAgICAgIF9jb25zdHJ1Y3QgPSBSZWZsZWN0LmNvbnN0cnVjdDtcbiAgICB9IGVsc2Uge1xuICAgICAgX2NvbnN0cnVjdCA9IGZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykge1xuICAgICAgICB2YXIgYSA9IFtudWxsXTtcbiAgICAgICAgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpO1xuICAgICAgICB2YXIgQ29uc3RydWN0b3IgPSBGdW5jdGlvbi5iaW5kLmFwcGx5KFBhcmVudCwgYSk7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IG5ldyBDb25zdHJ1Y3RvcigpO1xuICAgICAgICBpZiAoQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihpbnN0YW5jZSwgQ2xhc3MucHJvdG90eXBlKTtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gX2NvbnN0cnVjdC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgZnVuY3Rpb24gX2lzTmF0aXZlRnVuY3Rpb24oZm4pIHtcbiAgICByZXR1cm4gRnVuY3Rpb24udG9TdHJpbmcuY2FsbChmbikuaW5kZXhPZignW25hdGl2ZSBjb2RlXScpICE9PSAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHtcbiAgICB2YXIgX2NhY2hlID0gdHlwZW9mIE1hcCA9PT0gJ2Z1bmN0aW9uJyA/IG5ldyBNYXAoKSA6IHVuZGVmaW5lZDtcblxuICAgIF93cmFwTmF0aXZlU3VwZXIgPSBmdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7XG4gICAgICBpZiAoQ2xhc3MgPT09IG51bGwgfHwgIV9pc05hdGl2ZUZ1bmN0aW9uKENsYXNzKSkgcmV0dXJuIENsYXNzO1xuXG4gICAgICBpZiAodHlwZW9mIENsYXNzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uJ1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIF9jYWNoZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKF9jYWNoZS5oYXMoQ2xhc3MpKSByZXR1cm4gX2NhY2hlLmdldChDbGFzcyk7XG5cbiAgICAgICAgX2NhY2hlLnNldChDbGFzcywgV3JhcHBlcik7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIFdyYXBwZXIoKSB7XG4gICAgICAgIHJldHVybiBfY29uc3RydWN0KENsYXNzLCBhcmd1bWVudHMsIF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3Rvcik7XG4gICAgICB9XG5cbiAgICAgIFdyYXBwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICB2YWx1ZTogV3JhcHBlcixcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKFdyYXBwZXIsIENsYXNzKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpO1xuICB9XG5cbiAgZnVuY3Rpb24gX2luc3RhbmNlb2YobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAoXG4gICAgICByaWdodCAhPSBudWxsICYmXG4gICAgICB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgcmlnaHRbU3ltYm9sLmhhc0luc3RhbmNlXVxuICAgICkge1xuICAgICAgcmV0dXJuICEhcmlnaHRbU3ltYm9sLmhhc0luc3RhbmNlXShsZWZ0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGxlZnQgaW5zdGFuY2VvZiByaWdodDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGVcbiAgICAgID8gb2JqXG4gICAgICA6IHtcbiAgICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICAgICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikge1xuICAgIGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBuZXdPYmogPSB7fTtcblxuICAgICAgaWYgKG9iaiAhPSBudWxsKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgICAgdmFyIGRlc2MgPVxuICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvclxuICAgICAgICAgICAgICAgID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSlcbiAgICAgICAgICAgICAgICA6IHt9O1xuXG4gICAgICAgICAgICBpZiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpIHtcbiAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld09ialtrZXldID0gb2JqW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG5ld09iai5kZWZhdWx0ID0gb2JqO1xuICAgICAgcmV0dXJuIG5ld09iajtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfbmV3QXJyb3dDaGVjayhpbm5lclRoaXMsIGJvdW5kVGhpcykge1xuICAgIGlmIChpbm5lclRoaXMgIT09IGJvdW5kVGhpcykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGluc3RhbnRpYXRlIGFuIGFycm93IGZ1bmN0aW9uJyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX29iamVjdERlc3RydWN0dXJpbmdFbXB0eShvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBkZXN0cnVjdHVyZSB1bmRlZmluZWQnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgICB2YXIgdGFyZ2V0ID0ge307XG4gICAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICAgIHZhciBrZXksIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cblxuICBmdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkge1xuICAgIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuXG4gICAgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpO1xuXG4gICAgdmFyIGtleSwgaTtcblxuICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTtcbiAgICAgICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG5cbiAgZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gICAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFxuICAgICAgICBcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBzZWxmO1xuICB9XG5cbiAgZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICAgIGlmIChjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIGNhbGwgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICByZXR1cm4gY2FsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xuICAgICAgb2JqZWN0ID0gX2dldFByb3RvdHlwZU9mKG9iamVjdCk7XG4gICAgICBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG5cbiAgZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gJ3VuZGVmaW5lZCcgJiYgUmVmbGVjdC5nZXQpIHtcbiAgICAgIF9nZXQgPSBSZWZsZWN0LmdldDtcbiAgICB9IGVsc2Uge1xuICAgICAgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgICAgICAgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTtcblxuICAgICAgICBpZiAoIWJhc2UpIHJldHVybjtcbiAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTtcblxuICAgICAgICBpZiAoZGVzYy5nZXQpIHtcbiAgICAgICAgICByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVzYy52YWx1ZTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgcmVjZWl2ZXIpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgIT09ICd1bmRlZmluZWQnICYmIFJlZmxlY3Quc2V0KSB7XG4gICAgICBzZXQgPSBSZWZsZWN0LnNldDtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0ID0gZnVuY3Rpb24gc2V0KHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCByZWNlaXZlcikge1xuICAgICAgICB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpO1xuXG4gICAgICAgIHZhciBkZXNjO1xuXG4gICAgICAgIGlmIChiYXNlKSB7XG4gICAgICAgICAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpO1xuXG4gICAgICAgICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICAgICAgICBkZXNjLnNldC5jYWxsKHJlY2VpdmVyLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFkZXNjLndyaXRhYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocmVjZWl2ZXIsIHByb3BlcnR5KTtcblxuICAgICAgICBpZiAoZGVzYykge1xuICAgICAgICAgIGlmICghZGVzYy53cml0YWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRlc2MudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVjZWl2ZXIsIHByb3BlcnR5LCBkZXNjKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfZGVmaW5lUHJvcGVydHkocmVjZWl2ZXIsIHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHNldCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgcmVjZWl2ZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gX3NldCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgcmVjZWl2ZXIsIGlzU3RyaWN0KSB7XG4gICAgdmFyIHMgPSBzZXQodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIHJlY2VpdmVyIHx8IHRhcmdldCk7XG5cbiAgICBpZiAoIXMgJiYgaXNTdHJpY3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZmFpbGVkIHRvIHNldCBwcm9wZXJ0eScpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF90YWdnZWRUZW1wbGF0ZUxpdGVyYWwoc3RyaW5ncywgcmF3KSB7XG4gICAgaWYgKCFyYXcpIHtcbiAgICAgIHJhdyA9IHN0cmluZ3Muc2xpY2UoMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhzdHJpbmdzLCB7XG4gICAgICAgIHJhdzoge1xuICAgICAgICAgIHZhbHVlOiBPYmplY3QuZnJlZXplKHJhdylcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gX3RhZ2dlZFRlbXBsYXRlTGl0ZXJhbExvb3NlKHN0cmluZ3MsIHJhdykge1xuICAgIGlmICghcmF3KSB7XG4gICAgICByYXcgPSBzdHJpbmdzLnNsaWNlKDApO1xuICAgIH1cblxuICAgIHN0cmluZ3MucmF3ID0gcmF3O1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgZnVuY3Rpb24gX3RlbXBvcmFsUmVmKHZhbCwgbmFtZSkge1xuICAgIGlmICh2YWwgPT09IF90ZW1wb3JhbFVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKG5hbWUgKyAnIGlzIG5vdCBkZWZpbmVkIC0gdGVtcG9yYWwgZGVhZCB6b25lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX3JlYWRPbmx5RXJyb3IobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignXCInICsgbmFtZSArICdcIiBpcyByZWFkLW9ubHknKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc05hbWVURFpFcnJvcihuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0NsYXNzIFwiJyArIG5hbWUgKyAnXCIgY2Fubm90IGJlIHJlZmVyZW5jZWQgaW4gY29tcHV0ZWQgcHJvcGVydHkga2V5cy4nXG4gICAgKTtcbiAgfVxuXG4gIHZhciBfdGVtcG9yYWxVbmRlZmluZWQgPSB7fTtcblxuICBmdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHtcbiAgICByZXR1cm4gKFxuICAgICAgX2FycmF5V2l0aEhvbGVzKGFycikgfHxcbiAgICAgIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8XG4gICAgICBfbm9uSXRlcmFibGVSZXN0KClcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXlMb29zZShhcnIsIGkpIHtcbiAgICByZXR1cm4gKFxuICAgICAgX2FycmF5V2l0aEhvbGVzKGFycikgfHxcbiAgICAgIF9pdGVyYWJsZVRvQXJyYXlMaW1pdExvb3NlKGFyciwgaSkgfHxcbiAgICAgIF9ub25JdGVyYWJsZVJlc3QoKVxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBfdG9BcnJheShhcnIpIHtcbiAgICByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgICByZXR1cm4gKFxuICAgICAgX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKylcbiAgICAgICAgYXJyMltpXSA9IGFycltpXTtcblxuICAgICAgcmV0dXJuIGFycjI7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG4gIH1cblxuICBmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgICBpZiAoXG4gICAgICBTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXIpIHx8XG4gICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaXRlcikgPT09ICdbb2JqZWN0IEFyZ3VtZW50c10nXG4gICAgKVxuICAgICAgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG4gIH1cblxuICBmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7XG4gICAgdmFyIF9hcnIgPSBbXTtcbiAgICB2YXIgX24gPSB0cnVlO1xuICAgIHZhciBfZCA9IGZhbHNlO1xuICAgIHZhciBfZSA9IHVuZGVmaW5lZDtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKFxuICAgICAgICB2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfcztcbiAgICAgICAgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7XG4gICAgICAgIF9uID0gdHJ1ZVxuICAgICAgKSB7XG4gICAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG5cbiAgICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2QgPSB0cnVlO1xuICAgICAgX2UgPSBlcnI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghX24gJiYgX2lbJ3JldHVybiddICE9IG51bGwpIF9pWydyZXR1cm4nXSgpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gX2FycjtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdExvb3NlKGFyciwgaSkge1xuICAgIHZhciBfYXJyID0gW107XG5cbiAgICBmb3IgKFxuICAgICAgdmFyIF9pdGVyYXRvciA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwO1xuICAgICAgIShfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmU7XG5cbiAgICApIHtcbiAgICAgIF9hcnIucHVzaChfc3RlcC52YWx1ZSk7XG5cbiAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gX2FycjtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZScpO1xuICB9XG5cbiAgZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlJyk7XG4gIH1cblxuICBmdW5jdGlvbiBfc2tpcEZpcnN0R2VuZXJhdG9yTmV4dChmbikge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpdCA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBpdC5uZXh0KCk7XG4gICAgICByZXR1cm4gaXQ7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdvYmplY3QnIHx8IGlucHV0ID09PSBudWxsKSByZXR1cm4gaW5wdXQ7XG4gICAgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdO1xuXG4gICAgaWYgKHByaW0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIHJlcyA9IHByaW0uY2FsbChpbnB1dCwgaGludCB8fCAnZGVmYXVsdCcpO1xuICAgICAgaWYgKHR5cGVvZiByZXMgIT09ICdvYmplY3QnKSByZXR1cm4gcmVzO1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKGhpbnQgPT09ICdzdHJpbmcnID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7XG4gIH1cblxuICBmdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHtcbiAgICB2YXIga2V5ID0gX3RvUHJpbWl0aXZlKGFyZywgJ3N0cmluZycpO1xuXG4gICAgcmV0dXJuIHR5cGVvZiBrZXkgPT09ICdzeW1ib2wnID8ga2V5IDogU3RyaW5nKGtleSk7XG4gIH1cblxuICBmdW5jdGlvbiBfaW5pdGlhbGl6ZXJXYXJuaW5nSGVscGVyKGRlc2NyaXB0b3IsIGNvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnRGVjb3JhdGluZyBjbGFzcyBwcm9wZXJ0eSBmYWlsZWQuIFBsZWFzZSBlbnN1cmUgdGhhdCAnICtcbiAgICAgICAgJ3Byb3Bvc2FsLWNsYXNzLXByb3BlcnRpZXMgaXMgZW5hYmxlZCBhbmQgc2V0IHRvIHVzZSBsb29zZSBtb2RlLiAnICtcbiAgICAgICAgJ1RvIHVzZSBwcm9wb3NhbC1jbGFzcy1wcm9wZXJ0aWVzIGluIHNwZWMgbW9kZSB3aXRoIGRlY29yYXRvcnMsIHdhaXQgZm9yICcgK1xuICAgICAgICAndGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBkZWNvcmF0b3JzIGluIHN0YWdlIDIuJ1xuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBfaW5pdGlhbGl6ZXJEZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5LCBkZXNjcmlwdG9yLCBjb250ZXh0KSB7XG4gICAgaWYgKCFkZXNjcmlwdG9yKSByZXR1cm47XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHksIHtcbiAgICAgIGVudW1lcmFibGU6IGRlc2NyaXB0b3IuZW51bWVyYWJsZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogZGVzY3JpcHRvci5jb25maWd1cmFibGUsXG4gICAgICB3cml0YWJsZTogZGVzY3JpcHRvci53cml0YWJsZSxcbiAgICAgIHZhbHVlOiBkZXNjcmlwdG9yLmluaXRpYWxpemVyXG4gICAgICAgID8gZGVzY3JpcHRvci5pbml0aWFsaXplci5jYWxsKGNvbnRleHQpXG4gICAgICAgIDogdm9pZCAwXG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKFxuICAgIHRhcmdldCxcbiAgICBwcm9wZXJ0eSxcbiAgICBkZWNvcmF0b3JzLFxuICAgIGRlc2NyaXB0b3IsXG4gICAgY29udGV4dFxuICApIHtcbiAgICB2YXIgZGVzYyA9IHt9O1xuICAgIE9iamVjdC5rZXlzKGRlc2NyaXB0b3IpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICBkZXNjW2tleV0gPSBkZXNjcmlwdG9yW2tleV07XG4gICAgfSk7XG4gICAgZGVzYy5lbnVtZXJhYmxlID0gISFkZXNjLmVudW1lcmFibGU7XG4gICAgZGVzYy5jb25maWd1cmFibGUgPSAhIWRlc2MuY29uZmlndXJhYmxlO1xuXG4gICAgaWYgKCd2YWx1ZScgaW4gZGVzYyB8fCBkZXNjLmluaXRpYWxpemVyKSB7XG4gICAgICBkZXNjLndyaXRhYmxlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBkZXNjID0gZGVjb3JhdG9yc1xuICAgICAgLnNsaWNlKClcbiAgICAgIC5yZXZlcnNlKClcbiAgICAgIC5yZWR1Y2UoZnVuY3Rpb24oZGVzYywgZGVjb3JhdG9yKSB7XG4gICAgICAgIHJldHVybiBkZWNvcmF0b3IodGFyZ2V0LCBwcm9wZXJ0eSwgZGVzYykgfHwgZGVzYztcbiAgICAgIH0sIGRlc2MpO1xuXG4gICAgaWYgKGNvbnRleHQgJiYgZGVzYy5pbml0aWFsaXplciAhPT0gdm9pZCAwKSB7XG4gICAgICBkZXNjLnZhbHVlID0gZGVzYy5pbml0aWFsaXplciA/IGRlc2MuaW5pdGlhbGl6ZXIuY2FsbChjb250ZXh0KSA6IHZvaWQgMDtcbiAgICAgIGRlc2MuaW5pdGlhbGl6ZXIgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKGRlc2MuaW5pdGlhbGl6ZXIgPT09IHZvaWQgMCkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHksIGRlc2MpO1xuICAgICAgZGVzYyA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlc2M7XG4gIH1cblxuICB2YXIgaWQgPSAwO1xuXG4gIGZ1bmN0aW9uIF9jbGFzc1ByaXZhdGVGaWVsZExvb3NlS2V5KG5hbWUpIHtcbiAgICByZXR1cm4gJ19fcHJpdmF0ZV8nICsgaWQrKyArICdfJyArIG5hbWU7XG4gIH1cblxuICBmdW5jdGlvbiBfY2xhc3NQcml2YXRlRmllbGRMb29zZUJhc2UocmVjZWl2ZXIsIHByaXZhdGVLZXkpIHtcbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyZWNlaXZlciwgcHJpdmF0ZUtleSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2F0dGVtcHRlZCB0byB1c2UgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2UnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVjZWl2ZXI7XG4gIH1cblxuICBmdW5jdGlvbiBfY2xhc3NQcml2YXRlRmllbGRHZXQocmVjZWl2ZXIsIHByaXZhdGVNYXApIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByaXZhdGVNYXAuZ2V0KHJlY2VpdmVyKTtcblxuICAgIGlmICghZGVzY3JpcHRvcikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXR0ZW1wdGVkIHRvIGdldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZScpO1xuICAgIH1cblxuICAgIGlmIChkZXNjcmlwdG9yLmdldCkge1xuICAgICAgcmV0dXJuIGRlc2NyaXB0b3IuZ2V0LmNhbGwocmVjZWl2ZXIpO1xuICAgIH1cblxuICAgIHJldHVybiBkZXNjcmlwdG9yLnZhbHVlO1xuICB9XG5cbiAgZnVuY3Rpb24gX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHJlY2VpdmVyLCBwcml2YXRlTWFwLCB2YWx1ZSkge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJpdmF0ZU1hcC5nZXQocmVjZWl2ZXIpO1xuXG4gICAgaWYgKCFkZXNjcmlwdG9yKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhdHRlbXB0ZWQgdG8gc2V0IHByaXZhdGUgZmllbGQgb24gbm9uLWluc3RhbmNlJyk7XG4gICAgfVxuXG4gICAgaWYgKGRlc2NyaXB0b3Iuc2V0KSB7XG4gICAgICBkZXNjcmlwdG9yLnNldC5jYWxsKHJlY2VpdmVyLCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghZGVzY3JpcHRvci53cml0YWJsZSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhdHRlbXB0ZWQgdG8gc2V0IHJlYWQgb25seSBwcml2YXRlIGZpZWxkJyk7XG4gICAgICB9XG5cbiAgICAgIGRlc2NyaXB0b3IudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBmdW5jdGlvbiBfY2xhc3NQcml2YXRlRmllbGREZXN0cnVjdHVyZVNldChyZWNlaXZlciwgcHJpdmF0ZU1hcCkge1xuICAgIGlmICghcHJpdmF0ZU1hcC5oYXMocmVjZWl2ZXIpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhdHRlbXB0ZWQgdG8gc2V0IHByaXZhdGUgZmllbGQgb24gbm9uLWluc3RhbmNlJyk7XG4gICAgfVxuXG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcml2YXRlTWFwLmdldChyZWNlaXZlcik7XG5cbiAgICBpZiAoZGVzY3JpcHRvci5zZXQpIHtcbiAgICAgIGlmICghKCdfX2Rlc3RyT2JqJyBpbiBkZXNjcmlwdG9yKSkge1xuICAgICAgICBkZXNjcmlwdG9yLl9fZGVzdHJPYmogPSB7XG4gICAgICAgICAgc2V0IHZhbHVlKHYpIHtcbiAgICAgICAgICAgIGRlc2NyaXB0b3Iuc2V0LmNhbGwocmVjZWl2ZXIsIHYpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRlc2NyaXB0b3IuX19kZXN0ck9iajtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFkZXNjcmlwdG9yLndyaXRhYmxlKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2F0dGVtcHRlZCB0byBzZXQgcmVhZCBvbmx5IHByaXZhdGUgZmllbGQnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRlc2NyaXB0b3I7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX2NsYXNzU3RhdGljUHJpdmF0ZUZpZWxkU3BlY0dldChcbiAgICByZWNlaXZlcixcbiAgICBjbGFzc0NvbnN0cnVjdG9yLFxuICAgIGRlc2NyaXB0b3JcbiAgKSB7XG4gICAgaWYgKHJlY2VpdmVyICE9PSBjbGFzc0NvbnN0cnVjdG9yKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQcml2YXRlIHN0YXRpYyBhY2Nlc3Mgb2Ygd3JvbmcgcHJvdmVuYW5jZScpO1xuICAgIH1cblxuICAgIHJldHVybiBkZXNjcmlwdG9yLnZhbHVlO1xuICB9XG5cbiAgZnVuY3Rpb24gX2NsYXNzU3RhdGljUHJpdmF0ZUZpZWxkU3BlY1NldChcbiAgICByZWNlaXZlcixcbiAgICBjbGFzc0NvbnN0cnVjdG9yLFxuICAgIGRlc2NyaXB0b3IsXG4gICAgdmFsdWVcbiAgKSB7XG4gICAgaWYgKHJlY2VpdmVyICE9PSBjbGFzc0NvbnN0cnVjdG9yKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQcml2YXRlIHN0YXRpYyBhY2Nlc3Mgb2Ygd3JvbmcgcHJvdmVuYW5jZScpO1xuICAgIH1cblxuICAgIGlmICghZGVzY3JpcHRvci53cml0YWJsZSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXR0ZW1wdGVkIHRvIHNldCByZWFkIG9ubHkgcHJpdmF0ZSBmaWVsZCcpO1xuICAgIH1cblxuICAgIGRlc2NyaXB0b3IudmFsdWUgPSB2YWx1ZTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBmdW5jdGlvbiBfY2xhc3NTdGF0aWNQcml2YXRlTWV0aG9kR2V0KHJlY2VpdmVyLCBjbGFzc0NvbnN0cnVjdG9yLCBtZXRob2QpIHtcbiAgICBpZiAocmVjZWl2ZXIgIT09IGNsYXNzQ29uc3RydWN0b3IpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1ByaXZhdGUgc3RhdGljIGFjY2VzcyBvZiB3cm9uZyBwcm92ZW5hbmNlJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1ldGhvZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc1N0YXRpY1ByaXZhdGVNZXRob2RTZXQoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXR0ZW1wdGVkIHRvIHNldCByZWFkIG9ubHkgc3RhdGljIHByaXZhdGUgZmllbGQnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9kZWNvcmF0ZShkZWNvcmF0b3JzLCBmYWN0b3J5LCBzdXBlckNsYXNzLCBtaXhpbnMpIHtcbiAgICB2YXIgYXBpID0gX2dldERlY29yYXRvcnNBcGkoKTtcblxuICAgIGlmIChtaXhpbnMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWl4aW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFwaSA9IG1peGluc1tpXShhcGkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByID0gZmFjdG9yeShmdW5jdGlvbiBpbml0aWFsaXplKE8pIHtcbiAgICAgIGFwaS5pbml0aWFsaXplSW5zdGFuY2VFbGVtZW50cyhPLCBkZWNvcmF0ZWQuZWxlbWVudHMpO1xuICAgIH0sIHN1cGVyQ2xhc3MpO1xuICAgIHZhciBkZWNvcmF0ZWQgPSBhcGkuZGVjb3JhdGVDbGFzcyhcbiAgICAgIF9jb2FsZXNjZUNsYXNzRWxlbWVudHMoci5kLm1hcChfY3JlYXRlRWxlbWVudERlc2NyaXB0b3IpKSxcbiAgICAgIGRlY29yYXRvcnNcbiAgICApO1xuICAgIGFwaS5pbml0aWFsaXplQ2xhc3NFbGVtZW50cyhyLkYsIGRlY29yYXRlZC5lbGVtZW50cyk7XG4gICAgcmV0dXJuIGFwaS5ydW5DbGFzc0ZpbmlzaGVycyhyLkYsIGRlY29yYXRlZC5maW5pc2hlcnMpO1xuICB9XG5cbiAgZnVuY3Rpb24gX2dldERlY29yYXRvcnNBcGkoKSB7XG4gICAgX2dldERlY29yYXRvcnNBcGkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBhcGk7XG4gICAgfTtcblxuICAgIHZhciBhcGkgPSB7XG4gICAgICBlbGVtZW50c0RlZmluaXRpb25PcmRlcjogW1snbWV0aG9kJ10sIFsnZmllbGQnXV0sXG4gICAgICBpbml0aWFsaXplSW5zdGFuY2VFbGVtZW50czogZnVuY3Rpb24oTywgZWxlbWVudHMpIHtcbiAgICAgICAgWydtZXRob2QnLCAnZmllbGQnXS5mb3JFYWNoKGZ1bmN0aW9uKGtpbmQpIHtcbiAgICAgICAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50LmtpbmQgPT09IGtpbmQgJiYgZWxlbWVudC5wbGFjZW1lbnQgPT09ICdvd24nKSB7XG4gICAgICAgICAgICAgIHRoaXMuZGVmaW5lQ2xhc3NFbGVtZW50KE8sIGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgIH0sXG4gICAgICBpbml0aWFsaXplQ2xhc3NFbGVtZW50czogZnVuY3Rpb24oRiwgZWxlbWVudHMpIHtcbiAgICAgICAgdmFyIHByb3RvID0gRi5wcm90b3R5cGU7XG4gICAgICAgIFsnbWV0aG9kJywgJ2ZpZWxkJ10uZm9yRWFjaChmdW5jdGlvbihraW5kKSB7XG4gICAgICAgICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgcGxhY2VtZW50ID0gZWxlbWVudC5wbGFjZW1lbnQ7XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgZWxlbWVudC5raW5kID09PSBraW5kICYmXG4gICAgICAgICAgICAgIChwbGFjZW1lbnQgPT09ICdzdGF0aWMnIHx8IHBsYWNlbWVudCA9PT0gJ3Byb3RvdHlwZScpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgdmFyIHJlY2VpdmVyID0gcGxhY2VtZW50ID09PSAnc3RhdGljJyA/IEYgOiBwcm90bztcbiAgICAgICAgICAgICAgdGhpcy5kZWZpbmVDbGFzc0VsZW1lbnQocmVjZWl2ZXIsIGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgIH0sXG4gICAgICBkZWZpbmVDbGFzc0VsZW1lbnQ6IGZ1bmN0aW9uKHJlY2VpdmVyLCBlbGVtZW50KSB7XG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gZWxlbWVudC5kZXNjcmlwdG9yO1xuXG4gICAgICAgIGlmIChlbGVtZW50LmtpbmQgPT09ICdmaWVsZCcpIHtcbiAgICAgICAgICB2YXIgaW5pdGlhbGl6ZXIgPSBlbGVtZW50LmluaXRpYWxpemVyO1xuICAgICAgICAgIGRlc2NyaXB0b3IgPSB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBkZXNjcmlwdG9yLmVudW1lcmFibGUsXG4gICAgICAgICAgICB3cml0YWJsZTogZGVzY3JpcHRvci53cml0YWJsZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZGVzY3JpcHRvci5jb25maWd1cmFibGUsXG4gICAgICAgICAgICB2YWx1ZTogaW5pdGlhbGl6ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluaXRpYWxpemVyLmNhbGwocmVjZWl2ZXIpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZWNlaXZlciwgZWxlbWVudC5rZXksIGRlc2NyaXB0b3IpO1xuICAgICAgfSxcbiAgICAgIGRlY29yYXRlQ2xhc3M6IGZ1bmN0aW9uKGVsZW1lbnRzLCBkZWNvcmF0b3JzKSB7XG4gICAgICAgIHZhciBuZXdFbGVtZW50cyA9IFtdO1xuICAgICAgICB2YXIgZmluaXNoZXJzID0gW107XG4gICAgICAgIHZhciBwbGFjZW1lbnRzID0ge1xuICAgICAgICAgIHN0YXRpYzogW10sXG4gICAgICAgICAgcHJvdG90eXBlOiBbXSxcbiAgICAgICAgICBvd246IFtdXG4gICAgICAgIH07XG4gICAgICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgIHRoaXMuYWRkRWxlbWVudFBsYWNlbWVudChlbGVtZW50LCBwbGFjZW1lbnRzKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgIGlmICghX2hhc0RlY29yYXRvcnMoZWxlbWVudCkpIHJldHVybiBuZXdFbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgIHZhciBlbGVtZW50RmluaXNoZXJzRXh0cmFzID0gdGhpcy5kZWNvcmF0ZUVsZW1lbnQoXG4gICAgICAgICAgICBlbGVtZW50LFxuICAgICAgICAgICAgcGxhY2VtZW50c1xuICAgICAgICAgICk7XG4gICAgICAgICAgbmV3RWxlbWVudHMucHVzaChlbGVtZW50RmluaXNoZXJzRXh0cmFzLmVsZW1lbnQpO1xuICAgICAgICAgIG5ld0VsZW1lbnRzLnB1c2guYXBwbHkobmV3RWxlbWVudHMsIGVsZW1lbnRGaW5pc2hlcnNFeHRyYXMuZXh0cmFzKTtcbiAgICAgICAgICBmaW5pc2hlcnMucHVzaC5hcHBseShmaW5pc2hlcnMsIGVsZW1lbnRGaW5pc2hlcnNFeHRyYXMuZmluaXNoZXJzKTtcbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgaWYgKCFkZWNvcmF0b3JzKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVsZW1lbnRzOiBuZXdFbGVtZW50cyxcbiAgICAgICAgICAgIGZpbmlzaGVyczogZmluaXNoZXJzXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmRlY29yYXRlQ29uc3RydWN0b3IobmV3RWxlbWVudHMsIGRlY29yYXRvcnMpO1xuICAgICAgICBmaW5pc2hlcnMucHVzaC5hcHBseShmaW5pc2hlcnMsIHJlc3VsdC5maW5pc2hlcnMpO1xuICAgICAgICByZXN1bHQuZmluaXNoZXJzID0gZmluaXNoZXJzO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSxcbiAgICAgIGFkZEVsZW1lbnRQbGFjZW1lbnQ6IGZ1bmN0aW9uKGVsZW1lbnQsIHBsYWNlbWVudHMsIHNpbGVudCkge1xuICAgICAgICB2YXIga2V5cyA9IHBsYWNlbWVudHNbZWxlbWVudC5wbGFjZW1lbnRdO1xuXG4gICAgICAgIGlmICghc2lsZW50ICYmIGtleXMuaW5kZXhPZihlbGVtZW50LmtleSkgIT09IC0xKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRHVwbGljYXRlZCBlbGVtZW50ICgnICsgZWxlbWVudC5rZXkgKyAnKScpO1xuICAgICAgICB9XG5cbiAgICAgICAga2V5cy5wdXNoKGVsZW1lbnQua2V5KTtcbiAgICAgIH0sXG4gICAgICBkZWNvcmF0ZUVsZW1lbnQ6IGZ1bmN0aW9uKGVsZW1lbnQsIHBsYWNlbWVudHMpIHtcbiAgICAgICAgdmFyIGV4dHJhcyA9IFtdO1xuICAgICAgICB2YXIgZmluaXNoZXJzID0gW107XG5cbiAgICAgICAgZm9yIChcbiAgICAgICAgICB2YXIgZGVjb3JhdG9ycyA9IGVsZW1lbnQuZGVjb3JhdG9ycywgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTtcbiAgICAgICAgICBpID49IDA7XG4gICAgICAgICAgaS0tXG4gICAgICAgICkge1xuICAgICAgICAgIHZhciBrZXlzID0gcGxhY2VtZW50c1tlbGVtZW50LnBsYWNlbWVudF07XG4gICAgICAgICAga2V5cy5zcGxpY2Uoa2V5cy5pbmRleE9mKGVsZW1lbnQua2V5KSwgMSk7XG4gICAgICAgICAgdmFyIGVsZW1lbnRPYmplY3QgPSB0aGlzLmZyb21FbGVtZW50RGVzY3JpcHRvcihlbGVtZW50KTtcbiAgICAgICAgICB2YXIgZWxlbWVudEZpbmlzaGVyRXh0cmFzID0gdGhpcy50b0VsZW1lbnRGaW5pc2hlckV4dHJhcyhcbiAgICAgICAgICAgICgwLCBkZWNvcmF0b3JzW2ldKShlbGVtZW50T2JqZWN0KSB8fCBlbGVtZW50T2JqZWN0XG4gICAgICAgICAgKTtcbiAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudEZpbmlzaGVyRXh0cmFzLmVsZW1lbnQ7XG4gICAgICAgICAgdGhpcy5hZGRFbGVtZW50UGxhY2VtZW50KGVsZW1lbnQsIHBsYWNlbWVudHMpO1xuXG4gICAgICAgICAgaWYgKGVsZW1lbnRGaW5pc2hlckV4dHJhcy5maW5pc2hlcikge1xuICAgICAgICAgICAgZmluaXNoZXJzLnB1c2goZWxlbWVudEZpbmlzaGVyRXh0cmFzLmZpbmlzaGVyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgbmV3RXh0cmFzID0gZWxlbWVudEZpbmlzaGVyRXh0cmFzLmV4dHJhcztcblxuICAgICAgICAgIGlmIChuZXdFeHRyYXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbmV3RXh0cmFzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgIHRoaXMuYWRkRWxlbWVudFBsYWNlbWVudChuZXdFeHRyYXNbal0sIHBsYWNlbWVudHMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBleHRyYXMucHVzaC5hcHBseShleHRyYXMsIG5ld0V4dHJhcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgICAgIGZpbmlzaGVyczogZmluaXNoZXJzLFxuICAgICAgICAgIGV4dHJhczogZXh0cmFzXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgZGVjb3JhdGVDb25zdHJ1Y3RvcjogZnVuY3Rpb24oZWxlbWVudHMsIGRlY29yYXRvcnMpIHtcbiAgICAgICAgdmFyIGZpbmlzaGVycyA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdmFyIG9iaiA9IHRoaXMuZnJvbUNsYXNzRGVzY3JpcHRvcihlbGVtZW50cyk7XG4gICAgICAgICAgdmFyIGVsZW1lbnRzQW5kRmluaXNoZXIgPSB0aGlzLnRvQ2xhc3NEZXNjcmlwdG9yKFxuICAgICAgICAgICAgKDAsIGRlY29yYXRvcnNbaV0pKG9iaikgfHwgb2JqXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGlmIChlbGVtZW50c0FuZEZpbmlzaGVyLmZpbmlzaGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZpbmlzaGVycy5wdXNoKGVsZW1lbnRzQW5kRmluaXNoZXIuZmluaXNoZXIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChlbGVtZW50c0FuZEZpbmlzaGVyLmVsZW1lbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVsZW1lbnRzID0gZWxlbWVudHNBbmRGaW5pc2hlci5lbGVtZW50cztcblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBlbGVtZW50cy5sZW5ndGggLSAxOyBqKyspIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgayA9IGogKyAxOyBrIDwgZWxlbWVudHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICBlbGVtZW50c1tqXS5rZXkgPT09IGVsZW1lbnRzW2tdLmtleSAmJlxuICAgICAgICAgICAgICAgICAgZWxlbWVudHNbal0ucGxhY2VtZW50ID09PSBlbGVtZW50c1trXS5wbGFjZW1lbnRcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICdEdXBsaWNhdGVkIGVsZW1lbnQgKCcgKyBlbGVtZW50c1tqXS5rZXkgKyAnKSdcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBlbGVtZW50czogZWxlbWVudHMsXG4gICAgICAgICAgZmluaXNoZXJzOiBmaW5pc2hlcnNcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBmcm9tRWxlbWVudERlc2NyaXB0b3I6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIG9iaiA9IHtcbiAgICAgICAgICBraW5kOiBlbGVtZW50LmtpbmQsXG4gICAgICAgICAga2V5OiBlbGVtZW50LmtleSxcbiAgICAgICAgICBwbGFjZW1lbnQ6IGVsZW1lbnQucGxhY2VtZW50LFxuICAgICAgICAgIGRlc2NyaXB0b3I6IGVsZW1lbnQuZGVzY3JpcHRvclxuICAgICAgICB9O1xuICAgICAgICB2YXIgZGVzYyA9IHtcbiAgICAgICAgICB2YWx1ZTogJ0Rlc2NyaXB0b3InLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBTeW1ib2wudG9TdHJpbmdUYWcsIGRlc2MpO1xuICAgICAgICBpZiAoZWxlbWVudC5raW5kID09PSAnZmllbGQnKSBvYmouaW5pdGlhbGl6ZXIgPSBlbGVtZW50LmluaXRpYWxpemVyO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgfSxcbiAgICAgIHRvRWxlbWVudERlc2NyaXB0b3JzOiBmdW5jdGlvbihlbGVtZW50T2JqZWN0cykge1xuICAgICAgICBpZiAoZWxlbWVudE9iamVjdHMgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICAgICAgICByZXR1cm4gX3RvQXJyYXkoZWxlbWVudE9iamVjdHMpLm1hcChmdW5jdGlvbihlbGVtZW50T2JqZWN0KSB7XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLnRvRWxlbWVudERlc2NyaXB0b3IoZWxlbWVudE9iamVjdCk7XG4gICAgICAgICAgdGhpcy5kaXNhbGxvd1Byb3BlcnR5KFxuICAgICAgICAgICAgZWxlbWVudE9iamVjdCxcbiAgICAgICAgICAgICdmaW5pc2hlcicsXG4gICAgICAgICAgICAnQW4gZWxlbWVudCBkZXNjcmlwdG9yJ1xuICAgICAgICAgICk7XG4gICAgICAgICAgdGhpcy5kaXNhbGxvd1Byb3BlcnR5KFxuICAgICAgICAgICAgZWxlbWVudE9iamVjdCxcbiAgICAgICAgICAgICdleHRyYXMnLFxuICAgICAgICAgICAgJ0FuIGVsZW1lbnQgZGVzY3JpcHRvcidcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgIH0sXG4gICAgICB0b0VsZW1lbnREZXNjcmlwdG9yOiBmdW5jdGlvbihlbGVtZW50T2JqZWN0KSB7XG4gICAgICAgIHZhciBraW5kID0gU3RyaW5nKGVsZW1lbnRPYmplY3Qua2luZCk7XG5cbiAgICAgICAgaWYgKGtpbmQgIT09ICdtZXRob2QnICYmIGtpbmQgIT09ICdmaWVsZCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgJ0FuIGVsZW1lbnQgZGVzY3JpcHRvclxcJ3MgLmtpbmQgcHJvcGVydHkgbXVzdCBiZSBlaXRoZXIgXCJtZXRob2RcIiBvcicgK1xuICAgICAgICAgICAgICAnIFwiZmllbGRcIiwgYnV0IGEgZGVjb3JhdG9yIGNyZWF0ZWQgYW4gZWxlbWVudCBkZXNjcmlwdG9yIHdpdGgnICtcbiAgICAgICAgICAgICAgJyAua2luZCBcIicgK1xuICAgICAgICAgICAgICBraW5kICtcbiAgICAgICAgICAgICAgJ1wiJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIga2V5ID0gX3RvUHJvcGVydHlLZXkoZWxlbWVudE9iamVjdC5rZXkpO1xuXG4gICAgICAgIHZhciBwbGFjZW1lbnQgPSBTdHJpbmcoZWxlbWVudE9iamVjdC5wbGFjZW1lbnQpO1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgICBwbGFjZW1lbnQgIT09ICdzdGF0aWMnICYmXG4gICAgICAgICAgcGxhY2VtZW50ICE9PSAncHJvdG90eXBlJyAmJlxuICAgICAgICAgIHBsYWNlbWVudCAhPT0gJ293bidcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICdBbiBlbGVtZW50IGRlc2NyaXB0b3JcXCdzIC5wbGFjZW1lbnQgcHJvcGVydHkgbXVzdCBiZSBvbmUgb2YgXCJzdGF0aWNcIiwnICtcbiAgICAgICAgICAgICAgJyBcInByb3RvdHlwZVwiIG9yIFwib3duXCIsIGJ1dCBhIGRlY29yYXRvciBjcmVhdGVkIGFuIGVsZW1lbnQgZGVzY3JpcHRvcicgK1xuICAgICAgICAgICAgICAnIHdpdGggLnBsYWNlbWVudCBcIicgK1xuICAgICAgICAgICAgICBwbGFjZW1lbnQgK1xuICAgICAgICAgICAgICAnXCInXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gZWxlbWVudE9iamVjdC5kZXNjcmlwdG9yO1xuICAgICAgICB0aGlzLmRpc2FsbG93UHJvcGVydHkoXG4gICAgICAgICAgZWxlbWVudE9iamVjdCxcbiAgICAgICAgICAnZWxlbWVudHMnLFxuICAgICAgICAgICdBbiBlbGVtZW50IGRlc2NyaXB0b3InXG4gICAgICAgICk7XG4gICAgICAgIHZhciBlbGVtZW50ID0ge1xuICAgICAgICAgIGtpbmQ6IGtpbmQsXG4gICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICAgICAgZGVzY3JpcHRvcjogT2JqZWN0LmFzc2lnbih7fSwgZGVzY3JpcHRvcilcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoa2luZCAhPT0gJ2ZpZWxkJykge1xuICAgICAgICAgIHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShcbiAgICAgICAgICAgIGVsZW1lbnRPYmplY3QsXG4gICAgICAgICAgICAnaW5pdGlhbGl6ZXInLFxuICAgICAgICAgICAgJ0EgbWV0aG9kIGRlc2NyaXB0b3InXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmRpc2FsbG93UHJvcGVydHkoXG4gICAgICAgICAgICBkZXNjcmlwdG9yLFxuICAgICAgICAgICAgJ2dldCcsXG4gICAgICAgICAgICAnVGhlIHByb3BlcnR5IGRlc2NyaXB0b3Igb2YgYSBmaWVsZCBkZXNjcmlwdG9yJ1xuICAgICAgICAgICk7XG4gICAgICAgICAgdGhpcy5kaXNhbGxvd1Byb3BlcnR5KFxuICAgICAgICAgICAgZGVzY3JpcHRvcixcbiAgICAgICAgICAgICdzZXQnLFxuICAgICAgICAgICAgJ1RoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yIG9mIGEgZmllbGQgZGVzY3JpcHRvcidcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShcbiAgICAgICAgICAgIGRlc2NyaXB0b3IsXG4gICAgICAgICAgICAndmFsdWUnLFxuICAgICAgICAgICAgJ1RoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yIG9mIGEgZmllbGQgZGVzY3JpcHRvcidcbiAgICAgICAgICApO1xuICAgICAgICAgIGVsZW1lbnQuaW5pdGlhbGl6ZXIgPSBlbGVtZW50T2JqZWN0LmluaXRpYWxpemVyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICB9LFxuICAgICAgdG9FbGVtZW50RmluaXNoZXJFeHRyYXM6IGZ1bmN0aW9uKGVsZW1lbnRPYmplY3QpIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLnRvRWxlbWVudERlc2NyaXB0b3IoZWxlbWVudE9iamVjdCk7XG5cbiAgICAgICAgdmFyIGZpbmlzaGVyID0gX29wdGlvbmFsQ2FsbGFibGVQcm9wZXJ0eShlbGVtZW50T2JqZWN0LCAnZmluaXNoZXInKTtcblxuICAgICAgICB2YXIgZXh0cmFzID0gdGhpcy50b0VsZW1lbnREZXNjcmlwdG9ycyhlbGVtZW50T2JqZWN0LmV4dHJhcyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgICBmaW5pc2hlcjogZmluaXNoZXIsXG4gICAgICAgICAgZXh0cmFzOiBleHRyYXNcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBmcm9tQ2xhc3NEZXNjcmlwdG9yOiBmdW5jdGlvbihlbGVtZW50cykge1xuICAgICAgICB2YXIgb2JqID0ge1xuICAgICAgICAgIGtpbmQ6ICdjbGFzcycsXG4gICAgICAgICAgZWxlbWVudHM6IGVsZW1lbnRzLm1hcCh0aGlzLmZyb21FbGVtZW50RGVzY3JpcHRvciwgdGhpcylcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGRlc2MgPSB7XG4gICAgICAgICAgdmFsdWU6ICdEZXNjcmlwdG9yJyxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgU3ltYm9sLnRvU3RyaW5nVGFnLCBkZXNjKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgIH0sXG4gICAgICB0b0NsYXNzRGVzY3JpcHRvcjogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHZhciBraW5kID0gU3RyaW5nKG9iai5raW5kKTtcblxuICAgICAgICBpZiAoa2luZCAhPT0gJ2NsYXNzJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAnQSBjbGFzcyBkZXNjcmlwdG9yXFwncyAua2luZCBwcm9wZXJ0eSBtdXN0IGJlIFwiY2xhc3NcIiwgYnV0IGEgZGVjb3JhdG9yJyArXG4gICAgICAgICAgICAgICcgY3JlYXRlZCBhIGNsYXNzIGRlc2NyaXB0b3Igd2l0aCAua2luZCBcIicgK1xuICAgICAgICAgICAgICBraW5kICtcbiAgICAgICAgICAgICAgJ1wiJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRpc2FsbG93UHJvcGVydHkob2JqLCAna2V5JywgJ0EgY2xhc3MgZGVzY3JpcHRvcicpO1xuICAgICAgICB0aGlzLmRpc2FsbG93UHJvcGVydHkob2JqLCAncGxhY2VtZW50JywgJ0EgY2xhc3MgZGVzY3JpcHRvcicpO1xuICAgICAgICB0aGlzLmRpc2FsbG93UHJvcGVydHkob2JqLCAnZGVzY3JpcHRvcicsICdBIGNsYXNzIGRlc2NyaXB0b3InKTtcbiAgICAgICAgdGhpcy5kaXNhbGxvd1Byb3BlcnR5KG9iaiwgJ2luaXRpYWxpemVyJywgJ0EgY2xhc3MgZGVzY3JpcHRvcicpO1xuICAgICAgICB0aGlzLmRpc2FsbG93UHJvcGVydHkob2JqLCAnZXh0cmFzJywgJ0EgY2xhc3MgZGVzY3JpcHRvcicpO1xuXG4gICAgICAgIHZhciBmaW5pc2hlciA9IF9vcHRpb25hbENhbGxhYmxlUHJvcGVydHkob2JqLCAnZmluaXNoZXInKTtcblxuICAgICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLnRvRWxlbWVudERlc2NyaXB0b3JzKG9iai5lbGVtZW50cyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZWxlbWVudHM6IGVsZW1lbnRzLFxuICAgICAgICAgIGZpbmlzaGVyOiBmaW5pc2hlclxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHJ1bkNsYXNzRmluaXNoZXJzOiBmdW5jdGlvbihjb25zdHJ1Y3RvciwgZmluaXNoZXJzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmluaXNoZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIG5ld0NvbnN0cnVjdG9yID0gKDAsIGZpbmlzaGVyc1tpXSkoY29uc3RydWN0b3IpO1xuXG4gICAgICAgICAgaWYgKG5ld0NvbnN0cnVjdG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmV3Q29uc3RydWN0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmluaXNoZXJzIG11c3QgcmV0dXJuIGEgY29uc3RydWN0b3IuJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0cnVjdG9yID0gbmV3Q29uc3RydWN0b3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yO1xuICAgICAgfSxcbiAgICAgIGRpc2FsbG93UHJvcGVydHk6IGZ1bmN0aW9uKG9iaiwgbmFtZSwgb2JqZWN0VHlwZSkge1xuICAgICAgICBpZiAob2JqW25hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgb2JqZWN0VHlwZSArIFwiIGNhbid0IGhhdmUgYSAuXCIgKyBuYW1lICsgJyBwcm9wZXJ0eS4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGFwaTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9jcmVhdGVFbGVtZW50RGVzY3JpcHRvcihkZWYpIHtcbiAgICB2YXIga2V5ID0gX3RvUHJvcGVydHlLZXkoZGVmLmtleSk7XG5cbiAgICB2YXIgZGVzY3JpcHRvcjtcblxuICAgIGlmIChkZWYua2luZCA9PT0gJ21ldGhvZCcpIHtcbiAgICAgIGRlc2NyaXB0b3IgPSB7XG4gICAgICAgIHZhbHVlOiBkZWYudmFsdWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoZGVmLmtpbmQgPT09ICdnZXQnKSB7XG4gICAgICBkZXNjcmlwdG9yID0ge1xuICAgICAgICBnZXQ6IGRlZi52YWx1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGRlZi5raW5kID09PSAnc2V0Jykge1xuICAgICAgZGVzY3JpcHRvciA9IHtcbiAgICAgICAgc2V0OiBkZWYudmFsdWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChkZWYua2luZCA9PT0gJ2ZpZWxkJykge1xuICAgICAgZGVzY3JpcHRvciA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudCA9IHtcbiAgICAgIGtpbmQ6IGRlZi5raW5kID09PSAnZmllbGQnID8gJ2ZpZWxkJyA6ICdtZXRob2QnLFxuICAgICAga2V5OiBrZXksXG4gICAgICBwbGFjZW1lbnQ6IGRlZi5zdGF0aWNcbiAgICAgICAgPyAnc3RhdGljJ1xuICAgICAgICA6IGRlZi5raW5kID09PSAnZmllbGQnXG4gICAgICAgID8gJ293bidcbiAgICAgICAgOiAncHJvdG90eXBlJyxcbiAgICAgIGRlc2NyaXB0b3I6IGRlc2NyaXB0b3JcbiAgICB9O1xuICAgIGlmIChkZWYuZGVjb3JhdG9ycykgZWxlbWVudC5kZWNvcmF0b3JzID0gZGVmLmRlY29yYXRvcnM7XG4gICAgaWYgKGRlZi5raW5kID09PSAnZmllbGQnKSBlbGVtZW50LmluaXRpYWxpemVyID0gZGVmLnZhbHVlO1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgZnVuY3Rpb24gX2NvYWxlc2NlR2V0dGVyU2V0dGVyKGVsZW1lbnQsIG90aGVyKSB7XG4gICAgaWYgKGVsZW1lbnQuZGVzY3JpcHRvci5nZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgb3RoZXIuZGVzY3JpcHRvci5nZXQgPSBlbGVtZW50LmRlc2NyaXB0b3IuZ2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICBvdGhlci5kZXNjcmlwdG9yLnNldCA9IGVsZW1lbnQuZGVzY3JpcHRvci5zZXQ7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX2NvYWxlc2NlQ2xhc3NFbGVtZW50cyhlbGVtZW50cykge1xuICAgIHZhciBuZXdFbGVtZW50cyA9IFtdO1xuXG4gICAgdmFyIGlzU2FtZUVsZW1lbnQgPSBmdW5jdGlvbihvdGhlcikge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgb3RoZXIua2luZCA9PT0gJ21ldGhvZCcgJiZcbiAgICAgICAgb3RoZXIua2V5ID09PSBlbGVtZW50LmtleSAmJlxuICAgICAgICBvdGhlci5wbGFjZW1lbnQgPT09IGVsZW1lbnQucGxhY2VtZW50XG4gICAgICApO1xuICAgIH07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IGVsZW1lbnRzW2ldO1xuICAgICAgdmFyIG90aGVyO1xuXG4gICAgICBpZiAoXG4gICAgICAgIGVsZW1lbnQua2luZCA9PT0gJ21ldGhvZCcgJiZcbiAgICAgICAgKG90aGVyID0gbmV3RWxlbWVudHMuZmluZChpc1NhbWVFbGVtZW50KSlcbiAgICAgICkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgX2lzRGF0YURlc2NyaXB0b3IoZWxlbWVudC5kZXNjcmlwdG9yKSB8fFxuICAgICAgICAgIF9pc0RhdGFEZXNjcmlwdG9yKG90aGVyLmRlc2NyaXB0b3IpXG4gICAgICAgICkge1xuICAgICAgICAgIGlmIChfaGFzRGVjb3JhdG9ycyhlbGVtZW50KSB8fCBfaGFzRGVjb3JhdG9ycyhvdGhlcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcbiAgICAgICAgICAgICAgJ0R1cGxpY2F0ZWQgbWV0aG9kcyAoJyArIGVsZW1lbnQua2V5ICsgXCIpIGNhbid0IGJlIGRlY29yYXRlZC5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBvdGhlci5kZXNjcmlwdG9yID0gZWxlbWVudC5kZXNjcmlwdG9yO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChfaGFzRGVjb3JhdG9ycyhlbGVtZW50KSkge1xuICAgICAgICAgICAgaWYgKF9oYXNEZWNvcmF0b3JzKG90aGVyKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJEZWNvcmF0b3JzIGNhbid0IGJlIHBsYWNlZCBvbiBkaWZmZXJlbnQgYWNjZXNzb3JzIHdpdGggZm9yIFwiICtcbiAgICAgICAgICAgICAgICAgICd0aGUgc2FtZSBwcm9wZXJ0eSAoJyArXG4gICAgICAgICAgICAgICAgICBlbGVtZW50LmtleSArXG4gICAgICAgICAgICAgICAgICAnKS4nXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG90aGVyLmRlY29yYXRvcnMgPSBlbGVtZW50LmRlY29yYXRvcnM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX2NvYWxlc2NlR2V0dGVyU2V0dGVyKGVsZW1lbnQsIG90aGVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3RWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3RWxlbWVudHM7XG4gIH1cblxuICBmdW5jdGlvbiBfaGFzRGVjb3JhdG9ycyhlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuZGVjb3JhdG9ycyAmJiBlbGVtZW50LmRlY29yYXRvcnMubGVuZ3RoO1xuICB9XG5cbiAgZnVuY3Rpb24gX2lzRGF0YURlc2NyaXB0b3IoZGVzYykge1xuICAgIHJldHVybiAoXG4gICAgICBkZXNjICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICEoZGVzYy52YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGRlc2Mud3JpdGFibGUgPT09IHVuZGVmaW5lZClcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gX29wdGlvbmFsQ2FsbGFibGVQcm9wZXJ0eShvYmosIG5hbWUpIHtcbiAgICB2YXIgdmFsdWUgPSBvYmpbbmFtZV07XG5cbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCAnXCIgKyBuYW1lICsgXCInIHRvIGJlIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgZnVuY3Rpb24gX2NsYXNzUHJpdmF0ZU1ldGhvZEdldChyZWNlaXZlciwgcHJpdmF0ZVNldCwgZm4pIHtcbiAgICBpZiAoIXByaXZhdGVTZXQuaGFzKHJlY2VpdmVyKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXR0ZW1wdGVkIHRvIGdldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZScpO1xuICAgIH1cblxuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc1ByaXZhdGVNZXRob2RTZXQoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXR0ZW1wdGVkIHRvIHJlYXNzaWduIHByaXZhdGUgbWV0aG9kJyk7XG4gIH1cblxuICBmdW5jdGlvbiBfd3JhcFJlZ0V4cChyZSwgZ3JvdXBzKSB7XG4gICAgX3dyYXBSZWdFeHAgPSBmdW5jdGlvbihyZSwgZ3JvdXBzKSB7XG4gICAgICByZXR1cm4gbmV3IEJhYmVsUmVnRXhwKHJlLCBncm91cHMpO1xuICAgIH07XG5cbiAgICB2YXIgX1JlZ0V4cCA9IF93cmFwTmF0aXZlU3VwZXIoUmVnRXhwKTtcblxuICAgIHZhciBfc3VwZXIgPSBSZWdFeHAucHJvdG90eXBlO1xuXG4gICAgdmFyIF9ncm91cHMgPSBuZXcgV2Vha01hcCgpO1xuXG4gICAgZnVuY3Rpb24gQmFiZWxSZWdFeHAocmUsIGdyb3Vwcykge1xuICAgICAgdmFyIF90aGlzID0gX1JlZ0V4cC5jYWxsKHRoaXMsIHJlKTtcblxuICAgICAgX2dyb3Vwcy5zZXQoX3RoaXMsIGdyb3Vwcyk7XG5cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICBfaW5oZXJpdHMoQmFiZWxSZWdFeHAsIF9SZWdFeHApO1xuXG4gICAgQmFiZWxSZWdFeHAucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbihzdHIpIHtcbiAgICAgIHZhciByZXN1bHQgPSBfc3VwZXIuZXhlYy5jYWxsKHRoaXMsIHN0cik7XG5cbiAgICAgIGlmIChyZXN1bHQpIHJlc3VsdC5ncm91cHMgPSBidWlsZEdyb3VwcyhyZXN1bHQsIHRoaXMpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgQmFiZWxSZWdFeHAucHJvdG90eXBlW1N5bWJvbC5yZXBsYWNlXSA9IGZ1bmN0aW9uKHN0ciwgc3Vic3RpdHV0aW9uKSB7XG4gICAgICBpZiAodHlwZW9mIHN1YnN0aXR1dGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIGdyb3VwcyA9IF9ncm91cHMuZ2V0KHRoaXMpO1xuXG4gICAgICAgIHJldHVybiBfc3VwZXJbU3ltYm9sLnJlcGxhY2VdLmNhbGwoXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICBzdHIsXG4gICAgICAgICAgc3Vic3RpdHV0aW9uLnJlcGxhY2UoL1xcJDwoW14+XSspPi9nLCBmdW5jdGlvbihfLCBuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyQnICsgZ3JvdXBzW25hbWVdO1xuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzdWJzdGl0dXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICByZXR1cm4gX3N1cGVyW1N5bWJvbC5yZXBsYWNlXS5jYWxsKHRoaXMsIHN0ciwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICBhcmdzLnB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgYXJncy5wdXNoKGJ1aWxkR3JvdXBzKGFyZ3MsIF90aGlzKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHN1YnN0aXR1dGlvbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gX3N1cGVyW1N5bWJvbC5yZXBsYWNlXS5jYWxsKHRoaXMsIHN0ciwgc3Vic3RpdHV0aW9uKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gYnVpbGRHcm91cHMocmVzdWx0LCByZSkge1xuICAgICAgdmFyIGcgPSBfZ3JvdXBzLmdldChyZSk7XG5cbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyhnKS5yZWR1Y2UoZnVuY3Rpb24oZ3JvdXBzLCBuYW1lKSB7XG4gICAgICAgIGdyb3Vwc1tuYW1lXSA9IHJlc3VsdFtnW25hbWVdXTtcbiAgICAgICAgcmV0dXJuIGdyb3VwcztcbiAgICAgIH0sIE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgIH1cblxuICAgIHJldHVybiBfd3JhcFJlZ0V4cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgdmFyIGFycmF5UmVtb3ZlID0gZnVuY3Rpb24gYXJyYXlSZW1vdmUoYXJyLCBpbmRleCkge1xuICAgIHJldHVybiBhcnIuc3BsaWNlKGluZGV4LCAxKTtcbiAgfTtcblxuICB2YXIgcnVuID0gZnVuY3Rpb24gcnVuKGNiLCBzeW5jKSB7XG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIGNiKCk7XG4gICAgfSBlbHNlIGlmIChkb2N1bWVudC5oaWRkZW4pIHtcbiAgICAgIFByb21pc2UucmVzb2x2ZSgxKS50aGVuKGNiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0VGltZW91dChjYiwgMCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBvbiA9IGZ1bmN0aW9uIG9uKCkge1xuICAgIHZhciBsaXN0ZW5lcnMgPSBbXTtcbiAgICB2YXIgb2ZmID0gZnVuY3Rpb24gb2ZmKGV2ZW50LCBjYikge1xuICAgICAgYXJyYXlSZW1vdmUoXG4gICAgICAgIGxpc3RlbmVycyxcbiAgICAgICAgbGlzdGVuZXJzLmZpbmRJbmRleChmdW5jdGlvbihsaXN0ZW5lcikge1xuICAgICAgICAgIHJldHVybiBsaXN0ZW5lci5ldmVudCA9PT0gZXZlbnQgJiYgKGxpc3RlbmVyLmNiID09PSBjYiB8fCAhY2IpO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9O1xuICAgIHZhciBfZmlyZSA9IGZ1bmN0aW9uIGZpcmUoZXZlbnQsIGFyZ3MsIHN5bmMpIHtcbiAgICAgIGxpc3RlbmVyc1xuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG4gICAgICAgICAgcmV0dXJuIGxpc3RlbmVyLmV2ZW50ID09PSBldmVudDtcbiAgICAgICAgfSlcbiAgICAgICAgLm1hcChmdW5jdGlvbihsaXN0ZW5lcikge1xuICAgICAgICAgIHJldHVybiBsaXN0ZW5lci5jYjtcbiAgICAgICAgfSlcbiAgICAgICAgLmZvckVhY2goZnVuY3Rpb24oY2IpIHtcbiAgICAgICAgICByZXR1cm4gcnVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGNiLmFwcGx5KHZvaWQgMCwgX3RvQ29uc3VtYWJsZUFycmF5KGFyZ3MpKTtcbiAgICAgICAgICB9LCBzeW5jKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgZmlyZVN5bmM6IGZ1bmN0aW9uIGZpcmVTeW5jKGV2ZW50KSB7XG4gICAgICAgIGZvciAoXG4gICAgICAgICAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgICAgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksXG4gICAgICAgICAgICBfa2V5ID0gMTtcbiAgICAgICAgICBfa2V5IDwgX2xlbjtcbiAgICAgICAgICBfa2V5KytcbiAgICAgICAgKSB7XG4gICAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cbiAgICAgICAgX2ZpcmUoZXZlbnQsIGFyZ3MsIHRydWUpO1xuICAgICAgfSxcbiAgICAgIGZpcmU6IGZ1bmN0aW9uIGZpcmUoZXZlbnQpIHtcbiAgICAgICAgZm9yIChcbiAgICAgICAgICB2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgICAgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSxcbiAgICAgICAgICAgIF9rZXkyID0gMTtcbiAgICAgICAgICBfa2V5MiA8IF9sZW4yO1xuICAgICAgICAgIF9rZXkyKytcbiAgICAgICAgKSB7XG4gICAgICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgICAgfVxuICAgICAgICBfZmlyZShldmVudCwgYXJncywgZmFsc2UpO1xuICAgICAgfSxcbiAgICAgIG9uOiBmdW5jdGlvbiBvbihldmVudCwgY2IpIHtcbiAgICAgICAgbGlzdGVuZXJzLnB1c2goeyBldmVudDogZXZlbnQsIGNiOiBjYiB9KTtcbiAgICAgIH0sXG4gICAgICBvbk9uY2U6IGZ1bmN0aW9uIG9uT25jZShldmVudCwgX2NiKSB7XG4gICAgICAgIGxpc3RlbmVycy5wdXNoKHtcbiAgICAgICAgICBldmVudDogZXZlbnQsXG4gICAgICAgICAgY2I6IGZ1bmN0aW9uIGNiKCkge1xuICAgICAgICAgICAgb2ZmKGV2ZW50LCBfY2IpO1xuICAgICAgICAgICAgX2NiLmFwcGx5KHZvaWQgMCwgYXJndW1lbnRzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIG9mZjogb2ZmXG4gICAgfTtcbiAgfTtcblxuICB2YXIgY29weU9iamVjdFByb3BlcnRpZXNUb09iamVjdCA9IGZ1bmN0aW9uIGNvcHlPYmplY3RQcm9wZXJ0aWVzVG9PYmplY3QoXG4gICAgc3JjLFxuICAgIHRhcmdldCxcbiAgICBleGNsdWRlZFxuICApIHtcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzcmMpXG4gICAgICAuZmlsdGVyKGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gICAgICAgIHJldHVybiAhZXhjbHVkZWQuaW5jbHVkZXMocHJvcGVydHkpO1xuICAgICAgfSlcbiAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzcmMsIGtleSlcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICB9O1xuXG4gIHZhciBQUklWQVRFID0gW1xuICAgICdmaXJlJyxcbiAgICAncHJvY2VzcycsXG4gICAgJ3JldmVydCcsXG4gICAgJ2xvYWQnLFxuICAgICdvbicsXG4gICAgJ29mZicsXG4gICAgJ29uT25jZScsXG4gICAgJ3JldHJ5TG9hZCcsXG4gICAgJ2V4dGVuZCcsXG4gICAgJ2FyY2hpdmUnLFxuICAgICdhcmNoaXZlZCcsXG4gICAgJ3JlbGVhc2UnLFxuICAgICdyZWxlYXNlZCcsXG4gICAgJ3JlcXVlc3RQcm9jZXNzaW5nJyxcbiAgICAnZnJlZXplJ1xuICBdO1xuXG4gIHZhciBjcmVhdGVJdGVtQVBJID0gZnVuY3Rpb24gY3JlYXRlSXRlbUFQSShpdGVtKSB7XG4gICAgdmFyIGFwaSA9IHt9O1xuICAgIGNvcHlPYmplY3RQcm9wZXJ0aWVzVG9PYmplY3QoaXRlbSwgYXBpLCBQUklWQVRFKTtcbiAgICByZXR1cm4gYXBpO1xuICB9O1xuXG4gIHZhciByZW1vdmVSZWxlYXNlZEl0ZW1zID0gZnVuY3Rpb24gcmVtb3ZlUmVsZWFzZWRJdGVtcyhpdGVtcykge1xuICAgIGl0ZW1zLmZvckVhY2goZnVuY3Rpb24oaXRlbSwgaW5kZXgpIHtcbiAgICAgIGlmIChpdGVtLnJlbGVhc2VkKSB7XG4gICAgICAgIGFycmF5UmVtb3ZlKGl0ZW1zLCBpbmRleCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIEl0ZW1TdGF0dXMgPSB7XG4gICAgSU5JVDogMSxcbiAgICBJRExFOiAyLFxuICAgIFBST0NFU1NJTkdfUVVFVUVEOiA5LFxuICAgIFBST0NFU1NJTkc6IDMsXG4gICAgUFJPQ0VTU0lOR19DT01QTEVURTogNSxcbiAgICBQUk9DRVNTSU5HX0VSUk9SOiA2LFxuICAgIFBST0NFU1NJTkdfUkVWRVJUX0VSUk9SOiAxMCxcbiAgICBMT0FESU5HOiA3LFxuICAgIExPQURfRVJST1I6IDhcbiAgfTtcblxuICB2YXIgRmlsZU9yaWdpbiA9IHtcbiAgICBJTlBVVDogMSxcbiAgICBMSU1CTzogMixcbiAgICBMT0NBTDogM1xuICB9O1xuXG4gIHZhciBnZXROb25OdW1lcmljID0gZnVuY3Rpb24gZ2V0Tm9uTnVtZXJpYyhzdHIpIHtcbiAgICByZXR1cm4gL1teMC05XSsvLmV4ZWMoc3RyKTtcbiAgfTtcblxuICB2YXIgZ2V0RGVjaW1hbFNlcGFyYXRvciA9IGZ1bmN0aW9uIGdldERlY2ltYWxTZXBhcmF0b3IoKSB7XG4gICAgcmV0dXJuIGdldE5vbk51bWVyaWMoKDEuMSkudG9Mb2NhbGVTdHJpbmcoKSlbMF07XG4gIH07XG5cbiAgdmFyIGdldFRob3VzYW5kc1NlcGFyYXRvciA9IGZ1bmN0aW9uIGdldFRob3VzYW5kc1NlcGFyYXRvcigpIHtcbiAgICAvLyBBZGRlZCBmb3IgYnJvd3NlcnMgdGhhdCBkbyBub3QgcmV0dXJuIHRoZSB0aG91c2FuZHMgc2VwYXJhdG9yIChoYXBwZW5kIG9uIG5hdGl2ZSBicm93c2VyIEFuZHJvaWQgNC40LjQpXG4gICAgLy8gV2UgY2hlY2sgYWdhaW5zdCB0aGUgbm9ybWFsIHRvU3RyaW5nIG91dHB1dCBhbmQgaWYgdGhleSdyZSB0aGUgc2FtZSByZXR1cm4gYSBjb21tYSB3aGVuIGRlY2ltYWwgc2VwYXJhdG9yIGlzIGEgZG90XG4gICAgdmFyIGRlY2ltYWxTZXBhcmF0b3IgPSBnZXREZWNpbWFsU2VwYXJhdG9yKCk7XG4gICAgdmFyIHRob3VzYW5kc1N0cmluZ1dpdGhTZXBhcmF0b3IgPSAoMTAwMC4wKS50b0xvY2FsZVN0cmluZygpO1xuICAgIHZhciB0aG91c2FuZHNTdHJpbmdXaXRob3V0U2VwYXJhdG9yID0gKDEwMDAuMCkudG9TdHJpbmcoKTtcbiAgICBpZiAodGhvdXNhbmRzU3RyaW5nV2l0aFNlcGFyYXRvciAhPT0gdGhvdXNhbmRzU3RyaW5nV2l0aG91dFNlcGFyYXRvcikge1xuICAgICAgcmV0dXJuIGdldE5vbk51bWVyaWModGhvdXNhbmRzU3RyaW5nV2l0aFNlcGFyYXRvcilbMF07XG4gICAgfVxuICAgIHJldHVybiBkZWNpbWFsU2VwYXJhdG9yID09PSAnLicgPyAnLCcgOiAnLic7XG4gIH07XG5cbiAgdmFyIFR5cGUgPSB7XG4gICAgQk9PTEVBTjogJ2Jvb2xlYW4nLFxuICAgIElOVDogJ2ludCcsXG4gICAgTlVNQkVSOiAnbnVtYmVyJyxcbiAgICBTVFJJTkc6ICdzdHJpbmcnLFxuICAgIEFSUkFZOiAnYXJyYXknLFxuICAgIE9CSkVDVDogJ29iamVjdCcsXG4gICAgRlVOQ1RJT046ICdmdW5jdGlvbicsXG4gICAgQUNUSU9OOiAnYWN0aW9uJyxcbiAgICBTRVJWRVJfQVBJOiAnc2VydmVyYXBpJyxcbiAgICBSRUdFWDogJ3JlZ2V4J1xuICB9O1xuXG4gIC8vIGFsbCByZWdpc3RlcmVkIGZpbHRlcnNcbiAgdmFyIGZpbHRlcnMgPSBbXTtcblxuICAvLyBsb29wcyBvdmVyIG1hdGNoaW5nIGZpbHRlcnMgYW5kIHBhc3NlcyBvcHRpb25zIHRvIGVhY2ggZmlsdGVyLCByZXR1cm5pbmcgdGhlIG1hcHBlZCByZXN1bHRzXG4gIHZhciBhcHBseUZpbHRlckNoYWluID0gZnVuY3Rpb24gYXBwbHlGaWx0ZXJDaGFpbihrZXksIHZhbHVlLCB1dGlscykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIC8vIGZpbmQgbWF0Y2hpbmcgZmlsdGVycyBmb3IgdGhpcyBrZXlcbiAgICAgIHZhciBtYXRjaGluZ0ZpbHRlcnMgPSBmaWx0ZXJzXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oZikge1xuICAgICAgICAgIHJldHVybiBmLmtleSA9PT0ga2V5O1xuICAgICAgICB9KVxuICAgICAgICAubWFwKGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgICByZXR1cm4gZi5jYjtcbiAgICAgICAgfSk7XG5cbiAgICAgIC8vIHJlc29sdmUgbm93XG4gICAgICBpZiAobWF0Y2hpbmdGaWx0ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBmaXJzdCBmaWx0ZXIgdG8ga2ljayB0aGluZ3Mgb2ZcbiAgICAgIHZhciBpbml0aWFsRmlsdGVyID0gbWF0Y2hpbmdGaWx0ZXJzLnNoaWZ0KCk7XG5cbiAgICAgIC8vIGNoYWluIGZpbHRlcnNcbiAgICAgIG1hdGNoaW5nRmlsdGVyc1xuICAgICAgICAucmVkdWNlKFxuICAgICAgICAgIC8vIGxvb3Agb3ZlciBwcm9taXNlcyBwYXNzaW5nIHZhbHVlIHRvIG5leHQgcHJvbWlzZVxuICAgICAgICAgIGZ1bmN0aW9uKGN1cnJlbnQsIG5leHQpIHtcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50LnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQodmFsdWUsIHV0aWxzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvLyBjYWxsIGluaXRpYWwgZmlsdGVyLCB3aWxsIHJldHVybiBhIHByb21pc2VcbiAgICAgICAgICBpbml0aWFsRmlsdGVyKHZhbHVlLCB1dGlscylcblxuICAgICAgICAgIC8vIGFsbCBleGVjdXRlZFxuICAgICAgICApXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUodmFsdWUpO1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGFwcGx5RmlsdGVycyA9IGZ1bmN0aW9uIGFwcGx5RmlsdGVycyhrZXksIHZhbHVlLCB1dGlscykge1xuICAgIHJldHVybiBmaWx0ZXJzXG4gICAgICAuZmlsdGVyKGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgcmV0dXJuIGYua2V5ID09PSBrZXk7XG4gICAgICB9KVxuICAgICAgLm1hcChmdW5jdGlvbihmKSB7XG4gICAgICAgIHJldHVybiBmLmNiKHZhbHVlLCB1dGlscyk7XG4gICAgICB9KTtcbiAgfTtcblxuICAvLyBhZGRzIGEgbmV3IGZpbHRlciB0byB0aGUgbGlzdFxuICB2YXIgYWRkRmlsdGVyID0gZnVuY3Rpb24gYWRkRmlsdGVyKGtleSwgY2IpIHtcbiAgICByZXR1cm4gZmlsdGVycy5wdXNoKHsga2V5OiBrZXksIGNiOiBjYiB9KTtcbiAgfTtcblxuICB2YXIgZXh0ZW5kRGVmYXVsdE9wdGlvbnMgPSBmdW5jdGlvbiBleHRlbmREZWZhdWx0T3B0aW9ucyhhZGRpdGlvbmFsT3B0aW9ucykge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKGRlZmF1bHRPcHRpb25zLCBhZGRpdGlvbmFsT3B0aW9ucyk7XG4gIH07XG5cbiAgdmFyIGdldE9wdGlvbnMgPSBmdW5jdGlvbiBnZXRPcHRpb25zKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucyk7XG4gIH07XG5cbiAgdmFyIHNldE9wdGlvbnMgPSBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdHMpIHtcbiAgICBmb3JpbihvcHRzLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAvLyBrZXkgZG9lcyBub3QgZXhpc3QsIHNvIHRoaXMgb3B0aW9uIGNhbm5vdCBiZSBzZXRcbiAgICAgIGlmICghZGVmYXVsdE9wdGlvbnNba2V5XSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBkZWZhdWx0T3B0aW9uc1trZXldWzBdID0gZ2V0VmFsdWVCeVR5cGUoXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBkZWZhdWx0T3B0aW9uc1trZXldWzBdLFxuICAgICAgICBkZWZhdWx0T3B0aW9uc1trZXldWzFdXG4gICAgICApO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIGRlZmF1bHQgb3B0aW9ucyBvbiBhcHBcbiAgdmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICAgIC8vIHRoZSBpZCB0byBhZGQgdG8gdGhlIHJvb3QgZWxlbWVudFxuICAgIGlkOiBbbnVsbCwgVHlwZS5TVFJJTkddLFxuXG4gICAgLy8gaW5wdXQgZmllbGQgbmFtZSB0byB1c2VcbiAgICBuYW1lOiBbJ2ZpbGVwb25kJywgVHlwZS5TVFJJTkddLFxuXG4gICAgLy8gZGlzYWJsZSB0aGUgZmllbGRcbiAgICBkaXNhYmxlZDogW2ZhbHNlLCBUeXBlLkJPT0xFQU5dLFxuXG4gICAgLy8gY2xhc3NuYW1lIHRvIHB1dCBvbiB3cmFwcGVyXG4gICAgY2xhc3NOYW1lOiBbbnVsbCwgVHlwZS5TVFJJTkddLFxuXG4gICAgLy8gaXMgdGhlIGZpZWxkIHJlcXVpcmVkXG4gICAgcmVxdWlyZWQ6IFtmYWxzZSwgVHlwZS5CT09MRUFOXSxcblxuICAgIC8vIEFsbG93IG1lZGlhIGNhcHR1cmUgd2hlbiB2YWx1ZSBpcyBzZXRcbiAgICBjYXB0dXJlTWV0aG9kOiBbbnVsbCwgVHlwZS5TVFJJTkddLFxuICAgIC8vIC0gXCJjYW1lcmFcIiwgXCJtaWNyb3Bob25lXCIgb3IgXCJjYW1jb3JkZXJcIixcbiAgICAvLyAtIERvZXMgbm90IHdvcmsgd2l0aCBtdWx0aXBsZSBvbiBhcHBsZSBkZXZpY2VzXG4gICAgLy8gLSBJZiBzZXQsIGFjY2VwdGVkRmlsZVR5cGVzIG11c3QgYmUgbWFkZSB0byBtYXRjaCB3aXRoIG1lZGlhIHdpbGRjYXJkIFwiaW1hZ2UvKlwiLCBcImF1ZGlvLypcIiBvciBcInZpZGVvLypcIlxuXG4gICAgLy8gc3luYyBgYWNjZXB0ZWRGaWxlVHlwZXNgIHByb3BlcnR5IHdpdGggYGFjY2VwdGAgYXR0cmlidXRlXG4gICAgYWxsb3dTeW5jQWNjZXB0QXR0cmlidXRlOiBbdHJ1ZSwgVHlwZS5CT09MRUFOXSxcblxuICAgIC8vIEZlYXR1cmUgdG9nZ2xlc1xuICAgIGFsbG93RHJvcDogW3RydWUsIFR5cGUuQk9PTEVBTl0sIC8vIEFsbG93IGRyb3BwaW5nIG9mIGZpbGVzXG4gICAgYWxsb3dCcm93c2U6IFt0cnVlLCBUeXBlLkJPT0xFQU5dLCAvLyBBbGxvdyBicm93c2luZyB0aGUgZmlsZSBzeXN0ZW1cbiAgICBhbGxvd1Bhc3RlOiBbdHJ1ZSwgVHlwZS5CT09MRUFOXSwgLy8gQWxsb3cgcGFzdGluZyBmaWxlc1xuICAgIGFsbG93TXVsdGlwbGU6IFtmYWxzZSwgVHlwZS5CT09MRUFOXSwgLy8gQWxsb3cgbXVsdGlwbGUgZmlsZXMgKGRpc2FibGVkIGJ5IGRlZmF1bHQsIGFzIG11bHRpcGxlIGF0dHJpYnV0ZSBpcyBhbHNvIHJlcXVpcmVkIG9uIGlucHV0IHRvIGFsbG93IG11bHRpcGxlKVxuICAgIGFsbG93UmVwbGFjZTogW3RydWUsIFR5cGUuQk9PTEVBTl0sIC8vIEFsbG93IGRyb3BwaW5nIGEgZmlsZSBvbiBvdGhlciBmaWxlIHRvIHJlcGxhY2UgaXQgKG9ubHkgd29ya3Mgd2hlbiBtdWx0aXBsZSBpcyBzZXQgdG8gZmFsc2UpXG4gICAgYWxsb3dSZXZlcnQ6IFt0cnVlLCBUeXBlLkJPT0xFQU5dLCAvLyBBbGxvd3MgdXNlciB0byByZXZlcnQgZmlsZSB1cGxvYWRcbiAgICBhbGxvd1JlbW92ZTogW3RydWUsIFR5cGUuQk9PTEVBTl0sIC8vIEFsbG93IHVzZXIgdG8gcmVtb3ZlIGEgZmlsZVxuICAgIGFsbG93UHJvY2VzczogW3RydWUsIFR5cGUuQk9PTEVBTl0sIC8vIEFsbG93cyB1c2VyIHRvIHByb2Nlc3MgYSBmaWxlLCB3aGVuIHNldCB0byBmYWxzZSwgdGhpcyByZW1vdmVzIHRoZSBmaWxlIHVwbG9hZCBidXR0b25cbiAgICBhbGxvd1Jlb3JkZXI6IFtmYWxzZSwgVHlwZS5CT09MRUFOXSwgLy8gQWxsb3cgcmVvcmRlcmluZyBvZiBmaWxlc1xuICAgIGFsbG93RGlyZWN0b3JpZXNPbmx5OiBbZmFsc2UsIFR5cGUuQk9PTEVBTl0sIC8vIEFsbG93IG9ubHkgc2VsZWN0aW5nIGRpcmVjdG9yaWVzIHdpdGggYnJvd3NlIChubyBzdXBwb3J0IGZvciBmaWx0ZXJpbmcgZG5kIGF0IHRoaXMgcG9pbnQpXG5cbiAgICAvLyBSZXZlcnQgbW9kZVxuICAgIGZvcmNlUmV2ZXJ0OiBbZmFsc2UsIFR5cGUuQk9PTEVBTl0sIC8vIFNldCB0byAnZm9yY2UnIHRvIHJlcXVpcmUgdGhlIGZpbGUgdG8gYmUgcmV2ZXJ0ZWQgYmVmb3JlIHJlbW92YWxcblxuICAgIC8vIElucHV0IHJlcXVpcmVtZW50c1xuICAgIG1heEZpbGVzOiBbbnVsbCwgVHlwZS5JTlRdLCAvLyBNYXggbnVtYmVyIG9mIGZpbGVzXG4gICAgY2hlY2tWYWxpZGl0eTogW2ZhbHNlLCBUeXBlLkJPT0xFQU5dLCAvLyBFbmFibGVzIGN1c3RvbSB2YWxpZGl0eSBtZXNzYWdlc1xuXG4gICAgLy8gV2hlcmUgdG8gcHV0IGZpbGVcbiAgICBpdGVtSW5zZXJ0TG9jYXRpb25GcmVlZG9tOiBbdHJ1ZSwgVHlwZS5CT09MRUFOXSwgLy8gU2V0IHRvIGZhbHNlIHRvIGFsd2F5cyBhZGQgaXRlbXMgdG8gYmVnaW4gb3IgZW5kIG9mIGxpc3RcbiAgICBpdGVtSW5zZXJ0TG9jYXRpb246IFsnYmVmb3JlJywgVHlwZS5TVFJJTkddLCAvLyBEZWZhdWx0IGluZGV4IGluIGxpc3QgdG8gYWRkIGl0ZW1zIHRoYXQgaGF2ZSBiZWVuIGRyb3BwZWQgYXQgdGhlIHRvcCBvZiB0aGUgbGlzdFxuICAgIGl0ZW1JbnNlcnRJbnRlcnZhbDogWzc1LCBUeXBlLklOVF0sXG5cbiAgICAvLyBEcmFnICduIERyb3AgcmVsYXRlZFxuICAgIGRyb3BPblBhZ2U6IFtmYWxzZSwgVHlwZS5CT09MRUFOXSwgLy8gQWxsb3cgZHJvcHBpbmcgb2YgZmlsZXMgYW55d2hlcmUgb24gcGFnZSAocHJldmVudHMgYnJvd3NlciBmcm9tIG9wZW5pbmcgZmlsZSBpZiBkcm9wcGVkIG91dHNpZGUgb2YgVXApXG4gICAgZHJvcE9uRWxlbWVudDogW3RydWUsIFR5cGUuQk9PTEVBTl0sIC8vIERyb3AgbmVlZHMgdG8gaGFwcGVuIG9uIGVsZW1lbnQgKHNldCB0byBmYWxzZSB0byBhbHNvIGxvYWQgZHJvcHMgb3V0c2lkZSBvZiBVcClcbiAgICBkcm9wVmFsaWRhdGlvbjogW2ZhbHNlLCBUeXBlLkJPT0xFQU5dLCAvLyBFbmFibGUgb3IgZGlzYWJsZSB2YWxpZGF0aW5nIGZpbGVzIG9uIGRyb3BcbiAgICBpZ25vcmVkRmlsZXM6IFtbJy5kc19zdG9yZScsICd0aHVtYnMuZGInLCAnZGVza3RvcC5pbmknXSwgVHlwZS5BUlJBWV0sXG5cbiAgICAvLyBVcGxvYWQgcmVsYXRlZFxuICAgIGluc3RhbnRVcGxvYWQ6IFt0cnVlLCBUeXBlLkJPT0xFQU5dLCAvLyBTaG91bGQgdXBsb2FkIGZpbGVzIGltbWVkaWF0ZWx5IG9uIGRyb3BcbiAgICBtYXhQYXJhbGxlbFVwbG9hZHM6IFsyLCBUeXBlLklOVF0sIC8vIE1heGltdW0gZmlsZXMgdG8gdXBsb2FkIGluIHBhcmFsbGVsXG5cbiAgICAvLyBDaHVua3NcbiAgICBjaHVua1VwbG9hZHM6IFtmYWxzZSwgVHlwZS5CT09MRUFOXSwgLy8gRW5hYmxlIGNodW5rZWQgdXBsb2Fkc1xuICAgIGNodW5rRm9yY2U6IFtmYWxzZSwgVHlwZS5CT09MRUFOXSwgLy8gRm9yY2UgdXNlIG9mIGNodW5rIHVwbG9hZHMgZXZlbiBmb3IgZmlsZXMgc21hbGxlciB0aGFuIGNodW5rIHNpemVcbiAgICBjaHVua1NpemU6IFs1MDAwMDAwLCBUeXBlLklOVF0sIC8vIFNpemUgb2YgY2h1bmtzICg1TUIgZGVmYXVsdClcbiAgICBjaHVua1JldHJ5RGVsYXlzOiBbWzUwMCwgMTAwMCwgMzAwMF0sIFR5cGUuQXJyYXldLCAvLyBBbW91bnQgb2YgdGltZXMgdG8gcmV0cnkgdXBsb2FkIG9mIGEgY2h1bmsgd2hlbiBpdCBmYWlsc1xuXG4gICAgLy8gVGhlIHNlcnZlciBhcGkgZW5kIHBvaW50cyB0byB1c2UgZm9yIHVwbG9hZGluZyAoc2VlIGRvY3MpXG4gICAgc2VydmVyOiBbbnVsbCwgVHlwZS5TRVJWRVJfQVBJXSxcblxuICAgIC8vIEZpbGUgc2l6ZSBjYWxjdWxhdGlvbnMsIGNhbiBzZXQgdG8gMTAyNCwgdGhpcyBpcyBvbmx5IHVzZWQgZm9yIGRpc3BsYXksIHByb3BlcnRpZXMgdXNlIGZpbGUgc2l6ZSBiYXNlIDEwMDBcbiAgICBmaWxlU2l6ZUJhc2U6IFsxMDAwLCBUeXBlLklOVF0sXG5cbiAgICAvLyBMYWJlbHMgYW5kIHN0YXR1cyBtZXNzYWdlc1xuICAgIGxhYmVsRGVjaW1hbFNlcGFyYXRvcjogW2dldERlY2ltYWxTZXBhcmF0b3IoKSwgVHlwZS5TVFJJTkddLCAvLyBEZWZhdWx0IGlzIGxvY2FsZSBzZXBhcmF0b3JcbiAgICBsYWJlbFRob3VzYW5kc1NlcGFyYXRvcjogW2dldFRob3VzYW5kc1NlcGFyYXRvcigpLCBUeXBlLlNUUklOR10sIC8vIERlZmF1bHQgaXMgbG9jYWxlIHNlcGFyYXRvclxuXG4gICAgbGFiZWxJZGxlOiBbXG4gICAgICAnRHJhZyAmIERyb3AgeW91ciBmaWxlcyBvciA8c3BhbiBjbGFzcz1cImZpbGVwb25kLS1sYWJlbC1hY3Rpb25cIj5Ccm93c2U8L3NwYW4+JyxcbiAgICAgIFR5cGUuU1RSSU5HXG4gICAgXSxcbiAgICBsYWJlbEludmFsaWRGaWVsZDogWydGaWVsZCBjb250YWlucyBpbnZhbGlkIGZpbGVzJywgVHlwZS5TVFJJTkddLFxuICAgIGxhYmVsRmlsZVdhaXRpbmdGb3JTaXplOiBbJ1dhaXRpbmcgZm9yIHNpemUnLCBUeXBlLlNUUklOR10sXG4gICAgbGFiZWxGaWxlU2l6ZU5vdEF2YWlsYWJsZTogWydTaXplIG5vdCBhdmFpbGFibGUnLCBUeXBlLlNUUklOR10sXG4gICAgbGFiZWxGaWxlQ291bnRTaW5ndWxhcjogWydmaWxlIGluIGxpc3QnLCBUeXBlLlNUUklOR10sXG4gICAgbGFiZWxGaWxlQ291bnRQbHVyYWw6IFsnZmlsZXMgaW4gbGlzdCcsIFR5cGUuU1RSSU5HXSxcbiAgICBsYWJlbEZpbGVMb2FkaW5nOiBbJ0xvYWRpbmcnLCBUeXBlLlNUUklOR10sXG4gICAgbGFiZWxGaWxlQWRkZWQ6IFsnQWRkZWQnLCBUeXBlLlNUUklOR10sIC8vIGFzc2lzdGl2ZSBvbmx5XG4gICAgbGFiZWxGaWxlTG9hZEVycm9yOiBbJ0Vycm9yIGR1cmluZyBsb2FkJywgVHlwZS5TVFJJTkddLFxuICAgIGxhYmVsRmlsZVJlbW92ZWQ6IFsnUmVtb3ZlZCcsIFR5cGUuU1RSSU5HXSwgLy8gYXNzaXN0aXZlIG9ubHlcbiAgICBsYWJlbEZpbGVSZW1vdmVFcnJvcjogWydFcnJvciBkdXJpbmcgcmVtb3ZlJywgVHlwZS5TVFJJTkddLFxuICAgIGxhYmVsRmlsZVByb2Nlc3Npbmc6IFsnVXBsb2FkaW5nJywgVHlwZS5TVFJJTkddLFxuICAgIGxhYmVsRmlsZVByb2Nlc3NpbmdDb21wbGV0ZTogWydVcGxvYWQgY29tcGxldGUnLCBUeXBlLlNUUklOR10sXG4gICAgbGFiZWxGaWxlUHJvY2Vzc2luZ0Fib3J0ZWQ6IFsnVXBsb2FkIGNhbmNlbGxlZCcsIFR5cGUuU1RSSU5HXSxcbiAgICBsYWJlbEZpbGVQcm9jZXNzaW5nRXJyb3I6IFsnRXJyb3IgZHVyaW5nIHVwbG9hZCcsIFR5cGUuU1RSSU5HXSxcbiAgICBsYWJlbEZpbGVQcm9jZXNzaW5nUmV2ZXJ0RXJyb3I6IFsnRXJyb3IgZHVyaW5nIHJldmVydCcsIFR5cGUuU1RSSU5HXSxcblxuICAgIGxhYmVsVGFwVG9DYW5jZWw6IFsndGFwIHRvIGNhbmNlbCcsIFR5cGUuU1RSSU5HXSxcbiAgICBsYWJlbFRhcFRvUmV0cnk6IFsndGFwIHRvIHJldHJ5JywgVHlwZS5TVFJJTkddLFxuICAgIGxhYmVsVGFwVG9VbmRvOiBbJ3RhcCB0byB1bmRvJywgVHlwZS5TVFJJTkddLFxuXG4gICAgbGFiZWxCdXR0b25SZW1vdmVJdGVtOiBbJ1JlbW92ZScsIFR5cGUuU1RSSU5HXSxcbiAgICBsYWJlbEJ1dHRvbkFib3J0SXRlbUxvYWQ6IFsnQWJvcnQnLCBUeXBlLlNUUklOR10sXG4gICAgbGFiZWxCdXR0b25SZXRyeUl0ZW1Mb2FkOiBbJ1JldHJ5JywgVHlwZS5TVFJJTkddLFxuICAgIGxhYmVsQnV0dG9uQWJvcnRJdGVtUHJvY2Vzc2luZzogWydDYW5jZWwnLCBUeXBlLlNUUklOR10sXG4gICAgbGFiZWxCdXR0b25VbmRvSXRlbVByb2Nlc3Npbmc6IFsnVW5kbycsIFR5cGUuU1RSSU5HXSxcbiAgICBsYWJlbEJ1dHRvblJldHJ5SXRlbVByb2Nlc3Npbmc6IFsnUmV0cnknLCBUeXBlLlNUUklOR10sXG4gICAgbGFiZWxCdXR0b25Qcm9jZXNzSXRlbTogWydVcGxvYWQnLCBUeXBlLlNUUklOR10sXG5cbiAgICAvLyBtYWtlIHN1cmUgd2lkdGggYW5kIGhlaWdodCBwbHVzIHZpZXdwb3ggYXJlIGV2ZW4gbnVtYmVycyBzbyBpY29ucyBhcmUgbmljZWx5IGNlbnRlcmVkXG4gICAgaWNvblJlbW92ZTogW1xuICAgICAgJzxzdmcgd2lkdGg9XCIyNlwiIGhlaWdodD1cIjI2XCIgdmlld0JveD1cIjAgMCAyNiAyNlwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj48cGF0aCBkPVwiTTExLjU4NiAxM2wtMi4yOTMgMi4yOTNhMSAxIDAgMCAwIDEuNDE0IDEuNDE0TDEzIDE0LjQxNGwyLjI5MyAyLjI5M2ExIDEgMCAwIDAgMS40MTQtMS40MTRMMTQuNDE0IDEzbDIuMjkzLTIuMjkzYTEgMSAwIDAgMC0xLjQxNC0xLjQxNEwxMyAxMS41ODZsLTIuMjkzLTIuMjkzYTEgMSAwIDAgMC0xLjQxNCAxLjQxNEwxMS41ODYgMTN6XCIgZmlsbD1cImN1cnJlbnRDb2xvclwiIGZpbGwtcnVsZT1cIm5vbnplcm9cIi8+PC9zdmc+JyxcbiAgICAgIFR5cGUuU1RSSU5HXG4gICAgXSxcblxuICAgIGljb25Qcm9jZXNzOiBbXG4gICAgICAnPHN2ZyB3aWR0aD1cIjI2XCIgaGVpZ2h0PVwiMjZcIiB2aWV3Qm94PVwiMCAwIDI2IDI2XCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPjxwYXRoIGQ9XCJNMTQgMTAuNDE0djMuNTg1YTEgMSAwIDAgMS0yIDB2LTMuNTg1bC0xLjI5MyAxLjI5M2ExIDEgMCAwIDEtMS40MTQtMS40MTVsMy0zYTEgMSAwIDAgMSAxLjQxNCAwbDMgM2ExIDEgMCAwIDEtMS40MTQgMS40MTVMMTQgMTAuNDE0ek05IDE4YTEgMSAwIDAgMSAwLTJoOGExIDEgMCAwIDEgMCAySDl6XCIgZmlsbD1cImN1cnJlbnRDb2xvclwiIGZpbGwtcnVsZT1cImV2ZW5vZGRcIi8+PC9zdmc+JyxcbiAgICAgIFR5cGUuU1RSSU5HXG4gICAgXSxcblxuICAgIGljb25SZXRyeTogW1xuICAgICAgJzxzdmcgd2lkdGg9XCIyNlwiIGhlaWdodD1cIjI2XCIgdmlld0JveD1cIjAgMCAyNiAyNlwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj48cGF0aCBkPVwiTTEwLjgxIDkuMTg1bC0uMDM4LjAyQTQuOTk3IDQuOTk3IDAgMCAwIDggMTMuNjgzYTUgNSAwIDAgMCA1IDUgNSA1IDAgMCAwIDUtNSAxIDEgMCAwIDEgMiAwQTcgNyAwIDEgMSA5LjcyMiA3LjQ5NmwtLjg0Mi0uMjFhLjk5OS45OTkgMCAxIDEgLjQ4NC0xLjk0bDMuMjMuODA2Yy41MzUuMTMzLjg2LjY3NS43MyAxLjIxbC0uODA0IDMuMjMzYS45OTcuOTk3IDAgMCAxLTEuMjEuNzMuOTk3Ljk5NyAwIDAgMS0uNzMtMS4yMWwuMjMtLjkyOHYtLjAwMnpcIiBmaWxsPVwiY3VycmVudENvbG9yXCIgZmlsbC1ydWxlPVwibm9uemVyb1wiLz48L3N2Zz4nLFxuICAgICAgVHlwZS5TVFJJTkdcbiAgICBdLFxuXG4gICAgaWNvblVuZG86IFtcbiAgICAgICc8c3ZnIHdpZHRoPVwiMjZcIiBoZWlnaHQ9XCIyNlwiIHZpZXdCb3g9XCIwIDAgMjYgMjZcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+PHBhdGggZD1cIk05LjE4NSAxMC44MWwuMDItLjAzOEE0Ljk5NyA0Ljk5NyAwIDAgMSAxMy42ODMgOGE1IDUgMCAwIDEgNSA1IDUgNSAwIDAgMS01IDUgMSAxIDAgMCAwIDAgMkE3IDcgMCAxIDAgNy40OTYgOS43MjJsLS4yMS0uODQyYS45OTkuOTk5IDAgMSAwLTEuOTQuNDg0bC44MDYgMy4yM2MuMTMzLjUzNS42NzUuODYgMS4yMS43M2wzLjIzMy0uODAzYS45OTcuOTk3IDAgMCAwIC43My0xLjIxLjk5Ny45OTcgMCAwIDAtMS4yMS0uNzNsLS45MjguMjMtLjAwMi0uMDAxelwiIGZpbGw9XCJjdXJyZW50Q29sb3JcIiBmaWxsLXJ1bGU9XCJub256ZXJvXCIvPjwvc3ZnPicsXG4gICAgICBUeXBlLlNUUklOR1xuICAgIF0sXG5cbiAgICBpY29uRG9uZTogW1xuICAgICAgJzxzdmcgd2lkdGg9XCIyNlwiIGhlaWdodD1cIjI2XCIgdmlld0JveD1cIjAgMCAyNiAyNlwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj48cGF0aCBkPVwiTTE4LjI5MyA5LjI5M2ExIDEgMCAwIDEgMS40MTQgMS40MTRsLTcuMDAyIDdhMSAxIDAgMCAxLTEuNDE0IDBsLTMuOTk4LTRhMSAxIDAgMSAxIDEuNDE0LTEuNDE0TDEyIDE1LjU4Nmw2LjI5NC02LjI5M3pcIiBmaWxsPVwiY3VycmVudENvbG9yXCIgZmlsbC1ydWxlPVwibm9uemVyb1wiLz48L3N2Zz4nLFxuICAgICAgVHlwZS5TVFJJTkdcbiAgICBdLFxuXG4gICAgLy8gZXZlbnQgaGFuZGxlcnNcbiAgICBvbmluaXQ6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICBvbndhcm5pbmc6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICBvbmVycm9yOiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG4gICAgb25hY3RpdmF0ZWZpbGU6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICBvbmluaXRmaWxlOiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG4gICAgb25hZGRmaWxlc3RhcnQ6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICBvbmFkZGZpbGVwcm9ncmVzczogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuICAgIG9uYWRkZmlsZTogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuICAgIG9ucHJvY2Vzc2ZpbGVzdGFydDogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuICAgIG9ucHJvY2Vzc2ZpbGVwcm9ncmVzczogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuICAgIG9ucHJvY2Vzc2ZpbGVhYm9ydDogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuICAgIG9ucHJvY2Vzc2ZpbGVyZXZlcnQ6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICBvbnByb2Nlc3NmaWxlOiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG4gICAgb25wcm9jZXNzZmlsZXM6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICBvbnJlbW92ZWZpbGU6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICBvbnByZXBhcmVmaWxlOiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG4gICAgb251cGRhdGVmaWxlczogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuICAgIG9ucmVvcmRlcmZpbGVzOiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG5cbiAgICAvLyBob29rc1xuICAgIGJlZm9yZURyb3BGaWxlOiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG4gICAgYmVmb3JlQWRkRmlsZTogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuICAgIGJlZm9yZVJlbW92ZUZpbGU6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcblxuICAgIC8vIHN0eWxlc1xuICAgIHN0eWxlUGFuZWxMYXlvdXQ6IFtudWxsLCBUeXBlLlNUUklOR10sIC8vIG51bGwgJ2ludGVncmF0ZWQnLCAnY29tcGFjdCcsICdjaXJjbGUnXG4gICAgc3R5bGVQYW5lbEFzcGVjdFJhdGlvOiBbbnVsbCwgVHlwZS5TVFJJTkddLCAvLyBudWxsIG9yICczOjInIG9yIDFcbiAgICBzdHlsZUl0ZW1QYW5lbEFzcGVjdFJhdGlvOiBbbnVsbCwgVHlwZS5TVFJJTkddLFxuICAgIHN0eWxlQnV0dG9uUmVtb3ZlSXRlbVBvc2l0aW9uOiBbJ2xlZnQnLCBUeXBlLlNUUklOR10sXG4gICAgc3R5bGVCdXR0b25Qcm9jZXNzSXRlbVBvc2l0aW9uOiBbJ3JpZ2h0JywgVHlwZS5TVFJJTkddLFxuICAgIHN0eWxlTG9hZEluZGljYXRvclBvc2l0aW9uOiBbJ3JpZ2h0JywgVHlwZS5TVFJJTkddLFxuICAgIHN0eWxlUHJvZ3Jlc3NJbmRpY2F0b3JQb3NpdGlvbjogWydyaWdodCcsIFR5cGUuU1RSSU5HXSxcbiAgICBzdHlsZUJ1dHRvblJlbW92ZUl0ZW1BbGlnbjogW2ZhbHNlLCBUeXBlLkJPT0xFQU5dLFxuXG4gICAgLy8gY3VzdG9tIGluaXRpYWwgZmlsZXMgYXJyYXlcbiAgICBmaWxlczogW1tdLCBUeXBlLkFSUkFZXSxcblxuICAgIC8vIHNob3cgc3VwcG9ydCBieSBkaXNwbGF5aW5nIGNyZWRpdHNcbiAgICBjcmVkaXRzOiBbWydodHRwczovL3BxaW5hLm5sLycsICdQb3dlcmVkIGJ5IFBRSU5BJ10sIFR5cGUuQVJSQVldXG4gIH07XG5cbiAgdmFyIGdldEl0ZW1CeVF1ZXJ5ID0gZnVuY3Rpb24gZ2V0SXRlbUJ5UXVlcnkoaXRlbXMsIHF1ZXJ5KSB7XG4gICAgLy8ganVzdCByZXR1cm4gZmlyc3QgaW5kZXhcbiAgICBpZiAoaXNFbXB0eShxdWVyeSkpIHtcbiAgICAgIHJldHVybiBpdGVtc1swXSB8fCBudWxsO1xuICAgIH1cblxuICAgIC8vIHF1ZXJ5IGlzIGluZGV4XG4gICAgaWYgKGlzSW50KHF1ZXJ5KSkge1xuICAgICAgcmV0dXJuIGl0ZW1zW3F1ZXJ5XSB8fCBudWxsO1xuICAgIH1cblxuICAgIC8vIGlmIHF1ZXJ5IGlzIGl0ZW0sIGdldCB0aGUgaWRcbiAgICBpZiAodHlwZW9mIHF1ZXJ5ID09PSAnb2JqZWN0Jykge1xuICAgICAgcXVlcnkgPSBxdWVyeS5pZDtcbiAgICB9XG5cbiAgICAvLyBhc3N1bWUgcXVlcnkgaXMgYSBzdHJpbmcgYW5kIHJldHVybiBpdGVtIGJ5IGlkXG4gICAgcmV0dXJuIChcbiAgICAgIGl0ZW1zLmZpbmQoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbS5pZCA9PT0gcXVlcnk7XG4gICAgICB9KSB8fCBudWxsXG4gICAgKTtcbiAgfTtcblxuICB2YXIgZ2V0TnVtZXJpY0FzcGVjdFJhdGlvRnJvbVN0cmluZyA9IGZ1bmN0aW9uIGdldE51bWVyaWNBc3BlY3RSYXRpb0Zyb21TdHJpbmcoXG4gICAgYXNwZWN0UmF0aW9cbiAgKSB7XG4gICAgaWYgKGlzRW1wdHkoYXNwZWN0UmF0aW8pKSB7XG4gICAgICByZXR1cm4gYXNwZWN0UmF0aW87XG4gICAgfVxuICAgIGlmICgvOi8udGVzdChhc3BlY3RSYXRpbykpIHtcbiAgICAgIHZhciBwYXJ0cyA9IGFzcGVjdFJhdGlvLnNwbGl0KCc6Jyk7XG4gICAgICByZXR1cm4gcGFydHNbMV0gLyBwYXJ0c1swXTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQoYXNwZWN0UmF0aW8pO1xuICB9O1xuXG4gIHZhciBnZXRBY3RpdmVJdGVtcyA9IGZ1bmN0aW9uIGdldEFjdGl2ZUl0ZW1zKGl0ZW1zKSB7XG4gICAgcmV0dXJuIGl0ZW1zLmZpbHRlcihmdW5jdGlvbihpdGVtKSB7XG4gICAgICByZXR1cm4gIWl0ZW0uYXJjaGl2ZWQ7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIFN0YXR1cyA9IHtcbiAgICBFTVBUWTogMCxcbiAgICBJRExFOiAxLCAvLyB3YWl0aW5nXG4gICAgRVJST1I6IDIsIC8vIGEgZmlsZSBpcyBpbiBlcnJvciBzdGF0ZVxuICAgIEJVU1k6IDMsIC8vIGJ1c3kgcHJvY2Vzc2luZyBvciBsb2FkaW5nXG4gICAgUkVBRFk6IDQgLy8gYWxsIGZpbGVzIHVwbG9hZGVkXG4gIH07XG5cbiAgdmFyIElURU1fRVJST1IgPSBbXG4gICAgSXRlbVN0YXR1cy5MT0FEX0VSUk9SLFxuICAgIEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19FUlJPUixcbiAgICBJdGVtU3RhdHVzLlBST0NFU1NJTkdfUkVWRVJUX0VSUk9SXG4gIF07XG4gIHZhciBJVEVNX0JVU1kgPSBbXG4gICAgSXRlbVN0YXR1cy5MT0FESU5HLFxuICAgIEl0ZW1TdGF0dXMuUFJPQ0VTU0lORyxcbiAgICBJdGVtU3RhdHVzLlBST0NFU1NJTkdfUVVFVUVELFxuICAgIEl0ZW1TdGF0dXMuSU5JVFxuICBdO1xuICB2YXIgSVRFTV9SRUFEWSA9IFtJdGVtU3RhdHVzLlBST0NFU1NJTkdfQ09NUExFVEVdO1xuXG4gIHZhciBpc0l0ZW1JbkVycm9yU3RhdGUgPSBmdW5jdGlvbiBpc0l0ZW1JbkVycm9yU3RhdGUoaXRlbSkge1xuICAgIHJldHVybiBJVEVNX0VSUk9SLmluY2x1ZGVzKGl0ZW0uc3RhdHVzKTtcbiAgfTtcbiAgdmFyIGlzSXRlbUluQnVzeVN0YXRlID0gZnVuY3Rpb24gaXNJdGVtSW5CdXN5U3RhdGUoaXRlbSkge1xuICAgIHJldHVybiBJVEVNX0JVU1kuaW5jbHVkZXMoaXRlbS5zdGF0dXMpO1xuICB9O1xuICB2YXIgaXNJdGVtSW5SZWFkeVN0YXRlID0gZnVuY3Rpb24gaXNJdGVtSW5SZWFkeVN0YXRlKGl0ZW0pIHtcbiAgICByZXR1cm4gSVRFTV9SRUFEWS5pbmNsdWRlcyhpdGVtLnN0YXR1cyk7XG4gIH07XG5cbiAgdmFyIHF1ZXJpZXMgPSBmdW5jdGlvbiBxdWVyaWVzKHN0YXRlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEdFVF9TVEFUVVM6IGZ1bmN0aW9uIEdFVF9TVEFUVVMoKSB7XG4gICAgICAgIHZhciBpdGVtcyA9IGdldEFjdGl2ZUl0ZW1zKHN0YXRlLml0ZW1zKTtcbiAgICAgICAgdmFyIEVNUFRZID0gU3RhdHVzLkVNUFRZLFxuICAgICAgICAgIEVSUk9SID0gU3RhdHVzLkVSUk9SLFxuICAgICAgICAgIEJVU1kgPSBTdGF0dXMuQlVTWSxcbiAgICAgICAgICBJRExFID0gU3RhdHVzLklETEUsXG4gICAgICAgICAgUkVBRFkgPSBTdGF0dXMuUkVBRFk7XG5cbiAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA9PT0gMCkgcmV0dXJuIEVNUFRZO1xuXG4gICAgICAgIGlmIChpdGVtcy5zb21lKGlzSXRlbUluRXJyb3JTdGF0ZSkpIHJldHVybiBFUlJPUjtcblxuICAgICAgICBpZiAoaXRlbXMuc29tZShpc0l0ZW1JbkJ1c3lTdGF0ZSkpIHJldHVybiBCVVNZO1xuXG4gICAgICAgIGlmIChpdGVtcy5zb21lKGlzSXRlbUluUmVhZHlTdGF0ZSkpIHJldHVybiBSRUFEWTtcblxuICAgICAgICByZXR1cm4gSURMRTtcbiAgICAgIH0sXG5cbiAgICAgIEdFVF9JVEVNOiBmdW5jdGlvbiBHRVRfSVRFTShxdWVyeSkge1xuICAgICAgICByZXR1cm4gZ2V0SXRlbUJ5UXVlcnkoc3RhdGUuaXRlbXMsIHF1ZXJ5KTtcbiAgICAgIH0sXG5cbiAgICAgIEdFVF9BQ1RJVkVfSVRFTTogZnVuY3Rpb24gR0VUX0FDVElWRV9JVEVNKHF1ZXJ5KSB7XG4gICAgICAgIHJldHVybiBnZXRJdGVtQnlRdWVyeShnZXRBY3RpdmVJdGVtcyhzdGF0ZS5pdGVtcyksIHF1ZXJ5KTtcbiAgICAgIH0sXG5cbiAgICAgIEdFVF9BQ1RJVkVfSVRFTVM6IGZ1bmN0aW9uIEdFVF9BQ1RJVkVfSVRFTVMoKSB7XG4gICAgICAgIHJldHVybiBnZXRBY3RpdmVJdGVtcyhzdGF0ZS5pdGVtcyk7XG4gICAgICB9LFxuXG4gICAgICBHRVRfSVRFTVM6IGZ1bmN0aW9uIEdFVF9JVEVNUygpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlLml0ZW1zO1xuICAgICAgfSxcblxuICAgICAgR0VUX0lURU1fTkFNRTogZnVuY3Rpb24gR0VUX0lURU1fTkFNRShxdWVyeSkge1xuICAgICAgICB2YXIgaXRlbSA9IGdldEl0ZW1CeVF1ZXJ5KHN0YXRlLml0ZW1zLCBxdWVyeSk7XG4gICAgICAgIHJldHVybiBpdGVtID8gaXRlbS5maWxlbmFtZSA6IG51bGw7XG4gICAgICB9LFxuXG4gICAgICBHRVRfSVRFTV9TSVpFOiBmdW5jdGlvbiBHRVRfSVRFTV9TSVpFKHF1ZXJ5KSB7XG4gICAgICAgIHZhciBpdGVtID0gZ2V0SXRlbUJ5UXVlcnkoc3RhdGUuaXRlbXMsIHF1ZXJ5KTtcbiAgICAgICAgcmV0dXJuIGl0ZW0gPyBpdGVtLmZpbGVTaXplIDogbnVsbDtcbiAgICAgIH0sXG5cbiAgICAgIEdFVF9TVFlMRVM6IGZ1bmN0aW9uIEdFVF9TVFlMRVMoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhzdGF0ZS5vcHRpb25zKVxuICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gL15zdHlsZS8udGVzdChrZXkpO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLm1hcChmdW5jdGlvbihvcHRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIG5hbWU6IG9wdGlvbixcbiAgICAgICAgICAgICAgdmFsdWU6IHN0YXRlLm9wdGlvbnNbb3B0aW9uXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KTtcbiAgICAgIH0sXG5cbiAgICAgIEdFVF9QQU5FTF9BU1BFQ1RfUkFUSU86IGZ1bmN0aW9uIEdFVF9QQU5FTF9BU1BFQ1RfUkFUSU8oKSB7XG4gICAgICAgIHZhciBpc1NoYXBlQ2lyY2xlID0gL2NpcmNsZS8udGVzdChzdGF0ZS5vcHRpb25zLnN0eWxlUGFuZWxMYXlvdXQpO1xuICAgICAgICB2YXIgYXNwZWN0UmF0aW8gPSBpc1NoYXBlQ2lyY2xlXG4gICAgICAgICAgPyAxXG4gICAgICAgICAgOiBnZXROdW1lcmljQXNwZWN0UmF0aW9Gcm9tU3RyaW5nKFxuICAgICAgICAgICAgICBzdGF0ZS5vcHRpb25zLnN0eWxlUGFuZWxBc3BlY3RSYXRpb1xuICAgICAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGFzcGVjdFJhdGlvO1xuICAgICAgfSxcblxuICAgICAgR0VUX0lURU1fUEFORUxfQVNQRUNUX1JBVElPOiBmdW5jdGlvbiBHRVRfSVRFTV9QQU5FTF9BU1BFQ1RfUkFUSU8oKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZS5vcHRpb25zLnN0eWxlSXRlbVBhbmVsQXNwZWN0UmF0aW87XG4gICAgICB9LFxuXG4gICAgICBHRVRfSVRFTVNfQllfU1RBVFVTOiBmdW5jdGlvbiBHRVRfSVRFTVNfQllfU1RBVFVTKHN0YXR1cykge1xuICAgICAgICByZXR1cm4gZ2V0QWN0aXZlSXRlbXMoc3RhdGUuaXRlbXMpLmZpbHRlcihmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgcmV0dXJuIGl0ZW0uc3RhdHVzID09PSBzdGF0dXM7XG4gICAgICAgIH0pO1xuICAgICAgfSxcblxuICAgICAgR0VUX1RPVEFMX0lURU1TOiBmdW5jdGlvbiBHRVRfVE9UQUxfSVRFTVMoKSB7XG4gICAgICAgIHJldHVybiBnZXRBY3RpdmVJdGVtcyhzdGF0ZS5pdGVtcykubGVuZ3RoO1xuICAgICAgfSxcblxuICAgICAgSVNfQVNZTkM6IGZ1bmN0aW9uIElTX0FTWU5DKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGlzT2JqZWN0KHN0YXRlLm9wdGlvbnMuc2VydmVyKSAmJlxuICAgICAgICAgIChpc09iamVjdChzdGF0ZS5vcHRpb25zLnNlcnZlci5wcm9jZXNzKSB8fFxuICAgICAgICAgICAgaXNGdW5jdGlvbihzdGF0ZS5vcHRpb25zLnNlcnZlci5wcm9jZXNzKSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIHZhciBoYXNSb29tRm9ySXRlbSA9IGZ1bmN0aW9uIGhhc1Jvb21Gb3JJdGVtKHN0YXRlKSB7XG4gICAgdmFyIGNvdW50ID0gZ2V0QWN0aXZlSXRlbXMoc3RhdGUuaXRlbXMpLmxlbmd0aDtcblxuICAgIC8vIGlmIGNhbm5vdCBoYXZlIG11bHRpcGxlIGl0ZW1zLCB0byBhZGQgb25lIGl0ZW0gaXQgc2hvdWxkIGN1cnJlbnRseSBub3QgY29udGFpbiBpdGVtc1xuICAgIGlmICghc3RhdGUub3B0aW9ucy5hbGxvd011bHRpcGxlKSB7XG4gICAgICByZXR1cm4gY291bnQgPT09IDA7XG4gICAgfVxuXG4gICAgLy8gaWYgYWxsb3dzIG11bHRpcGxlIGl0ZW1zLCB3ZSBjaGVjayBpZiBhIG1heCBpdGVtIGNvdW50IGhhcyBiZWVuIHNldCwgaWYgbm90LCB0aGVyZSdzIG5vIGxpbWl0XG4gICAgdmFyIG1heEZpbGVDb3VudCA9IHN0YXRlLm9wdGlvbnMubWF4RmlsZXM7XG4gICAgaWYgKG1heEZpbGVDb3VudCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gd2UgY2hlY2sgaWYgdGhlIGN1cnJlbnQgY291bnQgaXMgc21hbGxlciB0aGFuIHRoZSBtYXggY291bnQsIGlmIHNvLCBhbm90aGVyIGZpbGUgY2FuIHN0aWxsIGJlIGFkZGVkXG4gICAgaWYgKGNvdW50IDwgbWF4RmlsZUNvdW50KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBubyBtb3JlIHJvb20gZm9yIGFub3RoZXIgZmlsZVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICB2YXIgbGltaXQgPSBmdW5jdGlvbiBsaW1pdCh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4obWF4LCB2YWx1ZSksIG1pbik7XG4gIH07XG5cbiAgdmFyIGFycmF5SW5zZXJ0ID0gZnVuY3Rpb24gYXJyYXlJbnNlcnQoYXJyLCBpbmRleCwgaXRlbSkge1xuICAgIHJldHVybiBhcnIuc3BsaWNlKGluZGV4LCAwLCBpdGVtKTtcbiAgfTtcblxuICB2YXIgaW5zZXJ0SXRlbSA9IGZ1bmN0aW9uIGluc2VydEl0ZW0oaXRlbXMsIGl0ZW0sIGluZGV4KSB7XG4gICAgaWYgKGlzRW1wdHkoaXRlbSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIGlmIGluZGV4IGlzIHVuZGVmaW5lZCwgYXBwZW5kXG4gICAgaWYgKHR5cGVvZiBpbmRleCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICByZXR1cm4gaXRlbTtcbiAgICB9XG5cbiAgICAvLyBsaW1pdCB0aGUgaW5kZXggdG8gdGhlIHNpemUgb2YgdGhlIGl0ZW1zIGFycmF5XG4gICAgaW5kZXggPSBsaW1pdChpbmRleCwgMCwgaXRlbXMubGVuZ3RoKTtcblxuICAgIC8vIGFkZCBpdGVtIHRvIGFycmF5XG4gICAgYXJyYXlJbnNlcnQoaXRlbXMsIGluZGV4LCBpdGVtKTtcblxuICAgIC8vIGV4cG9zZVxuICAgIHJldHVybiBpdGVtO1xuICB9O1xuXG4gIHZhciBpc0Jhc2U2NERhdGFVUkkgPSBmdW5jdGlvbiBpc0Jhc2U2NERhdGFVUkkoc3RyKSB7XG4gICAgcmV0dXJuIC9eXFxzKmRhdGE6KFthLXpdK1xcL1thLXowLTktKy5dKyg7W2Etei1dKz1bYS16MC05LV0rKT8pPyg7YmFzZTY0KT8sKFthLXowLTkhJCYnLCgpKis7PVxcLS5ffjpAXFwvPyVcXHNdKilcXHMqJC9pLnRlc3QoXG4gICAgICBzdHJcbiAgICApO1xuICB9O1xuXG4gIHZhciBnZXRGaWxlbmFtZUZyb21VUkwgPSBmdW5jdGlvbiBnZXRGaWxlbmFtZUZyb21VUkwodXJsKSB7XG4gICAgcmV0dXJuIHVybFxuICAgICAgLnNwbGl0KCcvJylcbiAgICAgIC5wb3AoKVxuICAgICAgLnNwbGl0KCc/JylcbiAgICAgIC5zaGlmdCgpO1xuICB9O1xuXG4gIHZhciBnZXRFeHRlbnNpb25Gcm9tRmlsZW5hbWUgPSBmdW5jdGlvbiBnZXRFeHRlbnNpb25Gcm9tRmlsZW5hbWUobmFtZSkge1xuICAgIHJldHVybiBuYW1lLnNwbGl0KCcuJykucG9wKCk7XG4gIH07XG5cbiAgdmFyIGd1ZXNzdGltYXRlRXh0ZW5zaW9uID0gZnVuY3Rpb24gZ3Vlc3N0aW1hdGVFeHRlbnNpb24odHlwZSkge1xuICAgIC8vIGlmIG5vIGV4dGVuc2lvbiBzdXBwbGllZCwgZXhpdCBoZXJlXG4gICAgaWYgKHR5cGVvZiB0eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIC8vIGdldCBzdWJ0eXBlXG4gICAgdmFyIHN1YnR5cGUgPSB0eXBlLnNwbGl0KCcvJykucG9wKCk7XG5cbiAgICAvLyBpcyBzdmcgc3VidHlwZVxuICAgIGlmICgvc3ZnLy50ZXN0KHN1YnR5cGUpKSB7XG4gICAgICByZXR1cm4gJ3N2Zyc7XG4gICAgfVxuXG4gICAgaWYgKC96aXB8Y29tcHJlc3NlZC8udGVzdChzdWJ0eXBlKSkge1xuICAgICAgcmV0dXJuICd6aXAnO1xuICAgIH1cblxuICAgIGlmICgvcGxhaW4vLnRlc3Qoc3VidHlwZSkpIHtcbiAgICAgIHJldHVybiAndHh0JztcbiAgICB9XG5cbiAgICBpZiAoL21zd29yZC8udGVzdChzdWJ0eXBlKSkge1xuICAgICAgcmV0dXJuICdkb2MnO1xuICAgIH1cblxuICAgIC8vIGlmIGlzIHZhbGlkIHN1YnR5cGVcbiAgICBpZiAoL1thLXpdKy8udGVzdChzdWJ0eXBlKSkge1xuICAgICAgLy8gYWx3YXlzIHVzZSBqcGcgZXh0ZW5zaW9uXG4gICAgICBpZiAoc3VidHlwZSA9PT0gJ2pwZWcnKSB7XG4gICAgICAgIHJldHVybiAnanBnJztcbiAgICAgIH1cblxuICAgICAgLy8gcmV0dXJuIHN1YnR5cGVcbiAgICAgIHJldHVybiBzdWJ0eXBlO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfTtcblxuICB2YXIgbGVmdFBhZCA9IGZ1bmN0aW9uIGxlZnRQYWQodmFsdWUpIHtcbiAgICB2YXIgcGFkZGluZyA9XG4gICAgICBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICcnO1xuICAgIHJldHVybiAocGFkZGluZyArIHZhbHVlKS5zbGljZSgtcGFkZGluZy5sZW5ndGgpO1xuICB9O1xuXG4gIHZhciBnZXREYXRlU3RyaW5nID0gZnVuY3Rpb24gZ2V0RGF0ZVN0cmluZygpIHtcbiAgICB2YXIgZGF0ZSA9XG4gICAgICBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZFxuICAgICAgICA/IGFyZ3VtZW50c1swXVxuICAgICAgICA6IG5ldyBEYXRlKCk7XG4gICAgcmV0dXJuIChcbiAgICAgIGRhdGUuZ2V0RnVsbFllYXIoKSArXG4gICAgICAnLScgK1xuICAgICAgbGVmdFBhZChkYXRlLmdldE1vbnRoKCkgKyAxLCAnMDAnKSArXG4gICAgICAnLScgK1xuICAgICAgbGVmdFBhZChkYXRlLmdldERhdGUoKSwgJzAwJykgK1xuICAgICAgJ18nICtcbiAgICAgIGxlZnRQYWQoZGF0ZS5nZXRIb3VycygpLCAnMDAnKSArXG4gICAgICAnLScgK1xuICAgICAgbGVmdFBhZChkYXRlLmdldE1pbnV0ZXMoKSwgJzAwJykgK1xuICAgICAgJy0nICtcbiAgICAgIGxlZnRQYWQoZGF0ZS5nZXRTZWNvbmRzKCksICcwMCcpXG4gICAgKTtcbiAgfTtcblxuICB2YXIgZ2V0RmlsZUZyb21CbG9iID0gZnVuY3Rpb24gZ2V0RmlsZUZyb21CbG9iKGJsb2IsIGZpbGVuYW1lKSB7XG4gICAgdmFyIHR5cGUgPVxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBudWxsO1xuICAgIHZhciBleHRlbnNpb24gPVxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBudWxsO1xuICAgIHZhciBmaWxlID1cbiAgICAgIHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJ1xuICAgICAgICA/IGJsb2Iuc2xpY2UoMCwgYmxvYi5zaXplLCB0eXBlKVxuICAgICAgICA6IGJsb2Iuc2xpY2UoMCwgYmxvYi5zaXplLCBibG9iLnR5cGUpO1xuICAgIGZpbGUubGFzdE1vZGlmaWVkRGF0ZSA9IG5ldyBEYXRlKCk7XG5cbiAgICAvLyBjb3B5IHJlbGF0aXZlIHBhdGhcbiAgICBpZiAoYmxvYi5fcmVsYXRpdmVQYXRoKSBmaWxlLl9yZWxhdGl2ZVBhdGggPSBibG9iLl9yZWxhdGl2ZVBhdGg7XG5cbiAgICAvLyBpZiBibG9iIGhhcyBuYW1lIHByb3BlcnR5LCB1c2UgYXMgZmlsZW5hbWUgaWYgbm8gZmlsZW5hbWUgc3VwcGxpZWRcbiAgICBpZiAoIWlzU3RyaW5nKGZpbGVuYW1lKSkge1xuICAgICAgZmlsZW5hbWUgPSBnZXREYXRlU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgLy8gaWYgZmlsZW5hbWUgc3VwcGxpZWQgYnV0IG5vIGV4dGVuc2lvbiBhbmQgZmlsZW5hbWUgaGFzIGV4dGVuc2lvblxuICAgIGlmIChmaWxlbmFtZSAmJiBleHRlbnNpb24gPT09IG51bGwgJiYgZ2V0RXh0ZW5zaW9uRnJvbUZpbGVuYW1lKGZpbGVuYW1lKSkge1xuICAgICAgZmlsZS5uYW1lID0gZmlsZW5hbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4dGVuc2lvbiA9IGV4dGVuc2lvbiB8fCBndWVzc3RpbWF0ZUV4dGVuc2lvbihmaWxlLnR5cGUpO1xuICAgICAgZmlsZS5uYW1lID0gZmlsZW5hbWUgKyAoZXh0ZW5zaW9uID8gJy4nICsgZXh0ZW5zaW9uIDogJycpO1xuICAgIH1cblxuICAgIHJldHVybiBmaWxlO1xuICB9O1xuXG4gIHZhciBnZXRCbG9iQnVpbGRlciA9IGZ1bmN0aW9uIGdldEJsb2JCdWlsZGVyKCkge1xuICAgIHJldHVybiAod2luZG93LkJsb2JCdWlsZGVyID1cbiAgICAgIHdpbmRvdy5CbG9iQnVpbGRlciB8fFxuICAgICAgd2luZG93LldlYktpdEJsb2JCdWlsZGVyIHx8XG4gICAgICB3aW5kb3cuTW96QmxvYkJ1aWxkZXIgfHxcbiAgICAgIHdpbmRvdy5NU0Jsb2JCdWlsZGVyKTtcbiAgfTtcblxuICB2YXIgY3JlYXRlQmxvYiA9IGZ1bmN0aW9uIGNyZWF0ZUJsb2IoYXJyYXlCdWZmZXIsIG1pbWVUeXBlKSB7XG4gICAgdmFyIEJCID0gZ2V0QmxvYkJ1aWxkZXIoKTtcblxuICAgIGlmIChCQikge1xuICAgICAgdmFyIGJiID0gbmV3IEJCKCk7XG4gICAgICBiYi5hcHBlbmQoYXJyYXlCdWZmZXIpO1xuICAgICAgcmV0dXJuIGJiLmdldEJsb2IobWltZVR5cGUpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQmxvYihbYXJyYXlCdWZmZXJdLCB7XG4gICAgICB0eXBlOiBtaW1lVHlwZVxuICAgIH0pO1xuICB9O1xuXG4gIHZhciBnZXRCbG9iRnJvbUJ5dGVTdHJpbmdXaXRoTWltZVR5cGUgPSBmdW5jdGlvbiBnZXRCbG9iRnJvbUJ5dGVTdHJpbmdXaXRoTWltZVR5cGUoXG4gICAgYnl0ZVN0cmluZyxcbiAgICBtaW1lVHlwZVxuICApIHtcbiAgICB2YXIgYWIgPSBuZXcgQXJyYXlCdWZmZXIoYnl0ZVN0cmluZy5sZW5ndGgpO1xuICAgIHZhciBpYSA9IG5ldyBVaW50OEFycmF5KGFiKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZVN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgaWFbaV0gPSBieXRlU3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZUJsb2IoYWIsIG1pbWVUeXBlKTtcbiAgfTtcblxuICB2YXIgZ2V0TWltZVR5cGVGcm9tQmFzZTY0RGF0YVVSSSA9IGZ1bmN0aW9uIGdldE1pbWVUeXBlRnJvbUJhc2U2NERhdGFVUkkoXG4gICAgZGF0YVVSSVxuICApIHtcbiAgICByZXR1cm4gKC9eZGF0YTooLispOy8uZXhlYyhkYXRhVVJJKSB8fCBbXSlbMV0gfHwgbnVsbDtcbiAgfTtcblxuICB2YXIgZ2V0QmFzZTY0RGF0YUZyb21CYXNlNjREYXRhVVJJID0gZnVuY3Rpb24gZ2V0QmFzZTY0RGF0YUZyb21CYXNlNjREYXRhVVJJKFxuICAgIGRhdGFVUklcbiAgKSB7XG4gICAgLy8gZ2V0IGRhdGEgcGFydCBvZiBzdHJpbmcgKHJlbW92ZSBkYXRhOmltYWdlL2pwZWcuLi4sKVxuICAgIHZhciBkYXRhID0gZGF0YVVSSS5zcGxpdCgnLCcpWzFdO1xuXG4gICAgLy8gcmVtb3ZlIGFueSB3aGl0ZXNwYWNlIGFzIHRoYXQgY2F1c2VzIEludmFsaWRDaGFyYWN0ZXJFcnJvciBpbiBJRVxuICAgIHJldHVybiBkYXRhLnJlcGxhY2UoL1xccy9nLCAnJyk7XG4gIH07XG5cbiAgdmFyIGdldEJ5dGVTdHJpbmdGcm9tQmFzZTY0RGF0YVVSSSA9IGZ1bmN0aW9uIGdldEJ5dGVTdHJpbmdGcm9tQmFzZTY0RGF0YVVSSShcbiAgICBkYXRhVVJJXG4gICkge1xuICAgIHJldHVybiBhdG9iKGdldEJhc2U2NERhdGFGcm9tQmFzZTY0RGF0YVVSSShkYXRhVVJJKSk7XG4gIH07XG5cbiAgdmFyIGdldEJsb2JGcm9tQmFzZTY0RGF0YVVSSSA9IGZ1bmN0aW9uIGdldEJsb2JGcm9tQmFzZTY0RGF0YVVSSShkYXRhVVJJKSB7XG4gICAgdmFyIG1pbWVUeXBlID0gZ2V0TWltZVR5cGVGcm9tQmFzZTY0RGF0YVVSSShkYXRhVVJJKTtcbiAgICB2YXIgYnl0ZVN0cmluZyA9IGdldEJ5dGVTdHJpbmdGcm9tQmFzZTY0RGF0YVVSSShkYXRhVVJJKTtcblxuICAgIHJldHVybiBnZXRCbG9iRnJvbUJ5dGVTdHJpbmdXaXRoTWltZVR5cGUoYnl0ZVN0cmluZywgbWltZVR5cGUpO1xuICB9O1xuXG4gIHZhciBnZXRGaWxlRnJvbUJhc2U2NERhdGFVUkkgPSBmdW5jdGlvbiBnZXRGaWxlRnJvbUJhc2U2NERhdGFVUkkoXG4gICAgZGF0YVVSSSxcbiAgICBmaWxlbmFtZSxcbiAgICBleHRlbnNpb25cbiAgKSB7XG4gICAgcmV0dXJuIGdldEZpbGVGcm9tQmxvYihcbiAgICAgIGdldEJsb2JGcm9tQmFzZTY0RGF0YVVSSShkYXRhVVJJKSxcbiAgICAgIGZpbGVuYW1lLFxuICAgICAgbnVsbCxcbiAgICAgIGV4dGVuc2lvblxuICAgICk7XG4gIH07XG5cbiAgdmFyIGdldEZpbGVOYW1lRnJvbUhlYWRlciA9IGZ1bmN0aW9uIGdldEZpbGVOYW1lRnJvbUhlYWRlcihoZWFkZXIpIHtcbiAgICAvLyB0ZXN0IGlmIGlzIGNvbnRlbnQgZGlzcG9zaXRpb24gaGVhZGVyLCBpZiBub3QgZXhpdFxuICAgIGlmICghL15jb250ZW50LWRpc3Bvc2l0aW9uOi9pLnRlc3QoaGVhZGVyKSkgcmV0dXJuIG51bGw7XG5cbiAgICAvLyBnZXQgZmlsZW5hbWUgcGFydHNcbiAgICB2YXIgbWF0Y2hlcyA9IGhlYWRlclxuICAgICAgLnNwbGl0KC9maWxlbmFtZT18ZmlsZW5hbWVcXCo9LisnJy8pXG4gICAgICAuc3BsaWNlKDEpXG4gICAgICAubWFwKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5hbWUudHJpbSgpLnJlcGxhY2UoL15bXCInXXxbO1wiJ117MCwyfSQvZywgJycpO1xuICAgICAgfSlcbiAgICAgIC5maWx0ZXIoZnVuY3Rpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gbmFtZS5sZW5ndGg7XG4gICAgICB9KTtcblxuICAgIHJldHVybiBtYXRjaGVzLmxlbmd0aCA/IGRlY29kZVVSSShtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV0pIDogbnVsbDtcbiAgfTtcblxuICB2YXIgZ2V0RmlsZVNpemVGcm9tSGVhZGVyID0gZnVuY3Rpb24gZ2V0RmlsZVNpemVGcm9tSGVhZGVyKGhlYWRlcikge1xuICAgIGlmICgvY29udGVudC1sZW5ndGg6L2kudGVzdChoZWFkZXIpKSB7XG4gICAgICB2YXIgc2l6ZSA9IGhlYWRlci5tYXRjaCgvWzAtOV0rLylbMF07XG4gICAgICByZXR1cm4gc2l6ZSA/IHBhcnNlSW50KHNpemUsIDEwKSA6IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIHZhciBnZXRUcmFuZnNlcklkRnJvbUhlYWRlciA9IGZ1bmN0aW9uIGdldFRyYW5mc2VySWRGcm9tSGVhZGVyKGhlYWRlcikge1xuICAgIGlmICgveC1jb250ZW50LXRyYW5zZmVyLWlkOi9pLnRlc3QoaGVhZGVyKSkge1xuICAgICAgdmFyIGlkID0gKGhlYWRlci5zcGxpdCgnOicpWzFdIHx8ICcnKS50cmltKCk7XG4gICAgICByZXR1cm4gaWQgfHwgbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgdmFyIGdldEZpbGVJbmZvRnJvbUhlYWRlcnMgPSBmdW5jdGlvbiBnZXRGaWxlSW5mb0Zyb21IZWFkZXJzKGhlYWRlcnMpIHtcbiAgICB2YXIgaW5mbyA9IHtcbiAgICAgIHNvdXJjZTogbnVsbCxcbiAgICAgIG5hbWU6IG51bGwsXG4gICAgICBzaXplOiBudWxsXG4gICAgfTtcblxuICAgIHZhciByb3dzID0gaGVhZGVycy5zcGxpdCgnXFxuJyk7XG4gICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICAgIHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcbiAgICB0cnkge1xuICAgICAgZm9yIChcbiAgICAgICAgdmFyIF9pdGVyYXRvciA9IHJvd3NbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDtcbiAgICAgICAgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7XG4gICAgICAgIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlXG4gICAgICApIHtcbiAgICAgICAgdmFyIGhlYWRlciA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICAgIHZhciBuYW1lID0gZ2V0RmlsZU5hbWVGcm9tSGVhZGVyKGhlYWRlcik7XG4gICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgaW5mby5uYW1lID0gbmFtZTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzaXplID0gZ2V0RmlsZVNpemVGcm9tSGVhZGVyKGhlYWRlcik7XG4gICAgICAgIGlmIChzaXplKSB7XG4gICAgICAgICAgaW5mby5zaXplID0gc2l6ZTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzb3VyY2UgPSBnZXRUcmFuZnNlcklkRnJvbUhlYWRlcihoZWFkZXIpO1xuICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgaW5mby5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybiAhPSBudWxsKSB7XG4gICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpbmZvO1xuICB9O1xuXG4gIHZhciBjcmVhdGVGaWxlTG9hZGVyID0gZnVuY3Rpb24gY3JlYXRlRmlsZUxvYWRlcihmZXRjaEZuKSB7XG4gICAgdmFyIHN0YXRlID0ge1xuICAgICAgc291cmNlOiBudWxsLFxuICAgICAgY29tcGxldGU6IGZhbHNlLFxuICAgICAgcHJvZ3Jlc3M6IDAsXG4gICAgICBzaXplOiBudWxsLFxuICAgICAgdGltZXN0YW1wOiBudWxsLFxuICAgICAgZHVyYXRpb246IDAsXG4gICAgICByZXF1ZXN0OiBudWxsXG4gICAgfTtcblxuICAgIHZhciBnZXRQcm9ncmVzcyA9IGZ1bmN0aW9uIGdldFByb2dyZXNzKCkge1xuICAgICAgcmV0dXJuIHN0YXRlLnByb2dyZXNzO1xuICAgIH07XG4gICAgdmFyIGFib3J0ID0gZnVuY3Rpb24gYWJvcnQoKSB7XG4gICAgICBpZiAoc3RhdGUucmVxdWVzdCAmJiBzdGF0ZS5yZXF1ZXN0LmFib3J0KSB7XG4gICAgICAgIHN0YXRlLnJlcXVlc3QuYWJvcnQoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gbG9hZCBzb3VyY2VcbiAgICB2YXIgbG9hZCA9IGZ1bmN0aW9uIGxvYWQoKSB7XG4gICAgICAvLyBnZXQgcXVpY2sgcmVmZXJlbmNlXG4gICAgICB2YXIgc291cmNlID0gc3RhdGUuc291cmNlO1xuXG4gICAgICBhcGkuZmlyZSgnaW5pdCcsIHNvdXJjZSk7XG5cbiAgICAgIC8vIExvYWQgRmlsZXNcbiAgICAgIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBGaWxlKSB7XG4gICAgICAgIGFwaS5maXJlKCdsb2FkJywgc291cmNlKTtcbiAgICAgIH0gZWxzZSBpZiAoc291cmNlIGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICAvLyBMb2FkIGJsb2JzLCBzZXQgZGVmYXVsdCBuYW1lIHRvIGN1cnJlbnQgZGF0ZVxuICAgICAgICBhcGkuZmlyZSgnbG9hZCcsIGdldEZpbGVGcm9tQmxvYihzb3VyY2UsIHNvdXJjZS5uYW1lKSk7XG4gICAgICB9IGVsc2UgaWYgKGlzQmFzZTY0RGF0YVVSSShzb3VyY2UpKSB7XG4gICAgICAgIC8vIExvYWQgYmFzZSA2NCwgc2V0IGRlZmF1bHQgbmFtZSB0byBjdXJyZW50IGRhdGVcbiAgICAgICAgYXBpLmZpcmUoJ2xvYWQnLCBnZXRGaWxlRnJvbUJhc2U2NERhdGFVUkkoc291cmNlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBEZWFsIGFzIGlmIGlzIGV4dGVybmFsIFVSTCwgbGV0J3MgbG9hZCBpdCFcbiAgICAgICAgbG9hZFVSTChzb3VyY2UpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBsb2FkcyBhIHVybFxuICAgIHZhciBsb2FkVVJMID0gZnVuY3Rpb24gbG9hZFVSTCh1cmwpIHtcbiAgICAgIC8vIGlzIHJlbW90ZSB1cmwgYW5kIG5vIGZldGNoIG1ldGhvZCBzdXBwbGllZFxuICAgICAgaWYgKCFmZXRjaEZuKSB7XG4gICAgICAgIGFwaS5maXJlKCdlcnJvcicsIHtcbiAgICAgICAgICB0eXBlOiAnZXJyb3InLFxuICAgICAgICAgIGJvZHk6IFwiQ2FuJ3QgbG9hZCBVUkxcIixcbiAgICAgICAgICBjb2RlOiA0MDBcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBzZXQgcmVxdWVzdCBzdGFydFxuICAgICAgc3RhdGUudGltZXN0YW1wID0gRGF0ZS5ub3coKTtcblxuICAgICAgLy8gbG9hZCBmaWxlXG4gICAgICBzdGF0ZS5yZXF1ZXN0ID0gZmV0Y2hGbihcbiAgICAgICAgdXJsLFxuICAgICAgICBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgIC8vIHVwZGF0ZSBkdXJhdGlvblxuICAgICAgICAgIHN0YXRlLmR1cmF0aW9uID0gRGF0ZS5ub3coKSAtIHN0YXRlLnRpbWVzdGFtcDtcblxuICAgICAgICAgIC8vIGRvbmUhXG4gICAgICAgICAgc3RhdGUuY29tcGxldGUgPSB0cnVlO1xuXG4gICAgICAgICAgLy8gdHVybiBibG9iIHJlc3BvbnNlIGludG8gYSBmaWxlXG4gICAgICAgICAgaWYgKHJlc3BvbnNlIGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICAgICAgcmVzcG9uc2UgPSBnZXRGaWxlRnJvbUJsb2IoXG4gICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICByZXNwb25zZS5uYW1lIHx8IGdldEZpbGVuYW1lRnJvbVVSTCh1cmwpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGFwaS5maXJlKFxuICAgICAgICAgICAgJ2xvYWQnLFxuICAgICAgICAgICAgLy8gaWYgaGFzIHJlY2VpdmVkIGJsb2IsIHdlIGdvIHdpdGggYmxvYiwgaWYgbm8gcmVzcG9uc2UsIHdlIHJldHVybiBudWxsXG4gICAgICAgICAgICByZXNwb25zZSBpbnN0YW5jZW9mIEJsb2JcbiAgICAgICAgICAgICAgPyByZXNwb25zZVxuICAgICAgICAgICAgICA6IHJlc3BvbnNlXG4gICAgICAgICAgICAgID8gcmVzcG9uc2UuYm9keVxuICAgICAgICAgICAgICA6IG51bGxcbiAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgIGFwaS5maXJlKFxuICAgICAgICAgICAgJ2Vycm9yJyxcbiAgICAgICAgICAgIHR5cGVvZiBlcnJvciA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiAnZXJyb3InLFxuICAgICAgICAgICAgICAgICAgY29kZTogMCxcbiAgICAgICAgICAgICAgICAgIGJvZHk6IGVycm9yXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICA6IGVycm9yXG4gICAgICAgICAgKTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24oY29tcHV0YWJsZSwgY3VycmVudCwgdG90YWwpIHtcbiAgICAgICAgICAvLyBjb2xsZWN0ZWQgc29tZSBtZXRhIGRhdGEgYWxyZWFkeVxuICAgICAgICAgIGlmICh0b3RhbCkge1xuICAgICAgICAgICAgc3RhdGUuc2l6ZSA9IHRvdGFsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHVwZGF0ZSBkdXJhdGlvblxuICAgICAgICAgIHN0YXRlLmR1cmF0aW9uID0gRGF0ZS5ub3coKSAtIHN0YXRlLnRpbWVzdGFtcDtcblxuICAgICAgICAgIC8vIGlmIHdlIGNhbid0IGNvbXB1dGUgcHJvZ3Jlc3MsIHdlJ3JlIG5vdCBnb2luZyB0byBmaXJlIHByb2dyZXNzIGV2ZW50c1xuICAgICAgICAgIGlmICghY29tcHV0YWJsZSkge1xuICAgICAgICAgICAgc3RhdGUucHJvZ3Jlc3MgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHVwZGF0ZSBwcm9ncmVzcyBwZXJjZW50YWdlXG4gICAgICAgICAgc3RhdGUucHJvZ3Jlc3MgPSBjdXJyZW50IC8gdG90YWw7XG5cbiAgICAgICAgICAvLyBleHBvc2VcbiAgICAgICAgICBhcGkuZmlyZSgncHJvZ3Jlc3MnLCBzdGF0ZS5wcm9ncmVzcyk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGFwaS5maXJlKCdhYm9ydCcpO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgIHZhciBmaWxlaW5mbyA9IGdldEZpbGVJbmZvRnJvbUhlYWRlcnMoXG4gICAgICAgICAgICB0eXBlb2YgcmVzcG9uc2UgPT09ICdzdHJpbmcnID8gcmVzcG9uc2UgOiByZXNwb25zZS5oZWFkZXJzXG4gICAgICAgICAgKTtcbiAgICAgICAgICBhcGkuZmlyZSgnbWV0YScsIHtcbiAgICAgICAgICAgIHNpemU6IHN0YXRlLnNpemUgfHwgZmlsZWluZm8uc2l6ZSxcbiAgICAgICAgICAgIGZpbGVuYW1lOiBmaWxlaW5mby5uYW1lLFxuICAgICAgICAgICAgc291cmNlOiBmaWxlaW5mby5zb3VyY2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgdmFyIGFwaSA9IE9iamVjdC5hc3NpZ24oe30sIG9uKCksIHtcbiAgICAgIHNldFNvdXJjZTogZnVuY3Rpb24gc2V0U291cmNlKHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gKHN0YXRlLnNvdXJjZSA9IHNvdXJjZSk7XG4gICAgICB9LFxuICAgICAgZ2V0UHJvZ3Jlc3M6IGdldFByb2dyZXNzLCAvLyBmaWxlIGxvYWQgcHJvZ3Jlc3NcbiAgICAgIGFib3J0OiBhYm9ydCwgLy8gYWJvcnQgZmlsZSBsb2FkXG4gICAgICBsb2FkOiBsb2FkIC8vIHN0YXJ0IGxvYWRcbiAgICB9KTtcblxuICAgIHJldHVybiBhcGk7XG4gIH07XG5cbiAgdmFyIGlzR2V0ID0gZnVuY3Rpb24gaXNHZXQobWV0aG9kKSB7XG4gICAgcmV0dXJuIC9HRVR8SEVBRC8udGVzdChtZXRob2QpO1xuICB9O1xuXG4gIHZhciBzZW5kUmVxdWVzdCA9IGZ1bmN0aW9uIHNlbmRSZXF1ZXN0KGRhdGEsIHVybCwgb3B0aW9ucykge1xuICAgIHZhciBhcGkgPSB7XG4gICAgICBvbmhlYWRlcnM6IGZ1bmN0aW9uIG9uaGVhZGVycygpIHt9LFxuICAgICAgb25wcm9ncmVzczogZnVuY3Rpb24gb25wcm9ncmVzcygpIHt9LFxuICAgICAgb25sb2FkOiBmdW5jdGlvbiBvbmxvYWQoKSB7fSxcbiAgICAgIG9udGltZW91dDogZnVuY3Rpb24gb250aW1lb3V0KCkge30sXG4gICAgICBvbmVycm9yOiBmdW5jdGlvbiBvbmVycm9yKCkge30sXG4gICAgICBvbmFib3J0OiBmdW5jdGlvbiBvbmFib3J0KCkge30sXG4gICAgICBhYm9ydDogZnVuY3Rpb24gYWJvcnQoKSB7XG4gICAgICAgIGFib3J0ZWQgPSB0cnVlO1xuICAgICAgICB4aHIuYWJvcnQoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gdGltZW91dCBpZGVudGlmaWVyLCBvbmx5IHVzZWQgd2hlbiB0aW1lb3V0IGlzIGRlZmluZWRcbiAgICB2YXIgYWJvcnRlZCA9IGZhbHNlO1xuICAgIHZhciBoZWFkZXJzUmVjZWl2ZWQgPSBmYWxzZTtcblxuICAgIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbihcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgICB3aXRoQ3JlZGVudGlhbHM6IGZhbHNlXG4gICAgICB9LFxuICAgICAgb3B0aW9uc1xuICAgICk7XG5cbiAgICAvLyBlbmNvZGUgdXJsXG4gICAgdXJsID0gZW5jb2RlVVJJKHVybCk7XG5cbiAgICAvLyBpZiBtZXRob2QgaXMgR0VULCBhZGQgYW55IHJlY2VpdmVkIGRhdGEgdG8gdXJsXG5cbiAgICBpZiAoaXNHZXQob3B0aW9ucy5tZXRob2QpICYmIGRhdGEpIHtcbiAgICAgIHVybCA9XG4gICAgICAgICcnICtcbiAgICAgICAgdXJsICtcbiAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KFxuICAgICAgICAgIHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyA/IGRhdGEgOiBKU09OLnN0cmluZ2lmeShkYXRhKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSByZXF1ZXN0XG4gICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgLy8gcHJvZ3Jlc3Mgb2YgbG9hZFxuICAgIHZhciBwcm9jZXNzID0gaXNHZXQob3B0aW9ucy5tZXRob2QpID8geGhyIDogeGhyLnVwbG9hZDtcbiAgICBwcm9jZXNzLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbihlKSB7XG4gICAgICAvLyBubyBwcm9ncmVzcyBldmVudCB3aGVuIGFib3J0ZWQgKCBvbnByb2dyZXNzIGlzIGNhbGxlZCBvbmNlIGFmdGVyIGFib3J0KCkgKVxuICAgICAgaWYgKGFib3J0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBhcGkub25wcm9ncmVzcyhlLmxlbmd0aENvbXB1dGFibGUsIGUubG9hZGVkLCBlLnRvdGFsKTtcbiAgICB9O1xuXG4gICAgLy8gdHJpZXMgdG8gZ2V0IGhlYWRlciBpbmZvIHRvIHRoZSBhcHAgYXMgZmFzdCBhcyBwb3NzaWJsZVxuICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIC8vIG5vdCBpbnRlcmVzdGluZyBpbiB0aGVzZSBzdGF0ZXMgKCd1bnNlbnQnIGFuZCAnb3BlbmVuZCcgYXMgdGhleSBkb24ndCBnaXZlIHVzIGFueSBhZGRpdGlvbmFsIGluZm8pXG4gICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPCAyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gbm8gc2VydmVyIHJlc3BvbnNlXG4gICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQgJiYgeGhyLnN0YXR1cyA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChoZWFkZXJzUmVjZWl2ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBoZWFkZXJzUmVjZWl2ZWQgPSB0cnVlO1xuXG4gICAgICAvLyB3ZSd2ZSBwcm9iYWJseSByZWNlaXZlZCBzb21lIHVzZWZ1bCBkYXRhIGluIHJlc3BvbnNlIGhlYWRlcnNcbiAgICAgIGFwaS5vbmhlYWRlcnMoeGhyKTtcbiAgICB9O1xuXG4gICAgLy8gbG9hZCBzdWNjZXNzZnVsXG4gICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gaXMgY2xhc3NpZmllZCBhcyB2YWxpZCByZXNwb25zZVxuICAgICAgaWYgKHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPCAzMDApIHtcbiAgICAgICAgYXBpLm9ubG9hZCh4aHIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXBpLm9uZXJyb3IoeGhyKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gZXJyb3IgZHVyaW5nIGxvYWRcbiAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGFwaS5vbmVycm9yKHhocik7XG4gICAgfTtcblxuICAgIC8vIHJlcXVlc3QgYWJvcnRlZFxuICAgIHhoci5vbmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgICBhYm9ydGVkID0gdHJ1ZTtcbiAgICAgIGFwaS5vbmFib3J0KCk7XG4gICAgfTtcblxuICAgIC8vIHJlcXVlc3QgdGltZW91dFxuICAgIHhoci5vbnRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBhcGkub250aW1lb3V0KHhocik7XG4gICAgfTtcblxuICAgIC8vIG9wZW4gdXAgb3BlbiB1cCFcbiAgICB4aHIub3BlbihvcHRpb25zLm1ldGhvZCwgdXJsLCB0cnVlKTtcblxuICAgIC8vIHNldCB0aW1lb3V0IGlmIGRlZmluZWQgKGRvIGl0IGFmdGVyIG9wZW4gc28gSUUxMSBwbGF5cyBiYWxsKVxuICAgIGlmIChpc0ludChvcHRpb25zLnRpbWVvdXQpKSB7XG4gICAgICB4aHIudGltZW91dCA9IG9wdGlvbnMudGltZW91dDtcbiAgICB9XG5cbiAgICAvLyBhZGQgaGVhZGVyc1xuICAgIE9iamVjdC5rZXlzKG9wdGlvbnMuaGVhZGVycykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChvcHRpb25zLmhlYWRlcnNba2V5XSkpO1xuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWx1ZSk7XG4gICAgfSk7XG5cbiAgICAvLyBzZXQgdHlwZSBvZiByZXNwb25zZVxuICAgIGlmIChvcHRpb25zLnJlc3BvbnNlVHlwZSkge1xuICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9IG9wdGlvbnMucmVzcG9uc2VUeXBlO1xuICAgIH1cblxuICAgIC8vIHNldCBjcmVkZW50aWFsc1xuICAgIGlmIChvcHRpb25zLndpdGhDcmVkZW50aWFscykge1xuICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gbGV0J3Mgc2VuZCBvdXIgZGF0YVxuICAgIHhoci5zZW5kKGRhdGEpO1xuXG4gICAgcmV0dXJuIGFwaTtcbiAgfTtcblxuICB2YXIgY3JlYXRlUmVzcG9uc2UgPSBmdW5jdGlvbiBjcmVhdGVSZXNwb25zZSh0eXBlLCBjb2RlLCBib2R5LCBoZWFkZXJzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBjb2RlOiBjb2RlLFxuICAgICAgYm9keTogYm9keSxcbiAgICAgIGhlYWRlcnM6IGhlYWRlcnNcbiAgICB9O1xuICB9O1xuXG4gIHZhciBjcmVhdGVUaW1lb3V0UmVzcG9uc2UgPSBmdW5jdGlvbiBjcmVhdGVUaW1lb3V0UmVzcG9uc2UoY2IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oeGhyKSB7XG4gICAgICBjYihjcmVhdGVSZXNwb25zZSgnZXJyb3InLCAwLCAnVGltZW91dCcsIHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSkpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGhhc1FTID0gZnVuY3Rpb24gaGFzUVMoc3RyKSB7XG4gICAgcmV0dXJuIC9cXD8vLnRlc3Qoc3RyKTtcbiAgfTtcbiAgdmFyIGJ1aWxkVVJMID0gZnVuY3Rpb24gYnVpbGRVUkwoKSB7XG4gICAgdmFyIHVybCA9ICcnO1xuICAgIGZvciAoXG4gICAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHBhcnRzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDtcbiAgICAgIF9rZXkgPCBfbGVuO1xuICAgICAgX2tleSsrXG4gICAgKSB7XG4gICAgICBwYXJ0c1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG4gICAgcGFydHMuZm9yRWFjaChmdW5jdGlvbihwYXJ0KSB7XG4gICAgICB1cmwgKz0gaGFzUVModXJsKSAmJiBoYXNRUyhwYXJ0KSA/IHBhcnQucmVwbGFjZSgvXFw/LywgJyYnKSA6IHBhcnQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIHVybDtcbiAgfTtcblxuICB2YXIgY3JlYXRlRmV0Y2hGdW5jdGlvbiA9IGZ1bmN0aW9uIGNyZWF0ZUZldGNoRnVuY3Rpb24oKSB7XG4gICAgdmFyIGFwaVVybCA9XG4gICAgICBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICcnO1xuICAgIHZhciBhY3Rpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICAvLyBjdXN0b20gaGFuZGxlciAoc2hvdWxkIGFsc28gaGFuZGxlIGZpbGUsIGxvYWQsIGVycm9yLCBwcm9ncmVzcyBhbmQgYWJvcnQpXG4gICAgaWYgKHR5cGVvZiBhY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBhY3Rpb247XG4gICAgfVxuXG4gICAgLy8gbm8gYWN0aW9uIHN1cHBsaWVkXG4gICAgaWYgKCFhY3Rpb24gfHwgIWlzU3RyaW5nKGFjdGlvbi51cmwpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBzZXQgb25sb2FkIGhhbmxkZXJcbiAgICB2YXIgb25sb2FkID1cbiAgICAgIGFjdGlvbi5vbmxvYWQgfHxcbiAgICAgIGZ1bmN0aW9uKHJlcykge1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfTtcbiAgICB2YXIgb25lcnJvciA9XG4gICAgICBhY3Rpb24ub25lcnJvciB8fFxuICAgICAgZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcblxuICAgIC8vIGludGVybmFsIGhhbmRsZXJcbiAgICByZXR1cm4gZnVuY3Rpb24odXJsLCBsb2FkLCBlcnJvciwgcHJvZ3Jlc3MsIGFib3J0LCBoZWFkZXJzKSB7XG4gICAgICAvLyBkbyBsb2NhbCBvciByZW1vdGUgcmVxdWVzdCBiYXNlZCBvbiBpZiB0aGUgdXJsIGlzIGV4dGVybmFsXG4gICAgICB2YXIgcmVxdWVzdCA9IHNlbmRSZXF1ZXN0KFxuICAgICAgICB1cmwsXG4gICAgICAgIGJ1aWxkVVJMKGFwaVVybCwgYWN0aW9uLnVybCksXG4gICAgICAgIE9iamVjdC5hc3NpZ24oe30sIGFjdGlvbiwge1xuICAgICAgICAgIHJlc3BvbnNlVHlwZTogJ2Jsb2InXG4gICAgICAgIH0pXG4gICAgICApO1xuXG4gICAgICByZXF1ZXN0Lm9ubG9hZCA9IGZ1bmN0aW9uKHhocikge1xuICAgICAgICAvLyBnZXQgaGVhZGVyc1xuICAgICAgICB2YXIgaGVhZGVycyA9IHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKTtcblxuICAgICAgICAvLyBnZXQgZmlsZW5hbWVcbiAgICAgICAgdmFyIGZpbGVuYW1lID1cbiAgICAgICAgICBnZXRGaWxlSW5mb0Zyb21IZWFkZXJzKGhlYWRlcnMpLm5hbWUgfHwgZ2V0RmlsZW5hbWVGcm9tVVJMKHVybCk7XG5cbiAgICAgICAgLy8gY3JlYXRlIHJlc3BvbnNlXG4gICAgICAgIGxvYWQoXG4gICAgICAgICAgY3JlYXRlUmVzcG9uc2UoXG4gICAgICAgICAgICAnbG9hZCcsXG4gICAgICAgICAgICB4aHIuc3RhdHVzLFxuICAgICAgICAgICAgYWN0aW9uLm1ldGhvZCA9PT0gJ0hFQUQnXG4gICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICA6IGdldEZpbGVGcm9tQmxvYihvbmxvYWQoeGhyLnJlc3BvbnNlKSwgZmlsZW5hbWUpLFxuICAgICAgICAgICAgaGVhZGVyc1xuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH07XG5cbiAgICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uKHhocikge1xuICAgICAgICBlcnJvcihcbiAgICAgICAgICBjcmVhdGVSZXNwb25zZShcbiAgICAgICAgICAgICdlcnJvcicsXG4gICAgICAgICAgICB4aHIuc3RhdHVzLFxuICAgICAgICAgICAgb25lcnJvcih4aHIucmVzcG9uc2UpIHx8IHhoci5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfTtcblxuICAgICAgcmVxdWVzdC5vbmhlYWRlcnMgPSBmdW5jdGlvbih4aHIpIHtcbiAgICAgICAgaGVhZGVycyhcbiAgICAgICAgICBjcmVhdGVSZXNwb25zZShcbiAgICAgICAgICAgICdoZWFkZXJzJyxcbiAgICAgICAgICAgIHhoci5zdGF0dXMsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfTtcblxuICAgICAgcmVxdWVzdC5vbnRpbWVvdXQgPSBjcmVhdGVUaW1lb3V0UmVzcG9uc2UoZXJyb3IpO1xuICAgICAgcmVxdWVzdC5vbnByb2dyZXNzID0gcHJvZ3Jlc3M7XG4gICAgICByZXF1ZXN0Lm9uYWJvcnQgPSBhYm9ydDtcblxuICAgICAgLy8gc2hvdWxkIHJldHVybiByZXF1ZXN0XG4gICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBDaHVua1N0YXR1cyA9IHtcbiAgICBRVUVVRUQ6IDAsXG4gICAgQ09NUExFVEU6IDEsXG4gICAgUFJPQ0VTU0lORzogMixcbiAgICBFUlJPUjogMyxcbiAgICBXQUlUSU5HOiA0XG4gIH07XG5cbiAgLypcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBzaWduYXR1cmU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZmlsZSwgbWV0YWRhdGEsIGxvYWQsIGVycm9yLCBwcm9ncmVzcywgYWJvcnQsIHRyYW5zZmVyLCBvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0OigpID0+IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cbiAgLy8gYXBpVXJsLCBhY3Rpb24sIG5hbWUsIGZpbGUsIG1ldGFkYXRhLCBsb2FkLCBlcnJvciwgcHJvZ3Jlc3MsIGFib3J0LCB0cmFuc2Zlciwgb3B0aW9uc1xuICB2YXIgcHJvY2Vzc0ZpbGVDaHVua2VkID0gZnVuY3Rpb24gcHJvY2Vzc0ZpbGVDaHVua2VkKFxuICAgIGFwaVVybCxcbiAgICBhY3Rpb24sXG4gICAgbmFtZSxcbiAgICBmaWxlLFxuICAgIG1ldGFkYXRhLFxuICAgIGxvYWQsXG4gICAgZXJyb3IsXG4gICAgcHJvZ3Jlc3MsXG4gICAgYWJvcnQsXG4gICAgdHJhbnNmZXIsXG4gICAgb3B0aW9uc1xuICApIHtcbiAgICAvLyBhbGwgY2h1bmtzXG4gICAgdmFyIGNodW5rcyA9IFtdO1xuICAgIHZhciBjaHVua1RyYW5zZmVySWQgPSBvcHRpb25zLmNodW5rVHJhbnNmZXJJZCxcbiAgICAgIGNodW5rU2VydmVyID0gb3B0aW9ucy5jaHVua1NlcnZlcixcbiAgICAgIGNodW5rU2l6ZSA9IG9wdGlvbnMuY2h1bmtTaXplLFxuICAgICAgY2h1bmtSZXRyeURlbGF5cyA9IG9wdGlvbnMuY2h1bmtSZXRyeURlbGF5cztcblxuICAgIC8vIGRlZmF1bHQgc3RhdGVcbiAgICB2YXIgc3RhdGUgPSB7XG4gICAgICBzZXJ2ZXJJZDogY2h1bmtUcmFuc2ZlcklkLFxuICAgICAgYWJvcnRlZDogZmFsc2VcbiAgICB9O1xuXG4gICAgLy8gc2V0IG9ubG9hZCBoYW5kbGVyc1xuICAgIHZhciBvbmRhdGEgPVxuICAgICAgYWN0aW9uLm9uZGF0YSB8fFxuICAgICAgZnVuY3Rpb24oZmQpIHtcbiAgICAgICAgcmV0dXJuIGZkO1xuICAgICAgfTtcbiAgICB2YXIgb25sb2FkID1cbiAgICAgIGFjdGlvbi5vbmxvYWQgfHxcbiAgICAgIGZ1bmN0aW9uKHhociwgbWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBtZXRob2QgPT09ICdIRUFEJ1xuICAgICAgICAgID8geGhyLmdldFJlc3BvbnNlSGVhZGVyKCdVcGxvYWQtT2Zmc2V0JylcbiAgICAgICAgICA6IHhoci5yZXNwb25zZTtcbiAgICAgIH07XG4gICAgdmFyIG9uZXJyb3IgPVxuICAgICAgYWN0aW9uLm9uZXJyb3IgfHxcbiAgICAgIGZ1bmN0aW9uKHJlcykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG5cbiAgICAvLyBjcmVhdGUgc2VydmVyIGhvb2tcbiAgICB2YXIgcmVxdWVzdFRyYW5zZmVySWQgPSBmdW5jdGlvbiByZXF1ZXN0VHJhbnNmZXJJZChjYikge1xuICAgICAgdmFyIGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG5cbiAgICAgIC8vIGFkZCBtZXRhZGF0YSB1bmRlciBzYW1lIG5hbWVcbiAgICAgIGlmIChpc09iamVjdChtZXRhZGF0YSkpIGZvcm1EYXRhLmFwcGVuZChuYW1lLCBKU09OLnN0cmluZ2lmeShtZXRhZGF0YSkpO1xuXG4gICAgICB2YXIgaGVhZGVycyA9XG4gICAgICAgIHR5cGVvZiBhY3Rpb24uaGVhZGVycyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgID8gYWN0aW9uLmhlYWRlcnMoZmlsZSwgbWV0YWRhdGEpXG4gICAgICAgICAgOiBPYmplY3QuYXNzaWduKHt9LCBhY3Rpb24uaGVhZGVycywge1xuICAgICAgICAgICAgICAnVXBsb2FkLUxlbmd0aCc6IGZpbGUuc2l6ZVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgIHZhciByZXF1ZXN0UGFyYW1zID0gT2JqZWN0LmFzc2lnbih7fSwgYWN0aW9uLCB7XG4gICAgICAgIGhlYWRlcnM6IGhlYWRlcnNcbiAgICAgIH0pO1xuXG4gICAgICAvLyBzZW5kIHJlcXVlc3Qgb2JqZWN0XG4gICAgICB2YXIgcmVxdWVzdCA9IHNlbmRSZXF1ZXN0KFxuICAgICAgICBvbmRhdGEoZm9ybURhdGEpLFxuICAgICAgICBidWlsZFVSTChhcGlVcmwsIGFjdGlvbi51cmwpLFxuICAgICAgICByZXF1ZXN0UGFyYW1zXG4gICAgICApO1xuXG4gICAgICByZXF1ZXN0Lm9ubG9hZCA9IGZ1bmN0aW9uKHhocikge1xuICAgICAgICByZXR1cm4gY2Iob25sb2FkKHhociwgcmVxdWVzdFBhcmFtcy5tZXRob2QpKTtcbiAgICAgIH07XG5cbiAgICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uKHhocikge1xuICAgICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgICAgY3JlYXRlUmVzcG9uc2UoXG4gICAgICAgICAgICAnZXJyb3InLFxuICAgICAgICAgICAgeGhyLnN0YXR1cyxcbiAgICAgICAgICAgIG9uZXJyb3IoeGhyLnJlc3BvbnNlKSB8fCB4aHIuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgIHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH07XG5cbiAgICAgIHJlcXVlc3Qub250aW1lb3V0ID0gY3JlYXRlVGltZW91dFJlc3BvbnNlKGVycm9yKTtcbiAgICB9O1xuXG4gICAgdmFyIHJlcXVlc3RUcmFuc2Zlck9mZnNldCA9IGZ1bmN0aW9uIHJlcXVlc3RUcmFuc2Zlck9mZnNldChjYikge1xuICAgICAgdmFyIHJlcXVlc3RVcmwgPSBidWlsZFVSTChhcGlVcmwsIGNodW5rU2VydmVyLnVybCwgc3RhdGUuc2VydmVySWQpO1xuXG4gICAgICB2YXIgaGVhZGVycyA9XG4gICAgICAgIHR5cGVvZiBhY3Rpb24uaGVhZGVycyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgID8gYWN0aW9uLmhlYWRlcnMoc3RhdGUuc2VydmVySWQpXG4gICAgICAgICAgOiBPYmplY3QuYXNzaWduKHt9LCBhY3Rpb24uaGVhZGVycyk7XG5cbiAgICAgIHZhciByZXF1ZXN0UGFyYW1zID0ge1xuICAgICAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgICAgICBtZXRob2Q6ICdIRUFEJ1xuICAgICAgfTtcblxuICAgICAgdmFyIHJlcXVlc3QgPSBzZW5kUmVxdWVzdChudWxsLCByZXF1ZXN0VXJsLCByZXF1ZXN0UGFyYW1zKTtcblxuICAgICAgcmVxdWVzdC5vbmxvYWQgPSBmdW5jdGlvbih4aHIpIHtcbiAgICAgICAgcmV0dXJuIGNiKG9ubG9hZCh4aHIsIHJlcXVlc3RQYXJhbXMubWV0aG9kKSk7XG4gICAgICB9O1xuXG4gICAgICByZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbih4aHIpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yKFxuICAgICAgICAgIGNyZWF0ZVJlc3BvbnNlKFxuICAgICAgICAgICAgJ2Vycm9yJyxcbiAgICAgICAgICAgIHhoci5zdGF0dXMsXG4gICAgICAgICAgICBvbmVycm9yKHhoci5yZXNwb25zZSkgfHwgeGhyLnN0YXR1c1RleHQsXG4gICAgICAgICAgICB4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKClcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9O1xuXG4gICAgICByZXF1ZXN0Lm9udGltZW91dCA9IGNyZWF0ZVRpbWVvdXRSZXNwb25zZShlcnJvcik7XG4gICAgfTtcblxuICAgIC8vIGNyZWF0ZSBjaHVua3NcbiAgICB2YXIgbGFzdENodW5rSW5kZXggPSBNYXRoLmZsb29yKGZpbGUuc2l6ZSAvIGNodW5rU2l6ZSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gbGFzdENodW5rSW5kZXg7IGkrKykge1xuICAgICAgdmFyIG9mZnNldCA9IGkgKiBjaHVua1NpemU7XG4gICAgICB2YXIgZGF0YSA9IGZpbGUuc2xpY2UoXG4gICAgICAgIG9mZnNldCxcbiAgICAgICAgb2Zmc2V0ICsgY2h1bmtTaXplLFxuICAgICAgICAnYXBwbGljYXRpb24vb2Zmc2V0K29jdGV0LXN0cmVhbSdcbiAgICAgICk7XG4gICAgICBjaHVua3NbaV0gPSB7XG4gICAgICAgIGluZGV4OiBpLFxuICAgICAgICBzaXplOiBkYXRhLnNpemUsXG4gICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICBmaWxlOiBmaWxlLFxuICAgICAgICBwcm9ncmVzczogMCxcbiAgICAgICAgcmV0cmllczogX3RvQ29uc3VtYWJsZUFycmF5KGNodW5rUmV0cnlEZWxheXMpLFxuICAgICAgICBzdGF0dXM6IENodW5rU3RhdHVzLlFVRVVFRCxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgIHJlcXVlc3Q6IG51bGwsXG4gICAgICAgIHRpbWVvdXQ6IG51bGxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGNvbXBsZXRlUHJvY2Vzc2luZ0NodW5rcyA9IGZ1bmN0aW9uIGNvbXBsZXRlUHJvY2Vzc2luZ0NodW5rcygpIHtcbiAgICAgIHJldHVybiBsb2FkKHN0YXRlLnNlcnZlcklkKTtcbiAgICB9O1xuXG4gICAgdmFyIGNhblByb2Nlc3NDaHVuayA9IGZ1bmN0aW9uIGNhblByb2Nlc3NDaHVuayhjaHVuaykge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgY2h1bmsuc3RhdHVzID09PSBDaHVua1N0YXR1cy5RVUVVRUQgfHxcbiAgICAgICAgY2h1bmsuc3RhdHVzID09PSBDaHVua1N0YXR1cy5FUlJPUlxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgdmFyIHByb2Nlc3NDaHVuayA9IGZ1bmN0aW9uIHByb2Nlc3NDaHVuayhjaHVuaykge1xuICAgICAgLy8gcHJvY2Vzc2luZyBpcyBwYXVzZWQsIHdhaXQgaGVyZVxuICAgICAgaWYgKHN0YXRlLmFib3J0ZWQpIHJldHVybjtcblxuICAgICAgLy8gZ2V0IG5leHQgY2h1bmsgdG8gcHJvY2Vzc1xuICAgICAgY2h1bmsgPSBjaHVuayB8fCBjaHVua3MuZmluZChjYW5Qcm9jZXNzQ2h1bmspO1xuXG4gICAgICAvLyBubyBtb3JlIGNodW5rcyB0byBwcm9jZXNzXG4gICAgICBpZiAoIWNodW5rKSB7XG4gICAgICAgIC8vIGFsbCBkb25lP1xuICAgICAgICBpZiAoXG4gICAgICAgICAgY2h1bmtzLmV2ZXJ5KGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgICAgICAgICByZXR1cm4gY2h1bmsuc3RhdHVzID09PSBDaHVua1N0YXR1cy5DT01QTEVURTtcbiAgICAgICAgICB9KVxuICAgICAgICApIHtcbiAgICAgICAgICBjb21wbGV0ZVByb2Nlc3NpbmdDaHVua3MoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5vIGNodW5rIHRvIGhhbmRsZVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIG5vdyBwcm9jZXNzaW5nIHRoaXMgY2h1bmtcbiAgICAgIGNodW5rLnN0YXR1cyA9IENodW5rU3RhdHVzLlBST0NFU1NJTkc7XG4gICAgICBjaHVuay5wcm9ncmVzcyA9IG51bGw7XG5cbiAgICAgIC8vIGFsbG93IHBhcnNpbmcgb2YgZm9ybWRhdGFcbiAgICAgIHZhciBvbmRhdGEgPVxuICAgICAgICBjaHVua1NlcnZlci5vbmRhdGEgfHxcbiAgICAgICAgZnVuY3Rpb24oZmQpIHtcbiAgICAgICAgICByZXR1cm4gZmQ7XG4gICAgICAgIH07XG4gICAgICB2YXIgb25lcnJvciA9XG4gICAgICAgIGNodW5rU2VydmVyLm9uZXJyb3IgfHxcbiAgICAgICAgZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG5cbiAgICAgIC8vIHNlbmQgcmVxdWVzdCBvYmplY3RcbiAgICAgIHZhciByZXF1ZXN0VXJsID0gYnVpbGRVUkwoYXBpVXJsLCBjaHVua1NlcnZlci51cmwsIHN0YXRlLnNlcnZlcklkKTtcblxuICAgICAgdmFyIGhlYWRlcnMgPVxuICAgICAgICB0eXBlb2YgY2h1bmtTZXJ2ZXIuaGVhZGVycyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgID8gY2h1bmtTZXJ2ZXIuaGVhZGVycyhjaHVuaylcbiAgICAgICAgICA6IE9iamVjdC5hc3NpZ24oe30sIGNodW5rU2VydmVyLmhlYWRlcnMsIHtcbiAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9vZmZzZXQrb2N0ZXQtc3RyZWFtJyxcbiAgICAgICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiBjaHVuay5vZmZzZXQsXG4gICAgICAgICAgICAgICdVcGxvYWQtTGVuZ3RoJzogZmlsZS5zaXplLFxuICAgICAgICAgICAgICAnVXBsb2FkLU5hbWUnOiBmaWxlLm5hbWVcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICB2YXIgcmVxdWVzdCA9IChjaHVuay5yZXF1ZXN0ID0gc2VuZFJlcXVlc3QoXG4gICAgICAgIG9uZGF0YShjaHVuay5kYXRhKSxcbiAgICAgICAgcmVxdWVzdFVybCxcbiAgICAgICAgT2JqZWN0LmFzc2lnbih7fSwgY2h1bmtTZXJ2ZXIsIHtcbiAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzXG4gICAgICAgIH0pXG4gICAgICApKTtcblxuICAgICAgcmVxdWVzdC5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gZG9uZSFcbiAgICAgICAgY2h1bmsuc3RhdHVzID0gQ2h1bmtTdGF0dXMuQ09NUExFVEU7XG5cbiAgICAgICAgLy8gcmVtb3ZlIHJlcXVlc3QgcmVmZXJlbmNlXG4gICAgICAgIGNodW5rLnJlcXVlc3QgPSBudWxsO1xuXG4gICAgICAgIC8vIHN0YXJ0IHByb2Nlc3NpbmcgbW9yZSBjaHVua3NcbiAgICAgICAgcHJvY2Vzc0NodW5rcygpO1xuICAgICAgfTtcblxuICAgICAgcmVxdWVzdC5vbnByb2dyZXNzID0gZnVuY3Rpb24obGVuZ3RoQ29tcHV0YWJsZSwgbG9hZGVkLCB0b3RhbCkge1xuICAgICAgICBjaHVuay5wcm9ncmVzcyA9IGxlbmd0aENvbXB1dGFibGUgPyBsb2FkZWQgOiBudWxsO1xuICAgICAgICB1cGRhdGVUb3RhbFByb2dyZXNzKCk7XG4gICAgICB9O1xuXG4gICAgICByZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbih4aHIpIHtcbiAgICAgICAgY2h1bmsuc3RhdHVzID0gQ2h1bmtTdGF0dXMuRVJST1I7XG4gICAgICAgIGNodW5rLnJlcXVlc3QgPSBudWxsO1xuICAgICAgICBjaHVuay5lcnJvciA9IG9uZXJyb3IoeGhyLnJlc3BvbnNlKSB8fCB4aHIuc3RhdHVzVGV4dDtcbiAgICAgICAgaWYgKCFyZXRyeVByb2Nlc3NDaHVuayhjaHVuaykpIHtcbiAgICAgICAgICBlcnJvcihcbiAgICAgICAgICAgIGNyZWF0ZVJlc3BvbnNlKFxuICAgICAgICAgICAgICAnZXJyb3InLFxuICAgICAgICAgICAgICB4aHIuc3RhdHVzLFxuICAgICAgICAgICAgICBvbmVycm9yKHhoci5yZXNwb25zZSkgfHwgeGhyLnN0YXR1c1RleHQsXG4gICAgICAgICAgICAgIHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHJlcXVlc3Qub250aW1lb3V0ID0gZnVuY3Rpb24oeGhyKSB7XG4gICAgICAgIGNodW5rLnN0YXR1cyA9IENodW5rU3RhdHVzLkVSUk9SO1xuICAgICAgICBjaHVuay5yZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgaWYgKCFyZXRyeVByb2Nlc3NDaHVuayhjaHVuaykpIHtcbiAgICAgICAgICBjcmVhdGVUaW1lb3V0UmVzcG9uc2UoZXJyb3IpKHhocik7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHJlcXVlc3Qub25hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjaHVuay5zdGF0dXMgPSBDaHVua1N0YXR1cy5RVUVVRUQ7XG4gICAgICAgIGNodW5rLnJlcXVlc3QgPSBudWxsO1xuICAgICAgICBhYm9ydCgpO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIHJldHJ5UHJvY2Vzc0NodW5rID0gZnVuY3Rpb24gcmV0cnlQcm9jZXNzQ2h1bmsoY2h1bmspIHtcbiAgICAgIC8vIG5vIG1vcmUgcmV0cmllcyBsZWZ0XG4gICAgICBpZiAoY2h1bmsucmV0cmllcy5sZW5ndGggPT09IDApIHJldHVybiBmYWxzZTtcblxuICAgICAgLy8gbmV3IHJldHJ5XG4gICAgICBjaHVuay5zdGF0dXMgPSBDaHVua1N0YXR1cy5XQUlUSU5HO1xuICAgICAgY2xlYXJUaW1lb3V0KGNodW5rLnRpbWVvdXQpO1xuICAgICAgY2h1bmsudGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHByb2Nlc3NDaHVuayhjaHVuayk7XG4gICAgICB9LCBjaHVuay5yZXRyaWVzLnNoaWZ0KCkpO1xuXG4gICAgICAvLyB3ZSdyZSBnb2luZyB0byByZXRyeVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIHZhciB1cGRhdGVUb3RhbFByb2dyZXNzID0gZnVuY3Rpb24gdXBkYXRlVG90YWxQcm9ncmVzcygpIHtcbiAgICAgIC8vIGNhbGN1bGF0ZSB0b3RhbCBwcm9ncmVzcyBmcmFjdGlvblxuICAgICAgdmFyIHRvdGFsQnl0ZXNUcmFuc2ZlcmVkID0gY2h1bmtzLnJlZHVjZShmdW5jdGlvbihwLCBjaHVuaykge1xuICAgICAgICBpZiAocCA9PT0gbnVsbCB8fCBjaHVuay5wcm9ncmVzcyA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBwICsgY2h1bmsucHJvZ3Jlc3M7XG4gICAgICB9LCAwKTtcblxuICAgICAgLy8gY2FuJ3QgY29tcHV0ZSBwcm9ncmVzc1xuICAgICAgaWYgKHRvdGFsQnl0ZXNUcmFuc2ZlcmVkID09PSBudWxsKSByZXR1cm4gcHJvZ3Jlc3MoZmFsc2UsIDAsIDApO1xuXG4gICAgICAvLyBjYWxjdWxhdGUgcHJvZ3Jlc3MgdmFsdWVzXG4gICAgICB2YXIgdG90YWxTaXplID0gY2h1bmtzLnJlZHVjZShmdW5jdGlvbih0b3RhbCwgY2h1bmspIHtcbiAgICAgICAgcmV0dXJuIHRvdGFsICsgY2h1bmsuc2l6ZTtcbiAgICAgIH0sIDApO1xuXG4gICAgICAvLyBjYW4gdXBkYXRlIHByb2dyZXNzIGluZGljYXRvclxuICAgICAgcHJvZ3Jlc3ModHJ1ZSwgdG90YWxCeXRlc1RyYW5zZmVyZWQsIHRvdGFsU2l6ZSk7XG4gICAgfTtcblxuICAgIC8vIHByb2Nlc3MgbmV3IGNodW5rc1xuICAgIHZhciBwcm9jZXNzQ2h1bmtzID0gZnVuY3Rpb24gcHJvY2Vzc0NodW5rcygpIHtcbiAgICAgIHZhciB0b3RhbFByb2Nlc3NpbmcgPSBjaHVua3MuZmlsdGVyKGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgICAgIHJldHVybiBjaHVuay5zdGF0dXMgPT09IENodW5rU3RhdHVzLlBST0NFU1NJTkc7XG4gICAgICB9KS5sZW5ndGg7XG4gICAgICBpZiAodG90YWxQcm9jZXNzaW5nID49IDEpIHJldHVybjtcbiAgICAgIHByb2Nlc3NDaHVuaygpO1xuICAgIH07XG5cbiAgICB2YXIgYWJvcnRDaHVua3MgPSBmdW5jdGlvbiBhYm9ydENodW5rcygpIHtcbiAgICAgIGNodW5rcy5mb3JFYWNoKGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChjaHVuay50aW1lb3V0KTtcbiAgICAgICAgaWYgKGNodW5rLnJlcXVlc3QpIHtcbiAgICAgICAgICBjaHVuay5yZXF1ZXN0LmFib3J0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBsZXQncyBnbyFcbiAgICBpZiAoIXN0YXRlLnNlcnZlcklkKSB7XG4gICAgICByZXF1ZXN0VHJhbnNmZXJJZChmdW5jdGlvbihzZXJ2ZXJJZCkge1xuICAgICAgICAvLyBzdG9wIGhlcmUgaWYgYWJvcnRlZCwgbWlnaHQgaGF2ZSBoYXBwZW5lZCBpbiBiZXR3ZWVuIHJlcXVlc3QgYW5kIGNhbGxiYWNrXG4gICAgICAgIGlmIChzdGF0ZS5hYm9ydGVkKSByZXR1cm47XG5cbiAgICAgICAgLy8gcGFzcyBiYWNrIHRvIGl0ZW0gc28gd2UgY2FuIHVzZSBpdCBpZiBzb21ldGhpbmcgZ29lcyB3cm9uZ1xuICAgICAgICB0cmFuc2ZlcihzZXJ2ZXJJZCk7XG5cbiAgICAgICAgLy8gc3RvcmUgaW50ZXJuYWxseVxuICAgICAgICBzdGF0ZS5zZXJ2ZXJJZCA9IHNlcnZlcklkO1xuICAgICAgICBwcm9jZXNzQ2h1bmtzKCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVxdWVzdFRyYW5zZmVyT2Zmc2V0KGZ1bmN0aW9uKG9mZnNldCkge1xuICAgICAgICAvLyBzdG9wIGhlcmUgaWYgYWJvcnRlZCwgbWlnaHQgaGF2ZSBoYXBwZW5lZCBpbiBiZXR3ZWVuIHJlcXVlc3QgYW5kIGNhbGxiYWNrXG4gICAgICAgIGlmIChzdGF0ZS5hYm9ydGVkKSByZXR1cm47XG5cbiAgICAgICAgLy8gbWFyayBjaHVua3Mgd2l0aCBsb3dlciBvZmZzZXQgYXMgY29tcGxldGVcbiAgICAgICAgY2h1bmtzXG4gICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihjaHVuaykge1xuICAgICAgICAgICAgcmV0dXJuIGNodW5rLm9mZnNldCA8IG9mZnNldDtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgICAgICAgICBjaHVuay5zdGF0dXMgPSBDaHVua1N0YXR1cy5DT01QTEVURTtcbiAgICAgICAgICAgIGNodW5rLnByb2dyZXNzID0gY2h1bmsuc2l6ZTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAvLyBjb250aW51ZSBwcm9jZXNzaW5nXG4gICAgICAgIHByb2Nlc3NDaHVua3MoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBhYm9ydDogZnVuY3Rpb24gYWJvcnQoKSB7XG4gICAgICAgIHN0YXRlLmFib3J0ZWQgPSB0cnVlO1xuICAgICAgICBhYm9ydENodW5rcygpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgLypcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHNpZ25hdHVyZTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGZpbGUsIG1ldGFkYXRhLCBsb2FkLCBlcnJvciwgcHJvZ3Jlc3MsIGFib3J0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYm9ydDooKSA9PiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICB2YXIgY3JlYXRlRmlsZVByb2Nlc3NvckZ1bmN0aW9uID0gZnVuY3Rpb24gY3JlYXRlRmlsZVByb2Nlc3NvckZ1bmN0aW9uKFxuICAgIGFwaVVybCxcbiAgICBhY3Rpb24sXG4gICAgbmFtZSxcbiAgICBvcHRpb25zXG4gICkge1xuICAgIHJldHVybiBmdW5jdGlvbihmaWxlLCBtZXRhZGF0YSwgbG9hZCwgZXJyb3IsIHByb2dyZXNzLCBhYm9ydCwgdHJhbnNmZXIpIHtcbiAgICAgIC8vIG5vIGZpbGUgcmVjZWl2ZWRcbiAgICAgIGlmICghZmlsZSkgcmV0dXJuO1xuXG4gICAgICAvLyBpZiB3YXMgcGFzc2VkIGEgZmlsZSwgYW5kIHdlIGNhbiBjaHVuayBpdCwgZXhpdCBoZXJlXG4gICAgICB2YXIgY2FuQ2h1bmtVcGxvYWQgPSBvcHRpb25zLmNodW5rVXBsb2FkcztcbiAgICAgIHZhciBzaG91bGRDaHVua1VwbG9hZCA9IGNhbkNodW5rVXBsb2FkICYmIGZpbGUuc2l6ZSA+IG9wdGlvbnMuY2h1bmtTaXplO1xuICAgICAgdmFyIHdpbGxDaHVua1VwbG9hZCA9XG4gICAgICAgIGNhbkNodW5rVXBsb2FkICYmIChzaG91bGRDaHVua1VwbG9hZCB8fCBvcHRpb25zLmNodW5rRm9yY2UpO1xuICAgICAgaWYgKGZpbGUgaW5zdGFuY2VvZiBCbG9iICYmIHdpbGxDaHVua1VwbG9hZClcbiAgICAgICAgcmV0dXJuIHByb2Nlc3NGaWxlQ2h1bmtlZChcbiAgICAgICAgICBhcGlVcmwsXG4gICAgICAgICAgYWN0aW9uLFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgZmlsZSxcbiAgICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgICBsb2FkLFxuICAgICAgICAgIGVycm9yLFxuICAgICAgICAgIHByb2dyZXNzLFxuICAgICAgICAgIGFib3J0LFxuICAgICAgICAgIHRyYW5zZmVyLFxuICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgKTtcblxuICAgICAgLy8gc2V0IGhhbmRsZXJzXG4gICAgICB2YXIgb25kYXRhID1cbiAgICAgICAgYWN0aW9uLm9uZGF0YSB8fFxuICAgICAgICBmdW5jdGlvbihmZCkge1xuICAgICAgICAgIHJldHVybiBmZDtcbiAgICAgICAgfTtcbiAgICAgIHZhciBvbmxvYWQgPVxuICAgICAgICBhY3Rpb24ub25sb2FkIHx8XG4gICAgICAgIGZ1bmN0aW9uKHJlcykge1xuICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH07XG4gICAgICB2YXIgb25lcnJvciA9XG4gICAgICAgIGFjdGlvbi5vbmVycm9yIHx8XG4gICAgICAgIGZ1bmN0aW9uKHJlcykge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuXG4gICAgICAvLyBjcmVhdGUgZm9ybWRhdGEgb2JqZWN0XG4gICAgICB2YXIgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcblxuICAgICAgLy8gYWRkIG1ldGFkYXRhIHVuZGVyIHNhbWUgbmFtZVxuICAgICAgaWYgKGlzT2JqZWN0KG1ldGFkYXRhKSkge1xuICAgICAgICBmb3JtRGF0YS5hcHBlbmQobmFtZSwgSlNPTi5zdHJpbmdpZnkobWV0YWRhdGEpKTtcbiAgICAgIH1cblxuICAgICAgLy8gVHVybiBpbnRvIGFuIGFycmF5IG9mIG9iamVjdHMgc28gbm8gbWF0dGVyIHdoYXQgdGhlIGlucHV0LCB3ZSBjYW4gaGFuZGxlIGl0IHRoZSBzYW1lIHdheVxuICAgICAgKGZpbGUgaW5zdGFuY2VvZiBCbG9iID8gW3sgbmFtZTogbnVsbCwgZmlsZTogZmlsZSB9XSA6IGZpbGUpLmZvckVhY2goXG4gICAgICAgIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgaXRlbS5maWxlLFxuICAgICAgICAgICAgaXRlbS5uYW1lID09PSBudWxsXG4gICAgICAgICAgICAgID8gaXRlbS5maWxlLm5hbWVcbiAgICAgICAgICAgICAgOiAnJyArIGl0ZW0ubmFtZSArIGl0ZW0uZmlsZS5uYW1lXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgKTtcblxuICAgICAgLy8gc2VuZCByZXF1ZXN0IG9iamVjdFxuICAgICAgdmFyIHJlcXVlc3QgPSBzZW5kUmVxdWVzdChcbiAgICAgICAgb25kYXRhKGZvcm1EYXRhKSxcbiAgICAgICAgYnVpbGRVUkwoYXBpVXJsLCBhY3Rpb24udXJsKSxcbiAgICAgICAgYWN0aW9uXG4gICAgICApO1xuICAgICAgcmVxdWVzdC5vbmxvYWQgPSBmdW5jdGlvbih4aHIpIHtcbiAgICAgICAgbG9hZChcbiAgICAgICAgICBjcmVhdGVSZXNwb25zZShcbiAgICAgICAgICAgICdsb2FkJyxcbiAgICAgICAgICAgIHhoci5zdGF0dXMsXG4gICAgICAgICAgICBvbmxvYWQoeGhyLnJlc3BvbnNlKSxcbiAgICAgICAgICAgIHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH07XG5cbiAgICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uKHhocikge1xuICAgICAgICBlcnJvcihcbiAgICAgICAgICBjcmVhdGVSZXNwb25zZShcbiAgICAgICAgICAgICdlcnJvcicsXG4gICAgICAgICAgICB4aHIuc3RhdHVzLFxuICAgICAgICAgICAgb25lcnJvcih4aHIucmVzcG9uc2UpIHx8IHhoci5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfTtcblxuICAgICAgcmVxdWVzdC5vbnRpbWVvdXQgPSBjcmVhdGVUaW1lb3V0UmVzcG9uc2UoZXJyb3IpO1xuICAgICAgcmVxdWVzdC5vbnByb2dyZXNzID0gcHJvZ3Jlc3M7XG4gICAgICByZXF1ZXN0Lm9uYWJvcnQgPSBhYm9ydDtcblxuICAgICAgLy8gc2hvdWxkIHJldHVybiByZXF1ZXN0XG4gICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBjcmVhdGVQcm9jZXNzb3JGdW5jdGlvbiA9IGZ1bmN0aW9uIGNyZWF0ZVByb2Nlc3NvckZ1bmN0aW9uKCkge1xuICAgIHZhciBhcGlVcmwgPVxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAnJztcbiAgICB2YXIgYWN0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gICAgdmFyIG5hbWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzID8gYXJndW1lbnRzWzNdIDogdW5kZWZpbmVkO1xuXG4gICAgLy8gY3VzdG9tIGhhbmRsZXIgKHNob3VsZCBhbHNvIGhhbmRsZSBmaWxlLCBsb2FkLCBlcnJvciwgcHJvZ3Jlc3MgYW5kIGFib3J0KVxuICAgIGlmICh0eXBlb2YgYWN0aW9uID09PSAnZnVuY3Rpb24nKVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IgKFxuICAgICAgICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcGFyYW1zID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDtcbiAgICAgICAgICBfa2V5IDwgX2xlbjtcbiAgICAgICAgICBfa2V5KytcbiAgICAgICAgKSB7XG4gICAgICAgICAgcGFyYW1zW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY3Rpb24uYXBwbHkodm9pZCAwLCBbbmFtZV0uY29uY2F0KHBhcmFtcywgW29wdGlvbnNdKSk7XG4gICAgICB9O1xuXG4gICAgLy8gbm8gYWN0aW9uIHN1cHBsaWVkXG4gICAgaWYgKCFhY3Rpb24gfHwgIWlzU3RyaW5nKGFjdGlvbi51cmwpKSByZXR1cm4gbnVsbDtcblxuICAgIC8vIGludGVybmFsIGhhbmRsZXJcbiAgICByZXR1cm4gY3JlYXRlRmlsZVByb2Nlc3NvckZ1bmN0aW9uKGFwaVVybCwgYWN0aW9uLCBuYW1lLCBvcHRpb25zKTtcbiAgfTtcblxuICAvKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gc2lnbmF0dXJlOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHVuaXF1ZUZpbGVJZCwgbG9hZCwgZXJyb3IpID0+IHsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgdmFyIGNyZWF0ZVJldmVydEZ1bmN0aW9uID0gZnVuY3Rpb24gY3JlYXRlUmV2ZXJ0RnVuY3Rpb24oKSB7XG4gICAgdmFyIGFwaVVybCA9XG4gICAgICBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICcnO1xuICAgIHZhciBhY3Rpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICAvLyBpcyBjdXN0b20gaW1wbGVtZW50YXRpb25cbiAgICBpZiAodHlwZW9mIGFjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGFjdGlvbjtcbiAgICB9XG5cbiAgICAvLyBubyBhY3Rpb24gc3VwcGxpZWQsIHJldHVybiBzdHViIGZ1bmN0aW9uLCBpbnRlcmZhY2Ugd2lsbCB3b3JrLCBidXQgZmlsZSB3b24ndCBiZSByZW1vdmVkXG4gICAgaWYgKCFhY3Rpb24gfHwgIWlzU3RyaW5nKGFjdGlvbi51cmwpKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24odW5pcXVlRmlsZUlkLCBsb2FkKSB7XG4gICAgICAgIHJldHVybiBsb2FkKCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIHNldCBvbmxvYWQgaGFubGRlclxuICAgIHZhciBvbmxvYWQgPVxuICAgICAgYWN0aW9uLm9ubG9hZCB8fFxuICAgICAgZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9O1xuICAgIHZhciBvbmVycm9yID1cbiAgICAgIGFjdGlvbi5vbmVycm9yIHx8XG4gICAgICBmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuXG4gICAgLy8gaW50ZXJuYWwgaW1wbGVtZW50YXRpb25cbiAgICByZXR1cm4gZnVuY3Rpb24odW5pcXVlRmlsZUlkLCBsb2FkLCBlcnJvcikge1xuICAgICAgdmFyIHJlcXVlc3QgPSBzZW5kUmVxdWVzdChcbiAgICAgICAgdW5pcXVlRmlsZUlkLFxuICAgICAgICBhcGlVcmwgKyBhY3Rpb24udXJsLFxuICAgICAgICBhY3Rpb24gLy8gY29udGFpbnMgbWV0aG9kLCBoZWFkZXJzIGFuZCB3aXRoQ3JlZGVudGlhbHMgcHJvcGVydGllc1xuICAgICAgKTtcbiAgICAgIHJlcXVlc3Qub25sb2FkID0gZnVuY3Rpb24oeGhyKSB7XG4gICAgICAgIGxvYWQoXG4gICAgICAgICAgY3JlYXRlUmVzcG9uc2UoXG4gICAgICAgICAgICAnbG9hZCcsXG4gICAgICAgICAgICB4aHIuc3RhdHVzLFxuICAgICAgICAgICAgb25sb2FkKHhoci5yZXNwb25zZSksXG4gICAgICAgICAgICB4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKClcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9O1xuXG4gICAgICByZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbih4aHIpIHtcbiAgICAgICAgZXJyb3IoXG4gICAgICAgICAgY3JlYXRlUmVzcG9uc2UoXG4gICAgICAgICAgICAnZXJyb3InLFxuICAgICAgICAgICAgeGhyLnN0YXR1cyxcbiAgICAgICAgICAgIG9uZXJyb3IoeGhyLnJlc3BvbnNlKSB8fCB4aHIuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgIHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH07XG5cbiAgICAgIHJlcXVlc3Qub250aW1lb3V0ID0gY3JlYXRlVGltZW91dFJlc3BvbnNlKGVycm9yKTtcblxuICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgZ2V0UmFuZG9tTnVtYmVyID0gZnVuY3Rpb24gZ2V0UmFuZG9tTnVtYmVyKCkge1xuICAgIHZhciBtaW4gPVxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuICAgIHZhciBtYXggPVxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAxO1xuICAgIHJldHVybiBtaW4gKyBNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbik7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZVBlcmNlaXZlZFBlcmZvcm1hbmNlVXBkYXRlciA9IGZ1bmN0aW9uIGNyZWF0ZVBlcmNlaXZlZFBlcmZvcm1hbmNlVXBkYXRlcihcbiAgICBjYlxuICApIHtcbiAgICB2YXIgZHVyYXRpb24gPVxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAxMDAwO1xuICAgIHZhciBvZmZzZXQgPVxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAwO1xuICAgIHZhciB0aWNrTWluID1cbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogMjU7XG4gICAgdmFyIHRpY2tNYXggPVxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiAyNTA7XG4gICAgdmFyIHRpbWVvdXQgPSBudWxsO1xuICAgIHZhciBzdGFydCA9IERhdGUubm93KCk7XG5cbiAgICB2YXIgdGljayA9IGZ1bmN0aW9uIHRpY2soKSB7XG4gICAgICB2YXIgcnVudGltZSA9IERhdGUubm93KCkgLSBzdGFydDtcbiAgICAgIHZhciBkZWxheSA9IGdldFJhbmRvbU51bWJlcih0aWNrTWluLCB0aWNrTWF4KTtcblxuICAgICAgaWYgKHJ1bnRpbWUgKyBkZWxheSA+IGR1cmF0aW9uKSB7XG4gICAgICAgIGRlbGF5ID0gcnVudGltZSArIGRlbGF5IC0gZHVyYXRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9ncmVzcyA9IHJ1bnRpbWUgLyBkdXJhdGlvbjtcbiAgICAgIGlmIChwcm9ncmVzcyA+PSAxIHx8IGRvY3VtZW50LmhpZGRlbikge1xuICAgICAgICBjYigxKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjYihwcm9ncmVzcyk7XG5cbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KHRpY2ssIGRlbGF5KTtcbiAgICB9O1xuXG4gICAgdGljaygpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNsZWFyOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUZpbGVQcm9jZXNzb3IgPSBmdW5jdGlvbiBjcmVhdGVGaWxlUHJvY2Vzc29yKHByb2Nlc3NGbikge1xuICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgIGNvbXBsZXRlOiBmYWxzZSxcbiAgICAgIHBlcmNlaXZlZFByb2dyZXNzOiAwLFxuICAgICAgcGVyY2VpdmVkUGVyZm9ybWFuY2VVcGRhdGVyOiBudWxsLFxuICAgICAgcHJvZ3Jlc3M6IG51bGwsXG4gICAgICB0aW1lc3RhbXA6IG51bGwsXG4gICAgICBwZXJjZWl2ZWREdXJhdGlvbjogMCxcbiAgICAgIGR1cmF0aW9uOiAwLFxuICAgICAgcmVxdWVzdDogbnVsbCxcbiAgICAgIHJlc3BvbnNlOiBudWxsXG4gICAgfTtcblxuICAgIHZhciBwcm9jZXNzID0gZnVuY3Rpb24gcHJvY2VzcyhmaWxlLCBtZXRhZGF0YSkge1xuICAgICAgdmFyIHByb2dyZXNzRm4gPSBmdW5jdGlvbiBwcm9ncmVzc0ZuKCkge1xuICAgICAgICAvLyB3ZSd2ZSBub3QgeWV0IHN0YXJ0ZWQgdGhlIHJlYWwgZG93bmxvYWQsIHN0b3AgaGVyZVxuICAgICAgICAvLyB0aGUgcmVxdWVzdCBtaWdodCBub3QgZ28gdGhyb3VnaCwgZm9yIGluc3RhbmNlLCB0aGVyZSBtaWdodCBiZSBzb21lIHNlcnZlciB0cm91YmxlXG4gICAgICAgIC8vIGlmIHN0YXRlLnByb2dyZXNzIGlzIG51bGwsIHRoZSBzZXJ2ZXIgZG9lcyBub3QgYWxsb3cgY29tcHV0aW5nIHByb2dyZXNzIGFuZCB3ZSBzaG93IHRoZSBzcGlubmVyIGluc3RlYWRcbiAgICAgICAgaWYgKHN0YXRlLmR1cmF0aW9uID09PSAwIHx8IHN0YXRlLnByb2dyZXNzID09PSBudWxsKSByZXR1cm47XG5cbiAgICAgICAgLy8gYXMgd2UncmUgbm93IHByb2Nlc3NpbmcsIGZpcmUgdGhlIHByb2dyZXNzIGV2ZW50XG4gICAgICAgIGFwaS5maXJlKCdwcm9ncmVzcycsIGFwaS5nZXRQcm9ncmVzcygpKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBjb21wbGV0ZUZuID0gZnVuY3Rpb24gY29tcGxldGVGbigpIHtcbiAgICAgICAgc3RhdGUuY29tcGxldGUgPSB0cnVlO1xuICAgICAgICBhcGkuZmlyZSgnbG9hZC1wZXJjZWl2ZWQnLCBzdGF0ZS5yZXNwb25zZS5ib2R5KTtcbiAgICAgIH07XG5cbiAgICAgIC8vIGxldCdzIHN0YXJ0IHByb2Nlc3NpbmdcbiAgICAgIGFwaS5maXJlKCdzdGFydCcpO1xuXG4gICAgICAvLyBzZXQgcmVxdWVzdCBzdGFydFxuICAgICAgc3RhdGUudGltZXN0YW1wID0gRGF0ZS5ub3coKTtcblxuICAgICAgLy8gY3JlYXRlIHBlcmNlaXZlZCBwZXJmb3JtYW5jZSBwcm9ncmVzcyBpbmRpY2F0b3JcbiAgICAgIHN0YXRlLnBlcmNlaXZlZFBlcmZvcm1hbmNlVXBkYXRlciA9IGNyZWF0ZVBlcmNlaXZlZFBlcmZvcm1hbmNlVXBkYXRlcihcbiAgICAgICAgZnVuY3Rpb24ocHJvZ3Jlc3MpIHtcbiAgICAgICAgICBzdGF0ZS5wZXJjZWl2ZWRQcm9ncmVzcyA9IHByb2dyZXNzO1xuICAgICAgICAgIHN0YXRlLnBlcmNlaXZlZER1cmF0aW9uID0gRGF0ZS5ub3coKSAtIHN0YXRlLnRpbWVzdGFtcDtcblxuICAgICAgICAgIHByb2dyZXNzRm4oKTtcblxuICAgICAgICAgIC8vIGlmIGZha2UgcHJvZ3Jlc3MgaXMgZG9uZSwgYW5kIGEgcmVzcG9uc2UgaGFzIGJlZW4gcmVjZWl2ZWQsXG4gICAgICAgICAgLy8gYW5kIHdlJ3ZlIG5vdCB5ZXQgY2FsbGVkIHRoZSBjb21wbGV0ZSBtZXRob2RcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBzdGF0ZS5yZXNwb25zZSAmJlxuICAgICAgICAgICAgc3RhdGUucGVyY2VpdmVkUHJvZ3Jlc3MgPT09IDEgJiZcbiAgICAgICAgICAgICFzdGF0ZS5jb21wbGV0ZVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgLy8gd2UgZG9uZSFcbiAgICAgICAgICAgIGNvbXBsZXRlRm4oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8vIHJhbmRvbSBkZWxheSBhcyBpbiBhIGxpc3Qgb2YgZmlsZXMgeW91IHN0YXJ0IG5vdGljaW5nXG4gICAgICAgIC8vIGZpbGVzIHVwbG9hZGluZyBhdCB0aGUgZXhhY3Qgc2FtZSBzcGVlZFxuICAgICAgICBnZXRSYW5kb21OdW1iZXIoNzUwLCAxNTAwKVxuICAgICAgKTtcblxuICAgICAgLy8gcmVtZW1iZXIgcmVxdWVzdCBzbyB3ZSBjYW4gYWJvcnQgaXQgbGF0ZXJcbiAgICAgIHN0YXRlLnJlcXVlc3QgPSBwcm9jZXNzRm4oXG4gICAgICAgIC8vIHRoZSBmaWxlIHRvIHByb2Nlc3NcbiAgICAgICAgZmlsZSxcblxuICAgICAgICAvLyB0aGUgbWV0YWRhdGEgdG8gc2VuZCBhbG9uZ1xuICAgICAgICBtZXRhZGF0YSxcblxuICAgICAgICAvLyBjYWxsYmFja3MgKGxvYWQsIGVycm9yLCBwcm9ncmVzcywgYWJvcnQsIHRyYW5zZmVyKVxuICAgICAgICAvLyBsb2FkIGV4cGVjdHMgdGhlIGJvZHkgdG8gYmUgYSBzZXJ2ZXIgaWQgaWZcbiAgICAgICAgLy8geW91IHdhbnQgdG8gbWFrZSB1c2Ugb2YgcmV2ZXJ0XG4gICAgICAgIGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgLy8gd2UgcHV0IHRoZSByZXNwb25zZSBpbiBzdGF0ZSBzbyB3ZSBjYW4gYWNjZXNzXG4gICAgICAgICAgLy8gaXQgb3V0c2lkZSBvZiB0aGlzIG1ldGhvZFxuICAgICAgICAgIHN0YXRlLnJlc3BvbnNlID0gaXNPYmplY3QocmVzcG9uc2UpXG4gICAgICAgICAgICA/IHJlc3BvbnNlXG4gICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnbG9hZCcsXG4gICAgICAgICAgICAgICAgY29kZTogMjAwLFxuICAgICAgICAgICAgICAgIGJvZHk6ICcnICsgcmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge31cbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgIC8vIHVwZGF0ZSBkdXJhdGlvblxuICAgICAgICAgIHN0YXRlLmR1cmF0aW9uID0gRGF0ZS5ub3coKSAtIHN0YXRlLnRpbWVzdGFtcDtcblxuICAgICAgICAgIC8vIGZvcmNlIHByb2dyZXNzIHRvIDEgYXMgd2UncmUgbm93IGRvbmVcbiAgICAgICAgICBzdGF0ZS5wcm9ncmVzcyA9IDE7XG5cbiAgICAgICAgICAvLyBhY3R1YWwgbG9hZCBpcyBkb25lIGxldCdzIHNoYXJlIHJlc3VsdHNcbiAgICAgICAgICBhcGkuZmlyZSgnbG9hZCcsIHN0YXRlLnJlc3BvbnNlLmJvZHkpO1xuXG4gICAgICAgICAgLy8gd2UgYXJlIHJlYWxseSBkb25lXG4gICAgICAgICAgLy8gaWYgcGVyY2VpdmVkIHByb2dyZXNzIGlzIDEgKCB3YWl0IGZvciBwZXJjZWl2ZWQgcHJvZ3Jlc3MgdG8gY29tcGxldGUgKVxuICAgICAgICAgIC8vIG9yIGlmIHNlcnZlciBkb2VzIG5vdCBzdXBwb3J0IHByb2dyZXNzICggbnVsbCApXG4gICAgICAgICAgaWYgKHN0YXRlLnBlcmNlaXZlZFByb2dyZXNzID09PSAxKSB7XG4gICAgICAgICAgICBjb21wbGV0ZUZuKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIGVycm9yIGlzIGV4cGVjdGVkIHRvIGJlIGFuIG9iamVjdCB3aXRoIHR5cGUsIGNvZGUsIGJvZHlcbiAgICAgICAgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAvLyBjYW5jZWwgdXBkYXRlclxuICAgICAgICAgIHN0YXRlLnBlcmNlaXZlZFBlcmZvcm1hbmNlVXBkYXRlci5jbGVhcigpO1xuXG4gICAgICAgICAgLy8gdXBkYXRlIG90aGVycyBhYm91dCB0aGlzIGVycm9yXG4gICAgICAgICAgYXBpLmZpcmUoXG4gICAgICAgICAgICAnZXJyb3InLFxuICAgICAgICAgICAgaXNPYmplY3QoZXJyb3IpXG4gICAgICAgICAgICAgID8gZXJyb3JcbiAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiAnZXJyb3InLFxuICAgICAgICAgICAgICAgICAgY29kZTogMCxcbiAgICAgICAgICAgICAgICAgIGJvZHk6ICcnICsgZXJyb3JcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBhY3R1YWwgcHJvY2Vzc2luZyBwcm9ncmVzc1xuICAgICAgICBmdW5jdGlvbihjb21wdXRhYmxlLCBjdXJyZW50LCB0b3RhbCkge1xuICAgICAgICAgIC8vIHVwZGF0ZSBhY3R1YWwgZHVyYXRpb25cbiAgICAgICAgICBzdGF0ZS5kdXJhdGlvbiA9IERhdGUubm93KCkgLSBzdGF0ZS50aW1lc3RhbXA7XG5cbiAgICAgICAgICAvLyB1cGRhdGUgYWN0dWFsIHByb2dyZXNzXG4gICAgICAgICAgc3RhdGUucHJvZ3Jlc3MgPSBjb21wdXRhYmxlID8gY3VycmVudCAvIHRvdGFsIDogbnVsbDtcblxuICAgICAgICAgIHByb2dyZXNzRm4oKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBhYm9ydCBkb2VzIG5vdCBleHBlY3QgYSB2YWx1ZVxuICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAvLyBzdG9wIHVwZGF0ZXJcbiAgICAgICAgICBzdGF0ZS5wZXJjZWl2ZWRQZXJmb3JtYW5jZVVwZGF0ZXIuY2xlYXIoKTtcblxuICAgICAgICAgIC8vIGZpcmUgdGhlIGFib3J0IGV2ZW50IHNvIHdlIGNhbiBzd2l0Y2ggdmlzdWFsc1xuICAgICAgICAgIGFwaS5maXJlKCdhYm9ydCcsIHN0YXRlLnJlc3BvbnNlID8gc3RhdGUucmVzcG9uc2UuYm9keSA6IG51bGwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIHJlZ2lzdGVyIHRoZSBpZCBmb3IgdGhpcyB0cmFuc2ZlclxuICAgICAgICBmdW5jdGlvbih0cmFuc2ZlcklkKSB7XG4gICAgICAgICAgYXBpLmZpcmUoJ3RyYW5zZmVyJywgdHJhbnNmZXJJZCk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfTtcblxuICAgIHZhciBhYm9ydCA9IGZ1bmN0aW9uIGFib3J0KCkge1xuICAgICAgLy8gbm8gcmVxdWVzdCBydW5uaW5nLCBjYW4ndCBhYm9ydFxuICAgICAgaWYgKCFzdGF0ZS5yZXF1ZXN0KSByZXR1cm47XG5cbiAgICAgIC8vIHN0b3AgdXBkYXRlclxuICAgICAgc3RhdGUucGVyY2VpdmVkUGVyZm9ybWFuY2VVcGRhdGVyLmNsZWFyKCk7XG5cbiAgICAgIC8vIGFib3J0IGFjdHVhbCByZXF1ZXN0XG4gICAgICBpZiAoc3RhdGUucmVxdWVzdC5hYm9ydCkgc3RhdGUucmVxdWVzdC5hYm9ydCgpO1xuXG4gICAgICAvLyBpZiBoYXMgcmVzcG9uc2Ugb2JqZWN0LCB3ZSd2ZSBjb21wbGV0ZWQgdGhlIHJlcXVlc3RcbiAgICAgIHN0YXRlLmNvbXBsZXRlID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgdmFyIHJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICBhYm9ydCgpO1xuICAgICAgc3RhdGUuY29tcGxldGUgPSBmYWxzZTtcbiAgICAgIHN0YXRlLnBlcmNlaXZlZFByb2dyZXNzID0gMDtcbiAgICAgIHN0YXRlLnByb2dyZXNzID0gMDtcbiAgICAgIHN0YXRlLnRpbWVzdGFtcCA9IG51bGw7XG4gICAgICBzdGF0ZS5wZXJjZWl2ZWREdXJhdGlvbiA9IDA7XG4gICAgICBzdGF0ZS5kdXJhdGlvbiA9IDA7XG4gICAgICBzdGF0ZS5yZXF1ZXN0ID0gbnVsbDtcbiAgICAgIHN0YXRlLnJlc3BvbnNlID0gbnVsbDtcbiAgICB9O1xuXG4gICAgdmFyIGdldFByb2dyZXNzID0gZnVuY3Rpb24gZ2V0UHJvZ3Jlc3MoKSB7XG4gICAgICByZXR1cm4gc3RhdGUucHJvZ3Jlc3NcbiAgICAgICAgPyBNYXRoLm1pbihzdGF0ZS5wcm9ncmVzcywgc3RhdGUucGVyY2VpdmVkUHJvZ3Jlc3MpXG4gICAgICAgIDogbnVsbDtcbiAgICB9O1xuICAgIHZhciBnZXREdXJhdGlvbiA9IGZ1bmN0aW9uIGdldER1cmF0aW9uKCkge1xuICAgICAgcmV0dXJuIE1hdGgubWluKHN0YXRlLmR1cmF0aW9uLCBzdGF0ZS5wZXJjZWl2ZWREdXJhdGlvbik7XG4gICAgfTtcblxuICAgIHZhciBhcGkgPSBPYmplY3QuYXNzaWduKHt9LCBvbigpLCB7XG4gICAgICBwcm9jZXNzOiBwcm9jZXNzLCAvLyBzdGFydCBwcm9jZXNzaW5nIGZpbGVcbiAgICAgIGFib3J0OiBhYm9ydCwgLy8gYWJvcnQgYWN0aXZlIHByb2Nlc3MgcmVxdWVzdFxuICAgICAgZ2V0UHJvZ3Jlc3M6IGdldFByb2dyZXNzLFxuICAgICAgZ2V0RHVyYXRpb246IGdldER1cmF0aW9uLFxuICAgICAgcmVzZXQ6IHJlc2V0XG4gICAgfSk7XG5cbiAgICByZXR1cm4gYXBpO1xuICB9O1xuXG4gIHZhciBnZXRGaWxlbmFtZVdpdGhvdXRFeHRlbnNpb24gPSBmdW5jdGlvbiBnZXRGaWxlbmFtZVdpdGhvdXRFeHRlbnNpb24obmFtZSkge1xuICAgIHJldHVybiBuYW1lLnN1YnN0cigwLCBuYW1lLmxhc3RJbmRleE9mKCcuJykpIHx8IG5hbWU7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUZpbGVTdHViID0gZnVuY3Rpb24gY3JlYXRlRmlsZVN0dWIoc291cmNlKSB7XG4gICAgdmFyIGRhdGEgPSBbc291cmNlLm5hbWUsIHNvdXJjZS5zaXplLCBzb3VyY2UudHlwZV07XG5cbiAgICAvLyBpcyBibG9iIG9yIGJhc2U2NCwgdGhlbiB3ZSBuZWVkIHRvIHNldCB0aGUgbmFtZVxuICAgIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBCbG9iIHx8IGlzQmFzZTY0RGF0YVVSSShzb3VyY2UpKSB7XG4gICAgICBkYXRhWzBdID0gc291cmNlLm5hbWUgfHwgZ2V0RGF0ZVN0cmluZygpO1xuICAgIH0gZWxzZSBpZiAoaXNCYXNlNjREYXRhVVJJKHNvdXJjZSkpIHtcbiAgICAgIC8vIGlmIGlzIGJhc2U2NCBkYXRhIHVyaSB3ZSBuZWVkIHRvIGRldGVybWluZSB0aGUgYXZlcmFnZSBzaXplIGFuZCB0eXBlXG4gICAgICBkYXRhWzFdID0gc291cmNlLmxlbmd0aDtcbiAgICAgIGRhdGFbMl0gPSBnZXRNaW1lVHlwZUZyb21CYXNlNjREYXRhVVJJKHNvdXJjZSk7XG4gICAgfSBlbHNlIGlmIChpc1N0cmluZyhzb3VyY2UpKSB7XG4gICAgICAvLyB1cmxcbiAgICAgIGRhdGFbMF0gPSBnZXRGaWxlbmFtZUZyb21VUkwoc291cmNlKTtcbiAgICAgIGRhdGFbMV0gPSAwO1xuICAgICAgZGF0YVsyXSA9ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBkYXRhWzBdLFxuICAgICAgc2l6ZTogZGF0YVsxXSxcbiAgICAgIHR5cGU6IGRhdGFbMl1cbiAgICB9O1xuICB9O1xuXG4gIHZhciBpc0ZpbGUgPSBmdW5jdGlvbiBpc0ZpbGUodmFsdWUpIHtcbiAgICByZXR1cm4gISEodmFsdWUgaW5zdGFuY2VvZiBGaWxlIHx8ICh2YWx1ZSBpbnN0YW5jZW9mIEJsb2IgJiYgdmFsdWUubmFtZSkpO1xuICB9O1xuXG4gIHZhciBkZWVwQ2xvbmVPYmplY3QgPSBmdW5jdGlvbiBkZWVwQ2xvbmVPYmplY3Qoc3JjKSB7XG4gICAgaWYgKCFpc09iamVjdChzcmMpKSByZXR1cm4gc3JjO1xuICAgIHZhciB0YXJnZXQgPSBpc0FycmF5KHNyYykgPyBbXSA6IHt9O1xuICAgIGZvciAodmFyIGtleSBpbiBzcmMpIHtcbiAgICAgIGlmICghc3JjLmhhc093blByb3BlcnR5KGtleSkpIGNvbnRpbnVlO1xuICAgICAgdmFyIHYgPSBzcmNba2V5XTtcbiAgICAgIHRhcmdldFtrZXldID0gdiAmJiBpc09iamVjdCh2KSA/IGRlZXBDbG9uZU9iamVjdCh2KSA6IHY7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUl0ZW0gPSBmdW5jdGlvbiBjcmVhdGVJdGVtKCkge1xuICAgIHZhciBvcmlnaW4gPVxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBudWxsO1xuICAgIHZhciBzZXJ2ZXJGaWxlUmVmZXJlbmNlID1cbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcbiAgICB2YXIgZmlsZSA9XG4gICAgICBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IG51bGw7XG4gICAgLy8gdW5pcXVlIGlkIGZvciB0aGlzIGl0ZW0sIGlzIHVzZWQgdG8gaWRlbnRpZnkgdGhlIGl0ZW0gYWNyb3NzIHZpZXdzXG4gICAgdmFyIGlkID0gZ2V0VW5pcXVlSWQoKTtcblxuICAgIC8qKlxuICAgICAqIEludGVybmFsIGl0ZW0gc3RhdGVcbiAgICAgKi9cbiAgICB2YXIgc3RhdGUgPSB7XG4gICAgICAvLyBpcyBhcmNoaXZlZFxuICAgICAgYXJjaGl2ZWQ6IGZhbHNlLFxuXG4gICAgICAvLyBpZiBpcyBmcm96ZW4sIG5vIGxvbmdlciBmaXJlcyBldmVudHNcbiAgICAgIGZyb3plbjogZmFsc2UsXG5cbiAgICAgIC8vIHJlbW92ZWQgZnJvbSB2aWV3XG4gICAgICByZWxlYXNlZDogZmFsc2UsXG5cbiAgICAgIC8vIG9yaWdpbmFsIHNvdXJjZVxuICAgICAgc291cmNlOiBudWxsLFxuXG4gICAgICAvLyBmaWxlIG1vZGVsIHJlZmVyZW5jZVxuICAgICAgZmlsZTogZmlsZSxcblxuICAgICAgLy8gaWQgb2YgZmlsZSBvbiBzZXJ2ZXJcbiAgICAgIHNlcnZlckZpbGVSZWZlcmVuY2U6IHNlcnZlckZpbGVSZWZlcmVuY2UsXG5cbiAgICAgIC8vIGlkIG9mIGZpbGUgdHJhbnNmZXIgb24gc2VydmVyXG4gICAgICB0cmFuc2ZlcklkOiBudWxsLFxuXG4gICAgICAvLyBpcyBhYm9ydGVkXG4gICAgICBwcm9jZXNzaW5nQWJvcnRlZDogZmFsc2UsXG5cbiAgICAgIC8vIGN1cnJlbnQgaXRlbSBzdGF0dXNcbiAgICAgIHN0YXR1czogc2VydmVyRmlsZVJlZmVyZW5jZVxuICAgICAgICA/IEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19DT01QTEVURVxuICAgICAgICA6IEl0ZW1TdGF0dXMuSU5JVCxcblxuICAgICAgLy8gYWN0aXZlIHByb2Nlc3Nlc1xuICAgICAgYWN0aXZlTG9hZGVyOiBudWxsLFxuICAgICAgYWN0aXZlUHJvY2Vzc29yOiBudWxsXG4gICAgfTtcblxuICAgIC8vIGNhbGxiYWNrIHVzZWQgd2hlbiBhYm9ydCBwcm9jZXNzaW5nIGlzIGNhbGxlZCB0byBsaW5rIGJhY2sgdG8gdGhlIHJlc29sdmUgbWV0aG9kXG4gICAgdmFyIGFib3J0UHJvY2Vzc2luZ1JlcXVlc3RDb21wbGV0ZSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBFeHRlcm5hbGx5IGFkZGVkIGl0ZW0gbWV0YWRhdGFcbiAgICAgKi9cbiAgICB2YXIgbWV0YWRhdGEgPSB7fTtcblxuICAgIC8vIGl0ZW0gZGF0YVxuICAgIHZhciBzZXRTdGF0dXMgPSBmdW5jdGlvbiBzZXRTdGF0dXMoc3RhdHVzKSB7XG4gICAgICByZXR1cm4gKHN0YXRlLnN0YXR1cyA9IHN0YXR1cyk7XG4gICAgfTtcblxuICAgIC8vIGZpcmUgZXZlbnQgdW5sZXNzIHRoZSBpdGVtIGhhcyBiZWVuIGFyY2hpdmVkXG4gICAgdmFyIGZpcmUgPSBmdW5jdGlvbiBmaXJlKGV2ZW50KSB7XG4gICAgICBpZiAoc3RhdGUucmVsZWFzZWQgfHwgc3RhdGUuZnJvemVuKSByZXR1cm47XG4gICAgICBmb3IgKFxuICAgICAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgICAgcGFyYW1zID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSxcbiAgICAgICAgICBfa2V5ID0gMTtcbiAgICAgICAgX2tleSA8IF9sZW47XG4gICAgICAgIF9rZXkrK1xuICAgICAgKSB7XG4gICAgICAgIHBhcmFtc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG4gICAgICBhcGkuZmlyZS5hcHBseShhcGksIFtldmVudF0uY29uY2F0KHBhcmFtcykpO1xuICAgIH07XG5cbiAgICAvLyBmaWxlIGRhdGFcbiAgICB2YXIgZ2V0RmlsZUV4dGVuc2lvbiA9IGZ1bmN0aW9uIGdldEZpbGVFeHRlbnNpb24oKSB7XG4gICAgICByZXR1cm4gZ2V0RXh0ZW5zaW9uRnJvbUZpbGVuYW1lKHN0YXRlLmZpbGUubmFtZSk7XG4gICAgfTtcbiAgICB2YXIgZ2V0RmlsZVR5cGUgPSBmdW5jdGlvbiBnZXRGaWxlVHlwZSgpIHtcbiAgICAgIHJldHVybiBzdGF0ZS5maWxlLnR5cGU7XG4gICAgfTtcbiAgICB2YXIgZ2V0RmlsZVNpemUgPSBmdW5jdGlvbiBnZXRGaWxlU2l6ZSgpIHtcbiAgICAgIHJldHVybiBzdGF0ZS5maWxlLnNpemU7XG4gICAgfTtcbiAgICB2YXIgZ2V0RmlsZSA9IGZ1bmN0aW9uIGdldEZpbGUoKSB7XG4gICAgICByZXR1cm4gc3RhdGUuZmlsZTtcbiAgICB9O1xuXG4gICAgLy9cbiAgICAvLyBsb2dpYyB0byBsb2FkIGEgZmlsZVxuICAgIC8vXG4gICAgdmFyIGxvYWQgPSBmdW5jdGlvbiBsb2FkKHNvdXJjZSwgbG9hZGVyLCBvbmxvYWQpIHtcbiAgICAgIC8vIHJlbWVtYmVyIHRoZSBvcmlnaW5hbCBpdGVtIHNvdXJjZVxuICAgICAgc3RhdGUuc291cmNlID0gc291cmNlO1xuXG4gICAgICAvLyBzb3VyY2UgaXMga25vd25cbiAgICAgIGFwaS5maXJlU3luYygnaW5pdCcpO1xuXG4gICAgICAvLyBmaWxlIHN0dWIgaXMgYWxyZWFkeSB0aGVyZVxuICAgICAgaWYgKHN0YXRlLmZpbGUpIHtcbiAgICAgICAgYXBpLmZpcmVTeW5jKCdsb2FkLXNraXAnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBzZXQgYSBzdHViIGZpbGUgb2JqZWN0IHdoaWxlIGxvYWRpbmcgdGhlIGFjdHVhbCBkYXRhXG4gICAgICBzdGF0ZS5maWxlID0gY3JlYXRlRmlsZVN0dWIoc291cmNlKTtcblxuICAgICAgLy8gc3RhcnRzIGxvYWRpbmdcbiAgICAgIGxvYWRlci5vbignaW5pdCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICBmaXJlKCdsb2FkLWluaXQnKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyB3ZSdldmUgcmVjZWl2ZWQgYSBzaXplIGluZGljYXRpb24sIGxldCdzIHVwZGF0ZSB0aGUgc3R1YlxuICAgICAgbG9hZGVyLm9uKCdtZXRhJywgZnVuY3Rpb24obWV0YSkge1xuICAgICAgICAvLyBzZXQgc2l6ZSBvZiBmaWxlIHN0dWJcbiAgICAgICAgc3RhdGUuZmlsZS5zaXplID0gbWV0YS5zaXplO1xuXG4gICAgICAgIC8vIHNldCBuYW1lIG9mIGZpbGUgc3R1YlxuICAgICAgICBzdGF0ZS5maWxlLmZpbGVuYW1lID0gbWV0YS5maWxlbmFtZTtcblxuICAgICAgICAvLyBpZiBoYXMgcmVjZWl2ZWQgc291cmNlLCB3ZSBkb25lXG4gICAgICAgIGlmIChtZXRhLnNvdXJjZSkge1xuICAgICAgICAgIG9yaWdpbiA9IEZpbGVPcmlnaW4uTElNQk87XG4gICAgICAgICAgc3RhdGUuc2VydmVyRmlsZVJlZmVyZW5jZSA9IG1ldGEuc291cmNlO1xuICAgICAgICAgIHN0YXRlLnN0YXR1cyA9IEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19DT01QTEVURTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNpemUgaGFzIGJlZW4gdXBkYXRlZFxuICAgICAgICBmaXJlKCdsb2FkLW1ldGEnKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyB0aGUgZmlsZSBpcyBub3cgbG9hZGluZyB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgcHJvZ3Jlc3MgaW5kaWNhdG9yc1xuICAgICAgbG9hZGVyLm9uKCdwcm9ncmVzcycsIGZ1bmN0aW9uKHByb2dyZXNzKSB7XG4gICAgICAgIHNldFN0YXR1cyhJdGVtU3RhdHVzLkxPQURJTkcpO1xuXG4gICAgICAgIGZpcmUoJ2xvYWQtcHJvZ3Jlc3MnLCBwcm9ncmVzcyk7XG4gICAgICB9KTtcblxuICAgICAgLy8gYW4gZXJyb3Igd2FzIHRocm93biB3aGlsZSBsb2FkaW5nIHRoZSBmaWxlLCB3ZSBuZWVkIHRvIHN3aXRjaCB0byBlcnJvciBzdGF0ZVxuICAgICAgbG9hZGVyLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgIHNldFN0YXR1cyhJdGVtU3RhdHVzLkxPQURfRVJST1IpO1xuXG4gICAgICAgIGZpcmUoJ2xvYWQtcmVxdWVzdC1lcnJvcicsIGVycm9yKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyB1c2VyIG9yIGFub3RoZXIgcHJvY2VzcyBhYm9ydGVkIHRoZSBmaWxlIGxvYWQgKGNhbm5vdCByZXRyeSlcbiAgICAgIGxvYWRlci5vbignYWJvcnQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgc2V0U3RhdHVzKEl0ZW1TdGF0dXMuSU5JVCk7XG4gICAgICAgIGZpcmUoJ2xvYWQtYWJvcnQnKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBkb25lIGxvYWRpbmdcbiAgICAgIGxvYWRlci5vbignbG9hZCcsIGZ1bmN0aW9uKGZpbGUpIHtcbiAgICAgICAgLy8gYXMgd2UndmUgbm93IGxvYWRlZCB0aGUgZmlsZSB0aGUgbG9hZGVyIGlzIG5vIGxvbmdlciByZXF1aXJlZFxuICAgICAgICBzdGF0ZS5hY3RpdmVMb2FkZXIgPSBudWxsO1xuXG4gICAgICAgIC8vIGNhbGxlZCB3aGVuIGZpbGUgaGFzIGxvYWRlZCBzdWNjZXNmdWxseVxuICAgICAgICB2YXIgc3VjY2VzcyA9IGZ1bmN0aW9uIHN1Y2Nlc3MocmVzdWx0KSB7XG4gICAgICAgICAgLy8gc2V0IChwb3NzaWJseSkgdHJhbnNmb3JtZWQgZmlsZVxuICAgICAgICAgIHN0YXRlLmZpbGUgPSBpc0ZpbGUocmVzdWx0KSA/IHJlc3VsdCA6IHN0YXRlLmZpbGU7XG5cbiAgICAgICAgICAvLyBmaWxlIHJlY2VpdmVkXG4gICAgICAgICAgaWYgKG9yaWdpbiA9PT0gRmlsZU9yaWdpbi5MSU1CTyAmJiBzdGF0ZS5zZXJ2ZXJGaWxlUmVmZXJlbmNlKSB7XG4gICAgICAgICAgICBzZXRTdGF0dXMoSXRlbVN0YXR1cy5QUk9DRVNTSU5HX0NPTVBMRVRFKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0U3RhdHVzKEl0ZW1TdGF0dXMuSURMRSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZmlyZSgnbG9hZCcpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBlcnJvciA9IGZ1bmN0aW9uIGVycm9yKHJlc3VsdCkge1xuICAgICAgICAgIC8vIHNldCBvcmlnaW5hbCBmaWxlXG4gICAgICAgICAgc3RhdGUuZmlsZSA9IGZpbGU7XG4gICAgICAgICAgZmlyZSgnbG9hZC1tZXRhJyk7XG5cbiAgICAgICAgICBzZXRTdGF0dXMoSXRlbVN0YXR1cy5MT0FEX0VSUk9SKTtcbiAgICAgICAgICBmaXJlKCdsb2FkLWZpbGUtZXJyb3InLCByZXN1bHQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGlmIHdlIGFscmVhZHkgaGF2ZSBhIHNlcnZlciBmaWxlIHJlZmVyZW5jZSwgd2UgZG9uJ3QgbmVlZCB0byBjYWxsIHRoZSBvbmxvYWQgbWV0aG9kXG4gICAgICAgIGlmIChzdGF0ZS5zZXJ2ZXJGaWxlUmVmZXJlbmNlKSB7XG4gICAgICAgICAgc3VjY2VzcyhmaWxlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBubyBzZXJ2ZXIgaWQsIGxldCdzIGdpdmUgdGhpcyBmaWxlIHRoZSBmdWxsIHRyZWF0bWVudFxuICAgICAgICBvbmxvYWQoZmlsZSwgc3VjY2VzcywgZXJyb3IpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIHNldCBsb2FkZXIgc291cmNlIGRhdGFcbiAgICAgIGxvYWRlci5zZXRTb3VyY2Uoc291cmNlKTtcblxuICAgICAgLy8gc2V0IGFzIGFjdGl2ZSBsb2FkZXJcbiAgICAgIHN0YXRlLmFjdGl2ZUxvYWRlciA9IGxvYWRlcjtcblxuICAgICAgLy8gbG9hZCB0aGUgc291cmNlIGRhdGFcbiAgICAgIGxvYWRlci5sb2FkKCk7XG4gICAgfTtcblxuICAgIHZhciByZXRyeUxvYWQgPSBmdW5jdGlvbiByZXRyeUxvYWQoKSB7XG4gICAgICBpZiAoIXN0YXRlLmFjdGl2ZUxvYWRlcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzdGF0ZS5hY3RpdmVMb2FkZXIubG9hZCgpO1xuICAgIH07XG5cbiAgICB2YXIgYWJvcnRMb2FkID0gZnVuY3Rpb24gYWJvcnRMb2FkKCkge1xuICAgICAgaWYgKHN0YXRlLmFjdGl2ZUxvYWRlcikge1xuICAgICAgICBzdGF0ZS5hY3RpdmVMb2FkZXIuYWJvcnQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2V0U3RhdHVzKEl0ZW1TdGF0dXMuSU5JVCk7XG4gICAgICBmaXJlKCdsb2FkLWFib3J0Jyk7XG4gICAgfTtcblxuICAgIC8vXG4gICAgLy8gbG9naWMgdG8gcHJvY2VzcyBhIGZpbGVcbiAgICAvL1xuICAgIHZhciBwcm9jZXNzID0gZnVuY3Rpb24gcHJvY2Vzcyhwcm9jZXNzb3IsIG9ucHJvY2Vzcykge1xuICAgICAgLy8gcHJvY2Vzc2luZyB3YXMgYWJvcnRlZFxuICAgICAgaWYgKHN0YXRlLnByb2Nlc3NpbmdBYm9ydGVkKSB7XG4gICAgICAgIHN0YXRlLnByb2Nlc3NpbmdBYm9ydGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gbm93IHByb2Nlc3NpbmdcbiAgICAgIHNldFN0YXR1cyhJdGVtU3RhdHVzLlBST0NFU1NJTkcpO1xuXG4gICAgICAvLyByZXNldCBhYm9ydCBjYWxsYmFja1xuICAgICAgYWJvcnRQcm9jZXNzaW5nUmVxdWVzdENvbXBsZXRlID0gbnVsbDtcblxuICAgICAgLy8gaWYgbm8gZmlsZSBsb2FkZWQgd2UnbGwgd2FpdCBmb3IgdGhlIGxvYWQgZXZlbnRcbiAgICAgIGlmICghKHN0YXRlLmZpbGUgaW5zdGFuY2VvZiBCbG9iKSkge1xuICAgICAgICBhcGkub24oJ2xvYWQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBwcm9jZXNzKHByb2Nlc3Nvciwgb25wcm9jZXNzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gc2V0dXAgcHJvY2Vzc29yXG4gICAgICBwcm9jZXNzb3Iub24oJ2xvYWQnLCBmdW5jdGlvbihzZXJ2ZXJGaWxlUmVmZXJlbmNlKSB7XG4gICAgICAgIC8vIG5lZWQgdGhpcyBpZCB0byBiZSBhYmxlIHRvIHJldmVydCB0aGUgdXBsb2FkXG4gICAgICAgIHN0YXRlLnRyYW5zZmVySWQgPSBudWxsO1xuICAgICAgICBzdGF0ZS5zZXJ2ZXJGaWxlUmVmZXJlbmNlID0gc2VydmVyRmlsZVJlZmVyZW5jZTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyByZWdpc3RlciB0cmFuc2ZlciBpZFxuICAgICAgcHJvY2Vzc29yLm9uKCd0cmFuc2ZlcicsIGZ1bmN0aW9uKHRyYW5zZmVySWQpIHtcbiAgICAgICAgLy8gbmVlZCB0aGlzIGlkIHRvIGJlIGFibGUgdG8gcmV2ZXJ0IHRoZSB1cGxvYWRcbiAgICAgICAgc3RhdGUudHJhbnNmZXJJZCA9IHRyYW5zZmVySWQ7XG4gICAgICB9KTtcblxuICAgICAgcHJvY2Vzc29yLm9uKCdsb2FkLXBlcmNlaXZlZCcsIGZ1bmN0aW9uKHNlcnZlckZpbGVSZWZlcmVuY2UpIHtcbiAgICAgICAgLy8gbm8gbG9uZ2VyIHJlcXVpcmVkXG4gICAgICAgIHN0YXRlLmFjdGl2ZVByb2Nlc3NvciA9IG51bGw7XG5cbiAgICAgICAgLy8gbmVlZCB0aGlzIGlkIHRvIGJlIGFibGUgdG8gcmV2ZXIgdGhlIHVwbG9hZFxuICAgICAgICBzdGF0ZS50cmFuc2ZlcklkID0gbnVsbDtcbiAgICAgICAgc3RhdGUuc2VydmVyRmlsZVJlZmVyZW5jZSA9IHNlcnZlckZpbGVSZWZlcmVuY2U7XG5cbiAgICAgICAgc2V0U3RhdHVzKEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19DT01QTEVURSk7XG4gICAgICAgIGZpcmUoJ3Byb2Nlc3MtY29tcGxldGUnLCBzZXJ2ZXJGaWxlUmVmZXJlbmNlKTtcbiAgICAgIH0pO1xuXG4gICAgICBwcm9jZXNzb3Iub24oJ3N0YXJ0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGZpcmUoJ3Byb2Nlc3Mtc3RhcnQnKTtcbiAgICAgIH0pO1xuXG4gICAgICBwcm9jZXNzb3Iub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgc3RhdGUuYWN0aXZlUHJvY2Vzc29yID0gbnVsbDtcbiAgICAgICAgc2V0U3RhdHVzKEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19FUlJPUik7XG4gICAgICAgIGZpcmUoJ3Byb2Nlc3MtZXJyb3InLCBlcnJvcik7XG4gICAgICB9KTtcblxuICAgICAgcHJvY2Vzc29yLm9uKCdhYm9ydCcsIGZ1bmN0aW9uKHNlcnZlckZpbGVSZWZlcmVuY2UpIHtcbiAgICAgICAgc3RhdGUuYWN0aXZlUHJvY2Vzc29yID0gbnVsbDtcblxuICAgICAgICAvLyBpZiBmaWxlIHdhcyB1cGxvYWRlZCBidXQgcHJvY2Vzc2luZyB3YXMgY2FuY2VsbGVkIGR1cmluZyBwZXJjZWl2ZWQgcHJvY2Vzc29yIHRpbWUgc3RvcmUgZmlsZSByZWZlcmVuY2VcbiAgICAgICAgc3RhdGUudHJhbnNmZXJJZCA9IG51bGw7XG4gICAgICAgIHN0YXRlLnNlcnZlckZpbGVSZWZlcmVuY2UgPSBzZXJ2ZXJGaWxlUmVmZXJlbmNlO1xuXG4gICAgICAgIHNldFN0YXR1cyhJdGVtU3RhdHVzLklETEUpO1xuICAgICAgICBmaXJlKCdwcm9jZXNzLWFib3J0Jyk7XG5cbiAgICAgICAgLy8gaGFzIHRpbWVvdXQgc28gZG9lc24ndCBpbnRlcmZlcmUgd2l0aCByZW1vdmUgYWN0aW9uXG4gICAgICAgIGlmIChhYm9ydFByb2Nlc3NpbmdSZXF1ZXN0Q29tcGxldGUpIHtcbiAgICAgICAgICBhYm9ydFByb2Nlc3NpbmdSZXF1ZXN0Q29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHByb2Nlc3Nvci5vbigncHJvZ3Jlc3MnLCBmdW5jdGlvbihwcm9ncmVzcykge1xuICAgICAgICBmaXJlKCdwcm9jZXNzLXByb2dyZXNzJywgcHJvZ3Jlc3MpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIHdoZW4gc3VjY2Vzc2Z1bGx5IHRyYW5zZm9ybWVkXG4gICAgICB2YXIgc3VjY2VzcyA9IGZ1bmN0aW9uIHN1Y2Nlc3MoZmlsZSkge1xuICAgICAgICAvLyBpZiB3YXMgYXJjaGl2ZWQgaW4gdGhlIG1lYW4gdGltZSwgZG9uJ3QgcHJvY2Vzc1xuICAgICAgICBpZiAoc3RhdGUuYXJjaGl2ZWQpIHJldHVybjtcblxuICAgICAgICAvLyBwcm9jZXNzIGZpbGUhXG4gICAgICAgIHByb2Nlc3Nvci5wcm9jZXNzKGZpbGUsIE9iamVjdC5hc3NpZ24oe30sIG1ldGFkYXRhKSk7XG4gICAgICB9O1xuXG4gICAgICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZyBkdXJpbmcgdHJhbnNmb3JtIHBoYXNlXG4gICAgICB2YXIgZXJyb3IgPSBjb25zb2xlLmVycm9yO1xuXG4gICAgICAvLyBzdGFydCBwcm9jZXNzaW5nIHRoZSBmaWxlXG4gICAgICBvbnByb2Nlc3Moc3RhdGUuZmlsZSwgc3VjY2VzcywgZXJyb3IpO1xuXG4gICAgICAvLyBzZXQgYXMgYWN0aXZlIHByb2Nlc3NvclxuICAgICAgc3RhdGUuYWN0aXZlUHJvY2Vzc29yID0gcHJvY2Vzc29yO1xuICAgIH07XG5cbiAgICB2YXIgcmVxdWVzdFByb2Nlc3NpbmcgPSBmdW5jdGlvbiByZXF1ZXN0UHJvY2Vzc2luZygpIHtcbiAgICAgIHN0YXRlLnByb2Nlc3NpbmdBYm9ydGVkID0gZmFsc2U7XG4gICAgICBzZXRTdGF0dXMoSXRlbVN0YXR1cy5QUk9DRVNTSU5HX1FVRVVFRCk7XG4gICAgfTtcblxuICAgIHZhciBhYm9ydFByb2Nlc3NpbmcgPSBmdW5jdGlvbiBhYm9ydFByb2Nlc3NpbmcoKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICBpZiAoIXN0YXRlLmFjdGl2ZVByb2Nlc3Nvcikge1xuICAgICAgICAgIHN0YXRlLnByb2Nlc3NpbmdBYm9ydGVkID0gdHJ1ZTtcblxuICAgICAgICAgIHNldFN0YXR1cyhJdGVtU3RhdHVzLklETEUpO1xuICAgICAgICAgIGZpcmUoJ3Byb2Nlc3MtYWJvcnQnKTtcblxuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBhYm9ydFByb2Nlc3NpbmdSZXF1ZXN0Q29tcGxldGUgPSBmdW5jdGlvbiBhYm9ydFByb2Nlc3NpbmdSZXF1ZXN0Q29tcGxldGUoKSB7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHN0YXRlLmFjdGl2ZVByb2Nlc3Nvci5hYm9ydCgpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vXG4gICAgLy8gbG9naWMgdG8gcmV2ZXJ0IGEgcHJvY2Vzc2VkIGZpbGVcbiAgICAvL1xuICAgIHZhciByZXZlcnQgPSBmdW5jdGlvbiByZXZlcnQocmV2ZXJ0RmlsZVVwbG9hZCwgZm9yY2VSZXZlcnQpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgLy8gY2Fubm90IHJldmVydCB3aXRob3V0IGEgc2VydmVyIGlkIGZvciB0aGlzIHByb2Nlc3NcbiAgICAgICAgaWYgKHN0YXRlLnNlcnZlckZpbGVSZWZlcmVuY2UgPT09IG51bGwpIHtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmV2ZXJ0IHRoZSB1cGxvYWQgKGZpcmUgYW5kIGZvcmdldClcbiAgICAgICAgcmV2ZXJ0RmlsZVVwbG9hZChcbiAgICAgICAgICBzdGF0ZS5zZXJ2ZXJGaWxlUmVmZXJlbmNlLFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gcmVzZXQgZmlsZSBzZXJ2ZXIgaWQgYXMgbm93IGl0J3Mgbm8gYXZhaWxhYmxlIG9uIHRoZSBzZXJ2ZXJcbiAgICAgICAgICAgIHN0YXRlLnNlcnZlckZpbGVSZWZlcmVuY2UgPSBudWxsO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIGRvbid0IHNldCBlcnJvciBzdGF0ZSB3aGVuIHJldmVydGluZyBpcyBvcHRpb25hbCwgaXQgd2lsbCBhbHdheXMgcmVzb2x2ZVxuICAgICAgICAgICAgaWYgKCFmb3JjZVJldmVydCkge1xuICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gb2ggbm8gZXJyb3JzXG4gICAgICAgICAgICBzZXRTdGF0dXMoSXRlbVN0YXR1cy5QUk9DRVNTSU5HX1JFVkVSVF9FUlJPUik7XG4gICAgICAgICAgICBmaXJlKCdwcm9jZXNzLXJldmVydC1lcnJvcicpO1xuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gZmlyZSBldmVudFxuICAgICAgICBzZXRTdGF0dXMoSXRlbVN0YXR1cy5JRExFKTtcbiAgICAgICAgZmlyZSgncHJvY2Vzcy1yZXZlcnQnKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBleHBvc2VkIG1ldGhvZHNcbiAgICB2YXIgX3NldE1ldGFkYXRhID0gZnVuY3Rpb24gc2V0TWV0YWRhdGEoa2V5LCB2YWx1ZSwgc2lsZW50KSB7XG4gICAgICB2YXIga2V5cyA9IGtleS5zcGxpdCgnLicpO1xuICAgICAgdmFyIHJvb3QgPSBrZXlzWzBdO1xuICAgICAgdmFyIGxhc3QgPSBrZXlzLnBvcCgpO1xuICAgICAgdmFyIGRhdGEgPSBtZXRhZGF0YTtcbiAgICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuIChkYXRhID0gZGF0YVtrZXldKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBjb21wYXJlIG9sZCB2YWx1ZSBhZ2FpbnN0IG5ldyB2YWx1ZSwgaWYgdGhleSdyZSB0aGUgc2FtZSwgd2UncmUgbm90IHVwZGF0aW5nXG4gICAgICBpZiAoSlNPTi5zdHJpbmdpZnkoZGF0YVtsYXN0XSkgPT09IEpTT04uc3RyaW5naWZ5KHZhbHVlKSkgcmV0dXJuO1xuXG4gICAgICAvLyB1cGRhdGUgdmFsdWVcbiAgICAgIGRhdGFbbGFzdF0gPSB2YWx1ZTtcblxuICAgICAgLy8gZG9uJ3QgZmlyZSB1cGRhdGVcbiAgICAgIGlmIChzaWxlbnQpIHJldHVybjtcblxuICAgICAgLy8gZmlyZSB1cGRhdGVcbiAgICAgIGZpcmUoJ21ldGFkYXRhLXVwZGF0ZScsIHtcbiAgICAgICAga2V5OiByb290LFxuICAgICAgICB2YWx1ZTogbWV0YWRhdGFbcm9vdF1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0TWV0YWRhdGEgPSBmdW5jdGlvbiBnZXRNZXRhZGF0YShrZXkpIHtcbiAgICAgIHJldHVybiBkZWVwQ2xvbmVPYmplY3Qoa2V5ID8gbWV0YWRhdGFba2V5XSA6IG1ldGFkYXRhKTtcbiAgICB9O1xuXG4gICAgdmFyIGFwaSA9IE9iamVjdC5hc3NpZ24oXG4gICAgICB7XG4gICAgICAgIGlkOiB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvcmlnaW46IHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW47XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzZXJ2ZXJJZDoge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlLnNlcnZlckZpbGVSZWZlcmVuY2U7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB0cmFuc2ZlcklkOiB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGUudHJhbnNmZXJJZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHN0YXR1czoge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlLnN0YXR1cztcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZpbGVuYW1lOiB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGUuZmlsZS5uYW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZmlsZW5hbWVXaXRob3V0RXh0ZW5zaW9uOiB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0RmlsZW5hbWVXaXRob3V0RXh0ZW5zaW9uKHN0YXRlLmZpbGUubmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmaWxlRXh0ZW5zaW9uOiB7IGdldDogZ2V0RmlsZUV4dGVuc2lvbiB9LFxuICAgICAgICBmaWxlVHlwZTogeyBnZXQ6IGdldEZpbGVUeXBlIH0sXG4gICAgICAgIGZpbGVTaXplOiB7IGdldDogZ2V0RmlsZVNpemUgfSxcbiAgICAgICAgZmlsZTogeyBnZXQ6IGdldEZpbGUgfSxcbiAgICAgICAgcmVsYXRpdmVQYXRoOiB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGUuZmlsZS5fcmVsYXRpdmVQYXRoO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBzb3VyY2U6IHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZS5zb3VyY2U7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGdldE1ldGFkYXRhOiBnZXRNZXRhZGF0YSxcbiAgICAgICAgc2V0TWV0YWRhdGE6IGZ1bmN0aW9uIHNldE1ldGFkYXRhKGtleSwgdmFsdWUsIHNpbGVudCkge1xuICAgICAgICAgIGlmIChpc09iamVjdChrZXkpKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IGtleTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGRhdGEpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgIF9zZXRNZXRhZGF0YShrZXksIGRhdGFba2V5XSwgdmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBfc2V0TWV0YWRhdGEoa2V5LCB2YWx1ZSwgc2lsZW50KTtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZXh0ZW5kOiBmdW5jdGlvbiBleHRlbmQobmFtZSwgaGFuZGxlcikge1xuICAgICAgICAgIHJldHVybiAoaXRlbUFQSVtuYW1lXSA9IGhhbmRsZXIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFib3J0TG9hZDogYWJvcnRMb2FkLFxuICAgICAgICByZXRyeUxvYWQ6IHJldHJ5TG9hZCxcbiAgICAgICAgcmVxdWVzdFByb2Nlc3Npbmc6IHJlcXVlc3RQcm9jZXNzaW5nLFxuICAgICAgICBhYm9ydFByb2Nlc3Npbmc6IGFib3J0UHJvY2Vzc2luZyxcblxuICAgICAgICBsb2FkOiBsb2FkLFxuICAgICAgICBwcm9jZXNzOiBwcm9jZXNzLFxuICAgICAgICByZXZlcnQ6IHJldmVydFxuICAgICAgfSxcblxuICAgICAgb24oKSxcbiAgICAgIHtcbiAgICAgICAgZnJlZXplOiBmdW5jdGlvbiBmcmVlemUoKSB7XG4gICAgICAgICAgcmV0dXJuIChzdGF0ZS5mcm96ZW4gPSB0cnVlKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZWxlYXNlOiBmdW5jdGlvbiByZWxlYXNlKCkge1xuICAgICAgICAgIHJldHVybiAoc3RhdGUucmVsZWFzZWQgPSB0cnVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVsZWFzZWQ6IHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZS5yZWxlYXNlZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgYXJjaGl2ZTogZnVuY3Rpb24gYXJjaGl2ZSgpIHtcbiAgICAgICAgICByZXR1cm4gKHN0YXRlLmFyY2hpdmVkID0gdHJ1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGFyY2hpdmVkOiB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGUuYXJjaGl2ZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcblxuICAgIC8vIGNyZWF0ZSBpdCBoZXJlIGluc3RlYWQgb2YgcmV0dXJuaW5nIGl0IGluc3RhbnRseSBzbyB3ZSBjYW4gZXh0ZW5kIGl0IGxhdGVyXG4gICAgdmFyIGl0ZW1BUEkgPSBjcmVhdGVPYmplY3QoYXBpKTtcblxuICAgIHJldHVybiBpdGVtQVBJO1xuICB9O1xuXG4gIHZhciBnZXRJdGVtSW5kZXhCeVF1ZXJ5ID0gZnVuY3Rpb24gZ2V0SXRlbUluZGV4QnlRdWVyeShpdGVtcywgcXVlcnkpIHtcbiAgICAvLyBqdXN0IHJldHVybiBmaXJzdCBpbmRleFxuICAgIGlmIChpc0VtcHR5KHF1ZXJ5KSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgLy8gaW52YWxpZCBxdWVyaWVzXG4gICAgaWYgKCFpc1N0cmluZyhxdWVyeSkpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvLyByZXR1cm4gaXRlbSBieSBpZCAob3IgLTEgaWYgbm90IGZvdW5kKVxuICAgIHJldHVybiBpdGVtcy5maW5kSW5kZXgoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgcmV0dXJuIGl0ZW0uaWQgPT09IHF1ZXJ5O1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBnZXRJdGVtQnlJZCA9IGZ1bmN0aW9uIGdldEl0ZW1CeUlkKGl0ZW1zLCBpdGVtSWQpIHtcbiAgICB2YXIgaW5kZXggPSBnZXRJdGVtSW5kZXhCeVF1ZXJ5KGl0ZW1zLCBpdGVtSWQpO1xuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIGl0ZW1zW2luZGV4XSB8fCBudWxsO1xuICB9O1xuXG4gIHZhciBmZXRjaEJsb2IgPSBmdW5jdGlvbiBmZXRjaEJsb2IoXG4gICAgdXJsLFxuICAgIGxvYWQsXG4gICAgZXJyb3IsXG4gICAgcHJvZ3Jlc3MsXG4gICAgYWJvcnQsXG4gICAgaGVhZGVyc1xuICApIHtcbiAgICB2YXIgcmVxdWVzdCA9IHNlbmRSZXF1ZXN0KG51bGwsIHVybCwge1xuICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgIHJlc3BvbnNlVHlwZTogJ2Jsb2InXG4gICAgfSk7XG5cbiAgICByZXF1ZXN0Lm9ubG9hZCA9IGZ1bmN0aW9uKHhocikge1xuICAgICAgLy8gZ2V0IGhlYWRlcnNcbiAgICAgIHZhciBoZWFkZXJzID0geGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpO1xuXG4gICAgICAvLyBnZXQgZmlsZW5hbWVcbiAgICAgIHZhciBmaWxlbmFtZSA9XG4gICAgICAgIGdldEZpbGVJbmZvRnJvbUhlYWRlcnMoaGVhZGVycykubmFtZSB8fCBnZXRGaWxlbmFtZUZyb21VUkwodXJsKTtcblxuICAgICAgLy8gY3JlYXRlIHJlc3BvbnNlXG4gICAgICBsb2FkKFxuICAgICAgICBjcmVhdGVSZXNwb25zZShcbiAgICAgICAgICAnbG9hZCcsXG4gICAgICAgICAgeGhyLnN0YXR1cyxcbiAgICAgICAgICBnZXRGaWxlRnJvbUJsb2IoeGhyLnJlc3BvbnNlLCBmaWxlbmFtZSksXG4gICAgICAgICAgaGVhZGVyc1xuICAgICAgICApXG4gICAgICApO1xuICAgIH07XG5cbiAgICByZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbih4aHIpIHtcbiAgICAgIGVycm9yKFxuICAgICAgICBjcmVhdGVSZXNwb25zZShcbiAgICAgICAgICAnZXJyb3InLFxuICAgICAgICAgIHhoci5zdGF0dXMsXG4gICAgICAgICAgeGhyLnN0YXR1c1RleHQsXG4gICAgICAgICAgeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfTtcblxuICAgIHJlcXVlc3Qub25oZWFkZXJzID0gZnVuY3Rpb24oeGhyKSB7XG4gICAgICBoZWFkZXJzKFxuICAgICAgICBjcmVhdGVSZXNwb25zZSgnaGVhZGVycycsIHhoci5zdGF0dXMsIG51bGwsIHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSlcbiAgICAgICk7XG4gICAgfTtcblxuICAgIHJlcXVlc3Qub250aW1lb3V0ID0gY3JlYXRlVGltZW91dFJlc3BvbnNlKGVycm9yKTtcbiAgICByZXF1ZXN0Lm9ucHJvZ3Jlc3MgPSBwcm9ncmVzcztcbiAgICByZXF1ZXN0Lm9uYWJvcnQgPSBhYm9ydDtcblxuICAgIC8vIHNob3VsZCByZXR1cm4gcmVxdWVzdFxuICAgIHJldHVybiByZXF1ZXN0O1xuICB9O1xuXG4gIHZhciBnZXREb21haW5Gcm9tVVJMID0gZnVuY3Rpb24gZ2V0RG9tYWluRnJvbVVSTCh1cmwpIHtcbiAgICBpZiAodXJsLmluZGV4T2YoJy8vJykgPT09IDApIHtcbiAgICAgIHVybCA9IGxvY2F0aW9uLnByb3RvY29sICsgdXJsO1xuICAgIH1cbiAgICByZXR1cm4gdXJsXG4gICAgICAudG9Mb3dlckNhc2UoKVxuICAgICAgLnJlcGxhY2UoJ2Jsb2I6JywgJycpXG4gICAgICAucmVwbGFjZSgvKFthLXpdKT86XFwvXFwvLywgJyQxJylcbiAgICAgIC5zcGxpdCgnLycpWzBdO1xuICB9O1xuXG4gIHZhciBpc0V4dGVybmFsVVJMID0gZnVuY3Rpb24gaXNFeHRlcm5hbFVSTCh1cmwpIHtcbiAgICByZXR1cm4gKFxuICAgICAgKHVybC5pbmRleE9mKCc6JykgPiAtMSB8fCB1cmwuaW5kZXhPZignLy8nKSA+IC0xKSAmJlxuICAgICAgZ2V0RG9tYWluRnJvbVVSTChsb2NhdGlvbi5ocmVmKSAhPT0gZ2V0RG9tYWluRnJvbVVSTCh1cmwpXG4gICAgKTtcbiAgfTtcblxuICB2YXIgZHluYW1pY0xhYmVsID0gZnVuY3Rpb24gZHluYW1pY0xhYmVsKGxhYmVsKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGlzRnVuY3Rpb24obGFiZWwpID8gbGFiZWwuYXBwbHkodm9pZCAwLCBhcmd1bWVudHMpIDogbGFiZWw7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgaXNNb2NrSXRlbSA9IGZ1bmN0aW9uIGlzTW9ja0l0ZW0oaXRlbSkge1xuICAgIHJldHVybiAhaXNGaWxlKGl0ZW0uZmlsZSk7XG4gIH07XG5cbiAgdmFyIGxpc3RVcGRhdGVkID0gZnVuY3Rpb24gbGlzdFVwZGF0ZWQoZGlzcGF0Y2gsIHN0YXRlKSB7XG4gICAgY2xlYXJUaW1lb3V0KHN0YXRlLmxpc3RVcGRhdGVUaW1lb3V0KTtcbiAgICBzdGF0ZS5saXN0VXBkYXRlVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBkaXNwYXRjaCgnRElEX1VQREFURV9JVEVNUycsIHsgaXRlbXM6IGdldEFjdGl2ZUl0ZW1zKHN0YXRlLml0ZW1zKSB9KTtcbiAgICB9LCAwKTtcbiAgfTtcblxuICB2YXIgb3B0aW9uYWxQcm9taXNlID0gZnVuY3Rpb24gb3B0aW9uYWxQcm9taXNlKGZuKSB7XG4gICAgZm9yIChcbiAgICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgcGFyYW1zID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSxcbiAgICAgICAgX2tleSA9IDE7XG4gICAgICBfa2V5IDwgX2xlbjtcbiAgICAgIF9rZXkrK1xuICAgICkge1xuICAgICAgcGFyYW1zW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgIGlmICghZm4pIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmUodHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSBmbi5hcHBseSh2b2lkIDAsIHBhcmFtcyk7XG5cbiAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZSh0cnVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09ICdib29sZWFuJykge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHJlc3VsdC50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJlc3VsdC50aGVuKHJlc29sdmUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHZhciBzb3J0SXRlbXMgPSBmdW5jdGlvbiBzb3J0SXRlbXMoc3RhdGUsIGNvbXBhcmUpIHtcbiAgICBzdGF0ZS5pdGVtcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgIHJldHVybiBjb21wYXJlKGNyZWF0ZUl0ZW1BUEkoYSksIGNyZWF0ZUl0ZW1BUEkoYikpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIHJldHVybnMgaXRlbSBiYXNlZCBvbiBzdGF0ZVxuICB2YXIgZ2V0SXRlbUJ5UXVlcnlGcm9tU3RhdGUgPSBmdW5jdGlvbiBnZXRJdGVtQnlRdWVyeUZyb21TdGF0ZShcbiAgICBzdGF0ZSxcbiAgICBpdGVtSGFuZGxlclxuICApIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgX3JlZiA9XG4gICAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgICB2YXIgcXVlcnkgPSBfcmVmLnF1ZXJ5LFxuICAgICAgICBfcmVmJHN1Y2Nlc3MgPSBfcmVmLnN1Y2Nlc3MsXG4gICAgICAgIHN1Y2Nlc3MgPSBfcmVmJHN1Y2Nlc3MgPT09IHZvaWQgMCA/IGZ1bmN0aW9uKCkge30gOiBfcmVmJHN1Y2Nlc3MsXG4gICAgICAgIF9yZWYkZmFpbHVyZSA9IF9yZWYuZmFpbHVyZSxcbiAgICAgICAgZmFpbHVyZSA9IF9yZWYkZmFpbHVyZSA9PT0gdm9pZCAwID8gZnVuY3Rpb24oKSB7fSA6IF9yZWYkZmFpbHVyZSxcbiAgICAgICAgb3B0aW9ucyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbXG4gICAgICAgICAgJ3F1ZXJ5JyxcbiAgICAgICAgICAnc3VjY2VzcycsXG4gICAgICAgICAgJ2ZhaWx1cmUnXG4gICAgICAgIF0pO1xuICAgICAgdmFyIGl0ZW0gPSBnZXRJdGVtQnlRdWVyeShzdGF0ZS5pdGVtcywgcXVlcnkpO1xuICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgIGZhaWx1cmUoe1xuICAgICAgICAgIGVycm9yOiBjcmVhdGVSZXNwb25zZSgnZXJyb3InLCAwLCAnSXRlbSBub3QgZm91bmQnKSxcblxuICAgICAgICAgIGZpbGU6IG51bGxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaXRlbUhhbmRsZXIoaXRlbSwgc3VjY2VzcywgZmFpbHVyZSwgb3B0aW9ucyB8fCB7fSk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgYWN0aW9ucyA9IGZ1bmN0aW9uIGFjdGlvbnMoZGlzcGF0Y2gsIHF1ZXJ5LCBzdGF0ZSkge1xuICAgIHJldHVybiB7XG4gICAgICAvKipcbiAgICAgICAqIEFib3J0cyBhbGwgb25nb2luZyBwcm9jZXNzZXNcbiAgICAgICAqL1xuICAgICAgQUJPUlRfQUxMOiBmdW5jdGlvbiBBQk9SVF9BTEwoKSB7XG4gICAgICAgIGdldEFjdGl2ZUl0ZW1zKHN0YXRlLml0ZW1zKS5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICBpdGVtLmZyZWV6ZSgpO1xuICAgICAgICAgIGl0ZW0uYWJvcnRMb2FkKCk7XG4gICAgICAgICAgaXRlbS5hYm9ydFByb2Nlc3NpbmcoKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFNldHMgaW5pdGlhbCBmaWxlc1xuICAgICAgICovXG4gICAgICBESURfU0VUX0ZJTEVTOiBmdW5jdGlvbiBESURfU0VUX0ZJTEVTKF9yZWYyKSB7XG4gICAgICAgIHZhciBfcmVmMiR2YWx1ZSA9IF9yZWYyLnZhbHVlLFxuICAgICAgICAgIHZhbHVlID0gX3JlZjIkdmFsdWUgPT09IHZvaWQgMCA/IFtdIDogX3JlZjIkdmFsdWU7XG5cbiAgICAgICAgLy8gbWFwIHZhbHVlcyB0byBmaWxlIG9iamVjdHNcbiAgICAgICAgdmFyIGZpbGVzID0gdmFsdWUubWFwKGZ1bmN0aW9uKGZpbGUpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc291cmNlOiBmaWxlLnNvdXJjZSA/IGZpbGUuc291cmNlIDogZmlsZSxcbiAgICAgICAgICAgIG9wdGlvbnM6IGZpbGUub3B0aW9uc1xuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGxvb3Agb3ZlciBmaWxlcywgaWYgZmlsZSBpcyBpbiBsaXN0LCBsZWF2ZSBpdCBiZSwgaWYgbm90LCByZW1vdmVcbiAgICAgICAgLy8gdGVzdCBpZiBpdGVtcyBzaG91bGQgYmUgbW92ZWRcbiAgICAgICAgdmFyIGFjdGl2ZUl0ZW1zID0gZ2V0QWN0aXZlSXRlbXMoc3RhdGUuaXRlbXMpO1xuXG4gICAgICAgIGFjdGl2ZUl0ZW1zLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgIC8vIGlmIGl0ZW0gbm90IGlzIGluIG5ldyB2YWx1ZSwgcmVtb3ZlXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIWZpbGVzLmZpbmQoZnVuY3Rpb24oZmlsZSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmlsZS5zb3VyY2UgPT09IGl0ZW0uc291cmNlIHx8IGZpbGUuc291cmNlID09PSBpdGVtLmZpbGU7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgZGlzcGF0Y2goJ1JFTU9WRV9JVEVNJywgeyBxdWVyeTogaXRlbSwgcmVtb3ZlOiBmYWxzZSB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGFkZCBuZXcgZmlsZXNcbiAgICAgICAgYWN0aXZlSXRlbXMgPSBnZXRBY3RpdmVJdGVtcyhzdGF0ZS5pdGVtcyk7XG4gICAgICAgIGZpbGVzLmZvckVhY2goZnVuY3Rpb24oZmlsZSwgaW5kZXgpIHtcbiAgICAgICAgICAvLyBpZiBmaWxlIGlzIGFscmVhZHkgaW4gbGlzdFxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGFjdGl2ZUl0ZW1zLmZpbmQoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICByZXR1cm4gaXRlbS5zb3VyY2UgPT09IGZpbGUuc291cmNlIHx8IGl0ZW0uZmlsZSA9PT0gZmlsZS5zb3VyY2U7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgIClcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgIC8vIG5vdCBpbiBsaXN0LCBhZGRcbiAgICAgICAgICBkaXNwYXRjaChcbiAgICAgICAgICAgICdBRERfSVRFTScsXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHt9LCBmaWxlLCB7XG4gICAgICAgICAgICAgIGludGVyYWN0aW9uTWV0aG9kOiBJbnRlcmFjdGlvbk1ldGhvZC5OT05FLFxuICAgICAgICAgICAgICBpbmRleDogaW5kZXhcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuXG4gICAgICBESURfVVBEQVRFX0lURU1fTUVUQURBVEE6IGZ1bmN0aW9uIERJRF9VUERBVEVfSVRFTV9NRVRBREFUQShfcmVmMykge1xuICAgICAgICB2YXIgaWQgPSBfcmVmMy5pZDtcblxuICAgICAgICAvLyBpZiBpcyBjYWxsZWQgbXVsdGlwbGUgdGltZXMgaW4gY2xvc2Ugc3VjY2Vzc2lvbiB3ZSBjb21iaW5lZCBhbGwgY2FsbHMgdG9nZXRoZXIgdG8gc2F2ZSByZXNvdXJjZXNcbiAgICAgICAgY2xlYXJUaW1lb3V0KHN0YXRlLml0ZW1VcGRhdGVUaW1lb3V0KTtcbiAgICAgICAgc3RhdGUuaXRlbVVwZGF0ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBpdGVtID0gZ2V0SXRlbUJ5SWQoc3RhdGUuaXRlbXMsIGlkKTtcblxuICAgICAgICAgIC8vIG9ubHkgcmV2ZXJ0IGFuZCBhdHRlbXB0IHRvIHVwbG9hZCB3aGVuIHdlJ3JlIHVwbG9hZGluZyB0byBhIHNlcnZlclxuICAgICAgICAgIGlmICghcXVlcnkoJ0lTX0FTWU5DJykpIHtcbiAgICAgICAgICAgIC8vIHNob3VsZCB3ZSB1cGRhdGUgdGhlIG91dHB1dCBkYXRhXG4gICAgICAgICAgICBhcHBseUZpbHRlckNoYWluKCdTSE9VTERfUFJFUEFSRV9PVVRQVVQnLCBmYWxzZSwge1xuICAgICAgICAgICAgICBpdGVtOiBpdGVtLFxuICAgICAgICAgICAgICBxdWVyeTogcXVlcnlcbiAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oc2hvdWxkUHJlcGFyZU91dHB1dCkge1xuICAgICAgICAgICAgICBpZiAoIXNob3VsZFByZXBhcmVPdXRwdXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGlzcGF0Y2goXG4gICAgICAgICAgICAgICAgJ1JFUVVFU1RfUFJFUEFSRV9PVVRQVVQnLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBpZCxcbiAgICAgICAgICAgICAgICAgIGl0ZW06IGl0ZW0sXG4gICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiBzdWNjZXNzKGZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9QUkVQQVJFX09VVFBVVCcsIHsgaWQ6IGlkLCBmaWxlOiBmaWxlIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBmb3IgYXN5bmMgc2NlbmFyaW9zXG4gICAgICAgICAgdmFyIHVwbG9hZCA9IGZ1bmN0aW9uIHVwbG9hZCgpIHtcbiAgICAgICAgICAgIC8vIHdlIHB1c2ggdGhpcyBmb3J3YXJkIGEgYml0IHNvIHRoZSBpbnRlcmZhY2UgaXMgdXBkYXRlZCBjb3JyZWN0bHlcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGRpc3BhdGNoKCdSRVFVRVNUX0lURU1fUFJPQ0VTU0lORycsIHsgcXVlcnk6IGlkIH0pO1xuICAgICAgICAgICAgfSwgMzIpO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICB2YXIgcmV2ZXJ0ID0gZnVuY3Rpb24gcmV2ZXJ0KGRvVXBsb2FkKSB7XG4gICAgICAgICAgICBpdGVtXG4gICAgICAgICAgICAgIC5yZXZlcnQoXG4gICAgICAgICAgICAgICAgY3JlYXRlUmV2ZXJ0RnVuY3Rpb24oXG4gICAgICAgICAgICAgICAgICBzdGF0ZS5vcHRpb25zLnNlcnZlci51cmwsXG4gICAgICAgICAgICAgICAgICBzdGF0ZS5vcHRpb25zLnNlcnZlci5yZXZlcnRcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIHF1ZXJ5KCdHRVRfRk9SQ0VfUkVWRVJUJylcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAudGhlbihkb1VwbG9hZCA/IHVwbG9hZCA6IGZ1bmN0aW9uKCkge30pXG4gICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbigpIHt9KTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgdmFyIGFib3J0ID0gZnVuY3Rpb24gYWJvcnQoZG9VcGxvYWQpIHtcbiAgICAgICAgICAgIGl0ZW0uYWJvcnRQcm9jZXNzaW5nKCkudGhlbihkb1VwbG9hZCA/IHVwbG9hZCA6IGZ1bmN0aW9uKCkge30pO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICAvLyBpZiB3ZSBzaG91bGQgcmUtdXBsb2FkIHRoZSBmaWxlIGltbWVkaWF0ZWx5XG4gICAgICAgICAgaWYgKGl0ZW0uc3RhdHVzID09PSBJdGVtU3RhdHVzLlBST0NFU1NJTkdfQ09NUExFVEUpIHtcbiAgICAgICAgICAgIHJldHVybiByZXZlcnQoc3RhdGUub3B0aW9ucy5pbnN0YW50VXBsb2FkKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBpZiBjdXJyZW50bHkgdXBsb2FkaW5nLCBjYW5jZWwgdXBsb2FkXG4gICAgICAgICAgaWYgKGl0ZW0uc3RhdHVzID09PSBJdGVtU3RhdHVzLlBST0NFU1NJTkcpIHtcbiAgICAgICAgICAgIHJldHVybiBhYm9ydChzdGF0ZS5vcHRpb25zLmluc3RhbnRVcGxvYWQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzdGF0ZS5vcHRpb25zLmluc3RhbnRVcGxvYWQpIHtcbiAgICAgICAgICAgIHVwbG9hZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgMCk7XG4gICAgICB9LFxuXG4gICAgICBNT1ZFX0lURU06IGZ1bmN0aW9uIE1PVkVfSVRFTShfcmVmNCkge1xuICAgICAgICB2YXIgcXVlcnkgPSBfcmVmNC5xdWVyeSxcbiAgICAgICAgICBpbmRleCA9IF9yZWY0LmluZGV4O1xuICAgICAgICB2YXIgaXRlbSA9IGdldEl0ZW1CeVF1ZXJ5KHN0YXRlLml0ZW1zLCBxdWVyeSk7XG4gICAgICAgIGlmICghaXRlbSkgcmV0dXJuO1xuICAgICAgICB2YXIgY3VycmVudEluZGV4ID0gc3RhdGUuaXRlbXMuaW5kZXhPZihpdGVtKTtcbiAgICAgICAgaW5kZXggPSBsaW1pdChpbmRleCwgMCwgc3RhdGUuaXRlbXMubGVuZ3RoIC0gMSk7XG4gICAgICAgIGlmIChjdXJyZW50SW5kZXggPT09IGluZGV4KSByZXR1cm47XG4gICAgICAgIHN0YXRlLml0ZW1zLnNwbGljZShpbmRleCwgMCwgc3RhdGUuaXRlbXMuc3BsaWNlKGN1cnJlbnRJbmRleCwgMSlbMF0pO1xuICAgICAgfSxcblxuICAgICAgU09SVDogZnVuY3Rpb24gU09SVChfcmVmNSkge1xuICAgICAgICB2YXIgY29tcGFyZSA9IF9yZWY1LmNvbXBhcmU7XG4gICAgICAgIHNvcnRJdGVtcyhzdGF0ZSwgY29tcGFyZSk7XG4gICAgICAgIGRpc3BhdGNoKCdESURfU09SVF9JVEVNUycsIHtcbiAgICAgICAgICBpdGVtczogcXVlcnkoJ0dFVF9BQ1RJVkVfSVRFTVMnKVxuICAgICAgICB9KTtcbiAgICAgIH0sXG5cbiAgICAgIEFERF9JVEVNUzogZnVuY3Rpb24gQUREX0lURU1TKF9yZWY2KSB7XG4gICAgICAgIHZhciBpdGVtcyA9IF9yZWY2Lml0ZW1zLFxuICAgICAgICAgIGluZGV4ID0gX3JlZjYuaW5kZXgsXG4gICAgICAgICAgaW50ZXJhY3Rpb25NZXRob2QgPSBfcmVmNi5pbnRlcmFjdGlvbk1ldGhvZCxcbiAgICAgICAgICBfcmVmNiRzdWNjZXNzID0gX3JlZjYuc3VjY2VzcyxcbiAgICAgICAgICBzdWNjZXNzID0gX3JlZjYkc3VjY2VzcyA9PT0gdm9pZCAwID8gZnVuY3Rpb24oKSB7fSA6IF9yZWY2JHN1Y2Nlc3MsXG4gICAgICAgICAgX3JlZjYkZmFpbHVyZSA9IF9yZWY2LmZhaWx1cmUsXG4gICAgICAgICAgZmFpbHVyZSA9IF9yZWY2JGZhaWx1cmUgPT09IHZvaWQgMCA/IGZ1bmN0aW9uKCkge30gOiBfcmVmNiRmYWlsdXJlO1xuXG4gICAgICAgIHZhciBjdXJyZW50SW5kZXggPSBpbmRleDtcblxuICAgICAgICBpZiAoaW5kZXggPT09IC0xIHx8IHR5cGVvZiBpbmRleCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB2YXIgaW5zZXJ0TG9jYXRpb24gPSBxdWVyeSgnR0VUX0lURU1fSU5TRVJUX0xPQ0FUSU9OJyk7XG4gICAgICAgICAgdmFyIHRvdGFsSXRlbXMgPSBxdWVyeSgnR0VUX1RPVEFMX0lURU1TJyk7XG4gICAgICAgICAgY3VycmVudEluZGV4ID0gaW5zZXJ0TG9jYXRpb24gPT09ICdiZWZvcmUnID8gMCA6IHRvdGFsSXRlbXM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaWdub3JlZEZpbGVzID0gcXVlcnkoJ0dFVF9JR05PUkVEX0ZJTEVTJyk7XG4gICAgICAgIHZhciBpc1ZhbGlkRmlsZSA9IGZ1bmN0aW9uIGlzVmFsaWRGaWxlKHNvdXJjZSkge1xuICAgICAgICAgIHJldHVybiBpc0ZpbGUoc291cmNlKVxuICAgICAgICAgICAgPyAhaWdub3JlZEZpbGVzLmluY2x1ZGVzKHNvdXJjZS5uYW1lLnRvTG93ZXJDYXNlKCkpXG4gICAgICAgICAgICA6ICFpc0VtcHR5KHNvdXJjZSk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciB2YWxpZEl0ZW1zID0gaXRlbXMuZmlsdGVyKGlzVmFsaWRGaWxlKTtcblxuICAgICAgICB2YXIgcHJvbWlzZXMgPSB2YWxpZEl0ZW1zLm1hcChmdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBkaXNwYXRjaCgnQUREX0lURU0nLCB7XG4gICAgICAgICAgICAgIGludGVyYWN0aW9uTWV0aG9kOiBpbnRlcmFjdGlvbk1ldGhvZCxcbiAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2Uuc291cmNlIHx8IHNvdXJjZSxcbiAgICAgICAgICAgICAgc3VjY2VzczogcmVzb2x2ZSxcbiAgICAgICAgICAgICAgZmFpbHVyZTogcmVqZWN0LFxuICAgICAgICAgICAgICBpbmRleDogY3VycmVudEluZGV4KyssXG4gICAgICAgICAgICAgIG9wdGlvbnM6IHNvdXJjZS5vcHRpb25zIHx8IHt9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgUHJvbWlzZS5hbGwocHJvbWlzZXMpXG4gICAgICAgICAgLnRoZW4oc3VjY2VzcylcbiAgICAgICAgICAuY2F0Y2goZmFpbHVyZSk7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSBzb3VyY2VcbiAgICAgICAqIEBwYXJhbSBpbmRleFxuICAgICAgICogQHBhcmFtIGludGVyYWN0aW9uTWV0aG9kXG4gICAgICAgKi9cbiAgICAgIEFERF9JVEVNOiBmdW5jdGlvbiBBRERfSVRFTShfcmVmNykge1xuICAgICAgICB2YXIgc291cmNlID0gX3JlZjcuc291cmNlLFxuICAgICAgICAgIF9yZWY3JGluZGV4ID0gX3JlZjcuaW5kZXgsXG4gICAgICAgICAgaW5kZXggPSBfcmVmNyRpbmRleCA9PT0gdm9pZCAwID8gLTEgOiBfcmVmNyRpbmRleCxcbiAgICAgICAgICBpbnRlcmFjdGlvbk1ldGhvZCA9IF9yZWY3LmludGVyYWN0aW9uTWV0aG9kLFxuICAgICAgICAgIF9yZWY3JHN1Y2Nlc3MgPSBfcmVmNy5zdWNjZXNzLFxuICAgICAgICAgIHN1Y2Nlc3MgPSBfcmVmNyRzdWNjZXNzID09PSB2b2lkIDAgPyBmdW5jdGlvbigpIHt9IDogX3JlZjckc3VjY2VzcyxcbiAgICAgICAgICBfcmVmNyRmYWlsdXJlID0gX3JlZjcuZmFpbHVyZSxcbiAgICAgICAgICBmYWlsdXJlID0gX3JlZjckZmFpbHVyZSA9PT0gdm9pZCAwID8gZnVuY3Rpb24oKSB7fSA6IF9yZWY3JGZhaWx1cmUsXG4gICAgICAgICAgX3JlZjckb3B0aW9ucyA9IF9yZWY3Lm9wdGlvbnMsXG4gICAgICAgICAgb3B0aW9ucyA9IF9yZWY3JG9wdGlvbnMgPT09IHZvaWQgMCA/IHt9IDogX3JlZjckb3B0aW9ucztcblxuICAgICAgICAvLyBpZiBubyBzb3VyY2Ugc3VwcGxpZWRcbiAgICAgICAgaWYgKGlzRW1wdHkoc291cmNlKSkge1xuICAgICAgICAgIGZhaWx1cmUoe1xuICAgICAgICAgICAgZXJyb3I6IGNyZWF0ZVJlc3BvbnNlKCdlcnJvcicsIDAsICdObyBzb3VyY2UnKSxcblxuICAgICAgICAgICAgZmlsZTogbnVsbFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmlsdGVyIG91dCBpbnZhbGlkIGZpbGUgaXRlbXMsIHVzZWQgdG8gZmlsdGVyIGRyb3BwZWQgZGlyZWN0b3J5IGNvbnRlbnRzXG4gICAgICAgIGlmIChcbiAgICAgICAgICBpc0ZpbGUoc291cmNlKSAmJlxuICAgICAgICAgIHN0YXRlLm9wdGlvbnMuaWdub3JlZEZpbGVzLmluY2x1ZGVzKHNvdXJjZS5uYW1lLnRvTG93ZXJDYXNlKCkpXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIGZhaWwgc2lsZW50bHlcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0ZXN0IGlmIHRoZXJlJ3Mgc3RpbGwgcm9vbSBpbiB0aGUgbGlzdCBvZiBmaWxlc1xuICAgICAgICBpZiAoIWhhc1Jvb21Gb3JJdGVtKHN0YXRlKSkge1xuICAgICAgICAgIC8vIGlmIG11bHRpcGxlIGFsbG93ZWQsIHdlIGNhbid0IHJlcGxhY2VcbiAgICAgICAgICAvLyBvciBpZiBvbmx5IGEgc2luZ2xlIGl0ZW0gaXMgYWxsb3dlZCBidXQgd2UncmUgbm90IGFsbG93ZWQgdG8gcmVwbGFjZSBpdCB3ZSBleGl0XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgc3RhdGUub3B0aW9ucy5hbGxvd011bHRpcGxlIHx8XG4gICAgICAgICAgICAoIXN0YXRlLm9wdGlvbnMuYWxsb3dNdWx0aXBsZSAmJiAhc3RhdGUub3B0aW9ucy5hbGxvd1JlcGxhY2UpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSBjcmVhdGVSZXNwb25zZSgnd2FybmluZycsIDAsICdNYXggZmlsZXMnKTtcblxuICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9USFJPV19NQVhfRklMRVMnLCB7XG4gICAgICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgICAgICBlcnJvcjogZXJyb3JcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBmYWlsdXJlKHsgZXJyb3I6IGVycm9yLCBmaWxlOiBudWxsIH0pO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gbGV0J3MgcmVwbGFjZSB0aGUgaXRlbVxuICAgICAgICAgIC8vIGlkIG9mIGZpcnN0IGl0ZW0gd2UncmUgYWJvdXQgdG8gcmVtb3ZlXG4gICAgICAgICAgdmFyIF9pdGVtID0gZ2V0QWN0aXZlSXRlbXMoc3RhdGUuaXRlbXMpWzBdO1xuXG4gICAgICAgICAgLy8gaWYgaGFzIGJlZW4gcHJvY2Vzc2VkIHJlbW92ZSBpdCBmcm9tIHRoZSBzZXJ2ZXIgYXMgd2VsbFxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIF9pdGVtLnN0YXR1cyA9PT0gSXRlbVN0YXR1cy5QUk9DRVNTSU5HX0NPTVBMRVRFIHx8XG4gICAgICAgICAgICBfaXRlbS5zdGF0dXMgPT09IEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19SRVZFUlRfRVJST1JcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciBmb3JjZVJldmVydCA9IHF1ZXJ5KCdHRVRfRk9SQ0VfUkVWRVJUJyk7XG4gICAgICAgICAgICBfaXRlbVxuICAgICAgICAgICAgICAucmV2ZXJ0KFxuICAgICAgICAgICAgICAgIGNyZWF0ZVJldmVydEZ1bmN0aW9uKFxuICAgICAgICAgICAgICAgICAgc3RhdGUub3B0aW9ucy5zZXJ2ZXIudXJsLFxuICAgICAgICAgICAgICAgICAgc3RhdGUub3B0aW9ucy5zZXJ2ZXIucmV2ZXJ0XG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBmb3JjZVJldmVydFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICghZm9yY2VSZXZlcnQpIHJldHVybjtcblxuICAgICAgICAgICAgICAgIC8vIHRyeSB0byBhZGQgbm93XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0FERF9JVEVNJywge1xuICAgICAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbk1ldGhvZDogaW50ZXJhY3Rpb25NZXRob2QsXG4gICAgICAgICAgICAgICAgICBzdWNjZXNzOiBzdWNjZXNzLFxuICAgICAgICAgICAgICAgICAgZmFpbHVyZTogZmFpbHVyZSxcbiAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKCkge30pOyAvLyBubyBuZWVkIHRvIGhhbmRsZSB0aGlzIGNhdGNoIHN0YXRlIGZvciBub3dcblxuICAgICAgICAgICAgaWYgKGZvcmNlUmV2ZXJ0KSByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gcmVtb3ZlIGZpcnN0IGl0ZW0gYXMgaXQgd2lsbCBiZSByZXBsYWNlZCBieSB0aGlzIGl0ZW1cbiAgICAgICAgICBkaXNwYXRjaCgnUkVNT1ZFX0lURU0nLCB7IHF1ZXJ5OiBfaXRlbS5pZCB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdoZXJlIGRpZCB0aGUgZmlsZSBvcmlnaW5hdGVcbiAgICAgICAgdmFyIG9yaWdpbiA9XG4gICAgICAgICAgb3B0aW9ucy50eXBlID09PSAnbG9jYWwnXG4gICAgICAgICAgICA/IEZpbGVPcmlnaW4uTE9DQUxcbiAgICAgICAgICAgIDogb3B0aW9ucy50eXBlID09PSAnbGltYm8nXG4gICAgICAgICAgICA/IEZpbGVPcmlnaW4uTElNQk9cbiAgICAgICAgICAgIDogRmlsZU9yaWdpbi5JTlBVVDtcblxuICAgICAgICAvLyBjcmVhdGUgYSBuZXcgYmxhbmsgaXRlbVxuICAgICAgICB2YXIgaXRlbSA9IGNyZWF0ZUl0ZW0oXG4gICAgICAgICAgLy8gd2hlcmUgZGlkIHRoaXMgZmlsZSBjb21lIGZyb21cbiAgICAgICAgICBvcmlnaW4sXG5cbiAgICAgICAgICAvLyBhbiBpbnB1dCBmaWxlIG5ldmVyIGhhcyBhIHNlcnZlciBmaWxlIHJlZmVyZW5jZVxuICAgICAgICAgIG9yaWdpbiA9PT0gRmlsZU9yaWdpbi5JTlBVVCA/IG51bGwgOiBzb3VyY2UsXG5cbiAgICAgICAgICAvLyBmaWxlIG1vY2sgZGF0YSwgaWYgZGVmaW5lZFxuICAgICAgICAgIG9wdGlvbnMuZmlsZVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIHNldCBpbml0aWFsIG1ldGEgZGF0YVxuICAgICAgICBPYmplY3Qua2V5cyhvcHRpb25zLm1ldGFkYXRhIHx8IHt9KS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgIGl0ZW0uc2V0TWV0YWRhdGEoa2V5LCBvcHRpb25zLm1ldGFkYXRhW2tleV0pO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBjcmVhdGVkIHRoZSBpdGVtLCBsZXQgcGx1Z2lucyBhZGQgbWV0aG9kc1xuICAgICAgICBhcHBseUZpbHRlcnMoJ0RJRF9DUkVBVEVfSVRFTScsIGl0ZW0sIHtcbiAgICAgICAgICBxdWVyeTogcXVlcnksXG4gICAgICAgICAgZGlzcGF0Y2g6IGRpc3BhdGNoXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHdoZXJlIHRvIGluc2VydCBuZXcgaXRlbXNcbiAgICAgICAgdmFyIGl0ZW1JbnNlcnRMb2NhdGlvbiA9IHF1ZXJ5KCdHRVRfSVRFTV9JTlNFUlRfTE9DQVRJT04nKTtcblxuICAgICAgICAvLyBhZGp1c3QgaW5kZXggaWYgaXMgbm90IGFsbG93ZWQgdG8gcGljayBsb2NhdGlvblxuICAgICAgICBpZiAoIXN0YXRlLm9wdGlvbnMuaXRlbUluc2VydExvY2F0aW9uRnJlZWRvbSkge1xuICAgICAgICAgIGluZGV4ID0gaXRlbUluc2VydExvY2F0aW9uID09PSAnYmVmb3JlJyA/IC0xIDogc3RhdGUuaXRlbXMubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIGl0ZW0gdG8gbGlzdFxuICAgICAgICBpbnNlcnRJdGVtKHN0YXRlLml0ZW1zLCBpdGVtLCBpbmRleCk7XG5cbiAgICAgICAgLy8gc29ydCBpdGVtcyBpbiBsaXN0XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKGl0ZW1JbnNlcnRMb2NhdGlvbikgJiYgc291cmNlKSB7XG4gICAgICAgICAgc29ydEl0ZW1zKHN0YXRlLCBpdGVtSW5zZXJ0TG9jYXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2V0IGEgcXVpY2sgcmVmZXJlbmNlIHRvIHRoZSBpdGVtIGlkXG4gICAgICAgIHZhciBpZCA9IGl0ZW0uaWQ7XG5cbiAgICAgICAgLy8gb2JzZXJ2ZSBpdGVtIGV2ZW50c1xuICAgICAgICBpdGVtLm9uKCdpbml0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZGlzcGF0Y2goJ0RJRF9JTklUX0lURU0nLCB7IGlkOiBpZCB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXRlbS5vbignbG9hZC1pbml0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZGlzcGF0Y2goJ0RJRF9TVEFSVF9JVEVNX0xPQUQnLCB7IGlkOiBpZCB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXRlbS5vbignbG9hZC1tZXRhJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZGlzcGF0Y2goJ0RJRF9VUERBVEVfSVRFTV9NRVRBJywgeyBpZDogaWQgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0ZW0ub24oJ2xvYWQtcHJvZ3Jlc3MnLCBmdW5jdGlvbihwcm9ncmVzcykge1xuICAgICAgICAgIGRpc3BhdGNoKCdESURfVVBEQVRFX0lURU1fTE9BRF9QUk9HUkVTUycsIHtcbiAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgIHByb2dyZXNzOiBwcm9ncmVzc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdGVtLm9uKCdsb2FkLXJlcXVlc3QtZXJyb3InLCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgIHZhciBtYWluU3RhdHVzID0gZHluYW1pY0xhYmVsKHN0YXRlLm9wdGlvbnMubGFiZWxGaWxlTG9hZEVycm9yKShcbiAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIC8vIGlzIGNsaWVudCBlcnJvciwgbm8gd2F5IHRvIHJlY292ZXJcbiAgICAgICAgICBpZiAoZXJyb3IuY29kZSA+PSA0MDAgJiYgZXJyb3IuY29kZSA8IDUwMCkge1xuICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9USFJPV19JVEVNX0lOVkFMSUQnLCB7XG4gICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICBzdGF0dXM6IHtcbiAgICAgICAgICAgICAgICBtYWluOiBtYWluU3RhdHVzLFxuICAgICAgICAgICAgICAgIHN1YjogZXJyb3IuY29kZSArICcgKCcgKyBlcnJvci5ib2R5ICsgJyknXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyByZWplY3QgdGhlIGZpbGUgc28gY2FuIGJlIGRlYWx0IHdpdGggdGhyb3VnaCBBUElcbiAgICAgICAgICAgIGZhaWx1cmUoeyBlcnJvcjogZXJyb3IsIGZpbGU6IGNyZWF0ZUl0ZW1BUEkoaXRlbSkgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gaXMgcG9zc2libGUgc2VydmVyIGVycm9yLCBzbyBtaWdodCBiZSBwb3NzaWJsZSB0byByZXRyeVxuICAgICAgICAgIGRpc3BhdGNoKCdESURfVEhST1dfSVRFTV9MT0FEX0VSUk9SJywge1xuICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgc3RhdHVzOiB7XG4gICAgICAgICAgICAgIG1haW46IG1haW5TdGF0dXMsXG4gICAgICAgICAgICAgIHN1Yjogc3RhdGUub3B0aW9ucy5sYWJlbFRhcFRvUmV0cnlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXRlbS5vbignbG9hZC1maWxlLWVycm9yJywgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICBkaXNwYXRjaCgnRElEX1RIUk9XX0lURU1fSU5WQUxJRCcsIHtcbiAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgIGVycm9yOiBlcnJvci5zdGF0dXMsXG4gICAgICAgICAgICBzdGF0dXM6IGVycm9yLnN0YXR1c1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgZmFpbHVyZSh7IGVycm9yOiBlcnJvci5zdGF0dXMsIGZpbGU6IGNyZWF0ZUl0ZW1BUEkoaXRlbSkgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0ZW0ub24oJ2xvYWQtYWJvcnQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBkaXNwYXRjaCgnUkVNT1ZFX0lURU0nLCB7IHF1ZXJ5OiBpZCB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXRlbS5vbignbG9hZC1za2lwJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZGlzcGF0Y2goJ0NPTVBMRVRFX0xPQURfSVRFTScsIHtcbiAgICAgICAgICAgIHF1ZXJ5OiBpZCxcbiAgICAgICAgICAgIGl0ZW06IGl0ZW0sXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgICAgICBzdWNjZXNzOiBzdWNjZXNzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0ZW0ub24oJ2xvYWQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgaGFuZGxlQWRkID0gZnVuY3Rpb24gaGFuZGxlQWRkKHNob3VsZEFkZCkge1xuICAgICAgICAgICAgLy8gbm8gc2hvdWxkIG5vdCBhZGQgdGhpcyBmaWxlXG4gICAgICAgICAgICBpZiAoIXNob3VsZEFkZCkge1xuICAgICAgICAgICAgICBkaXNwYXRjaCgnUkVNT1ZFX0lURU0nLCB7XG4gICAgICAgICAgICAgICAgcXVlcnk6IGlkXG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbm93IGludGVyZXN0ZWQgaW4gbWV0YWRhdGEgdXBkYXRlc1xuICAgICAgICAgICAgaXRlbS5vbignbWV0YWRhdGEtdXBkYXRlJywgZnVuY3Rpb24oY2hhbmdlKSB7XG4gICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfVVBEQVRFX0lURU1fTUVUQURBVEEnLCB7IGlkOiBpZCwgY2hhbmdlOiBjaGFuZ2UgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gbGV0IHBsdWdpbnMgZGVjaWRlIGlmIHRoZSBvdXRwdXQgZGF0YSBzaG91bGQgYmUgcHJlcGFyZWQgYXQgdGhpcyBwb2ludFxuICAgICAgICAgICAgLy8gbWVhbnMgd2UnbGwgZG8gdGhpcyBhbmQgd2FpdCBmb3IgaWRsZSBzdGF0ZVxuICAgICAgICAgICAgYXBwbHlGaWx0ZXJDaGFpbignU0hPVUxEX1BSRVBBUkVfT1VUUFVUJywgZmFsc2UsIHtcbiAgICAgICAgICAgICAgaXRlbTogaXRlbSxcbiAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5XG4gICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKHNob3VsZFByZXBhcmVPdXRwdXQpIHtcbiAgICAgICAgICAgICAgdmFyIGxvYWRDb21wbGV0ZSA9IGZ1bmN0aW9uIGxvYWRDb21wbGV0ZSgpIHtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaCgnQ09NUExFVEVfTE9BRF9JVEVNJywge1xuICAgICAgICAgICAgICAgICAgcXVlcnk6IGlkLFxuICAgICAgICAgICAgICAgICAgaXRlbTogaXRlbSxcbiAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHN1Y2Nlc3NcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGxpc3RVcGRhdGVkKGRpc3BhdGNoLCBzdGF0ZSk7XG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgLy8gZXhpdFxuICAgICAgICAgICAgICBpZiAoc2hvdWxkUHJlcGFyZU91dHB1dCkge1xuICAgICAgICAgICAgICAgIC8vIHdhaXQgZm9yIGlkbGUgc3RhdGUgYW5kIHRoZW4gcnVuIFBSRVBBUkVfT1VUUFVUXG4gICAgICAgICAgICAgICAgZGlzcGF0Y2goXG4gICAgICAgICAgICAgICAgICAnUkVRVUVTVF9QUkVQQVJFX09VVFBVVCcsXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBpZCxcbiAgICAgICAgICAgICAgICAgICAgaXRlbTogaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gc3VjY2VzcyhmaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9QUkVQQVJFX09VVFBVVCcsIHsgaWQ6IGlkLCBmaWxlOiBmaWxlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgIGxvYWRDb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBsb2FkQ29tcGxldGUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICAvLyBpdGVtIGxvYWRlZCwgYWxsb3cgcGx1Z2lucyB0b1xuICAgICAgICAgIC8vIC0gcmVhZCBkYXRhIChxdWlja2x5KVxuICAgICAgICAgIC8vIC0gYWRkIG1ldGFkYXRhXG4gICAgICAgICAgYXBwbHlGaWx0ZXJDaGFpbignRElEX0xPQURfSVRFTScsIGl0ZW0sIHtcbiAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICAgICAgICAgIGRpc3BhdGNoOiBkaXNwYXRjaFxuICAgICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgb3B0aW9uYWxQcm9taXNlKFxuICAgICAgICAgICAgICAgIHF1ZXJ5KCdHRVRfQkVGT1JFX0FERF9GSUxFJyksXG4gICAgICAgICAgICAgICAgY3JlYXRlSXRlbUFQSShpdGVtKVxuICAgICAgICAgICAgICApLnRoZW4oaGFuZGxlQWRkKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGhhbmRsZUFkZChmYWxzZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXRlbS5vbigncHJvY2Vzcy1zdGFydCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGRpc3BhdGNoKCdESURfU1RBUlRfSVRFTV9QUk9DRVNTSU5HJywgeyBpZDogaWQgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0ZW0ub24oJ3Byb2Nlc3MtcHJvZ3Jlc3MnLCBmdW5jdGlvbihwcm9ncmVzcykge1xuICAgICAgICAgIGRpc3BhdGNoKCdESURfVVBEQVRFX0lURU1fUFJPQ0VTU19QUk9HUkVTUycsIHtcbiAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgIHByb2dyZXNzOiBwcm9ncmVzc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdGVtLm9uKCdwcm9jZXNzLWVycm9yJywgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICBkaXNwYXRjaCgnRElEX1RIUk9XX0lURU1fUFJPQ0VTU0lOR19FUlJPUicsIHtcbiAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgIHN0YXR1czoge1xuICAgICAgICAgICAgICBtYWluOiBkeW5hbWljTGFiZWwoc3RhdGUub3B0aW9ucy5sYWJlbEZpbGVQcm9jZXNzaW5nRXJyb3IpKGVycm9yKSxcbiAgICAgICAgICAgICAgc3ViOiBzdGF0ZS5vcHRpb25zLmxhYmVsVGFwVG9SZXRyeVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdGVtLm9uKCdwcm9jZXNzLXJldmVydC1lcnJvcicsIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgZGlzcGF0Y2goJ0RJRF9USFJPV19JVEVNX1BST0NFU1NJTkdfUkVWRVJUX0VSUk9SJywge1xuICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgc3RhdHVzOiB7XG4gICAgICAgICAgICAgIG1haW46IGR5bmFtaWNMYWJlbChzdGF0ZS5vcHRpb25zLmxhYmVsRmlsZVByb2Nlc3NpbmdSZXZlcnRFcnJvcikoXG4gICAgICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgc3ViOiBzdGF0ZS5vcHRpb25zLmxhYmVsVGFwVG9SZXRyeVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdGVtLm9uKCdwcm9jZXNzLWNvbXBsZXRlJywgZnVuY3Rpb24oc2VydmVyRmlsZVJlZmVyZW5jZSkge1xuICAgICAgICAgIGRpc3BhdGNoKCdESURfQ09NUExFVEVfSVRFTV9QUk9DRVNTSU5HJywge1xuICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICBzZXJ2ZXJGaWxlUmVmZXJlbmNlOiBzZXJ2ZXJGaWxlUmVmZXJlbmNlXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBkaXNwYXRjaCgnRElEX0RFRklORV9WQUxVRScsIHsgaWQ6IGlkLCB2YWx1ZTogc2VydmVyRmlsZVJlZmVyZW5jZSB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXRlbS5vbigncHJvY2Vzcy1hYm9ydCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGRpc3BhdGNoKCdESURfQUJPUlRfSVRFTV9QUk9DRVNTSU5HJywgeyBpZDogaWQgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0ZW0ub24oJ3Byb2Nlc3MtcmV2ZXJ0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZGlzcGF0Y2goJ0RJRF9SRVZFUlRfSVRFTV9QUk9DRVNTSU5HJywgeyBpZDogaWQgfSk7XG4gICAgICAgICAgZGlzcGF0Y2goJ0RJRF9ERUZJTkVfVkFMVUUnLCB7IGlkOiBpZCwgdmFsdWU6IG51bGwgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGxldCB2aWV3IGtub3cgdGhlIGl0ZW0gaGFzIGJlZW4gaW5zZXJ0ZWRcbiAgICAgICAgZGlzcGF0Y2goJ0RJRF9BRERfSVRFTScsIHtcbiAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICAgIGludGVyYWN0aW9uTWV0aG9kOiBpbnRlcmFjdGlvbk1ldGhvZFxuICAgICAgICB9KTtcblxuICAgICAgICBsaXN0VXBkYXRlZChkaXNwYXRjaCwgc3RhdGUpO1xuXG4gICAgICAgIC8vIHN0YXJ0IGxvYWRpbmcgdGhlIHNvdXJjZVxuICAgICAgICB2YXIgX3JlZjggPSBzdGF0ZS5vcHRpb25zLnNlcnZlciB8fCB7fSxcbiAgICAgICAgICB1cmwgPSBfcmVmOC51cmwsXG4gICAgICAgICAgbG9hZCA9IF9yZWY4LmxvYWQsXG4gICAgICAgICAgcmVzdG9yZSA9IF9yZWY4LnJlc3RvcmUsXG4gICAgICAgICAgZmV0Y2ggPSBfcmVmOC5mZXRjaDtcblxuICAgICAgICBpdGVtLmxvYWQoXG4gICAgICAgICAgc291cmNlLFxuXG4gICAgICAgICAgLy8gdGhpcyBjcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBsb2FkcyB0aGUgZmlsZSBiYXNlZCBvbiB0aGUgdHlwZSBvZiBmaWxlIChzdHJpbmcsIGJhc2U2NCwgYmxvYiwgZmlsZSkgYW5kIGxvY2F0aW9uIG9mIGZpbGUgKGxvY2FsLCByZW1vdGUsIGxpbWJvKVxuICAgICAgICAgIGNyZWF0ZUZpbGVMb2FkZXIoXG4gICAgICAgICAgICBvcmlnaW4gPT09IEZpbGVPcmlnaW4uSU5QVVRcbiAgICAgICAgICAgICAgPyAvLyBpbnB1dCwgaWYgaXMgcmVtb3RlLCBzZWUgaWYgc2hvdWxkIHVzZSBjdXN0b20gZmV0Y2gsIGVsc2UgdXNlIGRlZmF1bHQgZmV0Y2hCbG9iXG4gICAgICAgICAgICAgICAgaXNTdHJpbmcoc291cmNlKSAmJiBpc0V4dGVybmFsVVJMKHNvdXJjZSlcbiAgICAgICAgICAgICAgICA/IGZldGNoXG4gICAgICAgICAgICAgICAgICA/IGNyZWF0ZUZldGNoRnVuY3Rpb24odXJsLCBmZXRjaClcbiAgICAgICAgICAgICAgICAgIDogZmV0Y2hCbG9iIC8vIHJlbW90ZSB1cmxcbiAgICAgICAgICAgICAgICA6IGZldGNoQmxvYiAvLyB0cnkgdG8gZmV0Y2ggdXJsXG4gICAgICAgICAgICAgIDogLy8gbGltYm8gb3IgbG9jYWxcbiAgICAgICAgICAgICAgb3JpZ2luID09PSBGaWxlT3JpZ2luLkxJTUJPXG4gICAgICAgICAgICAgID8gY3JlYXRlRmV0Y2hGdW5jdGlvbih1cmwsIHJlc3RvcmUpIC8vIGxpbWJvXG4gICAgICAgICAgICAgIDogY3JlYXRlRmV0Y2hGdW5jdGlvbih1cmwsIGxvYWQpIC8vIGxvY2FsXG4gICAgICAgICAgKSxcblxuICAgICAgICAgIC8vIGNhbGxlZCB3aGVuIHRoZSBmaWxlIGlzIGxvYWRlZCBzbyBpdCBjYW4gYmUgcGlwZWQgdGhyb3VnaCB0aGUgZmlsdGVyc1xuICAgICAgICAgIGZ1bmN0aW9uKGZpbGUsIHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICAgICAgICAvLyBsZXQncyBwcm9jZXNzIHRoZSBmaWxlXG4gICAgICAgICAgICBhcHBseUZpbHRlckNoYWluKCdMT0FEX0ZJTEUnLCBmaWxlLCB7IHF1ZXJ5OiBxdWVyeSB9KVxuICAgICAgICAgICAgICAudGhlbihzdWNjZXNzKVxuICAgICAgICAgICAgICAuY2F0Y2goZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgIH0sXG5cbiAgICAgIFJFUVVFU1RfUFJFUEFSRV9PVVRQVVQ6IGZ1bmN0aW9uIFJFUVVFU1RfUFJFUEFSRV9PVVRQVVQoX3JlZjkpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBfcmVmOS5pdGVtLFxuICAgICAgICAgIHN1Y2Nlc3MgPSBfcmVmOS5zdWNjZXNzLFxuICAgICAgICAgIF9yZWY5JGZhaWx1cmUgPSBfcmVmOS5mYWlsdXJlLFxuICAgICAgICAgIGZhaWx1cmUgPSBfcmVmOSRmYWlsdXJlID09PSB2b2lkIDAgPyBmdW5jdGlvbigpIHt9IDogX3JlZjkkZmFpbHVyZTtcblxuICAgICAgICAvLyBlcnJvciByZXNwb25zZSBpZiBpdGVtIGFyY2hpdmVkXG4gICAgICAgIHZhciBlcnIgPSB7XG4gICAgICAgICAgZXJyb3I6IGNyZWF0ZVJlc3BvbnNlKCdlcnJvcicsIDAsICdJdGVtIG5vdCBmb3VuZCcpLFxuXG4gICAgICAgICAgZmlsZTogbnVsbFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGRvbid0IGhhbmRsZSBhcmNoaXZlZCBpdGVtcywgYW4gaXRlbSBjb3VsZCBoYXZlIGJlZW4gYXJjaGl2ZWQgKGxvYWQgYWJvcnRlZCkgd2hpbGUgd2FpdGluZyB0byBiZSBwcmVwYXJlZFxuICAgICAgICBpZiAoaXRlbS5hcmNoaXZlZCkgcmV0dXJuIGZhaWx1cmUoZXJyKTtcblxuICAgICAgICAvLyBhbGxvdyBwbHVnaW5zIHRvIGFsdGVyIHRoZSBmaWxlIGRhdGFcbiAgICAgICAgYXBwbHlGaWx0ZXJDaGFpbignUFJFUEFSRV9PVVRQVVQnLCBpdGVtLmZpbGUsIHtcbiAgICAgICAgICBxdWVyeTogcXVlcnksXG4gICAgICAgICAgaXRlbTogaXRlbVxuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgIGFwcGx5RmlsdGVyQ2hhaW4oJ0NPTVBMRVRFX1BSRVBBUkVfT1VUUFVUJywgcmVzdWx0LCB7XG4gICAgICAgICAgICBxdWVyeTogcXVlcnksXG4gICAgICAgICAgICBpdGVtOiBpdGVtXG4gICAgICAgICAgfSkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICAgIC8vIGRvbid0IGhhbmRsZSBhcmNoaXZlZCBpdGVtcywgYW4gaXRlbSBjb3VsZCBoYXZlIGJlZW4gYXJjaGl2ZWQgKGxvYWQgYWJvcnRlZCkgd2hpbGUgYmVpbmcgcHJlcGFyZWRcbiAgICAgICAgICAgIGlmIChpdGVtLmFyY2hpdmVkKSByZXR1cm4gZmFpbHVyZShlcnIpO1xuXG4gICAgICAgICAgICAvLyB3ZSBkb25lIVxuICAgICAgICAgICAgc3VjY2VzcyhyZXN1bHQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG5cbiAgICAgIENPTVBMRVRFX0xPQURfSVRFTTogZnVuY3Rpb24gQ09NUExFVEVfTE9BRF9JVEVNKF9yZWYxMCkge1xuICAgICAgICB2YXIgaXRlbSA9IF9yZWYxMC5pdGVtLFxuICAgICAgICAgIGRhdGEgPSBfcmVmMTAuZGF0YTtcbiAgICAgICAgdmFyIHN1Y2Nlc3MgPSBkYXRhLnN1Y2Nlc3MsXG4gICAgICAgICAgc291cmNlID0gZGF0YS5zb3VyY2U7XG5cbiAgICAgICAgLy8gc29ydCBpdGVtcyBpbiBsaXN0XG4gICAgICAgIHZhciBpdGVtSW5zZXJ0TG9jYXRpb24gPSBxdWVyeSgnR0VUX0lURU1fSU5TRVJUX0xPQ0FUSU9OJyk7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKGl0ZW1JbnNlcnRMb2NhdGlvbikgJiYgc291cmNlKSB7XG4gICAgICAgICAgc29ydEl0ZW1zKHN0YXRlLCBpdGVtSW5zZXJ0TG9jYXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbGV0IGludGVyZmFjZSBrbm93IHRoZSBpdGVtIGhhcyBsb2FkZWRcbiAgICAgICAgZGlzcGF0Y2goJ0RJRF9MT0FEX0lURU0nLCB7XG4gICAgICAgICAgaWQ6IGl0ZW0uaWQsXG4gICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgc2VydmVyRmlsZVJlZmVyZW5jZTogaXRlbS5vcmlnaW4gPT09IEZpbGVPcmlnaW4uSU5QVVQgPyBudWxsIDogc291cmNlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGl0ZW0gaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5IGxvYWRlZCBhbmQgYWRkZWQgdG8gdGhlXG4gICAgICAgIC8vIGxpc3Qgb2YgaXRlbXMgc28gY2FuIG5vdyBiZSBzYWZlbHkgcmV0dXJuZWQgZm9yIHVzZVxuICAgICAgICBzdWNjZXNzKGNyZWF0ZUl0ZW1BUEkoaXRlbSkpO1xuXG4gICAgICAgIC8vIGlmIHRoaXMgaXMgYSBsb2NhbCBzZXJ2ZXIgZmlsZSB3ZSBuZWVkIHRvIHNob3cgYSBkaWZmZXJlbnQgc3RhdGVcbiAgICAgICAgaWYgKGl0ZW0ub3JpZ2luID09PSBGaWxlT3JpZ2luLkxPQ0FMKSB7XG4gICAgICAgICAgZGlzcGF0Y2goJ0RJRF9MT0FEX0xPQ0FMX0lURU0nLCB7IGlkOiBpdGVtLmlkIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIGlzIGEgdGVtcCBzZXJ2ZXIgZmlsZSB3ZSBwcmV2ZW50IGFzeW5jIHVwbG9hZCBjYWxsIGhlcmUgKGFzIHRoZSBmaWxlIGlzIGFscmVhZHkgb24gdGhlIHNlcnZlcilcbiAgICAgICAgaWYgKGl0ZW0ub3JpZ2luID09PSBGaWxlT3JpZ2luLkxJTUJPKSB7XG4gICAgICAgICAgZGlzcGF0Y2goJ0RJRF9DT01QTEVURV9JVEVNX1BST0NFU1NJTkcnLCB7XG4gICAgICAgICAgICBpZDogaXRlbS5pZCxcbiAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgc2VydmVyRmlsZVJlZmVyZW5jZTogc291cmNlXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBkaXNwYXRjaCgnRElEX0RFRklORV9WQUxVRScsIHtcbiAgICAgICAgICAgIGlkOiBpdGVtLmlkLFxuICAgICAgICAgICAgdmFsdWU6IHNvdXJjZVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWQgd2UgYXJlIGFsbG93ZWQgdG8gdXBsb2FkIHRoZSBmaWxlIGltbWVkaWF0ZWx5LCBsZXRzIGRvIGl0XG4gICAgICAgIGlmIChxdWVyeSgnSVNfQVNZTkMnKSAmJiBzdGF0ZS5vcHRpb25zLmluc3RhbnRVcGxvYWQpIHtcbiAgICAgICAgICBkaXNwYXRjaCgnUkVRVUVTVF9JVEVNX1BST0NFU1NJTkcnLCB7IHF1ZXJ5OiBpdGVtLmlkIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBSRVRSWV9JVEVNX0xPQUQ6IGdldEl0ZW1CeVF1ZXJ5RnJvbVN0YXRlKHN0YXRlLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIC8vIHRyeSBsb2FkaW5nIHRoZSBzb3VyY2Ugb25lIG1vcmUgdGltZVxuICAgICAgICBpdGVtLnJldHJ5TG9hZCgpO1xuICAgICAgfSksXG5cbiAgICAgIFJFUVVFU1RfSVRFTV9QUkVQQVJFOiBnZXRJdGVtQnlRdWVyeUZyb21TdGF0ZShzdGF0ZSwgZnVuY3Rpb24oXG4gICAgICAgIGl0ZW0sXG4gICAgICAgIF9zdWNjZXNzLFxuICAgICAgICBmYWlsdXJlXG4gICAgICApIHtcbiAgICAgICAgZGlzcGF0Y2goXG4gICAgICAgICAgJ1JFUVVFU1RfUFJFUEFSRV9PVVRQVVQnLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHF1ZXJ5OiBpdGVtLmlkLFxuICAgICAgICAgICAgaXRlbTogaXRlbSxcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIHN1Y2Nlc3MoZmlsZSkge1xuICAgICAgICAgICAgICBkaXNwYXRjaCgnRElEX1BSRVBBUkVfT1VUUFVUJywgeyBpZDogaXRlbS5pZCwgZmlsZTogZmlsZSB9KTtcbiAgICAgICAgICAgICAgX3N1Y2Nlc3Moe1xuICAgICAgICAgICAgICAgIGZpbGU6IGl0ZW0sXG4gICAgICAgICAgICAgICAgb3V0cHV0OiBmaWxlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZhaWx1cmU6IGZhaWx1cmVcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRydWVcbiAgICAgICAgKTtcbiAgICAgIH0pLFxuXG4gICAgICBSRVFVRVNUX0lURU1fUFJPQ0VTU0lORzogZ2V0SXRlbUJ5UXVlcnlGcm9tU3RhdGUoc3RhdGUsIGZ1bmN0aW9uKFxuICAgICAgICBpdGVtLFxuICAgICAgICBzdWNjZXNzLFxuICAgICAgICBmYWlsdXJlXG4gICAgICApIHtcbiAgICAgICAgLy8gY2Fubm90IGJlIHF1ZXVlZCAob3IgaXMgYWxyZWFkeSBxdWV1ZWQpXG4gICAgICAgIHZhciBpdGVtQ2FuQmVRdWV1ZWRGb3JQcm9jZXNzaW5nID1cbiAgICAgICAgICAvLyB3YWl0aW5nIGZvciBzb21ldGhpbmdcbiAgICAgICAgICBpdGVtLnN0YXR1cyA9PT0gSXRlbVN0YXR1cy5JRExFIHx8XG4gICAgICAgICAgLy8gcHJvY2Vzc2luZyB3ZW50IHdyb25nIGVhcmxpZXJcbiAgICAgICAgICBpdGVtLnN0YXR1cyA9PT0gSXRlbVN0YXR1cy5QUk9DRVNTSU5HX0VSUk9SO1xuXG4gICAgICAgIC8vIG5vdCByZWFkeSB0byBiZSBwcm9jZXNzZWRcbiAgICAgICAgaWYgKCFpdGVtQ2FuQmVRdWV1ZWRGb3JQcm9jZXNzaW5nKSB7XG4gICAgICAgICAgdmFyIHByb2Nlc3NOb3cgPSBmdW5jdGlvbiBwcm9jZXNzTm93KCkge1xuICAgICAgICAgICAgcmV0dXJuIGRpc3BhdGNoKCdSRVFVRVNUX0lURU1fUFJPQ0VTU0lORycsIHtcbiAgICAgICAgICAgICAgcXVlcnk6IGl0ZW0sXG4gICAgICAgICAgICAgIHN1Y2Nlc3M6IHN1Y2Nlc3MsXG4gICAgICAgICAgICAgIGZhaWx1cmU6IGZhaWx1cmVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICB2YXIgcHJvY2VzcyA9IGZ1bmN0aW9uIHByb2Nlc3MoKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQuaGlkZGVuID8gcHJvY2Vzc05vdygpIDogc2V0VGltZW91dChwcm9jZXNzTm93LCAzMik7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIC8vIGlmIGFscmVhZHkgZG9uZSBwcm9jZXNzaW5nIG9yIHRyaWVkIHRvIHJldmVydCBidXQgZGlkbid0IHdvcmssIHRyeSBhZ2FpblxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGl0ZW0uc3RhdHVzID09PSBJdGVtU3RhdHVzLlBST0NFU1NJTkdfQ09NUExFVEUgfHxcbiAgICAgICAgICAgIGl0ZW0uc3RhdHVzID09PSBJdGVtU3RhdHVzLlBST0NFU1NJTkdfUkVWRVJUX0VSUk9SXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBpdGVtXG4gICAgICAgICAgICAgIC5yZXZlcnQoXG4gICAgICAgICAgICAgICAgY3JlYXRlUmV2ZXJ0RnVuY3Rpb24oXG4gICAgICAgICAgICAgICAgICBzdGF0ZS5vcHRpb25zLnNlcnZlci51cmwsXG4gICAgICAgICAgICAgICAgICBzdGF0ZS5vcHRpb25zLnNlcnZlci5yZXZlcnRcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIHF1ZXJ5KCdHRVRfRk9SQ0VfUkVWRVJUJylcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAudGhlbihwcm9jZXNzKVxuICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24oKSB7fSk7IC8vIGRvbid0IGNvbnRpbnVlIHdpdGggcHJvY2Vzc2luZyBpZiBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbS5zdGF0dXMgPT09IEl0ZW1TdGF0dXMuUFJPQ0VTU0lORykge1xuICAgICAgICAgICAgaXRlbS5hYm9ydFByb2Nlc3NpbmcoKS50aGVuKHByb2Nlc3MpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFscmVhZHkgcXVldWVkIGZvciBwcm9jZXNzaW5nXG4gICAgICAgIGlmIChpdGVtLnN0YXR1cyA9PT0gSXRlbVN0YXR1cy5QUk9DRVNTSU5HX1FVRVVFRCkgcmV0dXJuO1xuXG4gICAgICAgIGl0ZW0ucmVxdWVzdFByb2Nlc3NpbmcoKTtcblxuICAgICAgICBkaXNwYXRjaCgnRElEX1JFUVVFU1RfSVRFTV9QUk9DRVNTSU5HJywgeyBpZDogaXRlbS5pZCB9KTtcblxuICAgICAgICBkaXNwYXRjaChcbiAgICAgICAgICAnUFJPQ0VTU19JVEVNJyxcbiAgICAgICAgICB7IHF1ZXJ5OiBpdGVtLCBzdWNjZXNzOiBzdWNjZXNzLCBmYWlsdXJlOiBmYWlsdXJlIH0sXG4gICAgICAgICAgdHJ1ZVxuICAgICAgICApO1xuICAgICAgfSksXG5cbiAgICAgIFBST0NFU1NfSVRFTTogZ2V0SXRlbUJ5UXVlcnlGcm9tU3RhdGUoc3RhdGUsIGZ1bmN0aW9uKFxuICAgICAgICBpdGVtLFxuICAgICAgICBzdWNjZXNzLFxuICAgICAgICBmYWlsdXJlXG4gICAgICApIHtcbiAgICAgICAgdmFyIG1heFBhcmFsbGVsVXBsb2FkcyA9IHF1ZXJ5KCdHRVRfTUFYX1BBUkFMTEVMX1VQTE9BRFMnKTtcbiAgICAgICAgdmFyIHRvdGFsQ3VycmVudFVwbG9hZHMgPSBxdWVyeShcbiAgICAgICAgICAnR0VUX0lURU1TX0JZX1NUQVRVUycsXG4gICAgICAgICAgSXRlbVN0YXR1cy5QUk9DRVNTSU5HXG4gICAgICAgICkubGVuZ3RoO1xuXG4gICAgICAgIC8vIHF1ZXVlIGFuZCB3YWl0IHRpbGwgcXVldWUgaXMgZnJlZWQgdXBcbiAgICAgICAgaWYgKHRvdGFsQ3VycmVudFVwbG9hZHMgPT09IG1heFBhcmFsbGVsVXBsb2Fkcykge1xuICAgICAgICAgIC8vIHF1ZXVlIGZvciBsYXRlciBwcm9jZXNzaW5nXG4gICAgICAgICAgc3RhdGUucHJvY2Vzc2luZ1F1ZXVlLnB1c2goe1xuICAgICAgICAgICAgaWQ6IGl0ZW0uaWQsXG4gICAgICAgICAgICBzdWNjZXNzOiBzdWNjZXNzLFxuICAgICAgICAgICAgZmFpbHVyZTogZmFpbHVyZVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gc3RvcCBpdCFcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB3YXMgbm90IHF1ZXVlZCBvciBpcyBhbHJlYWR5IHByb2Nlc3NpbmcgZXhpdCBoZXJlXG4gICAgICAgIGlmIChpdGVtLnN0YXR1cyA9PT0gSXRlbVN0YXR1cy5QUk9DRVNTSU5HKSByZXR1cm47XG5cbiAgICAgICAgdmFyIHByb2Nlc3NOZXh0ID0gZnVuY3Rpb24gcHJvY2Vzc05leHQoKSB7XG4gICAgICAgICAgLy8gcHJvY2VzcyBxdWV1ZXVkIGl0ZW1zXG4gICAgICAgICAgdmFyIHF1ZXVlRW50cnkgPSBzdGF0ZS5wcm9jZXNzaW5nUXVldWUuc2hpZnQoKTtcblxuICAgICAgICAgIC8vIG5vIGl0ZW1zIGxlZnRcbiAgICAgICAgICBpZiAoIXF1ZXVlRW50cnkpIHJldHVybjtcblxuICAgICAgICAgIC8vIGdldCBpdGVtIHJlZmVyZW5jZVxuICAgICAgICAgIHZhciBpZCA9IHF1ZXVlRW50cnkuaWQsXG4gICAgICAgICAgICBzdWNjZXNzID0gcXVldWVFbnRyeS5zdWNjZXNzLFxuICAgICAgICAgICAgZmFpbHVyZSA9IHF1ZXVlRW50cnkuZmFpbHVyZTtcbiAgICAgICAgICB2YXIgaXRlbVJlZmVyZW5jZSA9IGdldEl0ZW1CeVF1ZXJ5KHN0YXRlLml0ZW1zLCBpZCk7XG5cbiAgICAgICAgICAvLyBpZiBpdGVtIHdhcyBhcmNoaXZlZCB3aGlsZSBpbiBxdWV1ZSwganVtcCB0byBuZXh0XG4gICAgICAgICAgaWYgKCFpdGVtUmVmZXJlbmNlIHx8IGl0ZW1SZWZlcmVuY2UuYXJjaGl2ZWQpIHtcbiAgICAgICAgICAgIHByb2Nlc3NOZXh0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gcHJvY2VzcyBxdWV1ZWQgaXRlbVxuICAgICAgICAgIGRpc3BhdGNoKFxuICAgICAgICAgICAgJ1BST0NFU1NfSVRFTScsXG4gICAgICAgICAgICB7IHF1ZXJ5OiBpZCwgc3VjY2Vzczogc3VjY2VzcywgZmFpbHVyZTogZmFpbHVyZSB9LFxuICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gd2UgZG9uZSBmdW5jdGlvblxuICAgICAgICBpdGVtLm9uT25jZSgncHJvY2Vzcy1jb21wbGV0ZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHN1Y2Nlc3MoY3JlYXRlSXRlbUFQSShpdGVtKSk7XG4gICAgICAgICAgcHJvY2Vzc05leHQoKTtcblxuICAgICAgICAgIC8vIEFsbCBpdGVtcyBwcm9jZXNzZWQ/IE5vIGVycm9ycz9cbiAgICAgICAgICB2YXIgYWxsSXRlbXNQcm9jZXNzZWQgPVxuICAgICAgICAgICAgcXVlcnkoJ0dFVF9JVEVNU19CWV9TVEFUVVMnLCBJdGVtU3RhdHVzLlBST0NFU1NJTkdfQ09NUExFVEUpXG4gICAgICAgICAgICAgIC5sZW5ndGggPT09IHN0YXRlLml0ZW1zLmxlbmd0aDtcbiAgICAgICAgICBpZiAoYWxsSXRlbXNQcm9jZXNzZWQpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoKCdESURfQ09NUExFVEVfSVRFTV9QUk9DRVNTSU5HX0FMTCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gd2UgZXJyb3IgZnVuY3Rpb25cbiAgICAgICAgaXRlbS5vbk9uY2UoJ3Byb2Nlc3MtZXJyb3InLCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgIGZhaWx1cmUoeyBlcnJvcjogZXJyb3IsIGZpbGU6IGNyZWF0ZUl0ZW1BUEkoaXRlbSkgfSk7XG4gICAgICAgICAgcHJvY2Vzc05leHQoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gc3RhcnQgZmlsZSBwcm9jZXNzaW5nXG4gICAgICAgIHZhciBvcHRpb25zID0gc3RhdGUub3B0aW9ucztcbiAgICAgICAgaXRlbS5wcm9jZXNzKFxuICAgICAgICAgIGNyZWF0ZUZpbGVQcm9jZXNzb3IoXG4gICAgICAgICAgICBjcmVhdGVQcm9jZXNzb3JGdW5jdGlvbihcbiAgICAgICAgICAgICAgb3B0aW9ucy5zZXJ2ZXIudXJsLFxuICAgICAgICAgICAgICBvcHRpb25zLnNlcnZlci5wcm9jZXNzLFxuICAgICAgICAgICAgICBvcHRpb25zLm5hbWUsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjaHVua1RyYW5zZmVySWQ6IGl0ZW0udHJhbnNmZXJJZCxcbiAgICAgICAgICAgICAgICBjaHVua1NlcnZlcjogb3B0aW9ucy5zZXJ2ZXIucGF0Y2gsXG4gICAgICAgICAgICAgICAgY2h1bmtVcGxvYWRzOiBvcHRpb25zLmNodW5rVXBsb2FkcyxcbiAgICAgICAgICAgICAgICBjaHVua0ZvcmNlOiBvcHRpb25zLmNodW5rRm9yY2UsXG4gICAgICAgICAgICAgICAgY2h1bmtTaXplOiBvcHRpb25zLmNodW5rU2l6ZSxcbiAgICAgICAgICAgICAgICBjaHVua1JldHJ5RGVsYXlzOiBvcHRpb25zLmNodW5rUmV0cnlEZWxheXNcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKVxuICAgICAgICAgICksXG5cbiAgICAgICAgICAvLyBjYWxsZWQgd2hlbiB0aGUgZmlsZSBpcyBhYm91dCB0byBiZSBwcm9jZXNzZWQgc28gaXQgY2FuIGJlIHBpcGVkIHRocm91Z2ggdGhlIHRyYW5zZm9ybSBmaWx0ZXJzXG4gICAgICAgICAgZnVuY3Rpb24oZmlsZSwgc3VjY2VzcywgZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIGFsbG93IHBsdWdpbnMgdG8gYWx0ZXIgdGhlIGZpbGUgZGF0YVxuICAgICAgICAgICAgYXBwbHlGaWx0ZXJDaGFpbignUFJFUEFSRV9PVVRQVVQnLCBmaWxlLCB7XG4gICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICAgICAgICAgICAgaXRlbTogaXRlbVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oZmlsZSkge1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfUFJFUEFSRV9PVVRQVVQnLCB7IGlkOiBpdGVtLmlkLCBmaWxlOiBmaWxlIH0pO1xuXG4gICAgICAgICAgICAgICAgc3VjY2VzcyhmaWxlKTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgLmNhdGNoKGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICB9KSxcblxuICAgICAgUkVUUllfSVRFTV9QUk9DRVNTSU5HOiBnZXRJdGVtQnlRdWVyeUZyb21TdGF0ZShzdGF0ZSwgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICBkaXNwYXRjaCgnUkVRVUVTVF9JVEVNX1BST0NFU1NJTkcnLCB7IHF1ZXJ5OiBpdGVtIH0pO1xuICAgICAgfSksXG5cbiAgICAgIFJFUVVFU1RfUkVNT1ZFX0lURU06IGdldEl0ZW1CeVF1ZXJ5RnJvbVN0YXRlKHN0YXRlLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIG9wdGlvbmFsUHJvbWlzZShcbiAgICAgICAgICBxdWVyeSgnR0VUX0JFRk9SRV9SRU1PVkVfRklMRScpLFxuICAgICAgICAgIGNyZWF0ZUl0ZW1BUEkoaXRlbSlcbiAgICAgICAgKS50aGVuKGZ1bmN0aW9uKHNob3VsZFJlbW92ZSkge1xuICAgICAgICAgIGlmICghc2hvdWxkUmVtb3ZlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGRpc3BhdGNoKCdSRU1PVkVfSVRFTScsIHsgcXVlcnk6IGl0ZW0gfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSksXG5cbiAgICAgIFJFTEVBU0VfSVRFTTogZ2V0SXRlbUJ5UXVlcnlGcm9tU3RhdGUoc3RhdGUsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgaXRlbS5yZWxlYXNlKCk7XG4gICAgICB9KSxcblxuICAgICAgUkVNT1ZFX0lURU06IGdldEl0ZW1CeVF1ZXJ5RnJvbVN0YXRlKHN0YXRlLCBmdW5jdGlvbihcbiAgICAgICAgaXRlbSxcbiAgICAgICAgc3VjY2VzcyxcbiAgICAgICAgZmFpbHVyZSxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgKSB7XG4gICAgICAgIHZhciByZW1vdmVGcm9tVmlldyA9IGZ1bmN0aW9uIHJlbW92ZUZyb21WaWV3KCkge1xuICAgICAgICAgIC8vIGdldCBpZCByZWZlcmVuY2VcbiAgICAgICAgICB2YXIgaWQgPSBpdGVtLmlkO1xuXG4gICAgICAgICAgLy8gYXJjaGl2ZSB0aGUgaXRlbSwgdGhpcyBkb2VzIG5vdCByZW1vdmUgaXQgZnJvbSB0aGUgbGlzdFxuICAgICAgICAgIGdldEl0ZW1CeUlkKHN0YXRlLml0ZW1zLCBpZCkuYXJjaGl2ZSgpO1xuXG4gICAgICAgICAgLy8gdGVsbCB0aGUgdmlldyB0aGUgaXRlbSBoYXMgYmVlbiByZW1vdmVkXG4gICAgICAgICAgZGlzcGF0Y2goJ0RJRF9SRU1PVkVfSVRFTScsIHsgZXJyb3I6IG51bGwsIGlkOiBpZCwgaXRlbTogaXRlbSB9KTtcblxuICAgICAgICAgIC8vIG5vdyB0aGUgbGlzdCBoYXMgYmVlbiBtb2RpZmllZFxuICAgICAgICAgIGxpc3RVcGRhdGVkKGRpc3BhdGNoLCBzdGF0ZSk7XG5cbiAgICAgICAgICAvLyBjb3JyZWN0bHkgcmVtb3ZlZFxuICAgICAgICAgIHN1Y2Nlc3MoY3JlYXRlSXRlbUFQSShpdGVtKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gaWYgdGhpcyBpcyBhIGxvY2FsIGZpbGUgYW5kIHRoZSBzZXJ2ZXIucmVtb3ZlIGZ1bmN0aW9uIGhhcyBiZWVuIGNvbmZpZ3VyZWQsIHNlbmQgc291cmNlIHRoZXJlIHNvIGRldiBjYW4gcmVtb3ZlIGZpbGUgZnJvbSBzZXJ2ZXJcbiAgICAgICAgdmFyIHNlcnZlciA9IHN0YXRlLm9wdGlvbnMuc2VydmVyO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgaXRlbS5vcmlnaW4gPT09IEZpbGVPcmlnaW4uTE9DQUwgJiZcbiAgICAgICAgICBzZXJ2ZXIgJiZcbiAgICAgICAgICBpc0Z1bmN0aW9uKHNlcnZlci5yZW1vdmUpICYmXG4gICAgICAgICAgb3B0aW9ucy5yZW1vdmUgIT09IGZhbHNlXG4gICAgICAgICkge1xuICAgICAgICAgIGRpc3BhdGNoKCdESURfU1RBUlRfSVRFTV9SRU1PVkUnLCB7IGlkOiBpdGVtLmlkIH0pO1xuXG4gICAgICAgICAgc2VydmVyLnJlbW92ZShcbiAgICAgICAgICAgIGl0ZW0uc291cmNlLFxuICAgICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiByZW1vdmVGcm9tVmlldygpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uKHN0YXR1cykge1xuICAgICAgICAgICAgICBkaXNwYXRjaCgnRElEX1RIUk9XX0lURU1fUkVNT1ZFX0VSUk9SJywge1xuICAgICAgICAgICAgICAgIGlkOiBpdGVtLmlkLFxuICAgICAgICAgICAgICAgIGVycm9yOiBjcmVhdGVSZXNwb25zZSgnZXJyb3InLCAwLCBzdGF0dXMsIG51bGwpLFxuICAgICAgICAgICAgICAgIHN0YXR1czoge1xuICAgICAgICAgICAgICAgICAgbWFpbjogZHluYW1pY0xhYmVsKHN0YXRlLm9wdGlvbnMubGFiZWxGaWxlUmVtb3ZlRXJyb3IpKFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXNcbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICBzdWI6IHN0YXRlLm9wdGlvbnMubGFiZWxUYXBUb1JldHJ5XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGlmIGlzIHJlcXVlc3RpbmcgcmV2ZXJ0IGFuZCBjYW4gcmV2ZXJ0IG5lZWQgdG8gY2FsbCByZXZlcnQgaGFuZGxlciAobm90IGNhbGxpbmcgcmVxdWVzdF8gYmVjYXVzZSB0aGF0IHdvdWxkIGFsc28gdHJpZ2dlciBiZWZvcmVSZW1vdmVIb29rKVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIG9wdGlvbnMucmV2ZXJ0ICYmXG4gICAgICAgICAgICBpdGVtLm9yaWdpbiAhPT0gRmlsZU9yaWdpbi5MT0NBTCAmJlxuICAgICAgICAgICAgaXRlbS5zZXJ2ZXJJZCAhPT0gbnVsbFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgaXRlbS5yZXZlcnQoXG4gICAgICAgICAgICAgIGNyZWF0ZVJldmVydEZ1bmN0aW9uKFxuICAgICAgICAgICAgICAgIHN0YXRlLm9wdGlvbnMuc2VydmVyLnVybCxcbiAgICAgICAgICAgICAgICBzdGF0ZS5vcHRpb25zLnNlcnZlci5yZXZlcnRcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgcXVlcnkoJ0dFVF9GT1JDRV9SRVZFUlQnKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBjYW4gbm93IHNhZmVseSByZW1vdmUgZnJvbSB2aWV3XG4gICAgICAgICAgcmVtb3ZlRnJvbVZpZXcoKTtcbiAgICAgICAgfVxuICAgICAgfSksXG5cbiAgICAgIEFCT1JUX0lURU1fTE9BRDogZ2V0SXRlbUJ5UXVlcnlGcm9tU3RhdGUoc3RhdGUsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgaXRlbS5hYm9ydExvYWQoKTtcbiAgICAgIH0pLFxuXG4gICAgICBBQk9SVF9JVEVNX1BST0NFU1NJTkc6IGdldEl0ZW1CeVF1ZXJ5RnJvbVN0YXRlKHN0YXRlLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIC8vIHRlc3QgaWYgaXMgYWxyZWFkeSBwcm9jZXNzZWRcbiAgICAgICAgaWYgKGl0ZW0uc2VydmVySWQpIHtcbiAgICAgICAgICBkaXNwYXRjaCgnUkVWRVJUX0lURU1fUFJPQ0VTU0lORycsIHsgaWQ6IGl0ZW0uaWQgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWJvcnRcbiAgICAgICAgaXRlbS5hYm9ydFByb2Nlc3NpbmcoKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBzaG91bGRSZW1vdmUgPSBzdGF0ZS5vcHRpb25zLmluc3RhbnRVcGxvYWQ7XG4gICAgICAgICAgaWYgKHNob3VsZFJlbW92ZSkge1xuICAgICAgICAgICAgZGlzcGF0Y2goJ1JFTU9WRV9JVEVNJywgeyBxdWVyeTogaXRlbS5pZCB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSksXG5cbiAgICAgIFJFUVVFU1RfUkVWRVJUX0lURU1fUFJPQ0VTU0lORzogZ2V0SXRlbUJ5UXVlcnlGcm9tU3RhdGUoc3RhdGUsIGZ1bmN0aW9uKFxuICAgICAgICBpdGVtXG4gICAgICApIHtcbiAgICAgICAgLy8gbm90IGluc3RhbnQgdXBsb2FkaW5nLCByZXZlcnQgaW1tZWRpYXRlbHlcbiAgICAgICAgaWYgKCFzdGF0ZS5vcHRpb25zLmluc3RhbnRVcGxvYWQpIHtcbiAgICAgICAgICBkaXNwYXRjaCgnUkVWRVJUX0lURU1fUFJPQ0VTU0lORycsIHsgcXVlcnk6IGl0ZW0gfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgd2UncmUgaW5zdGFudCB1cGxvYWRpbmcgdGhlIGZpbGUgd2lsbCBhbHNvIGJlIHJlbW92ZWQgaWYgd2UgcmV2ZXJ0LFxuICAgICAgICAvLyBzbyBpZiBhIGJlZm9yZSByZW1vdmUgZmlsZSBob29rIGlzIGRlZmluZWQgd2UgbmVlZCB0byBydW4gaXQgbm93XG4gICAgICAgIHZhciBoYW5kbGVSZXZlcnQgPSBmdW5jdGlvbiBoYW5kbGVSZXZlcnQoc2hvdWxkUmV2ZXJ0KSB7XG4gICAgICAgICAgaWYgKCFzaG91bGRSZXZlcnQpIHJldHVybjtcbiAgICAgICAgICBkaXNwYXRjaCgnUkVWRVJUX0lURU1fUFJPQ0VTU0lORycsIHsgcXVlcnk6IGl0ZW0gfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGZuID0gcXVlcnkoJ0dFVF9CRUZPUkVfUkVNT1ZFX0ZJTEUnKTtcbiAgICAgICAgaWYgKCFmbikge1xuICAgICAgICAgIHJldHVybiBoYW5kbGVSZXZlcnQodHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVxdWVzdFJlbW92ZVJlc3VsdCA9IGZuKGNyZWF0ZUl0ZW1BUEkoaXRlbSkpO1xuICAgICAgICBpZiAocmVxdWVzdFJlbW92ZVJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgLy8gdW5kZWZpbmVkIG9yIG51bGxcbiAgICAgICAgICByZXR1cm4gaGFuZGxlUmV2ZXJ0KHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXF1ZXN0UmVtb3ZlUmVzdWx0ID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICByZXR1cm4gaGFuZGxlUmV2ZXJ0KHJlcXVlc3RSZW1vdmVSZXN1bHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXF1ZXN0UmVtb3ZlUmVzdWx0LnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZXF1ZXN0UmVtb3ZlUmVzdWx0LnRoZW4oaGFuZGxlUmV2ZXJ0KTtcbiAgICAgICAgfVxuICAgICAgfSksXG5cbiAgICAgIFJFVkVSVF9JVEVNX1BST0NFU1NJTkc6IGdldEl0ZW1CeVF1ZXJ5RnJvbVN0YXRlKHN0YXRlLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIGl0ZW1cbiAgICAgICAgICAucmV2ZXJ0KFxuICAgICAgICAgICAgY3JlYXRlUmV2ZXJ0RnVuY3Rpb24oXG4gICAgICAgICAgICAgIHN0YXRlLm9wdGlvbnMuc2VydmVyLnVybCxcbiAgICAgICAgICAgICAgc3RhdGUub3B0aW9ucy5zZXJ2ZXIucmV2ZXJ0XG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgcXVlcnkoJ0dFVF9GT1JDRV9SRVZFUlQnKVxuICAgICAgICAgIClcbiAgICAgICAgICAudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzaG91bGRSZW1vdmUgPSBzdGF0ZS5vcHRpb25zLmluc3RhbnRVcGxvYWQgfHwgaXNNb2NrSXRlbShpdGVtKTtcbiAgICAgICAgICAgIGlmIChzaG91bGRSZW1vdmUpIHtcbiAgICAgICAgICAgICAgZGlzcGF0Y2goJ1JFTU9WRV9JVEVNJywgeyBxdWVyeTogaXRlbS5pZCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICAgIC5jYXRjaChmdW5jdGlvbigpIHt9KTtcbiAgICAgIH0pLFxuXG4gICAgICBTRVRfT1BUSU9OUzogZnVuY3Rpb24gU0VUX09QVElPTlMoX3JlZjExKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gX3JlZjExLm9wdGlvbnM7XG4gICAgICAgIGZvcmluKG9wdGlvbnMsIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICBkaXNwYXRjaCgnU0VUXycgKyBmcm9tQ2FtZWxzKGtleSwgJ18nKS50b1VwcGVyQ2FzZSgpLCB7XG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICB2YXIgZm9ybWF0RmlsZW5hbWUgPSBmdW5jdGlvbiBmb3JtYXRGaWxlbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5hbWU7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUVsZW1lbnQkMSA9IGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodGFnTmFtZSkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICB9O1xuXG4gIHZhciB0ZXh0ID0gZnVuY3Rpb24gdGV4dChub2RlLCB2YWx1ZSkge1xuICAgIHZhciB0ZXh0Tm9kZSA9IG5vZGUuY2hpbGROb2Rlc1swXTtcbiAgICBpZiAoIXRleHROb2RlKSB7XG4gICAgICB0ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHZhbHVlKTtcbiAgICAgIG5vZGUuYXBwZW5kQ2hpbGQodGV4dE5vZGUpO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgIT09IHRleHROb2RlLm5vZGVWYWx1ZSkge1xuICAgICAgdGV4dE5vZGUubm9kZVZhbHVlID0gdmFsdWU7XG4gICAgfVxuICB9O1xuXG4gIHZhciBwb2xhclRvQ2FydGVzaWFuID0gZnVuY3Rpb24gcG9sYXJUb0NhcnRlc2lhbihcbiAgICBjZW50ZXJYLFxuICAgIGNlbnRlclksXG4gICAgcmFkaXVzLFxuICAgIGFuZ2xlSW5EZWdyZWVzXG4gICkge1xuICAgIHZhciBhbmdsZUluUmFkaWFucyA9ICgoKGFuZ2xlSW5EZWdyZWVzICUgMzYwKSAtIDkwKSAqIE1hdGguUEkpIC8gMTgwLjA7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGNlbnRlclggKyByYWRpdXMgKiBNYXRoLmNvcyhhbmdsZUluUmFkaWFucyksXG4gICAgICB5OiBjZW50ZXJZICsgcmFkaXVzICogTWF0aC5zaW4oYW5nbGVJblJhZGlhbnMpXG4gICAgfTtcbiAgfTtcblxuICB2YXIgZGVzY3JpYmVBcmMgPSBmdW5jdGlvbiBkZXNjcmliZUFyYyhcbiAgICB4LFxuICAgIHksXG4gICAgcmFkaXVzLFxuICAgIHN0YXJ0QW5nbGUsXG4gICAgZW5kQW5nbGUsXG4gICAgYXJjU3dlZXBcbiAgKSB7XG4gICAgdmFyIHN0YXJ0ID0gcG9sYXJUb0NhcnRlc2lhbih4LCB5LCByYWRpdXMsIGVuZEFuZ2xlKTtcbiAgICB2YXIgZW5kID0gcG9sYXJUb0NhcnRlc2lhbih4LCB5LCByYWRpdXMsIHN0YXJ0QW5nbGUpO1xuICAgIHJldHVybiBbXG4gICAgICAnTScsXG4gICAgICBzdGFydC54LFxuICAgICAgc3RhcnQueSxcbiAgICAgICdBJyxcbiAgICAgIHJhZGl1cyxcbiAgICAgIHJhZGl1cyxcbiAgICAgIDAsXG4gICAgICBhcmNTd2VlcCxcbiAgICAgIDAsXG4gICAgICBlbmQueCxcbiAgICAgIGVuZC55XG4gICAgXS5qb2luKCcgJyk7XG4gIH07XG5cbiAgdmFyIHBlcmNlbnRhZ2VBcmMgPSBmdW5jdGlvbiBwZXJjZW50YWdlQXJjKHgsIHksIHJhZGl1cywgZnJvbSwgdG8pIHtcbiAgICB2YXIgYXJjU3dlZXAgPSAxO1xuICAgIGlmICh0byA+IGZyb20gJiYgdG8gLSBmcm9tIDw9IDAuNSkge1xuICAgICAgYXJjU3dlZXAgPSAwO1xuICAgIH1cbiAgICBpZiAoZnJvbSA+IHRvICYmIGZyb20gLSB0byA+PSAwLjUpIHtcbiAgICAgIGFyY1N3ZWVwID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIGRlc2NyaWJlQXJjKFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICByYWRpdXMsXG4gICAgICBNYXRoLm1pbigwLjk5OTksIGZyb20pICogMzYwLFxuICAgICAgTWF0aC5taW4oMC45OTk5LCB0bykgKiAzNjAsXG4gICAgICBhcmNTd2VlcFxuICAgICk7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShfcmVmKSB7XG4gICAgdmFyIHJvb3QgPSBfcmVmLnJvb3QsXG4gICAgICBwcm9wcyA9IF9yZWYucHJvcHM7XG4gICAgLy8gc3RhcnQgYXQgMFxuICAgIHByb3BzLnNwaW4gPSBmYWxzZTtcbiAgICBwcm9wcy5wcm9ncmVzcyA9IDA7XG4gICAgcHJvcHMub3BhY2l0eSA9IDA7XG5cbiAgICAvLyBzdmdcbiAgICB2YXIgc3ZnID0gY3JlYXRlRWxlbWVudCgnc3ZnJyk7XG4gICAgcm9vdC5yZWYucGF0aCA9IGNyZWF0ZUVsZW1lbnQoJ3BhdGgnLCB7XG4gICAgICAnc3Ryb2tlLXdpZHRoJzogMixcbiAgICAgICdzdHJva2UtbGluZWNhcCc6ICdyb3VuZCdcbiAgICB9KTtcblxuICAgIHN2Zy5hcHBlbmRDaGlsZChyb290LnJlZi5wYXRoKTtcblxuICAgIHJvb3QucmVmLnN2ZyA9IHN2ZztcblxuICAgIHJvb3QuYXBwZW5kQ2hpbGQoc3ZnKTtcbiAgfTtcblxuICB2YXIgd3JpdGUgPSBmdW5jdGlvbiB3cml0ZShfcmVmMikge1xuICAgIHZhciByb290ID0gX3JlZjIucm9vdCxcbiAgICAgIHByb3BzID0gX3JlZjIucHJvcHM7XG5cbiAgICBpZiAocHJvcHMub3BhY2l0eSA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwcm9wcy5hbGlnbikge1xuICAgICAgcm9vdC5lbGVtZW50LmRhdGFzZXQuYWxpZ24gPSBwcm9wcy5hbGlnbjtcbiAgICB9XG5cbiAgICAvLyBnZXQgd2lkdGggb2Ygc3Ryb2tlXG4gICAgdmFyIHJpbmdTdHJva2VXaWR0aCA9IHBhcnNlSW50KGF0dHIocm9vdC5yZWYucGF0aCwgJ3N0cm9rZS13aWR0aCcpLCAxMCk7XG5cbiAgICAvLyBjYWxjdWxhdGUgc2l6ZSBvZiByaW5nXG4gICAgdmFyIHNpemUgPSByb290LnJlY3QuZWxlbWVudC53aWR0aCAqIDAuNTtcblxuICAgIC8vIHJpbmcgc3RhdGVcbiAgICB2YXIgcmluZ0Zyb20gPSAwO1xuICAgIHZhciByaW5nVG8gPSAwO1xuXG4gICAgLy8gbm93IGluIGJ1c3kgbW9kZVxuICAgIGlmIChwcm9wcy5zcGluKSB7XG4gICAgICByaW5nRnJvbSA9IDA7XG4gICAgICByaW5nVG8gPSAwLjU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJpbmdGcm9tID0gMDtcbiAgICAgIHJpbmdUbyA9IHByb3BzLnByb2dyZXNzO1xuICAgIH1cblxuICAgIC8vIGdldCBhcmMgcGF0aFxuICAgIHZhciBjb29yZGluYXRlcyA9IHBlcmNlbnRhZ2VBcmMoXG4gICAgICBzaXplLFxuICAgICAgc2l6ZSxcbiAgICAgIHNpemUgLSByaW5nU3Ryb2tlV2lkdGgsXG4gICAgICByaW5nRnJvbSxcbiAgICAgIHJpbmdUb1xuICAgICk7XG5cbiAgICAvLyB1cGRhdGUgcHJvZ3Jlc3MgYmFyXG4gICAgYXR0cihyb290LnJlZi5wYXRoLCAnZCcsIGNvb3JkaW5hdGVzKTtcblxuICAgIC8vIGhpZGUgd2hpbGUgY29udGFpbnMgMCB2YWx1ZVxuICAgIGF0dHIoXG4gICAgICByb290LnJlZi5wYXRoLFxuICAgICAgJ3N0cm9rZS1vcGFjaXR5JyxcbiAgICAgIHByb3BzLnNwaW4gfHwgcHJvcHMucHJvZ3Jlc3MgPiAwID8gMSA6IDBcbiAgICApO1xuICB9O1xuXG4gIHZhciBwcm9ncmVzc0luZGljYXRvciA9IGNyZWF0ZVZpZXcoe1xuICAgIHRhZzogJ2RpdicsXG4gICAgbmFtZTogJ3Byb2dyZXNzLWluZGljYXRvcicsXG4gICAgaWdub3JlUmVjdFVwZGF0ZTogdHJ1ZSxcbiAgICBpZ25vcmVSZWN0OiB0cnVlLFxuICAgIGNyZWF0ZTogY3JlYXRlLFxuICAgIHdyaXRlOiB3cml0ZSxcbiAgICBtaXhpbnM6IHtcbiAgICAgIGFwaXM6IFsncHJvZ3Jlc3MnLCAnc3BpbicsICdhbGlnbiddLFxuICAgICAgc3R5bGVzOiBbJ29wYWNpdHknXSxcbiAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgb3BhY2l0eTogeyB0eXBlOiAndHdlZW4nLCBkdXJhdGlvbjogNTAwIH0sXG4gICAgICAgIHByb2dyZXNzOiB7XG4gICAgICAgICAgdHlwZTogJ3NwcmluZycsXG4gICAgICAgICAgc3RpZmZuZXNzOiAwLjk1LFxuICAgICAgICAgIGRhbXBpbmc6IDAuNjUsXG4gICAgICAgICAgbWFzczogMTBcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgdmFyIGNyZWF0ZSQxID0gZnVuY3Rpb24gY3JlYXRlKF9yZWYpIHtcbiAgICB2YXIgcm9vdCA9IF9yZWYucm9vdCxcbiAgICAgIHByb3BzID0gX3JlZi5wcm9wcztcbiAgICByb290LmVsZW1lbnQuaW5uZXJIVE1MID1cbiAgICAgIChwcm9wcy5pY29uIHx8ICcnKSArICgnPHNwYW4+JyArIHByb3BzLmxhYmVsICsgJzwvc3Bhbj4nKTtcblxuICAgIHByb3BzLmlzRGlzYWJsZWQgPSBmYWxzZTtcbiAgfTtcblxuICB2YXIgd3JpdGUkMSA9IGZ1bmN0aW9uIHdyaXRlKF9yZWYyKSB7XG4gICAgdmFyIHJvb3QgPSBfcmVmMi5yb290LFxuICAgICAgcHJvcHMgPSBfcmVmMi5wcm9wcztcbiAgICB2YXIgaXNEaXNhYmxlZCA9IHByb3BzLmlzRGlzYWJsZWQ7XG4gICAgdmFyIHNob3VsZERpc2FibGUgPSByb290LnF1ZXJ5KCdHRVRfRElTQUJMRUQnKSB8fCBwcm9wcy5vcGFjaXR5ID09PSAwO1xuXG4gICAgaWYgKHNob3VsZERpc2FibGUgJiYgIWlzRGlzYWJsZWQpIHtcbiAgICAgIHByb3BzLmlzRGlzYWJsZWQgPSB0cnVlO1xuICAgICAgYXR0cihyb290LmVsZW1lbnQsICdkaXNhYmxlZCcsICdkaXNhYmxlZCcpO1xuICAgIH0gZWxzZSBpZiAoIXNob3VsZERpc2FibGUgJiYgaXNEaXNhYmxlZCkge1xuICAgICAgcHJvcHMuaXNEaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgcm9vdC5lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGZpbGVBY3Rpb25CdXR0b24gPSBjcmVhdGVWaWV3KHtcbiAgICB0YWc6ICdidXR0b24nLFxuICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgIHR5cGU6ICdidXR0b24nXG4gICAgfSxcblxuICAgIGlnbm9yZVJlY3Q6IHRydWUsXG4gICAgaWdub3JlUmVjdFVwZGF0ZTogdHJ1ZSxcbiAgICBuYW1lOiAnZmlsZS1hY3Rpb24tYnV0dG9uJyxcbiAgICBtaXhpbnM6IHtcbiAgICAgIGFwaXM6IFsnbGFiZWwnXSxcbiAgICAgIHN0eWxlczogWyd0cmFuc2xhdGVYJywgJ3RyYW5zbGF0ZVknLCAnc2NhbGVYJywgJ3NjYWxlWScsICdvcGFjaXR5J10sXG4gICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgIHNjYWxlWDogJ3NwcmluZycsXG4gICAgICAgIHNjYWxlWTogJ3NwcmluZycsXG4gICAgICAgIHRyYW5zbGF0ZVg6ICdzcHJpbmcnLFxuICAgICAgICB0cmFuc2xhdGVZOiAnc3ByaW5nJyxcbiAgICAgICAgb3BhY2l0eTogeyB0eXBlOiAndHdlZW4nLCBkdXJhdGlvbjogMjUwIH1cbiAgICAgIH0sXG5cbiAgICAgIGxpc3RlbmVyczogdHJ1ZVxuICAgIH0sXG5cbiAgICBjcmVhdGU6IGNyZWF0ZSQxLFxuICAgIHdyaXRlOiB3cml0ZSQxXG4gIH0pO1xuXG4gIHZhciB0b05hdHVyYWxGaWxlU2l6ZSA9IGZ1bmN0aW9uIHRvTmF0dXJhbEZpbGVTaXplKGJ5dGVzKSB7XG4gICAgdmFyIGRlY2ltYWxTZXBhcmF0b3IgPVxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnLic7XG4gICAgdmFyIGJhc2UgPVxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAxMDAwO1xuICAgIC8vIG5vIG5lZ2F0aXZlIGJ5dGUgc2l6ZXNcbiAgICBieXRlcyA9IE1hdGgucm91bmQoTWF0aC5hYnMoYnl0ZXMpKTtcblxuICAgIHZhciBLQiA9IGJhc2U7XG4gICAgdmFyIE1CID0gYmFzZSAqIGJhc2U7XG4gICAgdmFyIEdCID0gYmFzZSAqIGJhc2UgKiBiYXNlO1xuXG4gICAgLy8ganVzdCBieXRlc1xuICAgIGlmIChieXRlcyA8IEtCKSB7XG4gICAgICByZXR1cm4gYnl0ZXMgKyAnIGJ5dGVzJztcbiAgICB9XG5cbiAgICAvLyBraWxvYnl0ZXNcbiAgICBpZiAoYnl0ZXMgPCBNQikge1xuICAgICAgcmV0dXJuIE1hdGguZmxvb3IoYnl0ZXMgLyBLQikgKyAnIEtCJztcbiAgICB9XG5cbiAgICAvLyBtZWdhYnl0ZXNcbiAgICBpZiAoYnl0ZXMgPCBHQikge1xuICAgICAgcmV0dXJuIHJlbW92ZURlY2ltYWxzV2hlblplcm8oYnl0ZXMgLyBNQiwgMSwgZGVjaW1hbFNlcGFyYXRvcikgKyAnIE1CJztcbiAgICB9XG5cbiAgICAvLyBnaWdhYnl0ZXNcbiAgICByZXR1cm4gcmVtb3ZlRGVjaW1hbHNXaGVuWmVybyhieXRlcyAvIEdCLCAyLCBkZWNpbWFsU2VwYXJhdG9yKSArICcgR0InO1xuICB9O1xuXG4gIHZhciByZW1vdmVEZWNpbWFsc1doZW5aZXJvID0gZnVuY3Rpb24gcmVtb3ZlRGVjaW1hbHNXaGVuWmVybyhcbiAgICB2YWx1ZSxcbiAgICBkZWNpbWFsQ291bnQsXG4gICAgc2VwYXJhdG9yXG4gICkge1xuICAgIHJldHVybiB2YWx1ZVxuICAgICAgLnRvRml4ZWQoZGVjaW1hbENvdW50KVxuICAgICAgLnNwbGl0KCcuJylcbiAgICAgIC5maWx0ZXIoZnVuY3Rpb24ocGFydCkge1xuICAgICAgICByZXR1cm4gcGFydCAhPT0gJzAnO1xuICAgICAgfSlcbiAgICAgIC5qb2luKHNlcGFyYXRvcik7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZSQyID0gZnVuY3Rpb24gY3JlYXRlKF9yZWYpIHtcbiAgICB2YXIgcm9vdCA9IF9yZWYucm9vdCxcbiAgICAgIHByb3BzID0gX3JlZi5wcm9wcztcbiAgICAvLyBmaWxlbmFtZVxuICAgIHZhciBmaWxlTmFtZSA9IGNyZWF0ZUVsZW1lbnQkMSgnc3BhbicpO1xuICAgIGZpbGVOYW1lLmNsYXNzTmFtZSA9ICdmaWxlcG9uZC0tZmlsZS1pbmZvLW1haW4nO1xuICAgIC8vIGhpZGUgZm9yIHNjcmVlbnJlYWRlcnNcbiAgICAvLyB0aGUgZmlsZSBpcyBjb250YWluZWQgaW4gYSBmaWVsZHNldCB3aXRoIGxlZ2VuZCB0aGF0IGNvbnRhaW5zIHRoZSBmaWxlbmFtZVxuICAgIC8vIG5vIG5lZWQgdG8gcmVhZCBpdCB0d2ljZVxuICAgIGF0dHIoZmlsZU5hbWUsICdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG4gICAgcm9vdC5hcHBlbmRDaGlsZChmaWxlTmFtZSk7XG4gICAgcm9vdC5yZWYuZmlsZU5hbWUgPSBmaWxlTmFtZTtcblxuICAgIC8vIGZpbGVzaXplXG4gICAgdmFyIGZpbGVTaXplID0gY3JlYXRlRWxlbWVudCQxKCdzcGFuJyk7XG4gICAgZmlsZVNpemUuY2xhc3NOYW1lID0gJ2ZpbGVwb25kLS1maWxlLWluZm8tc3ViJztcbiAgICByb290LmFwcGVuZENoaWxkKGZpbGVTaXplKTtcbiAgICByb290LnJlZi5maWxlU2l6ZSA9IGZpbGVTaXplO1xuXG4gICAgLy8gc2V0IGluaXRpYWwgdmFsdWVzXG4gICAgdGV4dChmaWxlU2l6ZSwgcm9vdC5xdWVyeSgnR0VUX0xBQkVMX0ZJTEVfV0FJVElOR19GT1JfU0laRScpKTtcbiAgICB0ZXh0KGZpbGVOYW1lLCBmb3JtYXRGaWxlbmFtZShyb290LnF1ZXJ5KCdHRVRfSVRFTV9OQU1FJywgcHJvcHMuaWQpKSk7XG4gIH07XG5cbiAgdmFyIHVwZGF0ZUZpbGUgPSBmdW5jdGlvbiB1cGRhdGVGaWxlKF9yZWYyKSB7XG4gICAgdmFyIHJvb3QgPSBfcmVmMi5yb290LFxuICAgICAgcHJvcHMgPSBfcmVmMi5wcm9wcztcbiAgICB0ZXh0KFxuICAgICAgcm9vdC5yZWYuZmlsZVNpemUsXG4gICAgICB0b05hdHVyYWxGaWxlU2l6ZShcbiAgICAgICAgcm9vdC5xdWVyeSgnR0VUX0lURU1fU0laRScsIHByb3BzLmlkKSxcbiAgICAgICAgJy4nLFxuICAgICAgICByb290LnF1ZXJ5KCdHRVRfRklMRV9TSVpFX0JBU0UnKVxuICAgICAgKVxuICAgICk7XG5cbiAgICB0ZXh0KFxuICAgICAgcm9vdC5yZWYuZmlsZU5hbWUsXG4gICAgICBmb3JtYXRGaWxlbmFtZShyb290LnF1ZXJ5KCdHRVRfSVRFTV9OQU1FJywgcHJvcHMuaWQpKVxuICAgICk7XG4gIH07XG5cbiAgdmFyIHVwZGF0ZUZpbGVTaXplT25FcnJvciA9IGZ1bmN0aW9uIHVwZGF0ZUZpbGVTaXplT25FcnJvcihfcmVmMykge1xuICAgIHZhciByb290ID0gX3JlZjMucm9vdCxcbiAgICAgIHByb3BzID0gX3JlZjMucHJvcHM7XG4gICAgLy8gaWYgc2l6ZSBpcyBhdmFpbGFibGUgZG9uJ3QgZmFsbGJhY2sgdG8gdW5rbm93biBzaXplIG1lc3NhZ2VcbiAgICBpZiAoaXNJbnQocm9vdC5xdWVyeSgnR0VUX0lURU1fU0laRScsIHByb3BzLmlkKSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0ZXh0KHJvb3QucmVmLmZpbGVTaXplLCByb290LnF1ZXJ5KCdHRVRfTEFCRUxfRklMRV9TSVpFX05PVF9BVkFJTEFCTEUnKSk7XG4gIH07XG5cbiAgdmFyIGZpbGVJbmZvID0gY3JlYXRlVmlldyh7XG4gICAgbmFtZTogJ2ZpbGUtaW5mbycsXG4gICAgaWdub3JlUmVjdDogdHJ1ZSxcbiAgICBpZ25vcmVSZWN0VXBkYXRlOiB0cnVlLFxuICAgIHdyaXRlOiBjcmVhdGVSb3V0ZSh7XG4gICAgICBESURfTE9BRF9JVEVNOiB1cGRhdGVGaWxlLFxuICAgICAgRElEX1VQREFURV9JVEVNX01FVEE6IHVwZGF0ZUZpbGUsXG4gICAgICBESURfVEhST1dfSVRFTV9MT0FEX0VSUk9SOiB1cGRhdGVGaWxlU2l6ZU9uRXJyb3IsXG4gICAgICBESURfVEhST1dfSVRFTV9JTlZBTElEOiB1cGRhdGVGaWxlU2l6ZU9uRXJyb3JcbiAgICB9KSxcblxuICAgIGRpZENyZWF0ZVZpZXc6IGZ1bmN0aW9uIGRpZENyZWF0ZVZpZXcocm9vdCkge1xuICAgICAgYXBwbHlGaWx0ZXJzKCdDUkVBVEVfVklFVycsIE9iamVjdC5hc3NpZ24oe30sIHJvb3QsIHsgdmlldzogcm9vdCB9KSk7XG4gICAgfSxcbiAgICBjcmVhdGU6IGNyZWF0ZSQyLFxuICAgIG1peGluczoge1xuICAgICAgc3R5bGVzOiBbJ3RyYW5zbGF0ZVgnLCAndHJhbnNsYXRlWSddLFxuICAgICAgYW5pbWF0aW9uczoge1xuICAgICAgICB0cmFuc2xhdGVYOiAnc3ByaW5nJyxcbiAgICAgICAgdHJhbnNsYXRlWTogJ3NwcmluZydcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHZhciB0b1BlcmNlbnRhZ2UgPSBmdW5jdGlvbiB0b1BlcmNlbnRhZ2UodmFsdWUpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAqIDEwMCk7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZSQzID0gZnVuY3Rpb24gY3JlYXRlKF9yZWYpIHtcbiAgICB2YXIgcm9vdCA9IF9yZWYucm9vdDtcblxuICAgIC8vIG1haW4gc3RhdHVzXG4gICAgdmFyIG1haW4gPSBjcmVhdGVFbGVtZW50JDEoJ3NwYW4nKTtcbiAgICBtYWluLmNsYXNzTmFtZSA9ICdmaWxlcG9uZC0tZmlsZS1zdGF0dXMtbWFpbic7XG4gICAgcm9vdC5hcHBlbmRDaGlsZChtYWluKTtcbiAgICByb290LnJlZi5tYWluID0gbWFpbjtcblxuICAgIC8vIHN1YiBzdGF0dXNcbiAgICB2YXIgc3ViID0gY3JlYXRlRWxlbWVudCQxKCdzcGFuJyk7XG4gICAgc3ViLmNsYXNzTmFtZSA9ICdmaWxlcG9uZC0tZmlsZS1zdGF0dXMtc3ViJztcbiAgICByb290LmFwcGVuZENoaWxkKHN1Yik7XG4gICAgcm9vdC5yZWYuc3ViID0gc3ViO1xuXG4gICAgZGlkU2V0SXRlbUxvYWRQcm9ncmVzcyh7IHJvb3Q6IHJvb3QsIGFjdGlvbjogeyBwcm9ncmVzczogbnVsbCB9IH0pO1xuICB9O1xuXG4gIHZhciBkaWRTZXRJdGVtTG9hZFByb2dyZXNzID0gZnVuY3Rpb24gZGlkU2V0SXRlbUxvYWRQcm9ncmVzcyhfcmVmMikge1xuICAgIHZhciByb290ID0gX3JlZjIucm9vdCxcbiAgICAgIGFjdGlvbiA9IF9yZWYyLmFjdGlvbjtcbiAgICB2YXIgdGl0bGUgPVxuICAgICAgYWN0aW9uLnByb2dyZXNzID09PSBudWxsXG4gICAgICAgID8gcm9vdC5xdWVyeSgnR0VUX0xBQkVMX0ZJTEVfTE9BRElORycpXG4gICAgICAgIDogcm9vdC5xdWVyeSgnR0VUX0xBQkVMX0ZJTEVfTE9BRElORycpICtcbiAgICAgICAgICAnICcgK1xuICAgICAgICAgIHRvUGVyY2VudGFnZShhY3Rpb24ucHJvZ3Jlc3MpICtcbiAgICAgICAgICAnJSc7XG5cbiAgICB0ZXh0KHJvb3QucmVmLm1haW4sIHRpdGxlKTtcbiAgICB0ZXh0KHJvb3QucmVmLnN1Yiwgcm9vdC5xdWVyeSgnR0VUX0xBQkVMX1RBUF9UT19DQU5DRUwnKSk7XG4gIH07XG5cbiAgdmFyIGRpZFNldEl0ZW1Qcm9jZXNzUHJvZ3Jlc3MgPSBmdW5jdGlvbiBkaWRTZXRJdGVtUHJvY2Vzc1Byb2dyZXNzKF9yZWYzKSB7XG4gICAgdmFyIHJvb3QgPSBfcmVmMy5yb290LFxuICAgICAgYWN0aW9uID0gX3JlZjMuYWN0aW9uO1xuICAgIHZhciB0aXRsZSA9XG4gICAgICBhY3Rpb24ucHJvZ3Jlc3MgPT09IG51bGxcbiAgICAgICAgPyByb290LnF1ZXJ5KCdHRVRfTEFCRUxfRklMRV9QUk9DRVNTSU5HJylcbiAgICAgICAgOiByb290LnF1ZXJ5KCdHRVRfTEFCRUxfRklMRV9QUk9DRVNTSU5HJykgK1xuICAgICAgICAgICcgJyArXG4gICAgICAgICAgdG9QZXJjZW50YWdlKGFjdGlvbi5wcm9ncmVzcykgK1xuICAgICAgICAgICclJztcblxuICAgIHRleHQocm9vdC5yZWYubWFpbiwgdGl0bGUpO1xuICAgIHRleHQocm9vdC5yZWYuc3ViLCByb290LnF1ZXJ5KCdHRVRfTEFCRUxfVEFQX1RPX0NBTkNFTCcpKTtcbiAgfTtcblxuICB2YXIgZGlkUmVxdWVzdEl0ZW1Qcm9jZXNzaW5nID0gZnVuY3Rpb24gZGlkUmVxdWVzdEl0ZW1Qcm9jZXNzaW5nKF9yZWY0KSB7XG4gICAgdmFyIHJvb3QgPSBfcmVmNC5yb290O1xuICAgIHRleHQocm9vdC5yZWYubWFpbiwgcm9vdC5xdWVyeSgnR0VUX0xBQkVMX0ZJTEVfUFJPQ0VTU0lORycpKTtcbiAgICB0ZXh0KHJvb3QucmVmLnN1Yiwgcm9vdC5xdWVyeSgnR0VUX0xBQkVMX1RBUF9UT19DQU5DRUwnKSk7XG4gIH07XG5cbiAgdmFyIGRpZEFib3J0SXRlbVByb2Nlc3NpbmcgPSBmdW5jdGlvbiBkaWRBYm9ydEl0ZW1Qcm9jZXNzaW5nKF9yZWY1KSB7XG4gICAgdmFyIHJvb3QgPSBfcmVmNS5yb290O1xuICAgIHRleHQocm9vdC5yZWYubWFpbiwgcm9vdC5xdWVyeSgnR0VUX0xBQkVMX0ZJTEVfUFJPQ0VTU0lOR19BQk9SVEVEJykpO1xuICAgIHRleHQocm9vdC5yZWYuc3ViLCByb290LnF1ZXJ5KCdHRVRfTEFCRUxfVEFQX1RPX1JFVFJZJykpO1xuICB9O1xuXG4gIHZhciBkaWRDb21wbGV0ZUl0ZW1Qcm9jZXNzaW5nID0gZnVuY3Rpb24gZGlkQ29tcGxldGVJdGVtUHJvY2Vzc2luZyhfcmVmNikge1xuICAgIHZhciByb290ID0gX3JlZjYucm9vdDtcbiAgICB0ZXh0KHJvb3QucmVmLm1haW4sIHJvb3QucXVlcnkoJ0dFVF9MQUJFTF9GSUxFX1BST0NFU1NJTkdfQ09NUExFVEUnKSk7XG4gICAgdGV4dChyb290LnJlZi5zdWIsIHJvb3QucXVlcnkoJ0dFVF9MQUJFTF9UQVBfVE9fVU5ETycpKTtcbiAgfTtcblxuICB2YXIgY2xlYXIgPSBmdW5jdGlvbiBjbGVhcihfcmVmNykge1xuICAgIHZhciByb290ID0gX3JlZjcucm9vdDtcbiAgICB0ZXh0KHJvb3QucmVmLm1haW4sICcnKTtcbiAgICB0ZXh0KHJvb3QucmVmLnN1YiwgJycpO1xuICB9O1xuXG4gIHZhciBlcnJvciA9IGZ1bmN0aW9uIGVycm9yKF9yZWY4KSB7XG4gICAgdmFyIHJvb3QgPSBfcmVmOC5yb290LFxuICAgICAgYWN0aW9uID0gX3JlZjguYWN0aW9uO1xuICAgIHRleHQocm9vdC5yZWYubWFpbiwgYWN0aW9uLnN0YXR1cy5tYWluKTtcbiAgICB0ZXh0KHJvb3QucmVmLnN1YiwgYWN0aW9uLnN0YXR1cy5zdWIpO1xuICB9O1xuXG4gIHZhciBmaWxlU3RhdHVzID0gY3JlYXRlVmlldyh7XG4gICAgbmFtZTogJ2ZpbGUtc3RhdHVzJyxcbiAgICBpZ25vcmVSZWN0OiB0cnVlLFxuICAgIGlnbm9yZVJlY3RVcGRhdGU6IHRydWUsXG4gICAgd3JpdGU6IGNyZWF0ZVJvdXRlKHtcbiAgICAgIERJRF9MT0FEX0lURU06IGNsZWFyLFxuICAgICAgRElEX1JFVkVSVF9JVEVNX1BST0NFU1NJTkc6IGNsZWFyLFxuICAgICAgRElEX1JFUVVFU1RfSVRFTV9QUk9DRVNTSU5HOiBkaWRSZXF1ZXN0SXRlbVByb2Nlc3NpbmcsXG4gICAgICBESURfQUJPUlRfSVRFTV9QUk9DRVNTSU5HOiBkaWRBYm9ydEl0ZW1Qcm9jZXNzaW5nLFxuICAgICAgRElEX0NPTVBMRVRFX0lURU1fUFJPQ0VTU0lORzogZGlkQ29tcGxldGVJdGVtUHJvY2Vzc2luZyxcbiAgICAgIERJRF9VUERBVEVfSVRFTV9QUk9DRVNTX1BST0dSRVNTOiBkaWRTZXRJdGVtUHJvY2Vzc1Byb2dyZXNzLFxuICAgICAgRElEX1VQREFURV9JVEVNX0xPQURfUFJPR1JFU1M6IGRpZFNldEl0ZW1Mb2FkUHJvZ3Jlc3MsXG4gICAgICBESURfVEhST1dfSVRFTV9MT0FEX0VSUk9SOiBlcnJvcixcbiAgICAgIERJRF9USFJPV19JVEVNX0lOVkFMSUQ6IGVycm9yLFxuICAgICAgRElEX1RIUk9XX0lURU1fUFJPQ0VTU0lOR19FUlJPUjogZXJyb3IsXG4gICAgICBESURfVEhST1dfSVRFTV9QUk9DRVNTSU5HX1JFVkVSVF9FUlJPUjogZXJyb3IsXG4gICAgICBESURfVEhST1dfSVRFTV9SRU1PVkVfRVJST1I6IGVycm9yXG4gICAgfSksXG5cbiAgICBkaWRDcmVhdGVWaWV3OiBmdW5jdGlvbiBkaWRDcmVhdGVWaWV3KHJvb3QpIHtcbiAgICAgIGFwcGx5RmlsdGVycygnQ1JFQVRFX1ZJRVcnLCBPYmplY3QuYXNzaWduKHt9LCByb290LCB7IHZpZXc6IHJvb3QgfSkpO1xuICAgIH0sXG4gICAgY3JlYXRlOiBjcmVhdGUkMyxcbiAgICBtaXhpbnM6IHtcbiAgICAgIHN0eWxlczogWyd0cmFuc2xhdGVYJywgJ3RyYW5zbGF0ZVknLCAnb3BhY2l0eSddLFxuICAgICAgYW5pbWF0aW9uczoge1xuICAgICAgICBvcGFjaXR5OiB7IHR5cGU6ICd0d2VlbicsIGR1cmF0aW9uOiAyNTAgfSxcbiAgICAgICAgdHJhbnNsYXRlWDogJ3NwcmluZycsXG4gICAgICAgIHRyYW5zbGF0ZVk6ICdzcHJpbmcnXG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogQnV0dG9uIGRlZmluaXRpb25zIGZvciB0aGUgZmlsZSB2aWV3XG4gICAqL1xuXG4gIHZhciBCdXR0b25zID0ge1xuICAgIEFib3J0SXRlbUxvYWQ6IHtcbiAgICAgIGxhYmVsOiAnR0VUX0xBQkVMX0JVVFRPTl9BQk9SVF9JVEVNX0xPQUQnLFxuICAgICAgYWN0aW9uOiAnQUJPUlRfSVRFTV9MT0FEJyxcbiAgICAgIGNsYXNzTmFtZTogJ2ZpbGVwb25kLS1hY3Rpb24tYWJvcnQtaXRlbS1sb2FkJyxcbiAgICAgIGFsaWduOiAnTE9BRF9JTkRJQ0FUT1JfUE9TSVRJT04nIC8vIHJpZ2h0XG4gICAgfSxcbiAgICBSZXRyeUl0ZW1Mb2FkOiB7XG4gICAgICBsYWJlbDogJ0dFVF9MQUJFTF9CVVRUT05fUkVUUllfSVRFTV9MT0FEJyxcbiAgICAgIGFjdGlvbjogJ1JFVFJZX0lURU1fTE9BRCcsXG4gICAgICBpY29uOiAnR0VUX0lDT05fUkVUUlknLFxuICAgICAgY2xhc3NOYW1lOiAnZmlsZXBvbmQtLWFjdGlvbi1yZXRyeS1pdGVtLWxvYWQnLFxuICAgICAgYWxpZ246ICdCVVRUT05fUFJPQ0VTU19JVEVNX1BPU0lUSU9OJyAvLyByaWdodFxuICAgIH0sXG4gICAgUmVtb3ZlSXRlbToge1xuICAgICAgbGFiZWw6ICdHRVRfTEFCRUxfQlVUVE9OX1JFTU9WRV9JVEVNJyxcbiAgICAgIGFjdGlvbjogJ1JFUVVFU1RfUkVNT1ZFX0lURU0nLFxuICAgICAgaWNvbjogJ0dFVF9JQ09OX1JFTU9WRScsXG4gICAgICBjbGFzc05hbWU6ICdmaWxlcG9uZC0tYWN0aW9uLXJlbW92ZS1pdGVtJyxcbiAgICAgIGFsaWduOiAnQlVUVE9OX1JFTU9WRV9JVEVNX1BPU0lUSU9OJyAvLyBsZWZ0XG4gICAgfSxcbiAgICBQcm9jZXNzSXRlbToge1xuICAgICAgbGFiZWw6ICdHRVRfTEFCRUxfQlVUVE9OX1BST0NFU1NfSVRFTScsXG4gICAgICBhY3Rpb246ICdSRVFVRVNUX0lURU1fUFJPQ0VTU0lORycsXG4gICAgICBpY29uOiAnR0VUX0lDT05fUFJPQ0VTUycsXG4gICAgICBjbGFzc05hbWU6ICdmaWxlcG9uZC0tYWN0aW9uLXByb2Nlc3MtaXRlbScsXG4gICAgICBhbGlnbjogJ0JVVFRPTl9QUk9DRVNTX0lURU1fUE9TSVRJT04nIC8vIHJpZ2h0XG4gICAgfSxcbiAgICBBYm9ydEl0ZW1Qcm9jZXNzaW5nOiB7XG4gICAgICBsYWJlbDogJ0dFVF9MQUJFTF9CVVRUT05fQUJPUlRfSVRFTV9QUk9DRVNTSU5HJyxcbiAgICAgIGFjdGlvbjogJ0FCT1JUX0lURU1fUFJPQ0VTU0lORycsXG4gICAgICBjbGFzc05hbWU6ICdmaWxlcG9uZC0tYWN0aW9uLWFib3J0LWl0ZW0tcHJvY2Vzc2luZycsXG4gICAgICBhbGlnbjogJ0JVVFRPTl9QUk9DRVNTX0lURU1fUE9TSVRJT04nIC8vIHJpZ2h0XG4gICAgfSxcbiAgICBSZXRyeUl0ZW1Qcm9jZXNzaW5nOiB7XG4gICAgICBsYWJlbDogJ0dFVF9MQUJFTF9CVVRUT05fUkVUUllfSVRFTV9QUk9DRVNTSU5HJyxcbiAgICAgIGFjdGlvbjogJ1JFVFJZX0lURU1fUFJPQ0VTU0lORycsXG4gICAgICBpY29uOiAnR0VUX0lDT05fUkVUUlknLFxuICAgICAgY2xhc3NOYW1lOiAnZmlsZXBvbmQtLWFjdGlvbi1yZXRyeS1pdGVtLXByb2Nlc3NpbmcnLFxuICAgICAgYWxpZ246ICdCVVRUT05fUFJPQ0VTU19JVEVNX1BPU0lUSU9OJyAvLyByaWdodFxuICAgIH0sXG4gICAgUmV2ZXJ0SXRlbVByb2Nlc3Npbmc6IHtcbiAgICAgIGxhYmVsOiAnR0VUX0xBQkVMX0JVVFRPTl9VTkRPX0lURU1fUFJPQ0VTU0lORycsXG4gICAgICBhY3Rpb246ICdSRVFVRVNUX1JFVkVSVF9JVEVNX1BST0NFU1NJTkcnLFxuICAgICAgaWNvbjogJ0dFVF9JQ09OX1VORE8nLFxuICAgICAgY2xhc3NOYW1lOiAnZmlsZXBvbmQtLWFjdGlvbi1yZXZlcnQtaXRlbS1wcm9jZXNzaW5nJyxcbiAgICAgIGFsaWduOiAnQlVUVE9OX1BST0NFU1NfSVRFTV9QT1NJVElPTicgLy8gcmlnaHRcbiAgICB9XG4gIH07XG5cbiAgLy8gbWFrZSBhIGxpc3Qgb2YgYnV0dG9ucywgd2UgY2FuIHRoZW4gcmVtb3ZlIGJ1dHRvbnMgZnJvbSB0aGlzIGxpc3QgaWYgdGhleSdyZSBkaXNhYmxlZFxuICB2YXIgQnV0dG9uS2V5cyA9IFtdO1xuICBmb3JpbihCdXR0b25zLCBmdW5jdGlvbihrZXkpIHtcbiAgICBCdXR0b25LZXlzLnB1c2goa2V5KTtcbiAgfSk7XG5cbiAgdmFyIGNhbGN1bGF0ZUZpbGVJbmZvT2Zmc2V0ID0gZnVuY3Rpb24gY2FsY3VsYXRlRmlsZUluZm9PZmZzZXQocm9vdCkge1xuICAgIHZhciBidXR0b25SZWN0ID0gcm9vdC5yZWYuYnV0dG9uUmVtb3ZlSXRlbS5yZWN0LmVsZW1lbnQ7XG4gICAgcmV0dXJuIGJ1dHRvblJlY3QuaGlkZGVuID8gbnVsbCA6IGJ1dHRvblJlY3Qud2lkdGggKyBidXR0b25SZWN0LmxlZnQ7XG4gIH07XG5cbiAgdmFyIGNhbGN1bGF0ZUJ1dHRvbldpZHRoID0gZnVuY3Rpb24gY2FsY3VsYXRlQnV0dG9uV2lkdGgocm9vdCkge1xuICAgIHZhciBidXR0b25SZWN0ID0gcm9vdC5yZWYuYnV0dG9uQWJvcnRJdGVtTG9hZC5yZWN0LmVsZW1lbnQ7XG4gICAgcmV0dXJuIGJ1dHRvblJlY3Qud2lkdGg7XG4gIH07XG5cbiAgLy8gRm9yY2Ugb24gZnVsbCBwaXhlbHMgc28gdGV4dCBzdGF5cyBjcmlwc1xuICB2YXIgY2FsY3VsYXRlRmlsZVZlcnRpY2FsQ2VudGVyT2Zmc2V0ID0gZnVuY3Rpb24gY2FsY3VsYXRlRmlsZVZlcnRpY2FsQ2VudGVyT2Zmc2V0KFxuICAgIHJvb3RcbiAgKSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3Iocm9vdC5yZWYuYnV0dG9uUmVtb3ZlSXRlbS5yZWN0LmVsZW1lbnQuaGVpZ2h0IC8gNCk7XG4gIH07XG4gIHZhciBjYWxjdWxhdGVGaWxlSG9yaXpvbnRhbENlbnRlck9mZnNldCA9IGZ1bmN0aW9uIGNhbGN1bGF0ZUZpbGVIb3Jpem9udGFsQ2VudGVyT2Zmc2V0KFxuICAgIHJvb3RcbiAgKSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3Iocm9vdC5yZWYuYnV0dG9uUmVtb3ZlSXRlbS5yZWN0LmVsZW1lbnQubGVmdCAvIDIpO1xuICB9O1xuXG4gIHZhciBnZXRMb2FkSW5kaWNhdG9yQWxpZ25tZW50ID0gZnVuY3Rpb24gZ2V0TG9hZEluZGljYXRvckFsaWdubWVudChyb290KSB7XG4gICAgcmV0dXJuIHJvb3QucXVlcnkoJ0dFVF9TVFlMRV9MT0FEX0lORElDQVRPUl9QT1NJVElPTicpO1xuICB9O1xuICB2YXIgZ2V0UHJvY2Vzc0luZGljYXRvckFsaWdubWVudCA9IGZ1bmN0aW9uIGdldFByb2Nlc3NJbmRpY2F0b3JBbGlnbm1lbnQoXG4gICAgcm9vdFxuICApIHtcbiAgICByZXR1cm4gcm9vdC5xdWVyeSgnR0VUX1NUWUxFX1BST0dSRVNTX0lORElDQVRPUl9QT1NJVElPTicpO1xuICB9O1xuICB2YXIgZ2V0UmVtb3ZlSW5kaWNhdG9yQWxpZ21lbnQgPSBmdW5jdGlvbiBnZXRSZW1vdmVJbmRpY2F0b3JBbGlnbWVudChyb290KSB7XG4gICAgcmV0dXJuIHJvb3QucXVlcnkoJ0dFVF9TVFlMRV9CVVRUT05fUkVNT1ZFX0lURU1fUE9TSVRJT04nKTtcbiAgfTtcblxuICB2YXIgRGVmYXVsdFN0eWxlID0ge1xuICAgIGJ1dHRvbkFib3J0SXRlbUxvYWQ6IHsgb3BhY2l0eTogMCB9LFxuICAgIGJ1dHRvblJldHJ5SXRlbUxvYWQ6IHsgb3BhY2l0eTogMCB9LFxuICAgIGJ1dHRvblJlbW92ZUl0ZW06IHsgb3BhY2l0eTogMCB9LFxuICAgIGJ1dHRvblByb2Nlc3NJdGVtOiB7IG9wYWNpdHk6IDAgfSxcbiAgICBidXR0b25BYm9ydEl0ZW1Qcm9jZXNzaW5nOiB7IG9wYWNpdHk6IDAgfSxcbiAgICBidXR0b25SZXRyeUl0ZW1Qcm9jZXNzaW5nOiB7IG9wYWNpdHk6IDAgfSxcbiAgICBidXR0b25SZXZlcnRJdGVtUHJvY2Vzc2luZzogeyBvcGFjaXR5OiAwIH0sXG4gICAgbG9hZFByb2dyZXNzSW5kaWNhdG9yOiB7IG9wYWNpdHk6IDAsIGFsaWduOiBnZXRMb2FkSW5kaWNhdG9yQWxpZ25tZW50IH0sXG4gICAgcHJvY2Vzc1Byb2dyZXNzSW5kaWNhdG9yOiB7XG4gICAgICBvcGFjaXR5OiAwLFxuICAgICAgYWxpZ246IGdldFByb2Nlc3NJbmRpY2F0b3JBbGlnbm1lbnRcbiAgICB9LFxuICAgIHByb2Nlc3NpbmdDb21wbGV0ZUluZGljYXRvcjogeyBvcGFjaXR5OiAwLCBzY2FsZVg6IDAuNzUsIHNjYWxlWTogMC43NSB9LFxuICAgIGluZm86IHsgdHJhbnNsYXRlWDogMCwgdHJhbnNsYXRlWTogMCwgb3BhY2l0eTogMCB9LFxuICAgIHN0YXR1czogeyB0cmFuc2xhdGVYOiAwLCB0cmFuc2xhdGVZOiAwLCBvcGFjaXR5OiAwIH1cbiAgfTtcblxuICB2YXIgSWRsZVN0eWxlID0ge1xuICAgIGJ1dHRvblJlbW92ZUl0ZW06IHsgb3BhY2l0eTogMSB9LFxuICAgIGJ1dHRvblByb2Nlc3NJdGVtOiB7IG9wYWNpdHk6IDEgfSxcbiAgICBpbmZvOiB7IHRyYW5zbGF0ZVg6IGNhbGN1bGF0ZUZpbGVJbmZvT2Zmc2V0IH0sXG4gICAgc3RhdHVzOiB7IHRyYW5zbGF0ZVg6IGNhbGN1bGF0ZUZpbGVJbmZvT2Zmc2V0IH1cbiAgfTtcblxuICB2YXIgUHJvY2Vzc2luZ1N0eWxlID0ge1xuICAgIGJ1dHRvbkFib3J0SXRlbVByb2Nlc3Npbmc6IHsgb3BhY2l0eTogMSB9LFxuICAgIHByb2Nlc3NQcm9ncmVzc0luZGljYXRvcjogeyBvcGFjaXR5OiAxIH0sXG4gICAgc3RhdHVzOiB7IG9wYWNpdHk6IDEgfVxuICB9O1xuXG4gIHZhciBTdHlsZU1hcCA9IHtcbiAgICBESURfVEhST1dfSVRFTV9JTlZBTElEOiB7XG4gICAgICBidXR0b25SZW1vdmVJdGVtOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgIGluZm86IHsgdHJhbnNsYXRlWDogY2FsY3VsYXRlRmlsZUluZm9PZmZzZXQgfSxcbiAgICAgIHN0YXR1czogeyB0cmFuc2xhdGVYOiBjYWxjdWxhdGVGaWxlSW5mb09mZnNldCwgb3BhY2l0eTogMSB9XG4gICAgfSxcblxuICAgIERJRF9TVEFSVF9JVEVNX0xPQUQ6IHtcbiAgICAgIGJ1dHRvbkFib3J0SXRlbUxvYWQ6IHsgb3BhY2l0eTogMSB9LFxuICAgICAgbG9hZFByb2dyZXNzSW5kaWNhdG9yOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgIHN0YXR1czogeyBvcGFjaXR5OiAxIH1cbiAgICB9LFxuXG4gICAgRElEX1RIUk9XX0lURU1fTE9BRF9FUlJPUjoge1xuICAgICAgYnV0dG9uUmV0cnlJdGVtTG9hZDogeyBvcGFjaXR5OiAxIH0sXG4gICAgICBidXR0b25SZW1vdmVJdGVtOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgIGluZm86IHsgdHJhbnNsYXRlWDogY2FsY3VsYXRlRmlsZUluZm9PZmZzZXQgfSxcbiAgICAgIHN0YXR1czogeyBvcGFjaXR5OiAxIH1cbiAgICB9LFxuXG4gICAgRElEX1NUQVJUX0lURU1fUkVNT1ZFOiB7XG4gICAgICBwcm9jZXNzUHJvZ3Jlc3NJbmRpY2F0b3I6IHtcbiAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgYWxpZ246IGdldFJlbW92ZUluZGljYXRvckFsaWdtZW50XG4gICAgICB9LFxuICAgICAgaW5mbzogeyB0cmFuc2xhdGVYOiBjYWxjdWxhdGVGaWxlSW5mb09mZnNldCB9LFxuICAgICAgc3RhdHVzOiB7IG9wYWNpdHk6IDAgfVxuICAgIH0sXG5cbiAgICBESURfVEhST1dfSVRFTV9SRU1PVkVfRVJST1I6IHtcbiAgICAgIHByb2Nlc3NQcm9ncmVzc0luZGljYXRvcjoge1xuICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICBhbGlnbjogZ2V0UmVtb3ZlSW5kaWNhdG9yQWxpZ21lbnRcbiAgICAgIH0sXG4gICAgICBidXR0b25SZW1vdmVJdGVtOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgIGluZm86IHsgdHJhbnNsYXRlWDogY2FsY3VsYXRlRmlsZUluZm9PZmZzZXQgfSxcbiAgICAgIHN0YXR1czogeyBvcGFjaXR5OiAxLCB0cmFuc2xhdGVYOiBjYWxjdWxhdGVGaWxlSW5mb09mZnNldCB9XG4gICAgfSxcblxuICAgIERJRF9MT0FEX0lURU06IElkbGVTdHlsZSxcbiAgICBESURfTE9BRF9MT0NBTF9JVEVNOiB7XG4gICAgICBidXR0b25SZW1vdmVJdGVtOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgIGluZm86IHsgdHJhbnNsYXRlWDogY2FsY3VsYXRlRmlsZUluZm9PZmZzZXQgfSxcbiAgICAgIHN0YXR1czogeyB0cmFuc2xhdGVYOiBjYWxjdWxhdGVGaWxlSW5mb09mZnNldCB9XG4gICAgfSxcblxuICAgIERJRF9TVEFSVF9JVEVNX1BST0NFU1NJTkc6IFByb2Nlc3NpbmdTdHlsZSxcbiAgICBESURfUkVRVUVTVF9JVEVNX1BST0NFU1NJTkc6IFByb2Nlc3NpbmdTdHlsZSxcbiAgICBESURfVVBEQVRFX0lURU1fUFJPQ0VTU19QUk9HUkVTUzogUHJvY2Vzc2luZ1N0eWxlLFxuICAgIERJRF9DT01QTEVURV9JVEVNX1BST0NFU1NJTkc6IHtcbiAgICAgIGJ1dHRvblJldmVydEl0ZW1Qcm9jZXNzaW5nOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgIGluZm86IHsgb3BhY2l0eTogMSB9LFxuICAgICAgc3RhdHVzOiB7IG9wYWNpdHk6IDEgfVxuICAgIH0sXG5cbiAgICBESURfVEhST1dfSVRFTV9QUk9DRVNTSU5HX0VSUk9SOiB7XG4gICAgICBidXR0b25SZW1vdmVJdGVtOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgIGJ1dHRvblJldHJ5SXRlbVByb2Nlc3Npbmc6IHsgb3BhY2l0eTogMSB9LFxuICAgICAgc3RhdHVzOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgIGluZm86IHsgdHJhbnNsYXRlWDogY2FsY3VsYXRlRmlsZUluZm9PZmZzZXQgfVxuICAgIH0sXG5cbiAgICBESURfVEhST1dfSVRFTV9QUk9DRVNTSU5HX1JFVkVSVF9FUlJPUjoge1xuICAgICAgYnV0dG9uUmV2ZXJ0SXRlbVByb2Nlc3Npbmc6IHsgb3BhY2l0eTogMSB9LFxuICAgICAgc3RhdHVzOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgIGluZm86IHsgb3BhY2l0eTogMSB9XG4gICAgfSxcblxuICAgIERJRF9BQk9SVF9JVEVNX1BST0NFU1NJTkc6IHtcbiAgICAgIGJ1dHRvblJlbW92ZUl0ZW06IHsgb3BhY2l0eTogMSB9LFxuICAgICAgYnV0dG9uUHJvY2Vzc0l0ZW06IHsgb3BhY2l0eTogMSB9LFxuICAgICAgaW5mbzogeyB0cmFuc2xhdGVYOiBjYWxjdWxhdGVGaWxlSW5mb09mZnNldCB9LFxuICAgICAgc3RhdHVzOiB7IG9wYWNpdHk6IDEgfVxuICAgIH0sXG5cbiAgICBESURfUkVWRVJUX0lURU1fUFJPQ0VTU0lORzogSWRsZVN0eWxlXG4gIH07XG5cbiAgLy8gY29tcGxldGUgaW5kaWNhdG9yIHZpZXdcbiAgdmFyIHByb2Nlc3NpbmdDb21wbGV0ZUluZGljYXRvclZpZXcgPSBjcmVhdGVWaWV3KHtcbiAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZShfcmVmKSB7XG4gICAgICB2YXIgcm9vdCA9IF9yZWYucm9vdDtcbiAgICAgIHJvb3QuZWxlbWVudC5pbm5lckhUTUwgPSByb290LnF1ZXJ5KCdHRVRfSUNPTl9ET05FJyk7XG4gICAgfSxcbiAgICBuYW1lOiAncHJvY2Vzc2luZy1jb21wbGV0ZS1pbmRpY2F0b3InLFxuICAgIGlnbm9yZVJlY3Q6IHRydWUsXG4gICAgbWl4aW5zOiB7XG4gICAgICBzdHlsZXM6IFsnc2NhbGVYJywgJ3NjYWxlWScsICdvcGFjaXR5J10sXG4gICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgIHNjYWxlWDogJ3NwcmluZycsXG4gICAgICAgIHNjYWxlWTogJ3NwcmluZycsXG4gICAgICAgIG9wYWNpdHk6IHsgdHlwZTogJ3R3ZWVuJywgZHVyYXRpb246IDI1MCB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogQ3JlYXRlcyB0aGUgZmlsZSB2aWV3XG4gICAqL1xuICB2YXIgY3JlYXRlJDQgPSBmdW5jdGlvbiBjcmVhdGUoX3JlZjIpIHtcbiAgICB2YXIgcm9vdCA9IF9yZWYyLnJvb3QsXG4gICAgICBwcm9wcyA9IF9yZWYyLnByb3BzO1xuICAgIHZhciBpZCA9IHByb3BzLmlkO1xuXG4gICAgLy8gYWxsb3cgcmV2ZXJ0aW5nIHVwbG9hZFxuICAgIHZhciBhbGxvd1JldmVydCA9IHJvb3QucXVlcnkoJ0dFVF9BTExPV19SRVZFUlQnKTtcblxuICAgIC8vIGFsbG93IHJlbW92ZSBmaWxlXG4gICAgdmFyIGFsbG93UmVtb3ZlID0gcm9vdC5xdWVyeSgnR0VUX0FMTE9XX1JFTU9WRScpO1xuXG4gICAgLy8gYWxsb3cgcHJvY2Vzc2luZyB1cGxvYWRcbiAgICB2YXIgYWxsb3dQcm9jZXNzID0gcm9vdC5xdWVyeSgnR0VUX0FMTE9XX1BST0NFU1MnKTtcblxuICAgIC8vIGlzIGluc3RhbnQgdXBsb2FkaW5nLCBuZWVkIHRoaXMgdG8gZGV0ZXJtaW5lIHRoZSBpY29uIG9mIHRoZSB1bmRvIGJ1dHRvblxuICAgIHZhciBpbnN0YW50VXBsb2FkID0gcm9vdC5xdWVyeSgnR0VUX0lOU1RBTlRfVVBMT0FEJyk7XG5cbiAgICAvLyBpcyBhc3luYyBzZXQgdXBcbiAgICB2YXIgaXNBc3luYyA9IHJvb3QucXVlcnkoJ0lTX0FTWU5DJyk7XG5cbiAgICAvLyBzaG91bGQgYWxpZ24gcmVtb3ZlIGl0ZW0gYnV0dG9uc1xuICAgIHZhciBhbGlnblJlbW92ZUl0ZW1CdXR0b24gPSByb290LnF1ZXJ5KFxuICAgICAgJ0dFVF9TVFlMRV9CVVRUT05fUkVNT1ZFX0lURU1fQUxJR04nXG4gICAgKTtcblxuICAgIC8vIGVuYWJsZWQgYnV0dG9ucyBhcnJheVxuICAgIHZhciBidXR0b25GaWx0ZXI7XG4gICAgaWYgKGlzQXN5bmMpIHtcbiAgICAgIGlmIChhbGxvd1Byb2Nlc3MgJiYgIWFsbG93UmV2ZXJ0KSB7XG4gICAgICAgIC8vIG9ubHkgcmVtb3ZlIHJldmVydCBidXR0b25cbiAgICAgICAgYnV0dG9uRmlsdGVyID0gZnVuY3Rpb24gYnV0dG9uRmlsdGVyKGtleSkge1xuICAgICAgICAgIHJldHVybiAhL1JldmVydEl0ZW1Qcm9jZXNzaW5nLy50ZXN0KGtleSk7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKCFhbGxvd1Byb2Nlc3MgJiYgYWxsb3dSZXZlcnQpIHtcbiAgICAgICAgLy8gb25seSByZW1vdmUgcHJvY2VzcyBidXR0b25cbiAgICAgICAgYnV0dG9uRmlsdGVyID0gZnVuY3Rpb24gYnV0dG9uRmlsdGVyKGtleSkge1xuICAgICAgICAgIHJldHVybiAhL1Byb2Nlc3NJdGVtfFJldHJ5SXRlbVByb2Nlc3Npbmd8QWJvcnRJdGVtUHJvY2Vzc2luZy8udGVzdChcbiAgICAgICAgICAgIGtleVxuICAgICAgICAgICk7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKCFhbGxvd1Byb2Nlc3MgJiYgIWFsbG93UmV2ZXJ0KSB7XG4gICAgICAgIC8vIHJlbW92ZSBhbGwgcHJvY2VzcyBidXR0b25zXG4gICAgICAgIGJ1dHRvbkZpbHRlciA9IGZ1bmN0aW9uIGJ1dHRvbkZpbHRlcihrZXkpIHtcbiAgICAgICAgICByZXR1cm4gIS9Qcm9jZXNzLy50ZXN0KGtleSk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG5vIHByb2Nlc3MgY29udHJvbHMgYXZhaWxhYmxlXG4gICAgICBidXR0b25GaWx0ZXIgPSBmdW5jdGlvbiBidXR0b25GaWx0ZXIoa2V5KSB7XG4gICAgICAgIHJldHVybiAhL1Byb2Nlc3MvLnRlc3Qoa2V5KTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGVuYWJsZWRCdXR0b25zID0gYnV0dG9uRmlsdGVyXG4gICAgICA/IEJ1dHRvbktleXMuZmlsdGVyKGJ1dHRvbkZpbHRlcilcbiAgICAgIDogQnV0dG9uS2V5cy5jb25jYXQoKTtcblxuICAgIC8vIHVwZGF0ZSBpY29uIGFuZCBsYWJlbCBmb3IgcmV2ZXJ0IGJ1dHRvbiB3aGVuIGluc3RhbnQgdXBsb2FkaW5nXG4gICAgaWYgKGluc3RhbnRVcGxvYWQgJiYgYWxsb3dSZXZlcnQpIHtcbiAgICAgIEJ1dHRvbnNbJ1JldmVydEl0ZW1Qcm9jZXNzaW5nJ10ubGFiZWwgPSAnR0VUX0xBQkVMX0JVVFRPTl9SRU1PVkVfSVRFTSc7XG4gICAgICBCdXR0b25zWydSZXZlcnRJdGVtUHJvY2Vzc2luZyddLmljb24gPSAnR0VUX0lDT05fUkVNT1ZFJztcbiAgICB9XG5cbiAgICAvLyByZW1vdmUgbGFzdCBidXR0b24gKHJldmVydCkgaWYgbm90IGFsbG93ZWRcbiAgICBpZiAoaXNBc3luYyAmJiAhYWxsb3dSZXZlcnQpIHtcbiAgICAgIHZhciBtYXAgPSBTdHlsZU1hcFsnRElEX0NPTVBMRVRFX0lURU1fUFJPQ0VTU0lORyddO1xuICAgICAgbWFwLmluZm8udHJhbnNsYXRlWCA9IGNhbGN1bGF0ZUZpbGVIb3Jpem9udGFsQ2VudGVyT2Zmc2V0O1xuICAgICAgbWFwLmluZm8udHJhbnNsYXRlWSA9IGNhbGN1bGF0ZUZpbGVWZXJ0aWNhbENlbnRlck9mZnNldDtcbiAgICAgIG1hcC5zdGF0dXMudHJhbnNsYXRlWSA9IGNhbGN1bGF0ZUZpbGVWZXJ0aWNhbENlbnRlck9mZnNldDtcbiAgICAgIG1hcC5wcm9jZXNzaW5nQ29tcGxldGVJbmRpY2F0b3IgPSB7IG9wYWNpdHk6IDEsIHNjYWxlWDogMSwgc2NhbGVZOiAxIH07XG4gICAgfVxuXG4gICAgLy8gc2hvdWxkIGFsaWduIGNlbnRlclxuICAgIGlmIChpc0FzeW5jICYmICFhbGxvd1Byb2Nlc3MpIHtcbiAgICAgIFtcbiAgICAgICAgJ0RJRF9TVEFSVF9JVEVNX1BST0NFU1NJTkcnLFxuICAgICAgICAnRElEX1JFUVVFU1RfSVRFTV9QUk9DRVNTSU5HJyxcbiAgICAgICAgJ0RJRF9VUERBVEVfSVRFTV9QUk9DRVNTX1BST0dSRVNTJyxcbiAgICAgICAgJ0RJRF9USFJPV19JVEVNX1BST0NFU1NJTkdfRVJST1InXG4gICAgICBdLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIFN0eWxlTWFwW2tleV0uc3RhdHVzLnRyYW5zbGF0ZVkgPSBjYWxjdWxhdGVGaWxlVmVydGljYWxDZW50ZXJPZmZzZXQ7XG4gICAgICB9KTtcbiAgICAgIFN0eWxlTWFwW1xuICAgICAgICAnRElEX1RIUk9XX0lURU1fUFJPQ0VTU0lOR19FUlJPUidcbiAgICAgIF0uc3RhdHVzLnRyYW5zbGF0ZVggPSBjYWxjdWxhdGVCdXR0b25XaWR0aDtcbiAgICB9XG5cbiAgICAvLyBtb3ZlIHJlbW92ZSBidXR0b24gdG8gcmlnaHRcbiAgICBpZiAoYWxpZ25SZW1vdmVJdGVtQnV0dG9uICYmIGFsbG93UmV2ZXJ0KSB7XG4gICAgICBCdXR0b25zWydSZXZlcnRJdGVtUHJvY2Vzc2luZyddLmFsaWduID0gJ0JVVFRPTl9SRU1PVkVfSVRFTV9QT1NJVElPTic7XG4gICAgICB2YXIgX21hcCA9IFN0eWxlTWFwWydESURfQ09NUExFVEVfSVRFTV9QUk9DRVNTSU5HJ107XG4gICAgICBfbWFwLmluZm8udHJhbnNsYXRlWCA9IGNhbGN1bGF0ZUZpbGVJbmZvT2Zmc2V0O1xuICAgICAgX21hcC5zdGF0dXMudHJhbnNsYXRlWSA9IGNhbGN1bGF0ZUZpbGVWZXJ0aWNhbENlbnRlck9mZnNldDtcbiAgICAgIF9tYXAucHJvY2Vzc2luZ0NvbXBsZXRlSW5kaWNhdG9yID0geyBvcGFjaXR5OiAxLCBzY2FsZVg6IDEsIHNjYWxlWTogMSB9O1xuICAgIH1cblxuICAgIGlmICghYWxsb3dSZW1vdmUpIHtcbiAgICAgIEJ1dHRvbnNbJ1JlbW92ZUl0ZW0nXS5kaXNhYmxlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIHRoZSBidXR0b24gdmlld3NcbiAgICBmb3JpbihCdXR0b25zLCBmdW5jdGlvbihrZXksIGRlZmluaXRpb24pIHtcbiAgICAgIC8vIGNyZWF0ZSBidXR0b25cbiAgICAgIHZhciBidXR0b25WaWV3ID0gcm9vdC5jcmVhdGVDaGlsZFZpZXcoZmlsZUFjdGlvbkJ1dHRvbiwge1xuICAgICAgICBsYWJlbDogcm9vdC5xdWVyeShkZWZpbml0aW9uLmxhYmVsKSxcbiAgICAgICAgaWNvbjogcm9vdC5xdWVyeShkZWZpbml0aW9uLmljb24pLFxuICAgICAgICBvcGFjaXR5OiAwXG4gICAgICB9KTtcblxuICAgICAgLy8gc2hvdWxkIGJlIGFwcGVuZGVkP1xuICAgICAgaWYgKGVuYWJsZWRCdXR0b25zLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgcm9vdC5hcHBlbmRDaGlsZFZpZXcoYnV0dG9uVmlldyk7XG4gICAgICB9XG5cbiAgICAgIC8vIHRvZ2dsZVxuICAgICAgaWYgKGRlZmluaXRpb24uZGlzYWJsZWQpIHtcbiAgICAgICAgYnV0dG9uVmlldy5lbGVtZW50LnNldEF0dHJpYnV0ZSgnZGlzYWJsZWQnLCAnZGlzYWJsZWQnKTtcbiAgICAgICAgYnV0dG9uVmlldy5lbGVtZW50LnNldEF0dHJpYnV0ZSgnaGlkZGVuJywgJ2hpZGRlbicpO1xuICAgICAgfVxuXG4gICAgICAvLyBhZGQgcG9zaXRpb24gYXR0cmlidXRlXG4gICAgICBidXR0b25WaWV3LmVsZW1lbnQuZGF0YXNldC5hbGlnbiA9IHJvb3QucXVlcnkoXG4gICAgICAgICdHRVRfU1RZTEVfJyArIGRlZmluaXRpb24uYWxpZ25cbiAgICAgICk7XG5cbiAgICAgIC8vIGFkZCBjbGFzc1xuICAgICAgYnV0dG9uVmlldy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoZGVmaW5pdGlvbi5jbGFzc05hbWUpO1xuXG4gICAgICAvLyBoYW5kbGUgaW50ZXJhY3Rpb25zXG4gICAgICBidXR0b25WaWV3Lm9uKCdjbGljaycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgaWYgKGRlZmluaXRpb24uZGlzYWJsZWQpIHJldHVybjtcbiAgICAgICAgcm9vdC5kaXNwYXRjaChkZWZpbml0aW9uLmFjdGlvbiwgeyBxdWVyeTogaWQgfSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gc2V0IHJlZmVyZW5jZVxuICAgICAgcm9vdC5yZWZbJ2J1dHRvbicgKyBrZXldID0gYnV0dG9uVmlldztcbiAgICB9KTtcblxuICAgIC8vIGNoZWNrbWFya1xuICAgIHJvb3QucmVmLnByb2Nlc3NpbmdDb21wbGV0ZUluZGljYXRvciA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KFxuICAgICAgcm9vdC5jcmVhdGVDaGlsZFZpZXcocHJvY2Vzc2luZ0NvbXBsZXRlSW5kaWNhdG9yVmlldylcbiAgICApO1xuICAgIHJvb3QucmVmLnByb2Nlc3NpbmdDb21wbGV0ZUluZGljYXRvci5lbGVtZW50LmRhdGFzZXQuYWxpZ24gPSByb290LnF1ZXJ5KFxuICAgICAgJ0dFVF9TVFlMRV9CVVRUT05fUFJPQ0VTU19JVEVNX1BPU0lUSU9OJ1xuICAgICk7XG5cbiAgICAvLyBjcmVhdGUgZmlsZSBpbmZvIHZpZXdcbiAgICByb290LnJlZi5pbmZvID0gcm9vdC5hcHBlbmRDaGlsZFZpZXcoXG4gICAgICByb290LmNyZWF0ZUNoaWxkVmlldyhmaWxlSW5mbywgeyBpZDogaWQgfSlcbiAgICApO1xuXG4gICAgLy8gY3JlYXRlIGZpbGUgc3RhdHVzIHZpZXdcbiAgICByb290LnJlZi5zdGF0dXMgPSByb290LmFwcGVuZENoaWxkVmlldyhcbiAgICAgIHJvb3QuY3JlYXRlQ2hpbGRWaWV3KGZpbGVTdGF0dXMsIHsgaWQ6IGlkIH0pXG4gICAgKTtcblxuICAgIC8vIGFkZCBwcm9ncmVzcyBpbmRpY2F0b3JzXG4gICAgdmFyIGxvYWRJbmRpY2F0b3JWaWV3ID0gcm9vdC5hcHBlbmRDaGlsZFZpZXcoXG4gICAgICByb290LmNyZWF0ZUNoaWxkVmlldyhwcm9ncmVzc0luZGljYXRvciwge1xuICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICBhbGlnbjogcm9vdC5xdWVyeSgnR0VUX1NUWUxFX0xPQURfSU5ESUNBVE9SX1BPU0lUSU9OJylcbiAgICAgIH0pXG4gICAgKTtcblxuICAgIGxvYWRJbmRpY2F0b3JWaWV3LmVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnZmlsZXBvbmQtLWxvYWQtaW5kaWNhdG9yJyk7XG4gICAgcm9vdC5yZWYubG9hZFByb2dyZXNzSW5kaWNhdG9yID0gbG9hZEluZGljYXRvclZpZXc7XG5cbiAgICB2YXIgcHJvZ3Jlc3NJbmRpY2F0b3JWaWV3ID0gcm9vdC5hcHBlbmRDaGlsZFZpZXcoXG4gICAgICByb290LmNyZWF0ZUNoaWxkVmlldyhwcm9ncmVzc0luZGljYXRvciwge1xuICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICBhbGlnbjogcm9vdC5xdWVyeSgnR0VUX1NUWUxFX1BST0dSRVNTX0lORElDQVRPUl9QT1NJVElPTicpXG4gICAgICB9KVxuICAgICk7XG5cbiAgICBwcm9ncmVzc0luZGljYXRvclZpZXcuZWxlbWVudC5jbGFzc0xpc3QuYWRkKCdmaWxlcG9uZC0tcHJvY2Vzcy1pbmRpY2F0b3InKTtcbiAgICByb290LnJlZi5wcm9jZXNzUHJvZ3Jlc3NJbmRpY2F0b3IgPSBwcm9ncmVzc0luZGljYXRvclZpZXc7XG5cbiAgICAvLyBjdXJyZW50IGFjdGl2ZSBzdHlsZXNcbiAgICByb290LnJlZi5hY3RpdmVTdHlsZXMgPSBbXTtcbiAgfTtcblxuICB2YXIgd3JpdGUkMiA9IGZ1bmN0aW9uIHdyaXRlKF9yZWYzKSB7XG4gICAgdmFyIHJvb3QgPSBfcmVmMy5yb290LFxuICAgICAgYWN0aW9ucyA9IF9yZWYzLmFjdGlvbnMsXG4gICAgICBwcm9wcyA9IF9yZWYzLnByb3BzO1xuXG4gICAgLy8gcm91dGUgYWN0aW9uc1xuICAgIHJvdXRlKHsgcm9vdDogcm9vdCwgYWN0aW9uczogYWN0aW9ucywgcHJvcHM6IHByb3BzIH0pO1xuXG4gICAgLy8gc2VsZWN0IGxhc3Qgc3RhdGUgY2hhbmdlIGFjdGlvblxuICAgIHZhciBhY3Rpb24gPSBhY3Rpb25zXG4gICAgICAuY29uY2F0KClcbiAgICAgIC5maWx0ZXIoZnVuY3Rpb24oYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiAvXkRJRF8vLnRlc3QoYWN0aW9uLnR5cGUpO1xuICAgICAgfSlcbiAgICAgIC5yZXZlcnNlKClcbiAgICAgIC5maW5kKGZ1bmN0aW9uKGFjdGlvbikge1xuICAgICAgICByZXR1cm4gU3R5bGVNYXBbYWN0aW9uLnR5cGVdO1xuICAgICAgfSk7XG5cbiAgICAvLyBhIG5ldyBhY3Rpb24gaGFwcGVuZWQsIGxldCdzIGdldCB0aGUgbWF0Y2hpbmcgc3R5bGVzXG4gICAgaWYgKGFjdGlvbikge1xuICAgICAgLy8gZGVmaW5lIG5ldyBhY3RpdmUgc3R5bGVzXG4gICAgICByb290LnJlZi5hY3RpdmVTdHlsZXMgPSBbXTtcblxuICAgICAgdmFyIHN0eWxlc1RvQXBwbHkgPSBTdHlsZU1hcFthY3Rpb24udHlwZV07XG4gICAgICBmb3JpbihEZWZhdWx0U3R5bGUsIGZ1bmN0aW9uKG5hbWUsIGRlZmF1bHRTdHlsZXMpIHtcbiAgICAgICAgLy8gZ2V0IHJlZmVyZW5jZSB0byBjb250cm9sXG4gICAgICAgIHZhciBjb250cm9sID0gcm9vdC5yZWZbbmFtZV07XG5cbiAgICAgICAgLy8gbG9vcCBvdmVyIGFsbCBzdHlsZXMgZm9yIHRoaXMgY29udHJvbFxuICAgICAgICBmb3JpbihkZWZhdWx0U3R5bGVzLCBmdW5jdGlvbihrZXksIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9XG4gICAgICAgICAgICBzdHlsZXNUb0FwcGx5W25hbWVdICYmXG4gICAgICAgICAgICB0eXBlb2Ygc3R5bGVzVG9BcHBseVtuYW1lXVtrZXldICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICA/IHN0eWxlc1RvQXBwbHlbbmFtZV1ba2V5XVxuICAgICAgICAgICAgICA6IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICByb290LnJlZi5hY3RpdmVTdHlsZXMucHVzaCh7XG4gICAgICAgICAgICBjb250cm9sOiBjb250cm9sLFxuICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBhcHBseSBhY3RpdmUgc3R5bGVzIHRvIGVsZW1lbnRcbiAgICByb290LnJlZi5hY3RpdmVTdHlsZXMuZm9yRWFjaChmdW5jdGlvbihfcmVmNCkge1xuICAgICAgdmFyIGNvbnRyb2wgPSBfcmVmNC5jb250cm9sLFxuICAgICAgICBrZXkgPSBfcmVmNC5rZXksXG4gICAgICAgIHZhbHVlID0gX3JlZjQudmFsdWU7XG4gICAgICBjb250cm9sW2tleV0gPSB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgPyB2YWx1ZShyb290KSA6IHZhbHVlO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciByb3V0ZSA9IGNyZWF0ZVJvdXRlKHtcbiAgICBESURfU0VUX0xBQkVMX0JVVFRPTl9BQk9SVF9JVEVNX1BST0NFU1NJTkc6IGZ1bmN0aW9uIERJRF9TRVRfTEFCRUxfQlVUVE9OX0FCT1JUX0lURU1fUFJPQ0VTU0lORyhcbiAgICAgIF9yZWY1XG4gICAgKSB7XG4gICAgICB2YXIgcm9vdCA9IF9yZWY1LnJvb3QsXG4gICAgICAgIGFjdGlvbiA9IF9yZWY1LmFjdGlvbjtcbiAgICAgIHJvb3QucmVmLmJ1dHRvbkFib3J0SXRlbVByb2Nlc3NpbmcubGFiZWwgPSBhY3Rpb24udmFsdWU7XG4gICAgfSxcbiAgICBESURfU0VUX0xBQkVMX0JVVFRPTl9BQk9SVF9JVEVNX0xPQUQ6IGZ1bmN0aW9uIERJRF9TRVRfTEFCRUxfQlVUVE9OX0FCT1JUX0lURU1fTE9BRChcbiAgICAgIF9yZWY2XG4gICAgKSB7XG4gICAgICB2YXIgcm9vdCA9IF9yZWY2LnJvb3QsXG4gICAgICAgIGFjdGlvbiA9IF9yZWY2LmFjdGlvbjtcbiAgICAgIHJvb3QucmVmLmJ1dHRvbkFib3J0SXRlbUxvYWQubGFiZWwgPSBhY3Rpb24udmFsdWU7XG4gICAgfSxcbiAgICBESURfU0VUX0xBQkVMX0JVVFRPTl9BQk9SVF9JVEVNX1JFTU9WQUw6IGZ1bmN0aW9uIERJRF9TRVRfTEFCRUxfQlVUVE9OX0FCT1JUX0lURU1fUkVNT1ZBTChcbiAgICAgIF9yZWY3XG4gICAgKSB7XG4gICAgICB2YXIgcm9vdCA9IF9yZWY3LnJvb3QsXG4gICAgICAgIGFjdGlvbiA9IF9yZWY3LmFjdGlvbjtcbiAgICAgIHJvb3QucmVmLmJ1dHRvbkFib3J0SXRlbVJlbW92YWwubGFiZWwgPSBhY3Rpb24udmFsdWU7XG4gICAgfSxcbiAgICBESURfUkVRVUVTVF9JVEVNX1BST0NFU1NJTkc6IGZ1bmN0aW9uIERJRF9SRVFVRVNUX0lURU1fUFJPQ0VTU0lORyhfcmVmOCkge1xuICAgICAgdmFyIHJvb3QgPSBfcmVmOC5yb290O1xuICAgICAgcm9vdC5yZWYucHJvY2Vzc1Byb2dyZXNzSW5kaWNhdG9yLnNwaW4gPSB0cnVlO1xuICAgICAgcm9vdC5yZWYucHJvY2Vzc1Byb2dyZXNzSW5kaWNhdG9yLnByb2dyZXNzID0gMDtcbiAgICB9LFxuICAgIERJRF9TVEFSVF9JVEVNX0xPQUQ6IGZ1bmN0aW9uIERJRF9TVEFSVF9JVEVNX0xPQUQoX3JlZjkpIHtcbiAgICAgIHZhciByb290ID0gX3JlZjkucm9vdDtcbiAgICAgIHJvb3QucmVmLmxvYWRQcm9ncmVzc0luZGljYXRvci5zcGluID0gdHJ1ZTtcbiAgICAgIHJvb3QucmVmLmxvYWRQcm9ncmVzc0luZGljYXRvci5wcm9ncmVzcyA9IDA7XG4gICAgfSxcbiAgICBESURfU1RBUlRfSVRFTV9SRU1PVkU6IGZ1bmN0aW9uIERJRF9TVEFSVF9JVEVNX1JFTU9WRShfcmVmMTApIHtcbiAgICAgIHZhciByb290ID0gX3JlZjEwLnJvb3Q7XG4gICAgICByb290LnJlZi5wcm9jZXNzUHJvZ3Jlc3NJbmRpY2F0b3Iuc3BpbiA9IHRydWU7XG4gICAgICByb290LnJlZi5wcm9jZXNzUHJvZ3Jlc3NJbmRpY2F0b3IucHJvZ3Jlc3MgPSAwO1xuICAgIH0sXG4gICAgRElEX1VQREFURV9JVEVNX0xPQURfUFJPR1JFU1M6IGZ1bmN0aW9uIERJRF9VUERBVEVfSVRFTV9MT0FEX1BST0dSRVNTKFxuICAgICAgX3JlZjExXG4gICAgKSB7XG4gICAgICB2YXIgcm9vdCA9IF9yZWYxMS5yb290LFxuICAgICAgICBhY3Rpb24gPSBfcmVmMTEuYWN0aW9uO1xuICAgICAgcm9vdC5yZWYubG9hZFByb2dyZXNzSW5kaWNhdG9yLnNwaW4gPSBmYWxzZTtcbiAgICAgIHJvb3QucmVmLmxvYWRQcm9ncmVzc0luZGljYXRvci5wcm9ncmVzcyA9IGFjdGlvbi5wcm9ncmVzcztcbiAgICB9LFxuICAgIERJRF9VUERBVEVfSVRFTV9QUk9DRVNTX1BST0dSRVNTOiBmdW5jdGlvbiBESURfVVBEQVRFX0lURU1fUFJPQ0VTU19QUk9HUkVTUyhcbiAgICAgIF9yZWYxMlxuICAgICkge1xuICAgICAgdmFyIHJvb3QgPSBfcmVmMTIucm9vdCxcbiAgICAgICAgYWN0aW9uID0gX3JlZjEyLmFjdGlvbjtcbiAgICAgIHJvb3QucmVmLnByb2Nlc3NQcm9ncmVzc0luZGljYXRvci5zcGluID0gZmFsc2U7XG4gICAgICByb290LnJlZi5wcm9jZXNzUHJvZ3Jlc3NJbmRpY2F0b3IucHJvZ3Jlc3MgPSBhY3Rpb24ucHJvZ3Jlc3M7XG4gICAgfVxuICB9KTtcblxuICB2YXIgZmlsZSA9IGNyZWF0ZVZpZXcoe1xuICAgIGNyZWF0ZTogY3JlYXRlJDQsXG4gICAgd3JpdGU6IHdyaXRlJDIsXG4gICAgZGlkQ3JlYXRlVmlldzogZnVuY3Rpb24gZGlkQ3JlYXRlVmlldyhyb290KSB7XG4gICAgICBhcHBseUZpbHRlcnMoJ0NSRUFURV9WSUVXJywgT2JqZWN0LmFzc2lnbih7fSwgcm9vdCwgeyB2aWV3OiByb290IH0pKTtcbiAgICB9LFxuICAgIG5hbWU6ICdmaWxlJ1xuICB9KTtcblxuICAvKipcbiAgICogQ3JlYXRlcyB0aGUgZmlsZSB2aWV3XG4gICAqL1xuICB2YXIgY3JlYXRlJDUgPSBmdW5jdGlvbiBjcmVhdGUoX3JlZikge1xuICAgIHZhciByb290ID0gX3JlZi5yb290LFxuICAgICAgcHJvcHMgPSBfcmVmLnByb3BzO1xuXG4gICAgLy8gZmlsZW5hbWVcbiAgICByb290LnJlZi5maWxlTmFtZSA9IGNyZWF0ZUVsZW1lbnQkMSgnbGVnZW5kJyk7XG4gICAgcm9vdC5hcHBlbmRDaGlsZChyb290LnJlZi5maWxlTmFtZSk7XG5cbiAgICAvLyBmaWxlIGFwcGVuZGVkXG4gICAgcm9vdC5yZWYuZmlsZSA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KFxuICAgICAgcm9vdC5jcmVhdGVDaGlsZFZpZXcoZmlsZSwgeyBpZDogcHJvcHMuaWQgfSlcbiAgICApO1xuXG4gICAgLy8gZGF0YSBoYXMgbW92ZWQgdG8gZGF0YS5qc1xuICAgIHJvb3QucmVmLmRhdGEgPSBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogRGF0YSBzdG9yYWdlXG4gICAqL1xuICB2YXIgZGlkTG9hZEl0ZW0gPSBmdW5jdGlvbiBkaWRMb2FkSXRlbShfcmVmMikge1xuICAgIHZhciByb290ID0gX3JlZjIucm9vdCxcbiAgICAgIHByb3BzID0gX3JlZjIucHJvcHM7XG4gICAgLy8gdXBkYXRlcyB0aGUgbGVnZW5kIG9mIHRoZSBmaWVsZHNldCBzbyBzY3JlZW5yZWFkZXJzIGNhbiBiZXR0ZXIgZ3JvdXAgYnV0dG9uc1xuICAgIHRleHQoXG4gICAgICByb290LnJlZi5maWxlTmFtZSxcbiAgICAgIGZvcm1hdEZpbGVuYW1lKHJvb3QucXVlcnkoJ0dFVF9JVEVNX05BTUUnLCBwcm9wcy5pZCkpXG4gICAgKTtcbiAgfTtcblxuICB2YXIgZmlsZVdyYXBwZXIgPSBjcmVhdGVWaWV3KHtcbiAgICBjcmVhdGU6IGNyZWF0ZSQ1LFxuICAgIGlnbm9yZVJlY3Q6IHRydWUsXG4gICAgd3JpdGU6IGNyZWF0ZVJvdXRlKHtcbiAgICAgIERJRF9MT0FEX0lURU06IGRpZExvYWRJdGVtXG4gICAgfSksXG5cbiAgICBkaWRDcmVhdGVWaWV3OiBmdW5jdGlvbiBkaWRDcmVhdGVWaWV3KHJvb3QpIHtcbiAgICAgIGFwcGx5RmlsdGVycygnQ1JFQVRFX1ZJRVcnLCBPYmplY3QuYXNzaWduKHt9LCByb290LCB7IHZpZXc6IHJvb3QgfSkpO1xuICAgIH0sXG4gICAgdGFnOiAnZmllbGRzZXQnLFxuICAgIG5hbWU6ICdmaWxlLXdyYXBwZXInXG4gIH0pO1xuXG4gIHZhciBQQU5FTF9TUFJJTkdfUFJPUFMgPSB7IHR5cGU6ICdzcHJpbmcnLCBkYW1waW5nOiAwLjYsIG1hc3M6IDcgfTtcblxuICB2YXIgY3JlYXRlJDYgPSBmdW5jdGlvbiBjcmVhdGUoX3JlZikge1xuICAgIHZhciByb290ID0gX3JlZi5yb290LFxuICAgICAgcHJvcHMgPSBfcmVmLnByb3BzO1xuICAgIFtcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ3RvcCdcbiAgICAgIH0sXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2NlbnRlcicsXG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgdHJhbnNsYXRlWTogbnVsbCxcbiAgICAgICAgICBzY2FsZVk6IG51bGxcbiAgICAgICAgfSxcblxuICAgICAgICBtaXhpbnM6IHtcbiAgICAgICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgICAgICBzY2FsZVk6IFBBTkVMX1NQUklOR19QUk9QU1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBzdHlsZXM6IFsndHJhbnNsYXRlWScsICdzY2FsZVknXVxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdib3R0b20nLFxuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIHRyYW5zbGF0ZVk6IG51bGxcbiAgICAgICAgfSxcblxuICAgICAgICBtaXhpbnM6IHtcbiAgICAgICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgICAgICB0cmFuc2xhdGVZOiBQQU5FTF9TUFJJTkdfUFJPUFNcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgc3R5bGVzOiBbJ3RyYW5zbGF0ZVknXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgXS5mb3JFYWNoKGZ1bmN0aW9uKHNlY3Rpb24pIHtcbiAgICAgIGNyZWF0ZVNlY3Rpb24ocm9vdCwgc2VjdGlvbiwgcHJvcHMubmFtZSk7XG4gICAgfSk7XG5cbiAgICByb290LmVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnZmlsZXBvbmQtLScgKyBwcm9wcy5uYW1lKTtcblxuICAgIHJvb3QucmVmLnNjYWxhYmxlID0gbnVsbDtcbiAgfTtcblxuICB2YXIgY3JlYXRlU2VjdGlvbiA9IGZ1bmN0aW9uIGNyZWF0ZVNlY3Rpb24ocm9vdCwgc2VjdGlvbiwgY2xhc3NOYW1lKSB7XG4gICAgdmFyIHZpZXdDb25zdHJ1Y3RvciA9IGNyZWF0ZVZpZXcoe1xuICAgICAgbmFtZTogJ3BhbmVsLScgKyBzZWN0aW9uLm5hbWUgKyAnIGZpbGVwb25kLS0nICsgY2xhc3NOYW1lLFxuICAgICAgbWl4aW5zOiBzZWN0aW9uLm1peGlucyxcbiAgICAgIGlnbm9yZVJlY3RVcGRhdGU6IHRydWVcbiAgICB9KTtcblxuICAgIHZhciB2aWV3ID0gcm9vdC5jcmVhdGVDaGlsZFZpZXcodmlld0NvbnN0cnVjdG9yLCBzZWN0aW9uLnByb3BzKTtcblxuICAgIHJvb3QucmVmW3NlY3Rpb24ubmFtZV0gPSByb290LmFwcGVuZENoaWxkVmlldyh2aWV3KTtcbiAgfTtcblxuICB2YXIgd3JpdGUkMyA9IGZ1bmN0aW9uIHdyaXRlKF9yZWYyKSB7XG4gICAgdmFyIHJvb3QgPSBfcmVmMi5yb290LFxuICAgICAgcHJvcHMgPSBfcmVmMi5wcm9wcztcblxuICAgIC8vIHVwZGF0ZSBzY2FsYWJsZSBzdGF0ZVxuICAgIGlmIChyb290LnJlZi5zY2FsYWJsZSA9PT0gbnVsbCB8fCBwcm9wcy5zY2FsYWJsZSAhPT0gcm9vdC5yZWYuc2NhbGFibGUpIHtcbiAgICAgIHJvb3QucmVmLnNjYWxhYmxlID0gaXNCb29sZWFuKHByb3BzLnNjYWxhYmxlKSA/IHByb3BzLnNjYWxhYmxlIDogdHJ1ZTtcbiAgICAgIHJvb3QuZWxlbWVudC5kYXRhc2V0LnNjYWxhYmxlID0gcm9vdC5yZWYuc2NhbGFibGU7XG4gICAgfVxuXG4gICAgLy8gbm8gaGVpZ2h0LCBjYW4ndCBzZXRcbiAgICBpZiAoIXByb3BzLmhlaWdodCkgcmV0dXJuO1xuXG4gICAgLy8gZ2V0IGNoaWxkIHJlY3RzXG4gICAgdmFyIHRvcFJlY3QgPSByb290LnJlZi50b3AucmVjdC5lbGVtZW50O1xuICAgIHZhciBib3R0b21SZWN0ID0gcm9vdC5yZWYuYm90dG9tLnJlY3QuZWxlbWVudDtcblxuICAgIC8vIG1ha2Ugc3VyZSBoZWlnaHQgbmV2ZXIgaXMgc21hbGxlciB0aGFuIGJvdHRvbSBhbmQgdG9wIHNlY2l0b24gaGVpZ2h0cyBjb21iaW5lZCAod2lsbCBwcm9iYWJseSBuZXZlciBoYXBwZW4sIGJ1dCB3aG8ga25vd3MpXG4gICAgdmFyIGhlaWdodCA9IE1hdGgubWF4KHRvcFJlY3QuaGVpZ2h0ICsgYm90dG9tUmVjdC5oZWlnaHQsIHByb3BzLmhlaWdodCk7XG5cbiAgICAvLyBvZmZzZXQgY2VudGVyIHBhcnRcbiAgICByb290LnJlZi5jZW50ZXIudHJhbnNsYXRlWSA9IHRvcFJlY3QuaGVpZ2h0O1xuXG4gICAgLy8gc2NhbGUgY2VudGVyIHBhcnRcbiAgICAvLyB1c2UgbWF0aCBjZWlsIHRvIHByZXZlbnQgdHJhbnNwYXJlbnQgbGluZXMgYmVjYXVzZSBvZiByb3VuZGluZyBlcnJvcnNcbiAgICByb290LnJlZi5jZW50ZXIuc2NhbGVZID1cbiAgICAgIChoZWlnaHQgLSB0b3BSZWN0LmhlaWdodCAtIGJvdHRvbVJlY3QuaGVpZ2h0KSAvIDEwMDtcblxuICAgIC8vIG9mZnNldCBib3R0b20gcGFydFxuICAgIHJvb3QucmVmLmJvdHRvbS50cmFuc2xhdGVZID0gaGVpZ2h0IC0gYm90dG9tUmVjdC5oZWlnaHQ7XG4gIH07XG5cbiAgdmFyIHBhbmVsID0gY3JlYXRlVmlldyh7XG4gICAgbmFtZTogJ3BhbmVsJyxcbiAgICByZWFkOiBmdW5jdGlvbiByZWFkKF9yZWYzKSB7XG4gICAgICB2YXIgcm9vdCA9IF9yZWYzLnJvb3QsXG4gICAgICAgIHByb3BzID0gX3JlZjMucHJvcHM7XG4gICAgICByZXR1cm4gKHByb3BzLmhlaWdodEN1cnJlbnQgPSByb290LnJlZi5ib3R0b20udHJhbnNsYXRlWSk7XG4gICAgfSxcbiAgICB3cml0ZTogd3JpdGUkMyxcbiAgICBjcmVhdGU6IGNyZWF0ZSQ2LFxuICAgIGlnbm9yZVJlY3Q6IHRydWUsXG4gICAgbWl4aW5zOiB7XG4gICAgICBhcGlzOiBbJ2hlaWdodCcsICdoZWlnaHRDdXJyZW50JywgJ3NjYWxhYmxlJ11cbiAgICB9XG4gIH0pO1xuXG4gIHZhciBjcmVhdGVEcmFnSGVscGVyID0gZnVuY3Rpb24gY3JlYXRlRHJhZ0hlbHBlcihpdGVtcykge1xuICAgIHZhciBpdGVtSWRzID0gaXRlbXMubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgIHJldHVybiBpdGVtLmlkO1xuICAgIH0pO1xuICAgIHZhciBwcmV2SW5kZXggPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNldEluZGV4OiBmdW5jdGlvbiBzZXRJbmRleChpbmRleCkge1xuICAgICAgICBwcmV2SW5kZXggPSBpbmRleDtcbiAgICAgIH0sXG4gICAgICBnZXRJbmRleDogZnVuY3Rpb24gZ2V0SW5kZXgoKSB7XG4gICAgICAgIHJldHVybiBwcmV2SW5kZXg7XG4gICAgICB9LFxuICAgICAgZ2V0SXRlbUluZGV4OiBmdW5jdGlvbiBnZXRJdGVtSW5kZXgoaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbUlkcy5pbmRleE9mKGl0ZW0uaWQpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgdmFyIElURU1fVFJBTlNMQVRFX1NQUklORyA9IHtcbiAgICB0eXBlOiAnc3ByaW5nJyxcbiAgICBzdGlmZm5lc3M6IDAuNzUsXG4gICAgZGFtcGluZzogMC40NSxcbiAgICBtYXNzOiAxMFxuICB9O1xuXG4gIHZhciBJVEVNX1NDQUxFX1NQUklORyA9ICdzcHJpbmcnO1xuXG4gIHZhciBTdGF0ZU1hcCA9IHtcbiAgICBESURfU1RBUlRfSVRFTV9MT0FEOiAnYnVzeScsXG4gICAgRElEX1VQREFURV9JVEVNX0xPQURfUFJPR1JFU1M6ICdsb2FkaW5nJyxcbiAgICBESURfVEhST1dfSVRFTV9JTlZBTElEOiAnbG9hZC1pbnZhbGlkJyxcbiAgICBESURfVEhST1dfSVRFTV9MT0FEX0VSUk9SOiAnbG9hZC1lcnJvcicsXG4gICAgRElEX0xPQURfSVRFTTogJ2lkbGUnLFxuICAgIERJRF9USFJPV19JVEVNX1JFTU9WRV9FUlJPUjogJ3JlbW92ZS1lcnJvcicsXG4gICAgRElEX1NUQVJUX0lURU1fUkVNT1ZFOiAnYnVzeScsXG4gICAgRElEX1NUQVJUX0lURU1fUFJPQ0VTU0lORzogJ2J1c3kgcHJvY2Vzc2luZycsXG4gICAgRElEX1JFUVVFU1RfSVRFTV9QUk9DRVNTSU5HOiAnYnVzeSBwcm9jZXNzaW5nJyxcbiAgICBESURfVVBEQVRFX0lURU1fUFJPQ0VTU19QUk9HUkVTUzogJ3Byb2Nlc3NpbmcnLFxuICAgIERJRF9DT01QTEVURV9JVEVNX1BST0NFU1NJTkc6ICdwcm9jZXNzaW5nLWNvbXBsZXRlJyxcbiAgICBESURfVEhST1dfSVRFTV9QUk9DRVNTSU5HX0VSUk9SOiAncHJvY2Vzc2luZy1lcnJvcicsXG4gICAgRElEX1RIUk9XX0lURU1fUFJPQ0VTU0lOR19SRVZFUlRfRVJST1I6ICdwcm9jZXNzaW5nLXJldmVydC1lcnJvcicsXG4gICAgRElEX0FCT1JUX0lURU1fUFJPQ0VTU0lORzogJ2NhbmNlbGxlZCcsXG4gICAgRElEX1JFVkVSVF9JVEVNX1BST0NFU1NJTkc6ICdpZGxlJ1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIHRoZSBmaWxlIHZpZXdcbiAgICovXG4gIHZhciBjcmVhdGUkNyA9IGZ1bmN0aW9uIGNyZWF0ZShfcmVmKSB7XG4gICAgdmFyIHJvb3QgPSBfcmVmLnJvb3QsXG4gICAgICBwcm9wcyA9IF9yZWYucHJvcHM7XG5cbiAgICAvLyBzZWxlY3RcbiAgICByb290LnJlZi5oYW5kbGVDbGljayA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHJldHVybiByb290LmRpc3BhdGNoKCdESURfQUNUSVZBVEVfSVRFTScsIHsgaWQ6IHByb3BzLmlkIH0pO1xuICAgIH07XG5cbiAgICAvLyBzZXQgaWRcbiAgICByb290LmVsZW1lbnQuaWQgPSAnZmlsZXBvbmQtLWl0ZW0tJyArIHByb3BzLmlkO1xuICAgIHJvb3QuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHJvb3QucmVmLmhhbmRsZUNsaWNrKTtcblxuICAgIC8vIGZpbGUgdmlld1xuICAgIHJvb3QucmVmLmNvbnRhaW5lciA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KFxuICAgICAgcm9vdC5jcmVhdGVDaGlsZFZpZXcoZmlsZVdyYXBwZXIsIHsgaWQ6IHByb3BzLmlkIH0pXG4gICAgKTtcblxuICAgIC8vIGZpbGUgcGFuZWxcbiAgICByb290LnJlZi5wYW5lbCA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KFxuICAgICAgcm9vdC5jcmVhdGVDaGlsZFZpZXcocGFuZWwsIHsgbmFtZTogJ2l0ZW0tcGFuZWwnIH0pXG4gICAgKTtcblxuICAgIC8vIGRlZmF1bHQgc3RhcnQgaGVpZ2h0XG4gICAgcm9vdC5yZWYucGFuZWwuaGVpZ2h0ID0gbnVsbDtcblxuICAgIC8vIGJ5IGRlZmF1bHQgbm90IG1hcmtlZCBmb3IgcmVtb3ZhbFxuICAgIHByb3BzLm1hcmtlZEZvclJlbW92YWwgPSBmYWxzZTtcblxuICAgIC8vIGlmIG5vdCBhbGxvd2VkIHRvIHJlb3JkZXIgZmlsZSBpdGVtcywgZXhpdCBoZXJlXG4gICAgaWYgKCFyb290LnF1ZXJ5KCdHRVRfQUxMT1dfUkVPUkRFUicpKSByZXR1cm47XG5cbiAgICAvLyBzZXQgdG8gaWRsZSBzbyBzaG93cyBncmFiIGN1cnNvclxuICAgIHJvb3QuZWxlbWVudC5kYXRhc2V0LmRyYWdTdGF0ZSA9ICdpZGxlJztcblxuICAgIHZhciBncmFiID0gZnVuY3Rpb24gZ3JhYihlKSB7XG4gICAgICBpZiAoIWUuaXNQcmltYXJ5KSByZXR1cm47XG5cbiAgICAgIHZhciByZW1vdmVkQWN0aXZhdGVMaXN0ZW5lciA9IGZhbHNlO1xuXG4gICAgICB2YXIgb3JpZ2luID0ge1xuICAgICAgICB4OiBlLnBhZ2VYLFxuICAgICAgICB5OiBlLnBhZ2VZXG4gICAgICB9O1xuXG4gICAgICBwcm9wcy5kcmFnT3JpZ2luID0ge1xuICAgICAgICB4OiByb290LnRyYW5zbGF0ZVgsXG4gICAgICAgIHk6IHJvb3QudHJhbnNsYXRlWVxuICAgICAgfTtcblxuICAgICAgcHJvcHMuZHJhZ0NlbnRlciA9IHtcbiAgICAgICAgeDogZS5vZmZzZXRYLFxuICAgICAgICB5OiBlLm9mZnNldFlcbiAgICAgIH07XG5cbiAgICAgIHZhciBkcmFnU3RhdGUgPSBjcmVhdGVEcmFnSGVscGVyKHJvb3QucXVlcnkoJ0dFVF9BQ1RJVkVfSVRFTVMnKSk7XG5cbiAgICAgIHJvb3QuZGlzcGF0Y2goJ0RJRF9HUkFCX0lURU0nLCB7IGlkOiBwcm9wcy5pZCwgZHJhZ1N0YXRlOiBkcmFnU3RhdGUgfSk7XG5cbiAgICAgIHZhciBkcmFnID0gZnVuY3Rpb24gZHJhZyhlKSB7XG4gICAgICAgIGlmICghZS5pc1ByaW1hcnkpIHJldHVybjtcblxuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgcHJvcHMuZHJhZ09mZnNldCA9IHtcbiAgICAgICAgICB4OiBlLnBhZ2VYIC0gb3JpZ2luLngsXG4gICAgICAgICAgeTogZS5wYWdlWSAtIG9yaWdpbi55XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gaWYgZHJhZ2dlZCBzdG9wIGxpc3RlbmluZyB0byBjbGlja3MsIHdpbGwgcmUtYWRkIHdoZW4gZG9uZSBkcmFnZ2luZ1xuICAgICAgICB2YXIgZGlzdCA9XG4gICAgICAgICAgcHJvcHMuZHJhZ09mZnNldC54ICogcHJvcHMuZHJhZ09mZnNldC54ICtcbiAgICAgICAgICBwcm9wcy5kcmFnT2Zmc2V0LnkgKiBwcm9wcy5kcmFnT2Zmc2V0Lnk7XG4gICAgICAgIGlmIChkaXN0ID4gMTYgJiYgIXJlbW92ZWRBY3RpdmF0ZUxpc3RlbmVyKSB7XG4gICAgICAgICAgcmVtb3ZlZEFjdGl2YXRlTGlzdGVuZXIgPSB0cnVlO1xuICAgICAgICAgIHJvb3QuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHJvb3QucmVmLmhhbmRsZUNsaWNrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJvb3QuZGlzcGF0Y2goJ0RJRF9EUkFHX0lURU0nLCB7IGlkOiBwcm9wcy5pZCwgZHJhZ1N0YXRlOiBkcmFnU3RhdGUgfSk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgZHJvcCA9IGZ1bmN0aW9uIGRyb3AoZSkge1xuICAgICAgICBpZiAoIWUuaXNQcmltYXJ5KSByZXR1cm47XG5cbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcm1vdmUnLCBkcmFnKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgZHJvcCk7XG5cbiAgICAgICAgcHJvcHMuZHJhZ09mZnNldCA9IHtcbiAgICAgICAgICB4OiBlLnBhZ2VYIC0gb3JpZ2luLngsXG4gICAgICAgICAgeTogZS5wYWdlWSAtIG9yaWdpbi55XG4gICAgICAgIH07XG5cbiAgICAgICAgcm9vdC5kaXNwYXRjaCgnRElEX0RST1BfSVRFTScsIHsgaWQ6IHByb3BzLmlkLCBkcmFnU3RhdGU6IGRyYWdTdGF0ZSB9KTtcblxuICAgICAgICAvLyBzdGFydCBsaXN0ZW5pbmcgdG8gY2xpY2tzIGFnYWluXG4gICAgICAgIGlmIChyZW1vdmVkQWN0aXZhdGVMaXN0ZW5lcikge1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gcm9vdC5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgcm9vdC5yZWYuaGFuZGxlQ2xpY2spO1xuICAgICAgICAgIH0sIDApO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIGRyYWcpO1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgZHJvcCk7XG4gICAgfTtcblxuICAgIHJvb3QuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVyZG93bicsIGdyYWIpO1xuICB9O1xuXG4gIHZhciByb3V0ZSQxID0gY3JlYXRlUm91dGUoe1xuICAgIERJRF9VUERBVEVfUEFORUxfSEVJR0hUOiBmdW5jdGlvbiBESURfVVBEQVRFX1BBTkVMX0hFSUdIVChfcmVmMikge1xuICAgICAgdmFyIHJvb3QgPSBfcmVmMi5yb290LFxuICAgICAgICBhY3Rpb24gPSBfcmVmMi5hY3Rpb247XG4gICAgICByb290LmhlaWdodCA9IGFjdGlvbi5oZWlnaHQ7XG4gICAgfVxuICB9KTtcblxuICB2YXIgd3JpdGUkNCA9IGNyZWF0ZVJvdXRlKFxuICAgIHtcbiAgICAgIERJRF9HUkFCX0lURU06IGZ1bmN0aW9uIERJRF9HUkFCX0lURU0oX3JlZjMpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmMy5yb290LFxuICAgICAgICAgIHByb3BzID0gX3JlZjMucHJvcHM7XG4gICAgICAgIHByb3BzLmRyYWdPcmlnaW4gPSB7XG4gICAgICAgICAgeDogcm9vdC50cmFuc2xhdGVYLFxuICAgICAgICAgIHk6IHJvb3QudHJhbnNsYXRlWVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIERJRF9EUkFHX0lURU06IGZ1bmN0aW9uIERJRF9EUkFHX0lURU0oX3JlZjQpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBfcmVmNC5yb290O1xuICAgICAgICByb290LmVsZW1lbnQuZGF0YXNldC5kcmFnU3RhdGUgPSAnZHJhZyc7XG4gICAgICB9LFxuICAgICAgRElEX0RST1BfSVRFTTogZnVuY3Rpb24gRElEX0RST1BfSVRFTShfcmVmNSkge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWY1LnJvb3QsXG4gICAgICAgICAgcHJvcHMgPSBfcmVmNS5wcm9wcztcbiAgICAgICAgcHJvcHMuZHJhZ09mZnNldCA9IG51bGw7XG4gICAgICAgIHByb3BzLmRyYWdPcmlnaW4gPSBudWxsO1xuICAgICAgICByb290LmVsZW1lbnQuZGF0YXNldC5kcmFnU3RhdGUgPSAnZHJvcCc7XG4gICAgICB9XG4gICAgfSxcbiAgICBmdW5jdGlvbihfcmVmNikge1xuICAgICAgdmFyIHJvb3QgPSBfcmVmNi5yb290LFxuICAgICAgICBhY3Rpb25zID0gX3JlZjYuYWN0aW9ucyxcbiAgICAgICAgcHJvcHMgPSBfcmVmNi5wcm9wcyxcbiAgICAgICAgc2hvdWxkT3B0aW1pemUgPSBfcmVmNi5zaG91bGRPcHRpbWl6ZTtcblxuICAgICAgaWYgKHJvb3QuZWxlbWVudC5kYXRhc2V0LmRyYWdTdGF0ZSA9PT0gJ2Ryb3AnKSB7XG4gICAgICAgIGlmIChyb290LnNjYWxlWCA8PSAxKSB7XG4gICAgICAgICAgcm9vdC5lbGVtZW50LmRhdGFzZXQuZHJhZ1N0YXRlID0gJ2lkbGUnO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHNlbGVjdCBsYXN0IHN0YXRlIGNoYW5nZSBhY3Rpb25cbiAgICAgIHZhciBhY3Rpb24gPSBhY3Rpb25zXG4gICAgICAgIC5jb25jYXQoKVxuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGFjdGlvbikge1xuICAgICAgICAgIHJldHVybiAvXkRJRF8vLnRlc3QoYWN0aW9uLnR5cGUpO1xuICAgICAgICB9KVxuICAgICAgICAucmV2ZXJzZSgpXG4gICAgICAgIC5maW5kKGZ1bmN0aW9uKGFjdGlvbikge1xuICAgICAgICAgIHJldHVybiBTdGF0ZU1hcFthY3Rpb24udHlwZV07XG4gICAgICAgIH0pO1xuXG4gICAgICAvLyBubyBuZWVkIHRvIHNldCBzYW1lIHN0YXRlIHR3aWNlXG4gICAgICBpZiAoYWN0aW9uICYmIGFjdGlvbi50eXBlICE9PSBwcm9wcy5jdXJyZW50U3RhdGUpIHtcbiAgICAgICAgLy8gc2V0IGN1cnJlbnQgc3RhdGVcbiAgICAgICAgcHJvcHMuY3VycmVudFN0YXRlID0gYWN0aW9uLnR5cGU7XG5cbiAgICAgICAgLy8gc2V0IHN0YXRlXG4gICAgICAgIHJvb3QuZWxlbWVudC5kYXRhc2V0LmZpbGVwb25kSXRlbVN0YXRlID1cbiAgICAgICAgICBTdGF0ZU1hcFtwcm9wcy5jdXJyZW50U3RhdGVdIHx8ICcnO1xuICAgICAgfVxuXG4gICAgICAvLyByb3V0ZSBhY3Rpb25zXG4gICAgICB2YXIgYXNwZWN0UmF0aW8gPVxuICAgICAgICByb290LnF1ZXJ5KCdHRVRfSVRFTV9QQU5FTF9BU1BFQ1RfUkFUSU8nKSB8fFxuICAgICAgICByb290LnF1ZXJ5KCdHRVRfUEFORUxfQVNQRUNUX1JBVElPJyk7XG4gICAgICBpZiAoIWFzcGVjdFJhdGlvKSB7XG4gICAgICAgIHJvdXRlJDEoeyByb290OiByb290LCBhY3Rpb25zOiBhY3Rpb25zLCBwcm9wczogcHJvcHMgfSk7XG4gICAgICAgIGlmICghcm9vdC5oZWlnaHQgJiYgcm9vdC5yZWYuY29udGFpbmVyLnJlY3QuZWxlbWVudC5oZWlnaHQgPiAwKSB7XG4gICAgICAgICAgcm9vdC5oZWlnaHQgPSByb290LnJlZi5jb250YWluZXIucmVjdC5lbGVtZW50LmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghc2hvdWxkT3B0aW1pemUpIHtcbiAgICAgICAgcm9vdC5oZWlnaHQgPSByb290LnJlY3QuZWxlbWVudC53aWR0aCAqIGFzcGVjdFJhdGlvO1xuICAgICAgfVxuXG4gICAgICAvLyBzeW5jIHBhbmVsIGhlaWdodCB3aXRoIGl0ZW0gaGVpZ2h0XG4gICAgICBpZiAoc2hvdWxkT3B0aW1pemUpIHtcbiAgICAgICAgcm9vdC5yZWYucGFuZWwuaGVpZ2h0ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcm9vdC5yZWYucGFuZWwuaGVpZ2h0ID0gcm9vdC5oZWlnaHQ7XG4gICAgfVxuICApO1xuXG4gIHZhciBpdGVtID0gY3JlYXRlVmlldyh7XG4gICAgY3JlYXRlOiBjcmVhdGUkNyxcbiAgICB3cml0ZTogd3JpdGUkNCxcbiAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KF9yZWY3KSB7XG4gICAgICB2YXIgcm9vdCA9IF9yZWY3LnJvb3QsXG4gICAgICAgIHByb3BzID0gX3JlZjcucHJvcHM7XG4gICAgICByb290LmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCByb290LnJlZi5oYW5kbGVDbGljayk7XG4gICAgICByb290LmRpc3BhdGNoKCdSRUxFQVNFX0lURU0nLCB7IHF1ZXJ5OiBwcm9wcy5pZCB9KTtcbiAgICB9LFxuICAgIHRhZzogJ2xpJyxcbiAgICBuYW1lOiAnaXRlbScsXG4gICAgbWl4aW5zOiB7XG4gICAgICBhcGlzOiBbXG4gICAgICAgICdpZCcsXG4gICAgICAgICdpbnRlcmFjdGlvbk1ldGhvZCcsXG4gICAgICAgICdtYXJrZWRGb3JSZW1vdmFsJyxcbiAgICAgICAgJ3NwYXduRGF0ZScsXG4gICAgICAgICdkcmFnQ2VudGVyJyxcbiAgICAgICAgJ2RyYWdPcmlnaW4nLFxuICAgICAgICAnZHJhZ09mZnNldCdcbiAgICAgIF0sXG4gICAgICBzdHlsZXM6IFtcbiAgICAgICAgJ3RyYW5zbGF0ZVgnLFxuICAgICAgICAndHJhbnNsYXRlWScsXG4gICAgICAgICdzY2FsZVgnLFxuICAgICAgICAnc2NhbGVZJyxcbiAgICAgICAgJ29wYWNpdHknLFxuICAgICAgICAnaGVpZ2h0J1xuICAgICAgXSxcblxuICAgICAgYW5pbWF0aW9uczoge1xuICAgICAgICBzY2FsZVg6IElURU1fU0NBTEVfU1BSSU5HLFxuICAgICAgICBzY2FsZVk6IElURU1fU0NBTEVfU1BSSU5HLFxuICAgICAgICB0cmFuc2xhdGVYOiBJVEVNX1RSQU5TTEFURV9TUFJJTkcsXG4gICAgICAgIHRyYW5zbGF0ZVk6IElURU1fVFJBTlNMQVRFX1NQUklORyxcbiAgICAgICAgb3BhY2l0eTogeyB0eXBlOiAndHdlZW4nLCBkdXJhdGlvbjogMTUwIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHZhciBnZXRJdGVtSW5kZXhCeVBvc2l0aW9uID0gZnVuY3Rpb24gZ2V0SXRlbUluZGV4QnlQb3NpdGlvbihcbiAgICB2aWV3LFxuICAgIGNoaWxkcmVuLFxuICAgIHBvc2l0aW9uSW5WaWV3XG4gICkge1xuICAgIGlmICghcG9zaXRpb25JblZpZXcpIHJldHVybjtcblxuICAgIHZhciBob3Jpem9udGFsU3BhY2UgPSB2aWV3LnJlY3QuZWxlbWVudC53aWR0aDtcbiAgICAvLyBjb25zdCBjaGlsZHJlbiA9IHZpZXcuY2hpbGRWaWV3cztcbiAgICB2YXIgbCA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICB2YXIgbGFzdCA9IG51bGw7XG5cbiAgICAvLyAtMSwgZG9uJ3QgbW92ZSBpdGVtcyB0byBhY2NvbW9kYXRlIChlaXRoZXIgYWRkIHRvIHRvcCBvciBib3R0b20pXG4gICAgaWYgKGwgPT09IDAgfHwgcG9zaXRpb25JblZpZXcudG9wIDwgY2hpbGRyZW5bMF0ucmVjdC5lbGVtZW50LnRvcCkgcmV0dXJuIC0xO1xuXG4gICAgLy8gbGV0J3MgZ2V0IHRoZSBpdGVtIHdpZHRoXG4gICAgdmFyIGl0ZW0gPSBjaGlsZHJlblswXTtcbiAgICB2YXIgaXRlbVJlY3QgPSBpdGVtLnJlY3QuZWxlbWVudDtcbiAgICB2YXIgaXRlbUhvcml6b250YWxNYXJnaW4gPSBpdGVtUmVjdC5tYXJnaW5MZWZ0ICsgaXRlbVJlY3QubWFyZ2luUmlnaHQ7XG4gICAgdmFyIGl0ZW1XaWR0aCA9IGl0ZW1SZWN0LndpZHRoICsgaXRlbUhvcml6b250YWxNYXJnaW47XG4gICAgdmFyIGl0ZW1zUGVyUm93ID0gTWF0aC5yb3VuZChob3Jpem9udGFsU3BhY2UgLyBpdGVtV2lkdGgpO1xuXG4gICAgLy8gc3RhY2tcbiAgICBpZiAoaXRlbXNQZXJSb3cgPT09IDEpIHtcbiAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsOyBpbmRleCsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2luZGV4XTtcbiAgICAgICAgdmFyIGNoaWxkTWlkID0gY2hpbGQucmVjdC5vdXRlci50b3AgKyBjaGlsZC5yZWN0LmVsZW1lbnQuaGVpZ2h0ICogMC41O1xuICAgICAgICBpZiAocG9zaXRpb25JblZpZXcudG9wIDwgY2hpbGRNaWQpIHtcbiAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBsO1xuICAgIH1cblxuICAgIC8vIGdyaWRcbiAgICB2YXIgaXRlbVZlcnRpY2FsTWFyZ2luID0gaXRlbVJlY3QubWFyZ2luVG9wICsgaXRlbVJlY3QubWFyZ2luQm90dG9tO1xuICAgIHZhciBpdGVtSGVpZ2h0ID0gaXRlbVJlY3QuaGVpZ2h0ICsgaXRlbVZlcnRpY2FsTWFyZ2luO1xuICAgIGZvciAodmFyIF9pbmRleCA9IDA7IF9pbmRleCA8IGw7IF9pbmRleCsrKSB7XG4gICAgICB2YXIgaW5kZXhYID0gX2luZGV4ICUgaXRlbXNQZXJSb3c7XG4gICAgICB2YXIgaW5kZXhZID0gTWF0aC5mbG9vcihfaW5kZXggLyBpdGVtc1BlclJvdyk7XG5cbiAgICAgIHZhciBvZmZzZXRYID0gaW5kZXhYICogaXRlbVdpZHRoO1xuICAgICAgdmFyIG9mZnNldFkgPSBpbmRleFkgKiBpdGVtSGVpZ2h0O1xuXG4gICAgICB2YXIgaXRlbVRvcCA9IG9mZnNldFkgLSBpdGVtUmVjdC5tYXJnaW5Ub3A7XG4gICAgICB2YXIgaXRlbVJpZ2h0ID0gb2Zmc2V0WCArIGl0ZW1XaWR0aDtcbiAgICAgIHZhciBpdGVtQm90dG9tID0gb2Zmc2V0WSArIGl0ZW1IZWlnaHQgKyBpdGVtUmVjdC5tYXJnaW5Cb3R0b207XG5cbiAgICAgIGlmIChwb3NpdGlvbkluVmlldy50b3AgPCBpdGVtQm90dG9tICYmIHBvc2l0aW9uSW5WaWV3LnRvcCA+IGl0ZW1Ub3ApIHtcbiAgICAgICAgaWYgKHBvc2l0aW9uSW5WaWV3LmxlZnQgPCBpdGVtUmlnaHQpIHtcbiAgICAgICAgICByZXR1cm4gX2luZGV4O1xuICAgICAgICB9IGVsc2UgaWYgKF9pbmRleCAhPT0gbCAtIDEpIHtcbiAgICAgICAgICBsYXN0ID0gX2luZGV4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxhc3QgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGxhc3QgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBsYXN0O1xuICAgIH1cblxuICAgIHJldHVybiBsO1xuICB9O1xuXG4gIHZhciBkcm9wQXJlYURpbWVuc2lvbnMgPSB7XG4gICAgaGVpZ2h0OiAwLFxuICAgIHdpZHRoOiAwLFxuICAgIGdldCBnZXRIZWlnaHQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5oZWlnaHQ7XG4gICAgfSxcbiAgICBzZXQgc2V0SGVpZ2h0KHZhbCkge1xuICAgICAgaWYgKHRoaXMuaGVpZ2h0ID09PSAwIHx8IHZhbCA9PT0gMCkgdGhpcy5oZWlnaHQgPSB2YWw7XG4gICAgfSxcbiAgICBnZXQgZ2V0V2lkdGgoKSB7XG4gICAgICByZXR1cm4gdGhpcy53aWR0aDtcbiAgICB9LFxuICAgIHNldCBzZXRXaWR0aCh2YWwpIHtcbiAgICAgIGlmICh0aGlzLndpZHRoID09PSAwIHx8IHZhbCA9PT0gMCkgdGhpcy53aWR0aCA9IHZhbDtcbiAgICB9LFxuICAgIHNldERpbWVuc2lvbnM6IGZ1bmN0aW9uIHNldERpbWVuc2lvbnMoaGVpZ2h0LCB3aWR0aCkge1xuICAgICAgaWYgKHRoaXMuaGVpZ2h0ID09PSAwIHx8IGhlaWdodCA9PT0gMCkgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICBpZiAodGhpcy53aWR0aCA9PT0gMCB8fCB3aWR0aCA9PT0gMCkgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIH1cbiAgfTtcblxuICB2YXIgY3JlYXRlJDggPSBmdW5jdGlvbiBjcmVhdGUoX3JlZikge1xuICAgIHZhciByb290ID0gX3JlZi5yb290O1xuICAgIC8vIG5lZWQgdG8gc2V0IHJvbGUgdG8gbGlzdCBhcyBvdGhlcndpc2UgaXQgd29uJ3QgYmUgcmVhZCBhcyBhIGxpc3QgYnkgVm9pY2VPdmVyXG4gICAgYXR0cihyb290LmVsZW1lbnQsICdyb2xlJywgJ2xpc3QnKTtcblxuICAgIHJvb3QucmVmLmxhc3RJdGVtU3BhbndEYXRlID0gRGF0ZS5ub3coKTtcbiAgfTtcblxuICAvKipcbiAgICogSW5zZXJ0cyBhIG5ldyBpdGVtXG4gICAqIEBwYXJhbSByb290XG4gICAqIEBwYXJhbSBhY3Rpb25cbiAgICovXG4gIHZhciBhZGRJdGVtVmlldyA9IGZ1bmN0aW9uIGFkZEl0ZW1WaWV3KF9yZWYyKSB7XG4gICAgdmFyIHJvb3QgPSBfcmVmMi5yb290LFxuICAgICAgYWN0aW9uID0gX3JlZjIuYWN0aW9uO1xuICAgIHZhciBpZCA9IGFjdGlvbi5pZCxcbiAgICAgIGluZGV4ID0gYWN0aW9uLmluZGV4LFxuICAgICAgaW50ZXJhY3Rpb25NZXRob2QgPSBhY3Rpb24uaW50ZXJhY3Rpb25NZXRob2Q7XG5cbiAgICByb290LnJlZi5hZGRJbmRleCA9IGluZGV4O1xuXG4gICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gICAgdmFyIHNwYXduRGF0ZSA9IG5vdztcbiAgICB2YXIgb3BhY2l0eSA9IDE7XG5cbiAgICBpZiAoaW50ZXJhY3Rpb25NZXRob2QgIT09IEludGVyYWN0aW9uTWV0aG9kLk5PTkUpIHtcbiAgICAgIG9wYWNpdHkgPSAwO1xuICAgICAgdmFyIGNvb2xkb3duID0gcm9vdC5xdWVyeSgnR0VUX0lURU1fSU5TRVJUX0lOVEVSVkFMJyk7XG4gICAgICB2YXIgZGlzdCA9IG5vdyAtIHJvb3QucmVmLmxhc3RJdGVtU3BhbndEYXRlO1xuICAgICAgc3Bhd25EYXRlID0gZGlzdCA8IGNvb2xkb3duID8gbm93ICsgKGNvb2xkb3duIC0gZGlzdCkgOiBub3c7XG4gICAgfVxuXG4gICAgcm9vdC5yZWYubGFzdEl0ZW1TcGFud0RhdGUgPSBzcGF3bkRhdGU7XG5cbiAgICByb290LmFwcGVuZENoaWxkVmlldyhcbiAgICAgIHJvb3QuY3JlYXRlQ2hpbGRWaWV3KFxuICAgICAgICAvLyB2aWV3IHR5cGVcbiAgICAgICAgaXRlbSxcblxuICAgICAgICAvLyBwcm9wc1xuICAgICAgICB7XG4gICAgICAgICAgc3Bhd25EYXRlOiBzcGF3bkRhdGUsXG4gICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgIG9wYWNpdHk6IG9wYWNpdHksXG4gICAgICAgICAgaW50ZXJhY3Rpb25NZXRob2Q6IGludGVyYWN0aW9uTWV0aG9kXG4gICAgICAgIH1cbiAgICAgICksXG5cbiAgICAgIGluZGV4XG4gICAgKTtcbiAgfTtcblxuICB2YXIgbW92ZUl0ZW0gPSBmdW5jdGlvbiBtb3ZlSXRlbShpdGVtLCB4LCB5KSB7XG4gICAgdmFyIHZ4ID1cbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogMDtcbiAgICB2YXIgdnkgPVxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiAxO1xuXG4gICAgLy8gc2V0IHRvIG51bGwgdG8gcmVtb3ZlIGFuaW1hdGlvbiB3aGlsZSBkcmFnZ2luZ1xuICAgIGlmIChpdGVtLmRyYWdPZmZzZXQpIHtcbiAgICAgIGl0ZW0udHJhbnNsYXRlWCA9IG51bGw7XG4gICAgICBpdGVtLnRyYW5zbGF0ZVkgPSBudWxsO1xuICAgICAgaXRlbS50cmFuc2xhdGVYID0gaXRlbS5kcmFnT3JpZ2luLnggKyBpdGVtLmRyYWdPZmZzZXQueDtcbiAgICAgIGl0ZW0udHJhbnNsYXRlWSA9IGl0ZW0uZHJhZ09yaWdpbi55ICsgaXRlbS5kcmFnT2Zmc2V0Lnk7XG4gICAgICBpdGVtLnNjYWxlWCA9IDEuMDI1O1xuICAgICAgaXRlbS5zY2FsZVkgPSAxLjAyNTtcbiAgICB9IGVsc2Uge1xuICAgICAgaXRlbS50cmFuc2xhdGVYID0geDtcbiAgICAgIGl0ZW0udHJhbnNsYXRlWSA9IHk7XG5cbiAgICAgIGlmIChEYXRlLm5vdygpID4gaXRlbS5zcGF3bkRhdGUpIHtcbiAgICAgICAgLy8gcmV2ZWFsIGVsZW1lbnRcbiAgICAgICAgaWYgKGl0ZW0ub3BhY2l0eSA9PT0gMCkge1xuICAgICAgICAgIGludHJvSXRlbVZpZXcoaXRlbSwgeCwgeSwgdngsIHZ5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG1ha2Ugc3VyZSBpcyBkZWZhdWx0IHNjYWxlIGV2ZXJ5IGZyYW1lXG4gICAgICAgIGl0ZW0uc2NhbGVYID0gMTtcbiAgICAgICAgaXRlbS5zY2FsZVkgPSAxO1xuICAgICAgICBpdGVtLm9wYWNpdHkgPSAxO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgaW50cm9JdGVtVmlldyA9IGZ1bmN0aW9uIGludHJvSXRlbVZpZXcoaXRlbSwgeCwgeSwgdngsIHZ5KSB7XG4gICAgaWYgKGl0ZW0uaW50ZXJhY3Rpb25NZXRob2QgPT09IEludGVyYWN0aW9uTWV0aG9kLk5PTkUpIHtcbiAgICAgIGl0ZW0udHJhbnNsYXRlWCA9IG51bGw7XG4gICAgICBpdGVtLnRyYW5zbGF0ZVggPSB4O1xuICAgICAgaXRlbS50cmFuc2xhdGVZID0gbnVsbDtcbiAgICAgIGl0ZW0udHJhbnNsYXRlWSA9IHk7XG4gICAgfSBlbHNlIGlmIChpdGVtLmludGVyYWN0aW9uTWV0aG9kID09PSBJbnRlcmFjdGlvbk1ldGhvZC5EUk9QKSB7XG4gICAgICBpdGVtLnRyYW5zbGF0ZVggPSBudWxsO1xuICAgICAgaXRlbS50cmFuc2xhdGVYID0geCAtIHZ4ICogMjA7XG5cbiAgICAgIGl0ZW0udHJhbnNsYXRlWSA9IG51bGw7XG4gICAgICBpdGVtLnRyYW5zbGF0ZVkgPSB5IC0gdnkgKiAxMDtcblxuICAgICAgaXRlbS5zY2FsZVggPSAwLjg7XG4gICAgICBpdGVtLnNjYWxlWSA9IDAuODtcbiAgICB9IGVsc2UgaWYgKGl0ZW0uaW50ZXJhY3Rpb25NZXRob2QgPT09IEludGVyYWN0aW9uTWV0aG9kLkJST1dTRSkge1xuICAgICAgaXRlbS50cmFuc2xhdGVZID0gbnVsbDtcbiAgICAgIGl0ZW0udHJhbnNsYXRlWSA9IHkgLSAzMDtcbiAgICB9IGVsc2UgaWYgKGl0ZW0uaW50ZXJhY3Rpb25NZXRob2QgPT09IEludGVyYWN0aW9uTWV0aG9kLkFQSSkge1xuICAgICAgaXRlbS50cmFuc2xhdGVYID0gbnVsbDtcbiAgICAgIGl0ZW0udHJhbnNsYXRlWCA9IHggLSAzMDtcbiAgICAgIGl0ZW0udHJhbnNsYXRlWSA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFuIGV4aXN0aW5nIGl0ZW1cbiAgICogQHBhcmFtIHJvb3RcbiAgICogQHBhcmFtIGFjdGlvblxuICAgKi9cbiAgdmFyIHJlbW92ZUl0ZW1WaWV3ID0gZnVuY3Rpb24gcmVtb3ZlSXRlbVZpZXcoX3JlZjMpIHtcbiAgICB2YXIgcm9vdCA9IF9yZWYzLnJvb3QsXG4gICAgICBhY3Rpb24gPSBfcmVmMy5hY3Rpb247XG4gICAgdmFyIGlkID0gYWN0aW9uLmlkO1xuXG4gICAgLy8gZ2V0IHRoZSB2aWV3IG1hdGNoaW5nIHRoZSBnaXZlbiBpZFxuICAgIHZhciB2aWV3ID0gcm9vdC5jaGlsZFZpZXdzLmZpbmQoZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgIHJldHVybiBjaGlsZC5pZCA9PT0gaWQ7XG4gICAgfSk7XG5cbiAgICAvLyBpZiBubyB2aWV3IGZvdW5kLCBleGl0XG4gICAgaWYgKCF2aWV3KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYW5pbWF0ZSB2aWV3IG91dCBvZiB2aWV3XG4gICAgdmlldy5zY2FsZVggPSAwLjk7XG4gICAgdmlldy5zY2FsZVkgPSAwLjk7XG4gICAgdmlldy5vcGFjaXR5ID0gMDtcblxuICAgIC8vIG1hcmsgZm9yIHJlbW92YWxcbiAgICB2aWV3Lm1hcmtlZEZvclJlbW92YWwgPSB0cnVlO1xuICB9O1xuXG4gIHZhciBnZXRJdGVtSGVpZ2h0ID0gZnVuY3Rpb24gZ2V0SXRlbUhlaWdodChjaGlsZCkge1xuICAgIHJldHVybiAoXG4gICAgICBjaGlsZC5yZWN0LmVsZW1lbnQuaGVpZ2h0ICtcbiAgICAgIGNoaWxkLnJlY3QuZWxlbWVudC5tYXJnaW5Cb3R0b20gKiAwLjUgK1xuICAgICAgY2hpbGQucmVjdC5lbGVtZW50Lm1hcmdpblRvcCAqIDAuNVxuICAgICk7XG4gIH07XG4gIHZhciBnZXRJdGVtV2lkdGggPSBmdW5jdGlvbiBnZXRJdGVtV2lkdGgoY2hpbGQpIHtcbiAgICByZXR1cm4gKFxuICAgICAgY2hpbGQucmVjdC5lbGVtZW50LndpZHRoICtcbiAgICAgIGNoaWxkLnJlY3QuZWxlbWVudC5tYXJnaW5MZWZ0ICogMC41ICtcbiAgICAgIGNoaWxkLnJlY3QuZWxlbWVudC5tYXJnaW5SaWdodCAqIDAuNVxuICAgICk7XG4gIH07XG5cbiAgdmFyIGRyYWdJdGVtID0gZnVuY3Rpb24gZHJhZ0l0ZW0oX3JlZjQpIHtcbiAgICB2YXIgcm9vdCA9IF9yZWY0LnJvb3QsXG4gICAgICBhY3Rpb24gPSBfcmVmNC5hY3Rpb247XG4gICAgdmFyIGlkID0gYWN0aW9uLmlkLFxuICAgICAgZHJhZ1N0YXRlID0gYWN0aW9uLmRyYWdTdGF0ZTtcblxuICAgIC8vIHJlZmVyZW5jZSB0byBpdGVtXG4gICAgdmFyIGl0ZW0gPSByb290LnF1ZXJ5KCdHRVRfSVRFTScsIHsgaWQ6IGlkIH0pO1xuXG4gICAgLy8gZ2V0IHRoZSB2aWV3IG1hdGNoaW5nIHRoZSBnaXZlbiBpZFxuICAgIHZhciB2aWV3ID0gcm9vdC5jaGlsZFZpZXdzLmZpbmQoZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgIHJldHVybiBjaGlsZC5pZCA9PT0gaWQ7XG4gICAgfSk7XG5cbiAgICB2YXIgbnVtSXRlbXMgPSByb290LmNoaWxkVmlld3MubGVuZ3RoO1xuICAgIHZhciBvbGRJbmRleCA9IGRyYWdTdGF0ZS5nZXRJdGVtSW5kZXgoaXRlbSk7XG5cbiAgICAvLyBpZiBubyB2aWV3IGZvdW5kLCBleGl0XG4gICAgaWYgKCF2aWV3KSByZXR1cm47XG5cbiAgICB2YXIgZHJhZ1Bvc2l0aW9uID0ge1xuICAgICAgeDogdmlldy5kcmFnT3JpZ2luLnggKyB2aWV3LmRyYWdPZmZzZXQueCArIHZpZXcuZHJhZ0NlbnRlci54LFxuICAgICAgeTogdmlldy5kcmFnT3JpZ2luLnkgKyB2aWV3LmRyYWdPZmZzZXQueSArIHZpZXcuZHJhZ0NlbnRlci55XG5cbiAgICAgIC8vIGdldCBkcmFnIGFyZWEgZGltZW5zaW9uc1xuICAgIH07XG4gICAgdmFyIGRyYWdIZWlnaHQgPSBnZXRJdGVtSGVpZ2h0KHZpZXcpO1xuICAgIHZhciBkcmFnV2lkdGggPSBnZXRJdGVtV2lkdGgodmlldyk7XG5cbiAgICAvLyBnZXQgcm93cyBhbmQgY29sdW1ucyAoVGhlcmUgd2lsbCBhbHdheXMgYmUgYXQgbGVhc3Qgb25lIHJvdyBhbmQgb25lIGNvbHVtbiBpZiBhIGZpbGUgaXMgcHJlc2VudClcbiAgICB2YXIgY29scyA9IE1hdGguZmxvb3Iocm9vdC5yZWN0Lm91dGVyLndpZHRoIC8gZHJhZ1dpZHRoKTtcbiAgICBpZiAoY29scyA+IG51bUl0ZW1zKSBjb2xzID0gbnVtSXRlbXM7XG5cbiAgICAvLyByb3dzIGFyZSB1c2VkIHRvIGZpbmQgd2hlbiB3ZSBoYXZlIGxlZnQgdGhlIHByZXZpZXcgYXJlYSBib3VuZGluZyBib3hcbiAgICB2YXIgcm93cyA9IE1hdGguZmxvb3IobnVtSXRlbXMgLyBjb2xzICsgMSk7XG5cbiAgICBkcm9wQXJlYURpbWVuc2lvbnMuc2V0SGVpZ2h0ID0gZHJhZ0hlaWdodCAqIHJvd3M7XG4gICAgZHJvcEFyZWFEaW1lbnNpb25zLnNldFdpZHRoID0gZHJhZ1dpZHRoICogY29scztcblxuICAgIC8vIGdldCBuZXcgaW5kZXggb2YgZHJhZ2dlZCBpdGVtXG4gICAgdmFyIGxvY2F0aW9uID0ge1xuICAgICAgeTogTWF0aC5mbG9vcihkcmFnUG9zaXRpb24ueSAvIGRyYWdIZWlnaHQpLFxuICAgICAgeDogTWF0aC5mbG9vcihkcmFnUG9zaXRpb24ueCAvIGRyYWdXaWR0aCksXG4gICAgICBnZXRHcmlkSW5kZXg6IGZ1bmN0aW9uIGdldEdyaWRJbmRleCgpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGRyYWdQb3NpdGlvbi55ID4gZHJvcEFyZWFEaW1lbnNpb25zLmdldEhlaWdodCB8fFxuICAgICAgICAgIGRyYWdQb3NpdGlvbi55IDwgMCB8fFxuICAgICAgICAgIGRyYWdQb3NpdGlvbi54ID4gZHJvcEFyZWFEaW1lbnNpb25zLmdldFdpZHRoIHx8XG4gICAgICAgICAgZHJhZ1Bvc2l0aW9uLnggPCAwXG4gICAgICAgIClcbiAgICAgICAgICByZXR1cm4gb2xkSW5kZXg7XG4gICAgICAgIHJldHVybiB0aGlzLnkgKiBjb2xzICsgdGhpcy54O1xuICAgICAgfSxcbiAgICAgIGdldENvbEluZGV4OiBmdW5jdGlvbiBnZXRDb2xJbmRleCgpIHtcbiAgICAgICAgdmFyIGl0ZW1zID0gcm9vdC5xdWVyeSgnR0VUX0FDVElWRV9JVEVNUycpO1xuICAgICAgICB2YXIgdmlzaWJsZUNoaWxkcmVuID0gcm9vdC5jaGlsZFZpZXdzLmZpbHRlcihmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgIHJldHVybiBjaGlsZC5yZWN0LmVsZW1lbnQuaGVpZ2h0O1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gaXRlbXMubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICByZXR1cm4gdmlzaWJsZUNoaWxkcmVuLmZpbmQoZnVuY3Rpb24oY2hpbGRWaWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGRWaWV3LmlkID09PSBpdGVtLmlkO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGN1cnJlbnRJbmRleCA9IGNoaWxkcmVuLmZpbmRJbmRleChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgIHJldHVybiBjaGlsZCA9PT0gdmlldztcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBkcmFnSGVpZ2h0ID0gZ2V0SXRlbUhlaWdodCh2aWV3KTtcbiAgICAgICAgdmFyIGwgPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgIHZhciBpZHggPSBsO1xuICAgICAgICB2YXIgY2hpbGRIZWlnaHQgPSAwO1xuICAgICAgICB2YXIgY2hpbGRCb3R0b20gPSAwO1xuICAgICAgICB2YXIgY2hpbGRUb3AgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGNoaWxkSGVpZ2h0ID0gZ2V0SXRlbUhlaWdodChjaGlsZHJlbltpXSk7XG4gICAgICAgICAgY2hpbGRUb3AgPSBjaGlsZEJvdHRvbTtcbiAgICAgICAgICBjaGlsZEJvdHRvbSA9IGNoaWxkVG9wICsgY2hpbGRIZWlnaHQ7XG4gICAgICAgICAgaWYgKGRyYWdQb3NpdGlvbi55IDwgY2hpbGRCb3R0b20pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50SW5kZXggPiBpKSB7XG4gICAgICAgICAgICAgIGlmIChkcmFnUG9zaXRpb24ueSA8IGNoaWxkVG9wICsgZHJhZ0hlaWdodCkge1xuICAgICAgICAgICAgICAgIGlkeCA9IGk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZHggPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpZHg7XG4gICAgICB9XG5cbiAgICAgIC8vIGdldCBuZXcgaW5kZXhcbiAgICB9O1xuICAgIHZhciBpbmRleCA9IGNvbHMgPiAxID8gbG9jYXRpb24uZ2V0R3JpZEluZGV4KCkgOiBsb2NhdGlvbi5nZXRDb2xJbmRleCgpO1xuICAgIHJvb3QuZGlzcGF0Y2goJ01PVkVfSVRFTScsIHsgcXVlcnk6IHZpZXcsIGluZGV4OiBpbmRleCB9KTtcblxuICAgIC8vIGlmIHRoZSBpbmRleCBvZiB0aGUgaXRlbSBjaGFuZ2VkLCBkaXNwYXRjaCByZW9yZGVyIGFjdGlvblxuICAgIHZhciBjdXJyZW50SW5kZXggPSBkcmFnU3RhdGUuZ2V0SW5kZXgoKTtcblxuICAgIGlmIChjdXJyZW50SW5kZXggPT09IHVuZGVmaW5lZCB8fCBjdXJyZW50SW5kZXggIT09IGluZGV4KSB7XG4gICAgICBkcmFnU3RhdGUuc2V0SW5kZXgoaW5kZXgpO1xuXG4gICAgICBpZiAoY3VycmVudEluZGV4ID09PSB1bmRlZmluZWQpIHJldHVybjtcblxuICAgICAgcm9vdC5kaXNwYXRjaCgnRElEX1JFT1JERVJfSVRFTVMnLCB7XG4gICAgICAgIGl0ZW1zOiByb290LnF1ZXJ5KCdHRVRfQUNUSVZFX0lURU1TJyksXG4gICAgICAgIG9yaWdpbjogb2xkSW5kZXgsXG4gICAgICAgIHRhcmdldDogaW5kZXhcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2V0dXAgYWN0aW9uIHJvdXRlc1xuICAgKi9cbiAgdmFyIHJvdXRlJDIgPSBjcmVhdGVSb3V0ZSh7XG4gICAgRElEX0FERF9JVEVNOiBhZGRJdGVtVmlldyxcbiAgICBESURfUkVNT1ZFX0lURU06IHJlbW92ZUl0ZW1WaWV3LFxuICAgIERJRF9EUkFHX0lURU06IGRyYWdJdGVtXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBXcml0ZSB0byB2aWV3XG4gICAqIEBwYXJhbSByb290XG4gICAqIEBwYXJhbSBhY3Rpb25zXG4gICAqIEBwYXJhbSBwcm9wc1xuICAgKi9cbiAgdmFyIHdyaXRlJDUgPSBmdW5jdGlvbiB3cml0ZShfcmVmNSkge1xuICAgIHZhciByb290ID0gX3JlZjUucm9vdCxcbiAgICAgIHByb3BzID0gX3JlZjUucHJvcHMsXG4gICAgICBhY3Rpb25zID0gX3JlZjUuYWN0aW9ucyxcbiAgICAgIHNob3VsZE9wdGltaXplID0gX3JlZjUuc2hvdWxkT3B0aW1pemU7XG5cbiAgICAvLyByb3V0ZSBhY3Rpb25zXG4gICAgcm91dGUkMih7IHJvb3Q6IHJvb3QsIHByb3BzOiBwcm9wcywgYWN0aW9uczogYWN0aW9ucyB9KTtcbiAgICB2YXIgZHJhZ0Nvb3JkaW5hdGVzID0gcHJvcHMuZHJhZ0Nvb3JkaW5hdGVzO1xuXG4gICAgLy8gYXZhaWxhYmxlIHNwYWNlIG9uIGhvcml6b250YWwgYXhpc1xuICAgIHZhciBob3Jpem9udGFsU3BhY2UgPSByb290LnJlY3QuZWxlbWVudC53aWR0aDtcblxuICAgIC8vIG9ubHkgZHJhdyBjaGlsZHJlbiB0aGF0IGhhdmUgZGltZW5zaW9uc1xuICAgIHZhciB2aXNpYmxlQ2hpbGRyZW4gPSByb290LmNoaWxkVmlld3MuZmlsdGVyKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICByZXR1cm4gY2hpbGQucmVjdC5lbGVtZW50LmhlaWdodDtcbiAgICB9KTtcblxuICAgIC8vIHNvcnQgYmFzZWQgb24gY3VycmVudCBhY3RpdmUgaXRlbXNcbiAgICB2YXIgY2hpbGRyZW4gPSByb290XG4gICAgICAucXVlcnkoJ0dFVF9BQ1RJVkVfSVRFTVMnKVxuICAgICAgLm1hcChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIHJldHVybiB2aXNpYmxlQ2hpbGRyZW4uZmluZChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgIHJldHVybiBjaGlsZC5pZCA9PT0gaXRlbS5pZDtcbiAgICAgICAgfSk7XG4gICAgICB9KVxuICAgICAgLmZpbHRlcihmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgfSk7XG5cbiAgICAvLyBnZXQgaW5kZXhcbiAgICB2YXIgZHJhZ0luZGV4ID0gZHJhZ0Nvb3JkaW5hdGVzXG4gICAgICA/IGdldEl0ZW1JbmRleEJ5UG9zaXRpb24ocm9vdCwgY2hpbGRyZW4sIGRyYWdDb29yZGluYXRlcylcbiAgICAgIDogbnVsbDtcblxuICAgIC8vIGFkZCBpbmRleCBpcyB1c2VkIHRvIHJlc2VydmUgdGhlIGRyb3BwZWQvYWRkZWQgaXRlbSBpbmRleCB0aWxsIHRoZSBhY3R1YWwgaXRlbSBpcyByZW5kZXJlZFxuICAgIHZhciBhZGRJbmRleCA9IHJvb3QucmVmLmFkZEluZGV4IHx8IG51bGw7XG5cbiAgICAvLyBhZGQgaW5kZXggbm8gbG9uZ2VyIG5lZWRlZCB0aWxsIHBvc3NpYmx5IG5leHQgZHJhd1xuICAgIHJvb3QucmVmLmFkZEluZGV4ID0gbnVsbDtcblxuICAgIHZhciBkcmFnSW5kZXhPZmZzZXQgPSAwO1xuICAgIHZhciByZW1vdmVJbmRleE9mZnNldCA9IDA7XG4gICAgdmFyIGFkZEluZGV4T2Zmc2V0ID0gMDtcblxuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDApIHJldHVybjtcblxuICAgIHZhciBjaGlsZFJlY3QgPSBjaGlsZHJlblswXS5yZWN0LmVsZW1lbnQ7XG4gICAgdmFyIGl0ZW1WZXJ0aWNhbE1hcmdpbiA9IGNoaWxkUmVjdC5tYXJnaW5Ub3AgKyBjaGlsZFJlY3QubWFyZ2luQm90dG9tO1xuICAgIHZhciBpdGVtSG9yaXpvbnRhbE1hcmdpbiA9IGNoaWxkUmVjdC5tYXJnaW5MZWZ0ICsgY2hpbGRSZWN0Lm1hcmdpblJpZ2h0O1xuICAgIHZhciBpdGVtV2lkdGggPSBjaGlsZFJlY3Qud2lkdGggKyBpdGVtSG9yaXpvbnRhbE1hcmdpbjtcbiAgICB2YXIgaXRlbUhlaWdodCA9IGNoaWxkUmVjdC5oZWlnaHQgKyBpdGVtVmVydGljYWxNYXJnaW47XG4gICAgdmFyIGl0ZW1zUGVyUm93ID0gTWF0aC5yb3VuZChob3Jpem9udGFsU3BhY2UgLyBpdGVtV2lkdGgpO1xuXG4gICAgLy8gc3RhY2tcbiAgICBpZiAoaXRlbXNQZXJSb3cgPT09IDEpIHtcbiAgICAgIHZhciBvZmZzZXRZID0gMDtcbiAgICAgIHZhciBkcmFnT2Zmc2V0ID0gMDtcblxuICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihjaGlsZCwgaW5kZXgpIHtcbiAgICAgICAgaWYgKGRyYWdJbmRleCkge1xuICAgICAgICAgIHZhciBkaXN0ID0gaW5kZXggLSBkcmFnSW5kZXg7XG4gICAgICAgICAgaWYgKGRpc3QgPT09IC0yKSB7XG4gICAgICAgICAgICBkcmFnT2Zmc2V0ID0gLWl0ZW1WZXJ0aWNhbE1hcmdpbiAqIDAuMjU7XG4gICAgICAgICAgfSBlbHNlIGlmIChkaXN0ID09PSAtMSkge1xuICAgICAgICAgICAgZHJhZ09mZnNldCA9IC1pdGVtVmVydGljYWxNYXJnaW4gKiAwLjc1O1xuICAgICAgICAgIH0gZWxzZSBpZiAoZGlzdCA9PT0gMCkge1xuICAgICAgICAgICAgZHJhZ09mZnNldCA9IGl0ZW1WZXJ0aWNhbE1hcmdpbiAqIDAuNzU7XG4gICAgICAgICAgfSBlbHNlIGlmIChkaXN0ID09PSAxKSB7XG4gICAgICAgICAgICBkcmFnT2Zmc2V0ID0gaXRlbVZlcnRpY2FsTWFyZ2luICogMC4yNTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZHJhZ09mZnNldCA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNob3VsZE9wdGltaXplKSB7XG4gICAgICAgICAgY2hpbGQudHJhbnNsYXRlWCA9IG51bGw7XG4gICAgICAgICAgY2hpbGQudHJhbnNsYXRlWSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNoaWxkLm1hcmtlZEZvclJlbW92YWwpIHtcbiAgICAgICAgICBtb3ZlSXRlbShjaGlsZCwgMCwgb2Zmc2V0WSArIGRyYWdPZmZzZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGl0ZW1IZWlnaHQgPSBjaGlsZC5yZWN0LmVsZW1lbnQuaGVpZ2h0ICsgaXRlbVZlcnRpY2FsTWFyZ2luO1xuXG4gICAgICAgIHZhciB2aXN1YWxIZWlnaHQgPVxuICAgICAgICAgIGl0ZW1IZWlnaHQgKiAoY2hpbGQubWFya2VkRm9yUmVtb3ZhbCA/IGNoaWxkLm9wYWNpdHkgOiAxKTtcblxuICAgICAgICBvZmZzZXRZICs9IHZpc3VhbEhlaWdodDtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBncmlkXG4gICAgZWxzZSB7XG4gICAgICB2YXIgcHJldlggPSAwO1xuICAgICAgdmFyIHByZXZZID0gMDtcblxuICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihjaGlsZCwgaW5kZXgpIHtcbiAgICAgICAgaWYgKGluZGV4ID09PSBkcmFnSW5kZXgpIHtcbiAgICAgICAgICBkcmFnSW5kZXhPZmZzZXQgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluZGV4ID09PSBhZGRJbmRleCkge1xuICAgICAgICAgIGFkZEluZGV4T2Zmc2V0ICs9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2hpbGQubWFya2VkRm9yUmVtb3ZhbCAmJiBjaGlsZC5vcGFjaXR5IDwgMC41KSB7XG4gICAgICAgICAgcmVtb3ZlSW5kZXhPZmZzZXQgLT0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2aXN1YWxJbmRleCA9XG4gICAgICAgICAgaW5kZXggKyBhZGRJbmRleE9mZnNldCArIGRyYWdJbmRleE9mZnNldCArIHJlbW92ZUluZGV4T2Zmc2V0O1xuXG4gICAgICAgIHZhciBpbmRleFggPSB2aXN1YWxJbmRleCAlIGl0ZW1zUGVyUm93O1xuICAgICAgICB2YXIgaW5kZXhZID0gTWF0aC5mbG9vcih2aXN1YWxJbmRleCAvIGl0ZW1zUGVyUm93KTtcblxuICAgICAgICB2YXIgb2Zmc2V0WCA9IGluZGV4WCAqIGl0ZW1XaWR0aDtcbiAgICAgICAgdmFyIG9mZnNldFkgPSBpbmRleFkgKiBpdGVtSGVpZ2h0O1xuXG4gICAgICAgIHZhciB2ZWN0b3JYID0gTWF0aC5zaWduKG9mZnNldFggLSBwcmV2WCk7XG4gICAgICAgIHZhciB2ZWN0b3JZID0gTWF0aC5zaWduKG9mZnNldFkgLSBwcmV2WSk7XG5cbiAgICAgICAgcHJldlggPSBvZmZzZXRYO1xuICAgICAgICBwcmV2WSA9IG9mZnNldFk7XG5cbiAgICAgICAgaWYgKGNoaWxkLm1hcmtlZEZvclJlbW92YWwpIHJldHVybjtcblxuICAgICAgICBpZiAoc2hvdWxkT3B0aW1pemUpIHtcbiAgICAgICAgICBjaGlsZC50cmFuc2xhdGVYID0gbnVsbDtcbiAgICAgICAgICBjaGlsZC50cmFuc2xhdGVZID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIG1vdmVJdGVtKGNoaWxkLCBvZmZzZXRYLCBvZmZzZXRZLCB2ZWN0b3JYLCB2ZWN0b3JZKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRmlsdGVycyBhY3Rpb25zIHRoYXQgYXJlIG1lYW50IHNwZWNpZmljYWxseSBmb3IgYSBjZXJ0YWluIGNoaWxkIG9mIHRoZSBsaXN0XG4gICAqIEBwYXJhbSBjaGlsZFxuICAgKiBAcGFyYW0gYWN0aW9uc1xuICAgKi9cbiAgdmFyIGZpbHRlclNldEl0ZW1BY3Rpb25zID0gZnVuY3Rpb24gZmlsdGVyU2V0SXRlbUFjdGlvbnMoY2hpbGQsIGFjdGlvbnMpIHtcbiAgICByZXR1cm4gYWN0aW9ucy5maWx0ZXIoZnVuY3Rpb24oYWN0aW9uKSB7XG4gICAgICAvLyBpZiBhY3Rpb24gaGFzIGFuIGlkLCBmaWx0ZXIgb3V0IGFjdGlvbnMgdGhhdCBkb24ndCBoYXZlIHRoaXMgY2hpbGQgaWRcbiAgICAgIGlmIChhY3Rpb24uZGF0YSAmJiBhY3Rpb24uZGF0YS5pZCkge1xuICAgICAgICByZXR1cm4gY2hpbGQuaWQgPT09IGFjdGlvbi5kYXRhLmlkO1xuICAgICAgfVxuXG4gICAgICAvLyBhbGxvdyBhbGwgb3RoZXIgYWN0aW9uc1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGxpc3QgPSBjcmVhdGVWaWV3KHtcbiAgICBjcmVhdGU6IGNyZWF0ZSQ4LFxuICAgIHdyaXRlOiB3cml0ZSQ1LFxuICAgIHRhZzogJ3VsJyxcbiAgICBuYW1lOiAnbGlzdCcsXG4gICAgZGlkV3JpdGVWaWV3OiBmdW5jdGlvbiBkaWRXcml0ZVZpZXcoX3JlZjYpIHtcbiAgICAgIHZhciByb290ID0gX3JlZjYucm9vdDtcbiAgICAgIHJvb3QuY2hpbGRWaWV3c1xuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKHZpZXcpIHtcbiAgICAgICAgICByZXR1cm4gdmlldy5tYXJrZWRGb3JSZW1vdmFsICYmIHZpZXcub3BhY2l0eSA9PT0gMCAmJiB2aWV3LnJlc3Rpbmc7XG4gICAgICAgIH0pXG4gICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uKHZpZXcpIHtcbiAgICAgICAgICB2aWV3Ll9kZXN0cm95KCk7XG4gICAgICAgICAgcm9vdC5yZW1vdmVDaGlsZFZpZXcodmlldyk7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgZmlsdGVyRnJhbWVBY3Rpb25zRm9yQ2hpbGQ6IGZpbHRlclNldEl0ZW1BY3Rpb25zLFxuICAgIG1peGluczoge1xuICAgICAgYXBpczogWydkcmFnQ29vcmRpbmF0ZXMnXVxuICAgIH1cbiAgfSk7XG5cbiAgdmFyIGNyZWF0ZSQ5ID0gZnVuY3Rpb24gY3JlYXRlKF9yZWYpIHtcbiAgICB2YXIgcm9vdCA9IF9yZWYucm9vdCxcbiAgICAgIHByb3BzID0gX3JlZi5wcm9wcztcbiAgICByb290LnJlZi5saXN0ID0gcm9vdC5hcHBlbmRDaGlsZFZpZXcocm9vdC5jcmVhdGVDaGlsZFZpZXcobGlzdCkpO1xuICAgIHByb3BzLmRyYWdDb29yZGluYXRlcyA9IG51bGw7XG4gICAgcHJvcHMub3ZlcmZsb3dpbmcgPSBmYWxzZTtcbiAgfTtcblxuICB2YXIgc3RvcmVEcmFnQ29vcmRpbmF0ZXMgPSBmdW5jdGlvbiBzdG9yZURyYWdDb29yZGluYXRlcyhfcmVmMikge1xuICAgIHZhciByb290ID0gX3JlZjIucm9vdCxcbiAgICAgIHByb3BzID0gX3JlZjIucHJvcHMsXG4gICAgICBhY3Rpb24gPSBfcmVmMi5hY3Rpb247XG4gICAgaWYgKCFyb290LnF1ZXJ5KCdHRVRfSVRFTV9JTlNFUlRfTE9DQVRJT05fRlJFRURPTScpKSByZXR1cm47XG4gICAgcHJvcHMuZHJhZ0Nvb3JkaW5hdGVzID0ge1xuICAgICAgbGVmdDogYWN0aW9uLnBvc2l0aW9uLnNjb3BlTGVmdCAtIHJvb3QucmVmLmxpc3QucmVjdC5lbGVtZW50LmxlZnQsXG4gICAgICB0b3A6XG4gICAgICAgIGFjdGlvbi5wb3NpdGlvbi5zY29wZVRvcCAtXG4gICAgICAgIChyb290LnJlY3Qub3V0ZXIudG9wICtcbiAgICAgICAgICByb290LnJlY3QuZWxlbWVudC5tYXJnaW5Ub3AgK1xuICAgICAgICAgIHJvb3QucmVjdC5lbGVtZW50LnNjcm9sbFRvcClcbiAgICB9O1xuICB9O1xuXG4gIHZhciBjbGVhckRyYWdDb29yZGluYXRlcyA9IGZ1bmN0aW9uIGNsZWFyRHJhZ0Nvb3JkaW5hdGVzKF9yZWYzKSB7XG4gICAgdmFyIHByb3BzID0gX3JlZjMucHJvcHM7XG4gICAgcHJvcHMuZHJhZ0Nvb3JkaW5hdGVzID0gbnVsbDtcbiAgfTtcblxuICB2YXIgcm91dGUkMyA9IGNyZWF0ZVJvdXRlKHtcbiAgICBESURfRFJBRzogc3RvcmVEcmFnQ29vcmRpbmF0ZXMsXG4gICAgRElEX0VORF9EUkFHOiBjbGVhckRyYWdDb29yZGluYXRlc1xuICB9KTtcblxuICB2YXIgd3JpdGUkNiA9IGZ1bmN0aW9uIHdyaXRlKF9yZWY0KSB7XG4gICAgdmFyIHJvb3QgPSBfcmVmNC5yb290LFxuICAgICAgcHJvcHMgPSBfcmVmNC5wcm9wcyxcbiAgICAgIGFjdGlvbnMgPSBfcmVmNC5hY3Rpb25zO1xuXG4gICAgLy8gcm91dGUgYWN0aW9uc1xuICAgIHJvdXRlJDMoeyByb290OiByb290LCBwcm9wczogcHJvcHMsIGFjdGlvbnM6IGFjdGlvbnMgfSk7XG5cbiAgICAvLyBjdXJyZW50IGRyYWcgcG9zaXRpb25cbiAgICByb290LnJlZi5saXN0LmRyYWdDb29yZGluYXRlcyA9IHByb3BzLmRyYWdDb29yZGluYXRlcztcblxuICAgIC8vIGlmIGN1cnJlbnRseSBvdmVyZmxvd2luZyBidXQgbm8gbG9uZ2VyIHJlY2VpdmVkIG92ZXJmbG93XG4gICAgaWYgKHByb3BzLm92ZXJmbG93aW5nICYmICFwcm9wcy5vdmVyZmxvdykge1xuICAgICAgcHJvcHMub3ZlcmZsb3dpbmcgPSBmYWxzZTtcblxuICAgICAgLy8gcmVzZXQgb3ZlcmZsb3cgc3RhdGVcbiAgICAgIHJvb3QuZWxlbWVudC5kYXRhc2V0LnN0YXRlID0gJyc7XG4gICAgICByb290LmhlaWdodCA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gaWYgaXMgbm90IG92ZXJmbG93aW5nIGN1cnJlbnRseSBidXQgZG9lcyByZWNlaXZlIG92ZXJmbG93IHZhbHVlXG4gICAgaWYgKHByb3BzLm92ZXJmbG93KSB7XG4gICAgICB2YXIgbmV3SGVpZ2h0ID0gTWF0aC5yb3VuZChwcm9wcy5vdmVyZmxvdyk7XG4gICAgICBpZiAobmV3SGVpZ2h0ICE9PSByb290LmhlaWdodCkge1xuICAgICAgICBwcm9wcy5vdmVyZmxvd2luZyA9IHRydWU7XG4gICAgICAgIHJvb3QuZWxlbWVudC5kYXRhc2V0LnN0YXRlID0gJ292ZXJmbG93JztcbiAgICAgICAgcm9vdC5oZWlnaHQgPSBuZXdIZWlnaHQ7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBsaXN0U2Nyb2xsZXIgPSBjcmVhdGVWaWV3KHtcbiAgICBjcmVhdGU6IGNyZWF0ZSQ5LFxuICAgIHdyaXRlOiB3cml0ZSQ2LFxuICAgIG5hbWU6ICdsaXN0LXNjcm9sbGVyJyxcbiAgICBtaXhpbnM6IHtcbiAgICAgIGFwaXM6IFsnb3ZlcmZsb3cnLCAnZHJhZ0Nvb3JkaW5hdGVzJ10sXG4gICAgICBzdHlsZXM6IFsnaGVpZ2h0JywgJ3RyYW5zbGF0ZVknXSxcbiAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgdHJhbnNsYXRlWTogJ3NwcmluZydcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHZhciBhdHRyVG9nZ2xlID0gZnVuY3Rpb24gYXR0clRvZ2dsZShlbGVtZW50LCBuYW1lLCBzdGF0ZSkge1xuICAgIHZhciBlbmFibGVkVmFsdWUgPVxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAnJztcbiAgICBpZiAoc3RhdGUpIHtcbiAgICAgIGF0dHIoZWxlbWVudCwgbmFtZSwgZW5hYmxlZFZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciByZXNldEZpbGVJbnB1dCA9IGZ1bmN0aW9uIHJlc2V0RmlsZUlucHV0KGlucHV0KSB7XG4gICAgLy8gbm8gdmFsdWUsIG5vIG5lZWQgdG8gcmVzZXRcbiAgICBpZiAoIWlucHV0IHx8IGlucHV0LnZhbHVlID09PSAnJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAvLyBmb3IgbW9kZXJuIGJyb3dzZXJzXG4gICAgICBpbnB1dC52YWx1ZSA9ICcnO1xuICAgIH0gY2F0Y2ggKGVycikge31cblxuICAgIC8vIGZvciBJRTEwXG4gICAgaWYgKGlucHV0LnZhbHVlKSB7XG4gICAgICAvLyBxdWlja2x5IGFwcGVuZCBpbnB1dCB0byB0ZW1wIGZvcm0gYW5kIHJlc2V0IGZvcm1cbiAgICAgIHZhciBmb3JtID0gY3JlYXRlRWxlbWVudCQxKCdmb3JtJyk7XG4gICAgICB2YXIgcGFyZW50Tm9kZSA9IGlucHV0LnBhcmVudE5vZGU7XG4gICAgICB2YXIgcmVmID0gaW5wdXQubmV4dFNpYmxpbmc7XG4gICAgICBmb3JtLmFwcGVuZENoaWxkKGlucHV0KTtcbiAgICAgIGZvcm0ucmVzZXQoKTtcblxuICAgICAgLy8gcmUtaW5qZWN0IGlucHV0IHdoZXJlIGl0IG9yaWdpbmFsbHkgd2FzXG4gICAgICBpZiAocmVmKSB7XG4gICAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGlucHV0LCByZWYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyZW50Tm9kZS5hcHBlbmRDaGlsZChpbnB1dCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBjcmVhdGUkYSA9IGZ1bmN0aW9uIGNyZWF0ZShfcmVmKSB7XG4gICAgdmFyIHJvb3QgPSBfcmVmLnJvb3QsXG4gICAgICBwcm9wcyA9IF9yZWYucHJvcHM7XG5cbiAgICAvLyBzZXQgaWQgc28gY2FuIGJlIHJlZmVyZW5jZWQgZnJvbSBvdXRzaWRlIGxhYmVsc1xuICAgIHJvb3QuZWxlbWVudC5pZCA9ICdmaWxlcG9uZC0tYnJvd3Nlci0nICsgcHJvcHMuaWQ7XG5cbiAgICAvLyBzZXQgbmFtZSBvZiBlbGVtZW50IChpcyByZW1vdmVkIHdoZW4gYSB2YWx1ZSBpcyBzZXQpXG4gICAgYXR0cihyb290LmVsZW1lbnQsICduYW1lJywgcm9vdC5xdWVyeSgnR0VUX05BTUUnKSk7XG5cbiAgICAvLyB3ZSBoYXZlIHRvIGxpbmsgdGhpcyBlbGVtZW50IHRvIHRoZSBzdGF0dXMgZWxlbWVudFxuICAgIGF0dHIocm9vdC5lbGVtZW50LCAnYXJpYS1jb250cm9scycsICdmaWxlcG9uZC0tYXNzaXN0YW50LScgKyBwcm9wcy5pZCk7XG5cbiAgICAvLyBzZXQgbGFiZWwsIHdlIHVzZSBsYWJlbGxlZCBieSBhcyBvdGhlcndpc2UgdGhlIHNjcmVlbnJlYWRlciBkb2VzIG5vdCByZWFkIHRoZSBcImJyb3dzZVwiIHRleHQgaW4gdGhlIGxhYmVsIChhcyBpdCBoYXMgdGFiaW5kZXg6IDApXG4gICAgYXR0cihyb290LmVsZW1lbnQsICdhcmlhLWxhYmVsbGVkYnknLCAnZmlsZXBvbmQtLWRyb3AtbGFiZWwtJyArIHByb3BzLmlkKTtcblxuICAgIC8vIHNldCBjb25maWd1cmFibGUgcHJvcHNcbiAgICBzZXRBY2NlcHRlZEZpbGVUeXBlcyh7XG4gICAgICByb290OiByb290LFxuICAgICAgYWN0aW9uOiB7IHZhbHVlOiByb290LnF1ZXJ5KCdHRVRfQUNDRVBURURfRklMRV9UWVBFUycpIH1cbiAgICB9KTtcbiAgICB0b2dnbGVBbGxvd011bHRpcGxlKHtcbiAgICAgIHJvb3Q6IHJvb3QsXG4gICAgICBhY3Rpb246IHsgdmFsdWU6IHJvb3QucXVlcnkoJ0dFVF9BTExPV19NVUxUSVBMRScpIH1cbiAgICB9KTtcbiAgICB0b2dnbGVEaXJlY3RvcnlGaWx0ZXIoe1xuICAgICAgcm9vdDogcm9vdCxcbiAgICAgIGFjdGlvbjogeyB2YWx1ZTogcm9vdC5xdWVyeSgnR0VUX0FMTE9XX0RJUkVDVE9SSUVTX09OTFknKSB9XG4gICAgfSk7XG4gICAgdG9nZ2xlRGlzYWJsZWQoeyByb290OiByb290IH0pO1xuICAgIHRvZ2dsZVJlcXVpcmVkKHtcbiAgICAgIHJvb3Q6IHJvb3QsXG4gICAgICBhY3Rpb246IHsgdmFsdWU6IHJvb3QucXVlcnkoJ0dFVF9SRVFVSVJFRCcpIH1cbiAgICB9KTtcbiAgICBzZXRDYXB0dXJlTWV0aG9kKHtcbiAgICAgIHJvb3Q6IHJvb3QsXG4gICAgICBhY3Rpb246IHsgdmFsdWU6IHJvb3QucXVlcnkoJ0dFVF9DQVBUVVJFX01FVEhPRCcpIH1cbiAgICB9KTtcblxuICAgIC8vIGhhbmRsZSBjaGFuZ2VzIHRvIHRoZSBpbnB1dCBmaWVsZFxuICAgIHJvb3QucmVmLmhhbmRsZUNoYW5nZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmICghcm9vdC5lbGVtZW50LnZhbHVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gZXh0cmFjdCBmaWxlcyBhbmQgbW92ZSB2YWx1ZSBvZiB3ZWJraXRSZWxhdGl2ZVBhdGggcGF0aCB0byBfcmVsYXRpdmVQYXRoXG4gICAgICB2YXIgZmlsZXMgPSBBcnJheS5mcm9tKHJvb3QuZWxlbWVudC5maWxlcykubWFwKGZ1bmN0aW9uKGZpbGUpIHtcbiAgICAgICAgZmlsZS5fcmVsYXRpdmVQYXRoID0gZmlsZS53ZWJraXRSZWxhdGl2ZVBhdGg7XG4gICAgICAgIHJldHVybiBmaWxlO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIHdlIGFkZCBhIGxpdHRsZSBkZWxheSBzbyB0aGUgT1MgZmlsZSBzZWxlY3Qgd2luZG93IGNhbiBtb3ZlIG91dCBvZiB0aGUgd2F5IGJlZm9yZSB3ZSBhZGQgb3VyIGZpbGVcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIGxvYWQgZmlsZXNcbiAgICAgICAgcHJvcHMub25sb2FkKGZpbGVzKTtcblxuICAgICAgICAvLyByZXNldCBpbnB1dCwgaXQncyBqdXN0IGZvciBleHBvc2luZyBhIG1ldGhvZCB0byBkcm9wIGZpbGVzLCBzaG91bGQgbm90IHJldGFpbiBhbnkgc3RhdGVcbiAgICAgICAgcmVzZXRGaWxlSW5wdXQocm9vdC5lbGVtZW50KTtcbiAgICAgIH0sIDI1MCk7XG4gICAgfTtcblxuICAgIHJvb3QuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCByb290LnJlZi5oYW5kbGVDaGFuZ2UpO1xuICB9O1xuXG4gIHZhciBzZXRBY2NlcHRlZEZpbGVUeXBlcyA9IGZ1bmN0aW9uIHNldEFjY2VwdGVkRmlsZVR5cGVzKF9yZWYyKSB7XG4gICAgdmFyIHJvb3QgPSBfcmVmMi5yb290LFxuICAgICAgYWN0aW9uID0gX3JlZjIuYWN0aW9uO1xuICAgIGlmICghcm9vdC5xdWVyeSgnR0VUX0FMTE9XX1NZTkNfQUNDRVBUX0FUVFJJQlVURScpKSByZXR1cm47XG4gICAgYXR0clRvZ2dsZShcbiAgICAgIHJvb3QuZWxlbWVudCxcbiAgICAgICdhY2NlcHQnLFxuICAgICAgISFhY3Rpb24udmFsdWUsXG4gICAgICBhY3Rpb24udmFsdWUgPyBhY3Rpb24udmFsdWUuam9pbignLCcpIDogJydcbiAgICApO1xuICB9O1xuXG4gIHZhciB0b2dnbGVBbGxvd011bHRpcGxlID0gZnVuY3Rpb24gdG9nZ2xlQWxsb3dNdWx0aXBsZShfcmVmMykge1xuICAgIHZhciByb290ID0gX3JlZjMucm9vdCxcbiAgICAgIGFjdGlvbiA9IF9yZWYzLmFjdGlvbjtcbiAgICBhdHRyVG9nZ2xlKHJvb3QuZWxlbWVudCwgJ211bHRpcGxlJywgYWN0aW9uLnZhbHVlKTtcbiAgfTtcblxuICB2YXIgdG9nZ2xlRGlyZWN0b3J5RmlsdGVyID0gZnVuY3Rpb24gdG9nZ2xlRGlyZWN0b3J5RmlsdGVyKF9yZWY0KSB7XG4gICAgdmFyIHJvb3QgPSBfcmVmNC5yb290LFxuICAgICAgYWN0aW9uID0gX3JlZjQuYWN0aW9uO1xuICAgIGF0dHJUb2dnbGUocm9vdC5lbGVtZW50LCAnd2Via2l0ZGlyZWN0b3J5JywgYWN0aW9uLnZhbHVlKTtcbiAgfTtcblxuICB2YXIgdG9nZ2xlRGlzYWJsZWQgPSBmdW5jdGlvbiB0b2dnbGVEaXNhYmxlZChfcmVmNSkge1xuICAgIHZhciByb290ID0gX3JlZjUucm9vdDtcbiAgICB2YXIgaXNEaXNhYmxlZCA9IHJvb3QucXVlcnkoJ0dFVF9ESVNBQkxFRCcpO1xuICAgIHZhciBkb2VzQWxsb3dCcm93c2UgPSByb290LnF1ZXJ5KCdHRVRfQUxMT1dfQlJPV1NFJyk7XG4gICAgdmFyIGRpc2FibGVGaWVsZCA9IGlzRGlzYWJsZWQgfHwgIWRvZXNBbGxvd0Jyb3dzZTtcbiAgICBhdHRyVG9nZ2xlKHJvb3QuZWxlbWVudCwgJ2Rpc2FibGVkJywgZGlzYWJsZUZpZWxkKTtcbiAgfTtcblxuICB2YXIgdG9nZ2xlUmVxdWlyZWQgPSBmdW5jdGlvbiB0b2dnbGVSZXF1aXJlZChfcmVmNikge1xuICAgIHZhciByb290ID0gX3JlZjYucm9vdCxcbiAgICAgIGFjdGlvbiA9IF9yZWY2LmFjdGlvbjtcbiAgICAvLyB3YW50IHRvIHJlbW92ZSByZXF1aXJlZCwgYWx3YXlzIHBvc3NpYmxlXG4gICAgaWYgKCFhY3Rpb24udmFsdWUpIHtcbiAgICAgIGF0dHJUb2dnbGUocm9vdC5lbGVtZW50LCAncmVxdWlyZWQnLCBmYWxzZSk7XG4gICAgfVxuICAgIC8vIGlmIHdhbnQgdG8gbWFrZSByZXF1aXJlZCwgb25seSBwb3NzaWJsZSB3aGVuIHplcm8gaXRlbXNcbiAgICBlbHNlIGlmIChyb290LnF1ZXJ5KCdHRVRfVE9UQUxfSVRFTVMnKSA9PT0gMCkge1xuICAgICAgYXR0clRvZ2dsZShyb290LmVsZW1lbnQsICdyZXF1aXJlZCcsIHRydWUpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgc2V0Q2FwdHVyZU1ldGhvZCA9IGZ1bmN0aW9uIHNldENhcHR1cmVNZXRob2QoX3JlZjcpIHtcbiAgICB2YXIgcm9vdCA9IF9yZWY3LnJvb3QsXG4gICAgICBhY3Rpb24gPSBfcmVmNy5hY3Rpb247XG4gICAgYXR0clRvZ2dsZShcbiAgICAgIHJvb3QuZWxlbWVudCxcbiAgICAgICdjYXB0dXJlJyxcbiAgICAgICEhYWN0aW9uLnZhbHVlLFxuICAgICAgYWN0aW9uLnZhbHVlID09PSB0cnVlID8gJycgOiBhY3Rpb24udmFsdWVcbiAgICApO1xuICB9O1xuXG4gIHZhciB1cGRhdGVSZXF1aXJlZFN0YXR1cyA9IGZ1bmN0aW9uIHVwZGF0ZVJlcXVpcmVkU3RhdHVzKF9yZWY4KSB7XG4gICAgdmFyIHJvb3QgPSBfcmVmOC5yb290O1xuICAgIHZhciBlbGVtZW50ID0gcm9vdC5lbGVtZW50O1xuICAgIC8vIGFsd2F5cyByZW1vdmUgdGhlIHJlcXVpcmVkIGF0dHJpYnV0ZSB3aGVuIG1vcmUgdGhhbiB6ZXJvIGl0ZW1zXG4gICAgaWYgKHJvb3QucXVlcnkoJ0dFVF9UT1RBTF9JVEVNUycpID4gMCkge1xuICAgICAgYXR0clRvZ2dsZShlbGVtZW50LCAncmVxdWlyZWQnLCBmYWxzZSk7XG4gICAgICBhdHRyVG9nZ2xlKGVsZW1lbnQsICduYW1lJywgZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhZGQgbmFtZSBhdHRyaWJ1dGVcbiAgICAgIGF0dHJUb2dnbGUoZWxlbWVudCwgJ25hbWUnLCB0cnVlLCByb290LnF1ZXJ5KCdHRVRfTkFNRScpKTtcblxuICAgICAgLy8gcmVtb3ZlIGFueSB2YWxpZGF0aW9uIG1lc3NhZ2VzXG4gICAgICB2YXIgc2hvdWxkQ2hlY2tWYWxpZGl0eSA9IHJvb3QucXVlcnkoJ0dFVF9DSEVDS19WQUxJRElUWScpO1xuICAgICAgaWYgKHNob3VsZENoZWNrVmFsaWRpdHkpIHtcbiAgICAgICAgZWxlbWVudC5zZXRDdXN0b21WYWxpZGl0eSgnJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIHdlIG9ubHkgYWRkIHJlcXVpcmVkIGlmIHRoZSBmaWVsZCBoYXMgYmVlbiBkZWVtZWQgcmVxdWlyZWRcbiAgICAgIGlmIChyb290LnF1ZXJ5KCdHRVRfUkVRVUlSRUQnKSkge1xuICAgICAgICBhdHRyVG9nZ2xlKGVsZW1lbnQsICdyZXF1aXJlZCcsIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgdXBkYXRlRmllbGRWYWxpZGl0eVN0YXR1cyA9IGZ1bmN0aW9uIHVwZGF0ZUZpZWxkVmFsaWRpdHlTdGF0dXMoX3JlZjkpIHtcbiAgICB2YXIgcm9vdCA9IF9yZWY5LnJvb3Q7XG4gICAgdmFyIHNob3VsZENoZWNrVmFsaWRpdHkgPSByb290LnF1ZXJ5KCdHRVRfQ0hFQ0tfVkFMSURJVFknKTtcbiAgICBpZiAoIXNob3VsZENoZWNrVmFsaWRpdHkpIHJldHVybjtcbiAgICByb290LmVsZW1lbnQuc2V0Q3VzdG9tVmFsaWRpdHkocm9vdC5xdWVyeSgnR0VUX0xBQkVMX0lOVkFMSURfRklFTEQnKSk7XG4gIH07XG5cbiAgdmFyIGJyb3dzZXIgPSBjcmVhdGVWaWV3KHtcbiAgICB0YWc6ICdpbnB1dCcsXG4gICAgbmFtZTogJ2Jyb3dzZXInLFxuICAgIGlnbm9yZVJlY3Q6IHRydWUsXG4gICAgaWdub3JlUmVjdFVwZGF0ZTogdHJ1ZSxcbiAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICB0eXBlOiAnZmlsZSdcbiAgICB9LFxuXG4gICAgY3JlYXRlOiBjcmVhdGUkYSxcbiAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KF9yZWYxMCkge1xuICAgICAgdmFyIHJvb3QgPSBfcmVmMTAucm9vdDtcbiAgICAgIHJvb3QuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCByb290LnJlZi5oYW5kbGVDaGFuZ2UpO1xuICAgIH0sXG4gICAgd3JpdGU6IGNyZWF0ZVJvdXRlKHtcbiAgICAgIERJRF9MT0FEX0lURU06IHVwZGF0ZVJlcXVpcmVkU3RhdHVzLFxuICAgICAgRElEX1JFTU9WRV9JVEVNOiB1cGRhdGVSZXF1aXJlZFN0YXR1cyxcbiAgICAgIERJRF9USFJPV19JVEVNX0lOVkFMSUQ6IHVwZGF0ZUZpZWxkVmFsaWRpdHlTdGF0dXMsXG5cbiAgICAgIERJRF9TRVRfRElTQUJMRUQ6IHRvZ2dsZURpc2FibGVkLFxuICAgICAgRElEX1NFVF9BTExPV19CUk9XU0U6IHRvZ2dsZURpc2FibGVkLFxuICAgICAgRElEX1NFVF9BTExPV19ESVJFQ1RPUklFU19PTkxZOiB0b2dnbGVEaXJlY3RvcnlGaWx0ZXIsXG4gICAgICBESURfU0VUX0FMTE9XX01VTFRJUExFOiB0b2dnbGVBbGxvd011bHRpcGxlLFxuICAgICAgRElEX1NFVF9BQ0NFUFRFRF9GSUxFX1RZUEVTOiBzZXRBY2NlcHRlZEZpbGVUeXBlcyxcbiAgICAgIERJRF9TRVRfQ0FQVFVSRV9NRVRIT0Q6IHNldENhcHR1cmVNZXRob2QsXG4gICAgICBESURfU0VUX1JFUVVJUkVEOiB0b2dnbGVSZXF1aXJlZFxuICAgIH0pXG4gIH0pO1xuXG4gIHZhciBLZXkgPSB7XG4gICAgRU5URVI6IDEzLFxuICAgIFNQQUNFOiAzMlxuICB9O1xuXG4gIHZhciBjcmVhdGUkYiA9IGZ1bmN0aW9uIGNyZWF0ZShfcmVmKSB7XG4gICAgdmFyIHJvb3QgPSBfcmVmLnJvb3QsXG4gICAgICBwcm9wcyA9IF9yZWYucHJvcHM7XG5cbiAgICAvLyBjcmVhdGUgdGhlIGxhYmVsIGFuZCBsaW5rIGl0IHRvIHRoZSBmaWxlIGJyb3dzZXJcbiAgICB2YXIgbGFiZWwgPSBjcmVhdGVFbGVtZW50JDEoJ2xhYmVsJyk7XG4gICAgYXR0cihsYWJlbCwgJ2ZvcicsICdmaWxlcG9uZC0tYnJvd3Nlci0nICsgcHJvcHMuaWQpO1xuXG4gICAgLy8gdXNlIGZvciBsYWJlbGluZyBmaWxlIGlucHV0IChhcmlhLWxhYmVsbGVkYnkgb24gZmlsZSBpbnB1dClcbiAgICBhdHRyKGxhYmVsLCAnaWQnLCAnZmlsZXBvbmQtLWRyb3AtbGFiZWwtJyArIHByb3BzLmlkKTtcblxuICAgIC8vIGhpZGUgdGhlIGxhYmVsIGZvciBzY3JlZW5yZWFkZXJzLCB0aGUgaW5wdXQgZWxlbWVudCB3aWxsIHJlYWQgdGhlIGNvbnRlbnRzIG9mIHRoZSBsYWJlbCB3aGVuIGl0J3MgZm9jdXNzZWQuIElmIHdlIGRvbid0IHNldCBhcmlhLWhpZGRlbiB0aGUgc2NyZWVucmVhZGVyIHdpbGwgYWxzbyBuYXZpZ2F0ZSB0aGUgY29udGVudHMgb2YgdGhlIGxhYmVsIHNlcGFyYXRlbHkgZnJvbSB0aGUgaW5wdXQuXG4gICAgYXR0cihsYWJlbCwgJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcblxuICAgIC8vIGhhbmRsZSBrZXlzXG4gICAgcm9vdC5yZWYuaGFuZGxlS2V5RG93biA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHZhciBpc0FjdGl2YXRpb25LZXkgPSBlLmtleUNvZGUgPT09IEtleS5FTlRFUiB8fCBlLmtleUNvZGUgPT09IEtleS5TUEFDRTtcbiAgICAgIGlmICghaXNBY3RpdmF0aW9uS2V5KSByZXR1cm47XG4gICAgICAvLyBzdG9wcyBmcm9tIHRyaWdnZXJpbmcgdGhlIGVsZW1lbnQgYSBzZWNvbmQgdGltZVxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAvLyBjbGljayBsaW5rICh3aWxsIHRoZW4gaW4gdHVybiBhY3RpdmF0ZSBmaWxlIGlucHV0KVxuICAgICAgcm9vdC5yZWYubGFiZWwuY2xpY2soKTtcbiAgICB9O1xuXG4gICAgcm9vdC5yZWYuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgaXNMYWJlbENsaWNrID0gZS50YXJnZXQgPT09IGxhYmVsIHx8IGxhYmVsLmNvbnRhaW5zKGUudGFyZ2V0KTtcblxuICAgICAgLy8gZG9uJ3Qgd2FudCB0byBjbGljayB0d2ljZVxuICAgICAgaWYgKGlzTGFiZWxDbGljaykgcmV0dXJuO1xuXG4gICAgICAvLyBjbGljayBsaW5rICh3aWxsIHRoZW4gaW4gdHVybiBhY3RpdmF0ZSBmaWxlIGlucHV0KVxuICAgICAgcm9vdC5yZWYubGFiZWwuY2xpY2soKTtcbiAgICB9O1xuXG4gICAgLy8gYXR0YWNoIGV2ZW50c1xuICAgIGxhYmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCByb290LnJlZi5oYW5kbGVLZXlEb3duKTtcbiAgICByb290LmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCByb290LnJlZi5oYW5kbGVDbGljayk7XG5cbiAgICAvLyB1cGRhdGVcbiAgICB1cGRhdGVMYWJlbFZhbHVlKGxhYmVsLCBwcm9wcy5jYXB0aW9uKTtcblxuICAgIC8vIGFkZCFcbiAgICByb290LmFwcGVuZENoaWxkKGxhYmVsKTtcbiAgICByb290LnJlZi5sYWJlbCA9IGxhYmVsO1xuICB9O1xuXG4gIHZhciB1cGRhdGVMYWJlbFZhbHVlID0gZnVuY3Rpb24gdXBkYXRlTGFiZWxWYWx1ZShsYWJlbCwgdmFsdWUpIHtcbiAgICBsYWJlbC5pbm5lckhUTUwgPSB2YWx1ZTtcbiAgICB2YXIgY2xpY2thYmxlID0gbGFiZWwucXVlcnlTZWxlY3RvcignLmZpbGVwb25kLS1sYWJlbC1hY3Rpb24nKTtcbiAgICBpZiAoY2xpY2thYmxlKSB7XG4gICAgICBhdHRyKGNsaWNrYWJsZSwgJ3RhYmluZGV4JywgJzAnKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIHZhciBkcm9wTGFiZWwgPSBjcmVhdGVWaWV3KHtcbiAgICBuYW1lOiAnZHJvcC1sYWJlbCcsXG4gICAgaWdub3JlUmVjdDogdHJ1ZSxcbiAgICBjcmVhdGU6IGNyZWF0ZSRiLFxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koX3JlZjIpIHtcbiAgICAgIHZhciByb290ID0gX3JlZjIucm9vdDtcbiAgICAgIHJvb3QucmVmLmxhYmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCByb290LnJlZi5oYW5kbGVLZXlEb3duKTtcbiAgICAgIHJvb3QuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHJvb3QucmVmLmhhbmRsZUNsaWNrKTtcbiAgICB9LFxuICAgIHdyaXRlOiBjcmVhdGVSb3V0ZSh7XG4gICAgICBESURfU0VUX0xBQkVMX0lETEU6IGZ1bmN0aW9uIERJRF9TRVRfTEFCRUxfSURMRShfcmVmMykge1xuICAgICAgICB2YXIgcm9vdCA9IF9yZWYzLnJvb3QsXG4gICAgICAgICAgYWN0aW9uID0gX3JlZjMuYWN0aW9uO1xuICAgICAgICB1cGRhdGVMYWJlbFZhbHVlKHJvb3QucmVmLmxhYmVsLCBhY3Rpb24udmFsdWUpO1xuICAgICAgfVxuICAgIH0pLFxuXG4gICAgbWl4aW5zOiB7XG4gICAgICBzdHlsZXM6IFsnb3BhY2l0eScsICd0cmFuc2xhdGVYJywgJ3RyYW5zbGF0ZVknXSxcbiAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgb3BhY2l0eTogeyB0eXBlOiAndHdlZW4nLCBkdXJhdGlvbjogMTUwIH0sXG4gICAgICAgIHRyYW5zbGF0ZVg6ICdzcHJpbmcnLFxuICAgICAgICB0cmFuc2xhdGVZOiAnc3ByaW5nJ1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgdmFyIGJsb2IgPSBjcmVhdGVWaWV3KHtcbiAgICBuYW1lOiAnZHJpcC1ibG9iJyxcbiAgICBpZ25vcmVSZWN0OiB0cnVlLFxuICAgIG1peGluczoge1xuICAgICAgc3R5bGVzOiBbJ3RyYW5zbGF0ZVgnLCAndHJhbnNsYXRlWScsICdzY2FsZVgnLCAnc2NhbGVZJywgJ29wYWNpdHknXSxcbiAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgc2NhbGVYOiAnc3ByaW5nJyxcbiAgICAgICAgc2NhbGVZOiAnc3ByaW5nJyxcbiAgICAgICAgdHJhbnNsYXRlWDogJ3NwcmluZycsXG4gICAgICAgIHRyYW5zbGF0ZVk6ICdzcHJpbmcnLFxuICAgICAgICBvcGFjaXR5OiB7IHR5cGU6ICd0d2VlbicsIGR1cmF0aW9uOiAyNTAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgdmFyIGFkZEJsb2IgPSBmdW5jdGlvbiBhZGRCbG9iKF9yZWYpIHtcbiAgICB2YXIgcm9vdCA9IF9yZWYucm9vdDtcbiAgICB2YXIgY2VudGVyWCA9IHJvb3QucmVjdC5lbGVtZW50LndpZHRoICogMC41O1xuICAgIHZhciBjZW50ZXJZID0gcm9vdC5yZWN0LmVsZW1lbnQuaGVpZ2h0ICogMC41O1xuXG4gICAgcm9vdC5yZWYuYmxvYiA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KFxuICAgICAgcm9vdC5jcmVhdGVDaGlsZFZpZXcoYmxvYiwge1xuICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICBzY2FsZVg6IDIuNSxcbiAgICAgICAgc2NhbGVZOiAyLjUsXG4gICAgICAgIHRyYW5zbGF0ZVg6IGNlbnRlclgsXG4gICAgICAgIHRyYW5zbGF0ZVk6IGNlbnRlcllcbiAgICAgIH0pXG4gICAgKTtcbiAgfTtcblxuICB2YXIgbW92ZUJsb2IgPSBmdW5jdGlvbiBtb3ZlQmxvYihfcmVmMikge1xuICAgIHZhciByb290ID0gX3JlZjIucm9vdCxcbiAgICAgIGFjdGlvbiA9IF9yZWYyLmFjdGlvbjtcbiAgICBpZiAoIXJvb3QucmVmLmJsb2IpIHtcbiAgICAgIGFkZEJsb2IoeyByb290OiByb290IH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJvb3QucmVmLmJsb2IudHJhbnNsYXRlWCA9IGFjdGlvbi5wb3NpdGlvbi5zY29wZUxlZnQ7XG4gICAgcm9vdC5yZWYuYmxvYi50cmFuc2xhdGVZID0gYWN0aW9uLnBvc2l0aW9uLnNjb3BlVG9wO1xuICAgIHJvb3QucmVmLmJsb2Iuc2NhbGVYID0gMTtcbiAgICByb290LnJlZi5ibG9iLnNjYWxlWSA9IDE7XG4gICAgcm9vdC5yZWYuYmxvYi5vcGFjaXR5ID0gMTtcbiAgfTtcblxuICB2YXIgaGlkZUJsb2IgPSBmdW5jdGlvbiBoaWRlQmxvYihfcmVmMykge1xuICAgIHZhciByb290ID0gX3JlZjMucm9vdDtcbiAgICBpZiAoIXJvb3QucmVmLmJsb2IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcm9vdC5yZWYuYmxvYi5vcGFjaXR5ID0gMDtcbiAgfTtcblxuICB2YXIgZXhwbG9kZUJsb2IgPSBmdW5jdGlvbiBleHBsb2RlQmxvYihfcmVmNCkge1xuICAgIHZhciByb290ID0gX3JlZjQucm9vdDtcbiAgICBpZiAoIXJvb3QucmVmLmJsb2IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcm9vdC5yZWYuYmxvYi5zY2FsZVggPSAyLjU7XG4gICAgcm9vdC5yZWYuYmxvYi5zY2FsZVkgPSAyLjU7XG4gICAgcm9vdC5yZWYuYmxvYi5vcGFjaXR5ID0gMDtcbiAgfTtcblxuICB2YXIgd3JpdGUkNyA9IGZ1bmN0aW9uIHdyaXRlKF9yZWY1KSB7XG4gICAgdmFyIHJvb3QgPSBfcmVmNS5yb290LFxuICAgICAgcHJvcHMgPSBfcmVmNS5wcm9wcyxcbiAgICAgIGFjdGlvbnMgPSBfcmVmNS5hY3Rpb25zO1xuICAgIHJvdXRlJDQoeyByb290OiByb290LCBwcm9wczogcHJvcHMsIGFjdGlvbnM6IGFjdGlvbnMgfSk7XG4gICAgdmFyIGJsb2IgPSByb290LnJlZi5ibG9iO1xuXG4gICAgaWYgKGFjdGlvbnMubGVuZ3RoID09PSAwICYmIGJsb2IgJiYgYmxvYi5vcGFjaXR5ID09PSAwKSB7XG4gICAgICByb290LnJlbW92ZUNoaWxkVmlldyhibG9iKTtcbiAgICAgIHJvb3QucmVmLmJsb2IgPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICB2YXIgcm91dGUkNCA9IGNyZWF0ZVJvdXRlKHtcbiAgICBESURfRFJBRzogbW92ZUJsb2IsXG4gICAgRElEX0RST1A6IGV4cGxvZGVCbG9iLFxuICAgIERJRF9FTkRfRFJBRzogaGlkZUJsb2JcbiAgfSk7XG5cbiAgdmFyIGRyaXAgPSBjcmVhdGVWaWV3KHtcbiAgICBpZ25vcmVSZWN0OiB0cnVlLFxuICAgIGlnbm9yZVJlY3RVcGRhdGU6IHRydWUsXG4gICAgbmFtZTogJ2RyaXAnLFxuICAgIHdyaXRlOiB3cml0ZSQ3XG4gIH0pO1xuXG4gIHZhciBjcmVhdGUkYyA9IGZ1bmN0aW9uIGNyZWF0ZShfcmVmKSB7XG4gICAgdmFyIHJvb3QgPSBfcmVmLnJvb3Q7XG4gICAgcmV0dXJuIChyb290LnJlZi5maWVsZHMgPSB7fSk7XG4gIH07XG5cbiAgdmFyIGdldEZpZWxkID0gZnVuY3Rpb24gZ2V0RmllbGQocm9vdCwgaWQpIHtcbiAgICByZXR1cm4gcm9vdC5yZWYuZmllbGRzW2lkXTtcbiAgfTtcblxuICB2YXIgc3luY0ZpZWxkUG9zaXRpb25zV2l0aEl0ZW1zID0gZnVuY3Rpb24gc3luY0ZpZWxkUG9zaXRpb25zV2l0aEl0ZW1zKHJvb3QpIHtcbiAgICByb290LnF1ZXJ5KCdHRVRfQUNUSVZFX0lURU1TJykuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICBpZiAoIXJvb3QucmVmLmZpZWxkc1tpdGVtLmlkXSkgcmV0dXJuO1xuICAgICAgcm9vdC5lbGVtZW50LmFwcGVuZENoaWxkKHJvb3QucmVmLmZpZWxkc1tpdGVtLmlkXSk7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGRpZFJlb3JkZXJJdGVtcyA9IGZ1bmN0aW9uIGRpZFJlb3JkZXJJdGVtcyhfcmVmMikge1xuICAgIHZhciByb290ID0gX3JlZjIucm9vdDtcbiAgICByZXR1cm4gc3luY0ZpZWxkUG9zaXRpb25zV2l0aEl0ZW1zKHJvb3QpO1xuICB9O1xuXG4gIHZhciBkaWRBZGRJdGVtID0gZnVuY3Rpb24gZGlkQWRkSXRlbShfcmVmMykge1xuICAgIHZhciByb290ID0gX3JlZjMucm9vdCxcbiAgICAgIGFjdGlvbiA9IF9yZWYzLmFjdGlvbjtcbiAgICB2YXIgZGF0YUNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQkMSgnaW5wdXQnKTtcbiAgICBkYXRhQ29udGFpbmVyLnR5cGUgPSAnaGlkZGVuJztcbiAgICBkYXRhQ29udGFpbmVyLm5hbWUgPSByb290LnF1ZXJ5KCdHRVRfTkFNRScpO1xuICAgIGRhdGFDb250YWluZXIuZGlzYWJsZWQgPSByb290LnF1ZXJ5KCdHRVRfRElTQUJMRUQnKTtcbiAgICByb290LnJlZi5maWVsZHNbYWN0aW9uLmlkXSA9IGRhdGFDb250YWluZXI7XG4gICAgc3luY0ZpZWxkUG9zaXRpb25zV2l0aEl0ZW1zKHJvb3QpO1xuICB9O1xuXG4gIHZhciBkaWRMb2FkSXRlbSQxID0gZnVuY3Rpb24gZGlkTG9hZEl0ZW0oX3JlZjQpIHtcbiAgICB2YXIgcm9vdCA9IF9yZWY0LnJvb3QsXG4gICAgICBhY3Rpb24gPSBfcmVmNC5hY3Rpb247XG4gICAgdmFyIGZpZWxkID0gZ2V0RmllbGQocm9vdCwgYWN0aW9uLmlkKTtcbiAgICBpZiAoIWZpZWxkIHx8IGFjdGlvbi5zZXJ2ZXJGaWxlUmVmZXJlbmNlID09PSBudWxsKSByZXR1cm47XG4gICAgZmllbGQudmFsdWUgPSBhY3Rpb24uc2VydmVyRmlsZVJlZmVyZW5jZTtcbiAgfTtcblxuICB2YXIgZGlkU2V0RGlzYWJsZWQgPSBmdW5jdGlvbiBkaWRTZXREaXNhYmxlZChfcmVmNSkge1xuICAgIHZhciByb290ID0gX3JlZjUucm9vdDtcbiAgICByb290LmVsZW1lbnQuZGlzYWJsZWQgPSByb290LnF1ZXJ5KCdHRVRfRElTQUJMRUQnKTtcbiAgfTtcblxuICB2YXIgZGlkUmVtb3ZlSXRlbSA9IGZ1bmN0aW9uIGRpZFJlbW92ZUl0ZW0oX3JlZjYpIHtcbiAgICB2YXIgcm9vdCA9IF9yZWY2LnJvb3QsXG4gICAgICBhY3Rpb24gPSBfcmVmNi5hY3Rpb247XG4gICAgdmFyIGZpZWxkID0gZ2V0RmllbGQocm9vdCwgYWN0aW9uLmlkKTtcbiAgICBpZiAoIWZpZWxkKSByZXR1cm47XG4gICAgaWYgKGZpZWxkLnBhcmVudE5vZGUpIGZpZWxkLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZmllbGQpO1xuICAgIGRlbGV0ZSByb290LnJlZi5maWVsZHNbYWN0aW9uLmlkXTtcbiAgfTtcblxuICB2YXIgZGlkRGVmaW5lVmFsdWUgPSBmdW5jdGlvbiBkaWREZWZpbmVWYWx1ZShfcmVmNykge1xuICAgIHZhciByb290ID0gX3JlZjcucm9vdCxcbiAgICAgIGFjdGlvbiA9IF9yZWY3LmFjdGlvbjtcbiAgICB2YXIgZmllbGQgPSBnZXRGaWVsZChyb290LCBhY3Rpb24uaWQpO1xuICAgIGlmICghZmllbGQpIHJldHVybjtcbiAgICBpZiAoYWN0aW9uLnZhbHVlID09PSBudWxsKSB7XG4gICAgICBmaWVsZC5yZW1vdmVBdHRyaWJ1dGUoJ3ZhbHVlJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpZWxkLnZhbHVlID0gYWN0aW9uLnZhbHVlO1xuICAgIH1cbiAgICBzeW5jRmllbGRQb3NpdGlvbnNXaXRoSXRlbXMocm9vdCk7XG4gIH07XG5cbiAgdmFyIHdyaXRlJDggPSBjcmVhdGVSb3V0ZSh7XG4gICAgRElEX1NFVF9ESVNBQkxFRDogZGlkU2V0RGlzYWJsZWQsXG4gICAgRElEX0FERF9JVEVNOiBkaWRBZGRJdGVtLFxuICAgIERJRF9MT0FEX0lURU06IGRpZExvYWRJdGVtJDEsXG4gICAgRElEX1JFTU9WRV9JVEVNOiBkaWRSZW1vdmVJdGVtLFxuICAgIERJRF9ERUZJTkVfVkFMVUU6IGRpZERlZmluZVZhbHVlLFxuICAgIERJRF9SRU9SREVSX0lURU1TOiBkaWRSZW9yZGVySXRlbXMsXG4gICAgRElEX1NPUlRfSVRFTVM6IGRpZFJlb3JkZXJJdGVtc1xuICB9KTtcblxuICB2YXIgZGF0YSA9IGNyZWF0ZVZpZXcoe1xuICAgIHRhZzogJ2ZpZWxkc2V0JyxcbiAgICBuYW1lOiAnZGF0YScsXG4gICAgY3JlYXRlOiBjcmVhdGUkYyxcbiAgICB3cml0ZTogd3JpdGUkOCxcbiAgICBpZ25vcmVSZWN0OiB0cnVlXG4gIH0pO1xuXG4gIHZhciBnZXRSb290Tm9kZSA9IGZ1bmN0aW9uIGdldFJvb3ROb2RlKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gJ2dldFJvb3ROb2RlJyBpbiBlbGVtZW50ID8gZWxlbWVudC5nZXRSb290Tm9kZSgpIDogZG9jdW1lbnQ7XG4gIH07XG5cbiAgdmFyIGltYWdlcyA9IFsnanBnJywgJ2pwZWcnLCAncG5nJywgJ2dpZicsICdibXAnLCAnd2VicCcsICdzdmcnLCAndGlmZiddO1xuICB2YXIgdGV4dCQxID0gWydjc3MnLCAnY3N2JywgJ2h0bWwnLCAndHh0J107XG4gIHZhciBtYXAgPSB7XG4gICAgemlwOiAnemlwfGNvbXByZXNzZWQnLFxuICAgIGVwdWI6ICdhcHBsaWNhdGlvbi9lcHViK3ppcCdcbiAgfTtcblxuICB2YXIgZ3Vlc3N0aW1hdGVNaW1lVHlwZSA9IGZ1bmN0aW9uIGd1ZXNzdGltYXRlTWltZVR5cGUoKSB7XG4gICAgdmFyIGV4dGVuc2lvbiA9XG4gICAgICBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICcnO1xuICAgIGV4dGVuc2lvbiA9IGV4dGVuc2lvbi50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChpbWFnZXMuaW5jbHVkZXMoZXh0ZW5zaW9uKSkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgJ2ltYWdlLycgK1xuICAgICAgICAoZXh0ZW5zaW9uID09PSAnanBnJ1xuICAgICAgICAgID8gJ2pwZWcnXG4gICAgICAgICAgOiBleHRlbnNpb24gPT09ICdzdmcnXG4gICAgICAgICAgPyAnc3ZnK3htbCdcbiAgICAgICAgICA6IGV4dGVuc2lvbilcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICh0ZXh0JDEuaW5jbHVkZXMoZXh0ZW5zaW9uKSkge1xuICAgICAgcmV0dXJuICd0ZXh0LycgKyBleHRlbnNpb247XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcFtleHRlbnNpb25dIHx8ICcnO1xuICB9O1xuXG4gIHZhciByZXF1ZXN0RGF0YVRyYW5zZmVySXRlbXMgPSBmdW5jdGlvbiByZXF1ZXN0RGF0YVRyYW5zZmVySXRlbXMoXG4gICAgZGF0YVRyYW5zZmVyXG4gICkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIC8vIHRyeSB0byBnZXQgbGlua3MgZnJvbSB0cmFuc2ZlciwgaWYgZm91bmQgd2UnbGwgZXhpdCBpbW1lZGlhdGVseSAodW5sZXNzIGEgZmlsZSBpcyBpbiB0aGUgZGF0YVRyYW5zZmVyIGFzIHdlbGwsIHRoaXMgaXMgYmVjYXVzZSBGaXJlZm94IGNvdWxkIHJlcHJlc2VudCB0aGUgZmlsZSBhcyBhIFVSTCBhbmQgYSBmaWxlIG9iamVjdCBhdCB0aGUgc2FtZSB0aW1lKVxuICAgICAgdmFyIGxpbmtzID0gZ2V0TGlua3MoZGF0YVRyYW5zZmVyKTtcbiAgICAgIGlmIChsaW5rcy5sZW5ndGggJiYgIWhhc0ZpbGVzKGRhdGFUcmFuc2ZlcikpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmUobGlua3MpO1xuICAgICAgfVxuICAgICAgLy8gdHJ5IHRvIGdldCBmaWxlcyBmcm9tIHRoZSB0cmFuc2ZlclxuICAgICAgZ2V0RmlsZXMoZGF0YVRyYW5zZmVyKS50aGVuKHJlc29sdmUpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUZXN0IGlmIGRhdGF0cmFuc2ZlciBoYXMgZmlsZXNcbiAgICovXG4gIHZhciBoYXNGaWxlcyA9IGZ1bmN0aW9uIGhhc0ZpbGVzKGRhdGFUcmFuc2Zlcikge1xuICAgIGlmIChkYXRhVHJhbnNmZXIuZmlsZXMpIHJldHVybiBkYXRhVHJhbnNmZXIuZmlsZXMubGVuZ3RoID4gMDtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIEV4dHJhY3RzIGZpbGVzIGZyb20gYSBEYXRhVHJhbnNmZXIgb2JqZWN0XG4gICAqL1xuICB2YXIgZ2V0RmlsZXMgPSBmdW5jdGlvbiBnZXRGaWxlcyhkYXRhVHJhbnNmZXIpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAvLyBnZXQgdGhlIHRyYW5zZmVyIGl0ZW1zIGFzIHByb21pc2VzXG4gICAgICB2YXIgcHJvbWlzZWRGaWxlcyA9IChkYXRhVHJhbnNmZXIuaXRlbXNcbiAgICAgICAgPyBBcnJheS5mcm9tKGRhdGFUcmFuc2Zlci5pdGVtcylcbiAgICAgICAgOiBbXVxuICAgICAgKVxuICAgICAgICAvLyBvbmx5IGtlZXAgZmlsZSBzeXN0ZW0gaXRlbXMgKGZpbGVzIGFuZCBkaXJlY3RvcmllcylcbiAgICAgICAgLmZpbHRlcihmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgcmV0dXJuIGlzRmlsZVN5c3RlbUl0ZW0oaXRlbSk7XG4gICAgICAgIH0pXG5cbiAgICAgICAgLy8gbWFwIGVhY2ggaXRlbSB0byBwcm9taXNlXG4gICAgICAgIC5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgIHJldHVybiBnZXRGaWxlc0Zyb21JdGVtKGl0ZW0pO1xuICAgICAgICB9KTtcblxuICAgICAgLy8gaWYgaXMgZW1wdHksIHNlZSBpZiB3ZSBjYW4gZXh0cmFjdCBzb21lIGluZm8gZnJvbSB0aGUgZmlsZXMgcHJvcGVydHkgYXMgYSBmYWxsYmFja1xuICAgICAgaWYgKCFwcm9taXNlZEZpbGVzLmxlbmd0aCkge1xuICAgICAgICAvLyBUT0RPOiB0ZXN0IGZvciBkaXJlY3RvcmllcyAoc2hvdWxkIG5vdCBiZSBhbGxvd2VkKVxuICAgICAgICAvLyBVc2UgRmlsZVJlYWRlciwgcHJvYmxlbSBpcyB0aGF0IHRoZSBmaWxlcyBwcm9wZXJ0eSBnZXRzIGxvc3QgaW4gdGhlIHByb2Nlc3NcbiAgICAgICAgcmVzb2x2ZShkYXRhVHJhbnNmZXIuZmlsZXMgPyBBcnJheS5mcm9tKGRhdGFUcmFuc2Zlci5maWxlcykgOiBbXSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gZG9uZSFcbiAgICAgIFByb21pc2UuYWxsKHByb21pc2VkRmlsZXMpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKHJldHVybmVkRmlsZUdyb3Vwcykge1xuICAgICAgICAgIC8vIGZsYXR0ZW4gZ3JvdXBzXG4gICAgICAgICAgdmFyIGZpbGVzID0gW107XG4gICAgICAgICAgcmV0dXJuZWRGaWxlR3JvdXBzLmZvckVhY2goZnVuY3Rpb24oZ3JvdXApIHtcbiAgICAgICAgICAgIGZpbGVzLnB1c2guYXBwbHkoZmlsZXMsIGdyb3VwKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIGRvbmUgKGZpbHRlciBvdXQgZW1wdHkgZmlsZXMpIVxuICAgICAgICAgIHJlc29sdmUoXG4gICAgICAgICAgICBmaWxlc1xuICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGZpbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsZTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbihmaWxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmaWxlLl9yZWxhdGl2ZVBhdGgpXG4gICAgICAgICAgICAgICAgICBmaWxlLl9yZWxhdGl2ZVBhdGggPSBmaWxlLndlYmtpdFJlbGF0aXZlUGF0aDtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsZTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGlzRmlsZVN5c3RlbUl0ZW0gPSBmdW5jdGlvbiBpc0ZpbGVTeXN0ZW1JdGVtKGl0ZW0pIHtcbiAgICBpZiAoaXNFbnRyeShpdGVtKSkge1xuICAgICAgdmFyIGVudHJ5ID0gZ2V0QXNFbnRyeShpdGVtKTtcbiAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICByZXR1cm4gZW50cnkuaXNGaWxlIHx8IGVudHJ5LmlzRGlyZWN0b3J5O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaXRlbS5raW5kID09PSAnZmlsZSc7XG4gIH07XG5cbiAgdmFyIGdldEZpbGVzRnJvbUl0ZW0gPSBmdW5jdGlvbiBnZXRGaWxlc0Zyb21JdGVtKGl0ZW0pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBpZiAoaXNEaXJlY3RvcnlFbnRyeShpdGVtKSkge1xuICAgICAgICBnZXRGaWxlc0luRGlyZWN0b3J5KGdldEFzRW50cnkoaXRlbSkpXG4gICAgICAgICAgLnRoZW4ocmVzb2x2ZSlcbiAgICAgICAgICAuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXNvbHZlKFtpdGVtLmdldEFzRmlsZSgpXSk7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGdldEZpbGVzSW5EaXJlY3RvcnkgPSBmdW5jdGlvbiBnZXRGaWxlc0luRGlyZWN0b3J5KGVudHJ5KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIGZpbGVzID0gW107XG5cbiAgICAgIC8vIHRoZSB0b3RhbCBlbnRyaWVzIHRvIHJlYWRcbiAgICAgIHZhciBkaXJDb3VudGVyID0gMDtcbiAgICAgIHZhciBmaWxlQ291bnRlciA9IDA7XG5cbiAgICAgIHZhciByZXNvbHZlSWZEb25lID0gZnVuY3Rpb24gcmVzb2x2ZUlmRG9uZSgpIHtcbiAgICAgICAgaWYgKGZpbGVDb3VudGVyID09PSAwICYmIGRpckNvdW50ZXIgPT09IDApIHtcbiAgICAgICAgICByZXNvbHZlKGZpbGVzKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gdGhlIHJlY3Vyc2l2ZSBmdW5jdGlvblxuICAgICAgdmFyIHJlYWRFbnRyaWVzID0gZnVuY3Rpb24gcmVhZEVudHJpZXMoZGlyRW50cnkpIHtcbiAgICAgICAgZGlyQ291bnRlcisrO1xuXG4gICAgICAgIHZhciBkaXJlY3RvcnlSZWFkZXIgPSBkaXJFbnRyeS5jcmVhdGVSZWFkZXIoKTtcblxuICAgICAgICAvLyBkaXJlY3RvcmllcyBhcmUgcmV0dXJuZWQgaW4gYmF0Y2hlcywgd2UgbmVlZCB0byBwcm9jZXNzIGFsbCBiYXRjaGVzIGJlZm9yZSB3ZSdyZSBkb25lXG4gICAgICAgIHZhciByZWFkQmF0Y2ggPSBmdW5jdGlvbiByZWFkQmF0Y2goKSB7XG4gICAgICAgICAgZGlyZWN0b3J5UmVhZGVyLnJlYWRFbnRyaWVzKGZ1bmN0aW9uKGVudHJpZXMpIHtcbiAgICAgICAgICAgIGlmIChlbnRyaWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICBkaXJDb3VudGVyLS07XG4gICAgICAgICAgICAgIHJlc29sdmVJZkRvbmUoKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlbnRyaWVzLmZvckVhY2goZnVuY3Rpb24oZW50cnkpIHtcbiAgICAgICAgICAgICAgLy8gcmVjdXJzaXZlbHkgcmVhZCBtb3JlIGRpcmVjdG9yaWVzXG4gICAgICAgICAgICAgIGlmIChlbnRyeS5pc0RpcmVjdG9yeSkge1xuICAgICAgICAgICAgICAgIHJlYWRFbnRyaWVzKGVudHJ5KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyByZWFkIGFzIGZpbGVcbiAgICAgICAgICAgICAgICBmaWxlQ291bnRlcisrO1xuXG4gICAgICAgICAgICAgICAgZW50cnkuZmlsZShmdW5jdGlvbihmaWxlKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgY29ycmVjdGVkRmlsZSA9IGNvcnJlY3RNaXNzaW5nRmlsZVR5cGUoZmlsZSk7XG4gICAgICAgICAgICAgICAgICBpZiAoZW50cnkuZnVsbFBhdGgpXG4gICAgICAgICAgICAgICAgICAgIGNvcnJlY3RlZEZpbGUuX3JlbGF0aXZlUGF0aCA9IGVudHJ5LmZ1bGxQYXRoO1xuICAgICAgICAgICAgICAgICAgZmlsZXMucHVzaChjb3JyZWN0ZWRGaWxlKTtcbiAgICAgICAgICAgICAgICAgIGZpbGVDb3VudGVyLS07XG4gICAgICAgICAgICAgICAgICByZXNvbHZlSWZEb25lKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyB0cnkgdG8gZ2V0IG5leHQgYmF0Y2ggb2YgZmlsZXNcbiAgICAgICAgICAgIHJlYWRCYXRjaCgpO1xuICAgICAgICAgIH0sIHJlamVjdCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gcmVhZCBmaXJzdCBiYXRjaCBvZiBmaWxlc1xuICAgICAgICByZWFkQmF0Y2goKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIGdvIVxuICAgICAgcmVhZEVudHJpZXMoZW50cnkpO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBjb3JyZWN0TWlzc2luZ0ZpbGVUeXBlID0gZnVuY3Rpb24gY29ycmVjdE1pc3NpbmdGaWxlVHlwZShmaWxlKSB7XG4gICAgaWYgKGZpbGUudHlwZS5sZW5ndGgpIHJldHVybiBmaWxlO1xuICAgIHZhciBkYXRlID0gZmlsZS5sYXN0TW9kaWZpZWREYXRlO1xuICAgIHZhciBuYW1lID0gZmlsZS5uYW1lO1xuICAgIHZhciB0eXBlID0gZ3Vlc3N0aW1hdGVNaW1lVHlwZShnZXRFeHRlbnNpb25Gcm9tRmlsZW5hbWUoZmlsZS5uYW1lKSk7XG4gICAgaWYgKCF0eXBlLmxlbmd0aCkgcmV0dXJuIGZpbGU7XG4gICAgZmlsZSA9IGZpbGUuc2xpY2UoMCwgZmlsZS5zaXplLCB0eXBlKTtcbiAgICBmaWxlLm5hbWUgPSBuYW1lO1xuICAgIGZpbGUubGFzdE1vZGlmaWVkRGF0ZSA9IGRhdGU7XG4gICAgcmV0dXJuIGZpbGU7XG4gIH07XG5cbiAgdmFyIGlzRGlyZWN0b3J5RW50cnkgPSBmdW5jdGlvbiBpc0RpcmVjdG9yeUVudHJ5KGl0ZW0pIHtcbiAgICByZXR1cm4gaXNFbnRyeShpdGVtKSAmJiAoZ2V0QXNFbnRyeShpdGVtKSB8fCB7fSkuaXNEaXJlY3Rvcnk7XG4gIH07XG5cbiAgdmFyIGlzRW50cnkgPSBmdW5jdGlvbiBpc0VudHJ5KGl0ZW0pIHtcbiAgICByZXR1cm4gJ3dlYmtpdEdldEFzRW50cnknIGluIGl0ZW07XG4gIH07XG5cbiAgdmFyIGdldEFzRW50cnkgPSBmdW5jdGlvbiBnZXRBc0VudHJ5KGl0ZW0pIHtcbiAgICByZXR1cm4gaXRlbS53ZWJraXRHZXRBc0VudHJ5KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEV4dHJhY3RzIGxpbmtzIGZyb20gYSBEYXRhVHJhbnNmZXIgb2JqZWN0XG4gICAqL1xuICB2YXIgZ2V0TGlua3MgPSBmdW5jdGlvbiBnZXRMaW5rcyhkYXRhVHJhbnNmZXIpIHtcbiAgICB2YXIgbGlua3MgPSBbXTtcbiAgICB0cnkge1xuICAgICAgLy8gbG9vayBpbiBtZXRhIGRhdGEgcHJvcGVydHlcbiAgICAgIGxpbmtzID0gZ2V0TGlua3NGcm9tVHJhbnNmZXJNZXRhRGF0YShkYXRhVHJhbnNmZXIpO1xuICAgICAgaWYgKGxpbmtzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbGlua3M7XG4gICAgICB9XG4gICAgICBsaW5rcyA9IGdldExpbmtzRnJvbVRyYW5zZmVyVVJMRGF0YShkYXRhVHJhbnNmZXIpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIG5vcGUgbm9wZSBub3BlIChwcm9iYWJseSBJRSB0cm91YmxlKVxuICAgIH1cbiAgICByZXR1cm4gbGlua3M7XG4gIH07XG5cbiAgdmFyIGdldExpbmtzRnJvbVRyYW5zZmVyVVJMRGF0YSA9IGZ1bmN0aW9uIGdldExpbmtzRnJvbVRyYW5zZmVyVVJMRGF0YShcbiAgICBkYXRhVHJhbnNmZXJcbiAgKSB7XG4gICAgdmFyIGRhdGEgPSBkYXRhVHJhbnNmZXIuZ2V0RGF0YSgndXJsJyk7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyAmJiBkYXRhLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIFtkYXRhXTtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xuICB9O1xuXG4gIHZhciBnZXRMaW5rc0Zyb21UcmFuc2Zlck1ldGFEYXRhID0gZnVuY3Rpb24gZ2V0TGlua3NGcm9tVHJhbnNmZXJNZXRhRGF0YShcbiAgICBkYXRhVHJhbnNmZXJcbiAgKSB7XG4gICAgdmFyIGRhdGEgPSBkYXRhVHJhbnNmZXIuZ2V0RGF0YSgndGV4dC9odG1sJyk7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyAmJiBkYXRhLmxlbmd0aCkge1xuICAgICAgdmFyIG1hdGNoZXMgPSBkYXRhLm1hdGNoKC9zcmNcXHMqPVxccypcIiguKz8pXCIvKTtcbiAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgIHJldHVybiBbbWF0Y2hlc1sxXV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfTtcblxuICB2YXIgZHJhZ05Ecm9wT2JzZXJ2ZXJzID0gW107XG5cbiAgdmFyIGV2ZW50UG9zaXRpb24gPSBmdW5jdGlvbiBldmVudFBvc2l0aW9uKGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcGFnZUxlZnQ6IGUucGFnZVgsXG4gICAgICBwYWdlVG9wOiBlLnBhZ2VZLFxuICAgICAgc2NvcGVMZWZ0OiBlLm9mZnNldFggfHwgZS5sYXllclgsXG4gICAgICBzY29wZVRvcDogZS5vZmZzZXRZIHx8IGUubGF5ZXJZXG4gICAgfTtcbiAgfTtcblxuICB2YXIgY3JlYXRlRHJhZ05Ecm9wQ2xpZW50ID0gZnVuY3Rpb24gY3JlYXRlRHJhZ05Ecm9wQ2xpZW50KFxuICAgIGVsZW1lbnQsXG4gICAgc2NvcGVUb09ic2VydmUsXG4gICAgZmlsdGVyRWxlbWVudFxuICApIHtcbiAgICB2YXIgb2JzZXJ2ZXIgPSBnZXREcmFnTkRyb3BPYnNlcnZlcihzY29wZVRvT2JzZXJ2ZSk7XG5cbiAgICB2YXIgY2xpZW50ID0ge1xuICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgIGZpbHRlckVsZW1lbnQ6IGZpbHRlckVsZW1lbnQsXG4gICAgICBzdGF0ZTogbnVsbCxcbiAgICAgIG9uZHJvcDogZnVuY3Rpb24gb25kcm9wKCkge30sXG4gICAgICBvbmVudGVyOiBmdW5jdGlvbiBvbmVudGVyKCkge30sXG4gICAgICBvbmRyYWc6IGZ1bmN0aW9uIG9uZHJhZygpIHt9LFxuICAgICAgb25leGl0OiBmdW5jdGlvbiBvbmV4aXQoKSB7fSxcbiAgICAgIG9ubG9hZDogZnVuY3Rpb24gb25sb2FkKCkge30sXG4gICAgICBhbGxvd2Ryb3A6IGZ1bmN0aW9uIGFsbG93ZHJvcCgpIHt9XG4gICAgfTtcblxuICAgIGNsaWVudC5kZXN0cm95ID0gb2JzZXJ2ZXIuYWRkTGlzdGVuZXIoY2xpZW50KTtcblxuICAgIHJldHVybiBjbGllbnQ7XG4gIH07XG5cbiAgdmFyIGdldERyYWdORHJvcE9ic2VydmVyID0gZnVuY3Rpb24gZ2V0RHJhZ05Ecm9wT2JzZXJ2ZXIoZWxlbWVudCkge1xuICAgIC8vIHNlZSBpZiBhbHJlYWR5IGV4aXN0cywgaWYgc28sIHJldHVyblxuICAgIHZhciBvYnNlcnZlciA9IGRyYWdORHJvcE9ic2VydmVycy5maW5kKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgIHJldHVybiBpdGVtLmVsZW1lbnQgPT09IGVsZW1lbnQ7XG4gICAgfSk7XG4gICAgaWYgKG9ic2VydmVyKSB7XG4gICAgICByZXR1cm4gb2JzZXJ2ZXI7XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIG5ldyBvYnNlcnZlciwgZG9lcyBub3QgeWV0IGV4aXN0IGZvciB0aGlzIGVsZW1lbnRcbiAgICB2YXIgbmV3T2JzZXJ2ZXIgPSBjcmVhdGVEcmFnTkRyb3BPYnNlcnZlcihlbGVtZW50KTtcbiAgICBkcmFnTkRyb3BPYnNlcnZlcnMucHVzaChuZXdPYnNlcnZlcik7XG4gICAgcmV0dXJuIG5ld09ic2VydmVyO1xuICB9O1xuXG4gIHZhciBjcmVhdGVEcmFnTkRyb3BPYnNlcnZlciA9IGZ1bmN0aW9uIGNyZWF0ZURyYWdORHJvcE9ic2VydmVyKGVsZW1lbnQpIHtcbiAgICB2YXIgY2xpZW50cyA9IFtdO1xuXG4gICAgdmFyIHJvdXRlcyA9IHtcbiAgICAgIGRyYWdlbnRlcjogZHJhZ2VudGVyLFxuICAgICAgZHJhZ292ZXI6IGRyYWdvdmVyLFxuICAgICAgZHJhZ2xlYXZlOiBkcmFnbGVhdmUsXG4gICAgICBkcm9wOiBkcm9wXG4gICAgfTtcblxuICAgIHZhciBoYW5kbGVycyA9IHt9O1xuXG4gICAgZm9yaW4ocm91dGVzLCBmdW5jdGlvbihldmVudCwgY3JlYXRlSGFuZGxlcikge1xuICAgICAgaGFuZGxlcnNbZXZlbnRdID0gY3JlYXRlSGFuZGxlcihlbGVtZW50LCBjbGllbnRzKTtcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlcnNbZXZlbnRdLCBmYWxzZSk7XG4gICAgfSk7XG5cbiAgICB2YXIgb2JzZXJ2ZXIgPSB7XG4gICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgYWRkTGlzdGVuZXI6IGZ1bmN0aW9uIGFkZExpc3RlbmVyKGNsaWVudCkge1xuICAgICAgICAvLyBhZGQgYXMgY2xpZW50XG4gICAgICAgIGNsaWVudHMucHVzaChjbGllbnQpO1xuXG4gICAgICAgIC8vIHJldHVybiByZW1vdmVMaXN0ZW5lciBmdW5jdGlvblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgLy8gcmVtb3ZlIGNsaWVudFxuICAgICAgICAgIGNsaWVudHMuc3BsaWNlKGNsaWVudHMuaW5kZXhPZihjbGllbnQpLCAxKTtcblxuICAgICAgICAgIC8vIGlmIG5vIG1vcmUgY2xpZW50cywgY2xlYW4gdXAgb2JzZXJ2ZXJcbiAgICAgICAgICBpZiAoY2xpZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGRyYWdORHJvcE9ic2VydmVycy5zcGxpY2UoZHJhZ05Ecm9wT2JzZXJ2ZXJzLmluZGV4T2Yob2JzZXJ2ZXIpLCAxKTtcblxuICAgICAgICAgICAgZm9yaW4ocm91dGVzLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXJzW2V2ZW50XSwgZmFsc2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gb2JzZXJ2ZXI7XG4gIH07XG5cbiAgdmFyIGVsZW1lbnRGcm9tUG9pbnQgPSBmdW5jdGlvbiBlbGVtZW50RnJvbVBvaW50KHJvb3QsIHBvaW50KSB7XG4gICAgaWYgKCEoJ2VsZW1lbnRGcm9tUG9pbnQnIGluIHJvb3QpKSB7XG4gICAgICByb290ID0gZG9jdW1lbnQ7XG4gICAgfVxuICAgIHJldHVybiByb290LmVsZW1lbnRGcm9tUG9pbnQocG9pbnQueCwgcG9pbnQueSk7XG4gIH07XG5cbiAgdmFyIGlzRXZlbnRUYXJnZXQgPSBmdW5jdGlvbiBpc0V2ZW50VGFyZ2V0KGUsIHRhcmdldCkge1xuICAgIC8vIGdldCByb290XG4gICAgdmFyIHJvb3QgPSBnZXRSb290Tm9kZSh0YXJnZXQpO1xuXG4gICAgLy8gZ2V0IGVsZW1lbnQgYXQgcG9zaXRpb25cbiAgICAvLyBpZiByb290IGlzIG5vdCBhY3R1YWwgc2hhZG93IERPTSBhbmQgZG9lcyBub3QgaGF2ZSBlbGVtZW50RnJvbVBvaW50IG1ldGhvZCwgdXNlIHRoZSBvbmUgb24gZG9jdW1lbnRcbiAgICB2YXIgZWxlbWVudEF0UG9zaXRpb24gPSBlbGVtZW50RnJvbVBvaW50KHJvb3QsIHtcbiAgICAgIHg6IGUucGFnZVggLSB3aW5kb3cucGFnZVhPZmZzZXQsXG4gICAgICB5OiBlLnBhZ2VZIC0gd2luZG93LnBhZ2VZT2Zmc2V0XG4gICAgfSk7XG5cbiAgICAvLyB0ZXN0IGlmIHRhcmdldCBpcyB0aGUgZWxlbWVudCBvciBpZiBvbmUgb2YgaXRzIGNoaWxkcmVuIGlzXG4gICAgcmV0dXJuIGVsZW1lbnRBdFBvc2l0aW9uID09PSB0YXJnZXQgfHwgdGFyZ2V0LmNvbnRhaW5zKGVsZW1lbnRBdFBvc2l0aW9uKTtcbiAgfTtcblxuICB2YXIgaW5pdGlhbFRhcmdldCA9IG51bGw7XG5cbiAgdmFyIHNldERyb3BFZmZlY3QgPSBmdW5jdGlvbiBzZXREcm9wRWZmZWN0KGRhdGFUcmFuc2ZlciwgZWZmZWN0KSB7XG4gICAgLy8gaXMgaW4gdHJ5IGNhdGNoIGFzIElFMTEgd2lsbCB0aHJvdyBlcnJvciBpZiBub3RcbiAgICB0cnkge1xuICAgICAgZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QgPSBlZmZlY3Q7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfTtcblxuICB2YXIgZHJhZ2VudGVyID0gZnVuY3Rpb24gZHJhZ2VudGVyKHJvb3QsIGNsaWVudHMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICBpbml0aWFsVGFyZ2V0ID0gZS50YXJnZXQ7XG5cbiAgICAgIGNsaWVudHMuZm9yRWFjaChmdW5jdGlvbihjbGllbnQpIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBjbGllbnQuZWxlbWVudCxcbiAgICAgICAgICBvbmVudGVyID0gY2xpZW50Lm9uZW50ZXI7XG5cbiAgICAgICAgaWYgKGlzRXZlbnRUYXJnZXQoZSwgZWxlbWVudCkpIHtcbiAgICAgICAgICBjbGllbnQuc3RhdGUgPSAnZW50ZXInO1xuXG4gICAgICAgICAgLy8gZmlyZSBlbnRlciBldmVudFxuICAgICAgICAgIG9uZW50ZXIoZXZlbnRQb3NpdGlvbihlKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGRyYWdvdmVyID0gZnVuY3Rpb24gZHJhZ292ZXIocm9vdCwgY2xpZW50cykge1xuICAgIHJldHVybiBmdW5jdGlvbihlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIHZhciBkYXRhVHJhbnNmZXIgPSBlLmRhdGFUcmFuc2ZlcjtcblxuICAgICAgcmVxdWVzdERhdGFUcmFuc2Zlckl0ZW1zKGRhdGFUcmFuc2ZlcikudGhlbihmdW5jdGlvbihpdGVtcykge1xuICAgICAgICB2YXIgb3ZlckRyb3BUYXJnZXQgPSBmYWxzZTtcblxuICAgICAgICBjbGllbnRzLnNvbWUoZnVuY3Rpb24oY2xpZW50KSB7XG4gICAgICAgICAgdmFyIGZpbHRlckVsZW1lbnQgPSBjbGllbnQuZmlsdGVyRWxlbWVudCxcbiAgICAgICAgICAgIGVsZW1lbnQgPSBjbGllbnQuZWxlbWVudCxcbiAgICAgICAgICAgIG9uZW50ZXIgPSBjbGllbnQub25lbnRlcixcbiAgICAgICAgICAgIG9uZXhpdCA9IGNsaWVudC5vbmV4aXQsXG4gICAgICAgICAgICBvbmRyYWcgPSBjbGllbnQub25kcmFnLFxuICAgICAgICAgICAgYWxsb3dkcm9wID0gY2xpZW50LmFsbG93ZHJvcDtcblxuICAgICAgICAgIC8vIGJ5IGRlZmF1bHQgd2UgY2FuIGRyb3BcbiAgICAgICAgICBzZXREcm9wRWZmZWN0KGRhdGFUcmFuc2ZlciwgJ2NvcHknKTtcblxuICAgICAgICAgIC8vIGFsbG93IHRyYW5zZmVyIG9mIHRoZXNlIGl0ZW1zXG4gICAgICAgICAgdmFyIGFsbG93c1RyYW5zZmVyID0gYWxsb3dkcm9wKGl0ZW1zKTtcblxuICAgICAgICAgIC8vIG9ubHkgdXNlZCB3aGVuIGNhbiBiZSBkcm9wcGVkIG9uIHBhZ2VcbiAgICAgICAgICBpZiAoIWFsbG93c1RyYW5zZmVyKSB7XG4gICAgICAgICAgICBzZXREcm9wRWZmZWN0KGRhdGFUcmFuc2ZlciwgJ25vbmUnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyB0YXJnZXR0aW5nIHRoaXMgY2xpZW50XG4gICAgICAgICAgaWYgKGlzRXZlbnRUYXJnZXQoZSwgZWxlbWVudCkpIHtcbiAgICAgICAgICAgIG92ZXJEcm9wVGFyZ2V0ID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gaGFkIG5vIHByZXZpb3VzIHN0YXRlLCBtZWFucyB3ZSBhcmUgZW50ZXJpbmcgdGhpcyBjbGllbnRcbiAgICAgICAgICAgIGlmIChjbGllbnQuc3RhdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgY2xpZW50LnN0YXRlID0gJ2VudGVyJztcbiAgICAgICAgICAgICAgb25lbnRlcihldmVudFBvc2l0aW9uKGUpKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBub3cgb3ZlciBlbGVtZW50IChubyBtYXR0ZXIgaWYgaXQgYWxsb3dzIHRoZSBkcm9wIG9yIG5vdClcbiAgICAgICAgICAgIGNsaWVudC5zdGF0ZSA9ICdvdmVyJztcblxuICAgICAgICAgICAgLy8gbmVlZHMgdG8gYWxsb3cgdHJhbnNmZXJcbiAgICAgICAgICAgIGlmIChmaWx0ZXJFbGVtZW50ICYmICFhbGxvd3NUcmFuc2Zlcikge1xuICAgICAgICAgICAgICBzZXREcm9wRWZmZWN0KGRhdGFUcmFuc2ZlciwgJ25vbmUnKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBkcmFnZ2luZ1xuICAgICAgICAgICAgb25kcmFnKGV2ZW50UG9zaXRpb24oZSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBzaG91bGQgYmUgb3ZlciBhbiBlbGVtZW50IHRvIGRyb3BcbiAgICAgICAgICAgIGlmIChmaWx0ZXJFbGVtZW50ICYmICFvdmVyRHJvcFRhcmdldCkge1xuICAgICAgICAgICAgICBzZXREcm9wRWZmZWN0KGRhdGFUcmFuc2ZlciwgJ25vbmUnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbWlnaHQgaGF2ZSBqdXN0IGxlZnQgdGhpcyBjbGllbnQ/XG4gICAgICAgICAgICBpZiAoY2xpZW50LnN0YXRlKSB7XG4gICAgICAgICAgICAgIGNsaWVudC5zdGF0ZSA9IG51bGw7XG4gICAgICAgICAgICAgIG9uZXhpdChldmVudFBvc2l0aW9uKGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgZHJvcCA9IGZ1bmN0aW9uIGRyb3Aocm9vdCwgY2xpZW50cykge1xuICAgIHJldHVybiBmdW5jdGlvbihlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIHZhciBkYXRhVHJhbnNmZXIgPSBlLmRhdGFUcmFuc2ZlcjtcblxuICAgICAgcmVxdWVzdERhdGFUcmFuc2Zlckl0ZW1zKGRhdGFUcmFuc2ZlcikudGhlbihmdW5jdGlvbihpdGVtcykge1xuICAgICAgICBjbGllbnRzLmZvckVhY2goZnVuY3Rpb24oY2xpZW50KSB7XG4gICAgICAgICAgdmFyIGZpbHRlckVsZW1lbnQgPSBjbGllbnQuZmlsdGVyRWxlbWVudCxcbiAgICAgICAgICAgIGVsZW1lbnQgPSBjbGllbnQuZWxlbWVudCxcbiAgICAgICAgICAgIG9uZHJvcCA9IGNsaWVudC5vbmRyb3AsXG4gICAgICAgICAgICBvbmV4aXQgPSBjbGllbnQub25leGl0LFxuICAgICAgICAgICAgYWxsb3dkcm9wID0gY2xpZW50LmFsbG93ZHJvcDtcblxuICAgICAgICAgIGNsaWVudC5zdGF0ZSA9IG51bGw7XG5cbiAgICAgICAgICAvLyBpZiB3ZSdyZSBmaWx0ZXJpbmcgb24gZWxlbWVudCB3ZSBuZWVkIHRvIGJlIG92ZXIgdGhlIGVsZW1lbnQgdG8gZHJvcFxuICAgICAgICAgIGlmIChmaWx0ZXJFbGVtZW50ICYmICFpc0V2ZW50VGFyZ2V0KGUsIGVsZW1lbnQpKSByZXR1cm47XG5cbiAgICAgICAgICAvLyBubyB0cmFuc2ZlciBmb3IgdGhpcyBjbGllbnRcbiAgICAgICAgICBpZiAoIWFsbG93ZHJvcChpdGVtcykpIHJldHVybiBvbmV4aXQoZXZlbnRQb3NpdGlvbihlKSk7XG5cbiAgICAgICAgICAvLyB3ZSBjYW4gZHJvcCB0aGVzZSBpdGVtcyBvbiB0aGlzIGNsaWVudFxuICAgICAgICAgIG9uZHJvcChldmVudFBvc2l0aW9uKGUpLCBpdGVtcyk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgZHJhZ2xlYXZlID0gZnVuY3Rpb24gZHJhZ2xlYXZlKHJvb3QsIGNsaWVudHMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKGluaXRpYWxUYXJnZXQgIT09IGUudGFyZ2V0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY2xpZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGNsaWVudCkge1xuICAgICAgICB2YXIgb25leGl0ID0gY2xpZW50Lm9uZXhpdDtcblxuICAgICAgICBjbGllbnQuc3RhdGUgPSBudWxsO1xuXG4gICAgICAgIG9uZXhpdChldmVudFBvc2l0aW9uKGUpKTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUhvcHBlciA9IGZ1bmN0aW9uIGNyZWF0ZUhvcHBlcihzY29wZSwgdmFsaWRhdGVJdGVtcywgb3B0aW9ucykge1xuICAgIC8vIGlzIG5vdyBob3BwZXIgc2NvcGVcbiAgICBzY29wZS5jbGFzc0xpc3QuYWRkKCdmaWxlcG9uZC0taG9wcGVyJyk7XG5cbiAgICAvLyBzaG9ydGN1dHNcbiAgICB2YXIgY2F0Y2hlc0Ryb3BzT25QYWdlID0gb3B0aW9ucy5jYXRjaGVzRHJvcHNPblBhZ2UsXG4gICAgICByZXF1aXJlc0Ryb3BPbkVsZW1lbnQgPSBvcHRpb25zLnJlcXVpcmVzRHJvcE9uRWxlbWVudCxcbiAgICAgIF9vcHRpb25zJGZpbHRlckl0ZW1zID0gb3B0aW9ucy5maWx0ZXJJdGVtcyxcbiAgICAgIGZpbHRlckl0ZW1zID1cbiAgICAgICAgX29wdGlvbnMkZmlsdGVySXRlbXMgPT09IHZvaWQgMFxuICAgICAgICAgID8gZnVuY3Rpb24oaXRlbXMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIDogX29wdGlvbnMkZmlsdGVySXRlbXM7XG5cbiAgICAvLyBjcmVhdGUgYSBkbmQgY2xpZW50XG4gICAgdmFyIGNsaWVudCA9IGNyZWF0ZURyYWdORHJvcENsaWVudChcbiAgICAgIHNjb3BlLFxuICAgICAgY2F0Y2hlc0Ryb3BzT25QYWdlID8gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IDogc2NvcGUsXG4gICAgICByZXF1aXJlc0Ryb3BPbkVsZW1lbnRcbiAgICApO1xuXG4gICAgLy8gY3VycmVudCBjbGllbnQgc3RhdGVcbiAgICB2YXIgbGFzdFN0YXRlID0gJyc7XG4gICAgdmFyIGN1cnJlbnRTdGF0ZSA9ICcnO1xuXG4gICAgLy8gZGV0ZXJtaW5lcyBpZiBhIGZpbGUgbWF5IGJlIGRyb3BwZWRcbiAgICBjbGllbnQuYWxsb3dkcm9wID0gZnVuY3Rpb24oaXRlbXMpIHtcbiAgICAgIC8vIFRPRE86IGlmIHdlIGNhbiwgdGhyb3cgZXJyb3IgdG8gaW5kaWNhdGUgdGhlIGl0ZW1zIGNhbm5vdCBieSBkcm9wcGVkXG5cbiAgICAgIHJldHVybiB2YWxpZGF0ZUl0ZW1zKGZpbHRlckl0ZW1zKGl0ZW1zKSk7XG4gICAgfTtcblxuICAgIGNsaWVudC5vbmRyb3AgPSBmdW5jdGlvbihwb3NpdGlvbiwgaXRlbXMpIHtcbiAgICAgIHZhciBmaWx0ZXJlZEl0ZW1zID0gZmlsdGVySXRlbXMoaXRlbXMpO1xuXG4gICAgICBpZiAoIXZhbGlkYXRlSXRlbXMoZmlsdGVyZWRJdGVtcykpIHtcbiAgICAgICAgYXBpLm9uZHJhZ2VuZChwb3NpdGlvbik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY3VycmVudFN0YXRlID0gJ2RyYWctZHJvcCc7XG5cbiAgICAgIGFwaS5vbmxvYWQoZmlsdGVyZWRJdGVtcywgcG9zaXRpb24pO1xuICAgIH07XG5cbiAgICBjbGllbnQub25kcmFnID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgICAgIGFwaS5vbmRyYWcocG9zaXRpb24pO1xuICAgIH07XG5cbiAgICBjbGllbnQub25lbnRlciA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG4gICAgICBjdXJyZW50U3RhdGUgPSAnZHJhZy1vdmVyJztcblxuICAgICAgYXBpLm9uZHJhZ3N0YXJ0KHBvc2l0aW9uKTtcbiAgICB9O1xuXG4gICAgY2xpZW50Lm9uZXhpdCA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG4gICAgICBjdXJyZW50U3RhdGUgPSAnZHJhZy1leGl0JztcblxuICAgICAgYXBpLm9uZHJhZ2VuZChwb3NpdGlvbik7XG4gICAgfTtcblxuICAgIHZhciBhcGkgPSB7XG4gICAgICB1cGRhdGVIb3BwZXJTdGF0ZTogZnVuY3Rpb24gdXBkYXRlSG9wcGVyU3RhdGUoKSB7XG4gICAgICAgIGlmIChsYXN0U3RhdGUgIT09IGN1cnJlbnRTdGF0ZSkge1xuICAgICAgICAgIHNjb3BlLmRhdGFzZXQuaG9wcGVyU3RhdGUgPSBjdXJyZW50U3RhdGU7XG4gICAgICAgICAgbGFzdFN0YXRlID0gY3VycmVudFN0YXRlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25sb2FkOiBmdW5jdGlvbiBvbmxvYWQoKSB7fSxcbiAgICAgIG9uZHJhZ3N0YXJ0OiBmdW5jdGlvbiBvbmRyYWdzdGFydCgpIHt9LFxuICAgICAgb25kcmFnOiBmdW5jdGlvbiBvbmRyYWcoKSB7fSxcbiAgICAgIG9uZHJhZ2VuZDogZnVuY3Rpb24gb25kcmFnZW5kKCkge30sXG4gICAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICAvLyBkZXN0cm95IGNsaWVudFxuICAgICAgICBjbGllbnQuZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gYXBpO1xuICB9O1xuXG4gIHZhciBsaXN0ZW5pbmcgPSBmYWxzZTtcbiAgdmFyIGxpc3RlbmVycyQxID0gW107XG5cbiAgdmFyIGhhbmRsZVBhc3RlID0gZnVuY3Rpb24gaGFuZGxlUGFzdGUoZSkge1xuICAgIC8vIGlmIGlzIHBhc3RpbmcgaW4gaW5wdXQgb3IgdGV4dGFyZWEgYW5kIHRoZSB0YXJnZXQgaXMgb3V0c2lkZSBvZiBhIGZpbGVwb25kIHNjb3BlLCBpZ25vcmVcbiAgICB2YXIgYWN0aXZlRWwgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgIGlmIChhY3RpdmVFbCAmJiAvdGV4dGFyZWF8aW5wdXQvaS50ZXN0KGFjdGl2ZUVsLm5vZGVOYW1lKSkge1xuICAgICAgLy8gdGVzdCB0ZXh0YXJlYSBvciBpbnB1dCBpcyBjb250YWluZWQgaW4gZmlsZXBvbmQgcm9vdFxuICAgICAgdmFyIGluU2NvcGUgPSBmYWxzZTtcbiAgICAgIHZhciBlbGVtZW50ID0gYWN0aXZlRWw7XG4gICAgICB3aGlsZSAoZWxlbWVudCAhPT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICBpZiAoZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ2ZpbGVwb25kLS1yb290JykpIHtcbiAgICAgICAgICBpblNjb3BlID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWluU2NvcGUpIHJldHVybjtcbiAgICB9XG5cbiAgICByZXF1ZXN0RGF0YVRyYW5zZmVySXRlbXMoZS5jbGlwYm9hcmREYXRhKS50aGVuKGZ1bmN0aW9uKGZpbGVzKSB7XG4gICAgICAvLyBubyBmaWxlcyByZWNlaXZlZFxuICAgICAgaWYgKCFmaWxlcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBub3RpZnkgbGlzdGVuZXJzIG9mIHJlY2VpdmVkIGZpbGVzXG4gICAgICBsaXN0ZW5lcnMkMS5mb3JFYWNoKGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBsaXN0ZW5lcihmaWxlcyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgbGlzdGVuID0gZnVuY3Rpb24gbGlzdGVuKGNiKSB7XG4gICAgLy8gY2FuJ3QgYWRkIHR3aWNlXG4gICAgaWYgKGxpc3RlbmVycyQxLmluY2x1ZGVzKGNiKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGFkZCBpbml0aWFsIGxpc3RlbmVyXG4gICAgbGlzdGVuZXJzJDEucHVzaChjYik7XG5cbiAgICAvLyBzZXR1cCBwYXN0ZSBsaXN0ZW5lciBmb3IgZW50aXJlIHBhZ2VcbiAgICBpZiAobGlzdGVuaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGlzdGVuaW5nID0gdHJ1ZTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdwYXN0ZScsIGhhbmRsZVBhc3RlKTtcbiAgfTtcblxuICB2YXIgdW5saXN0ZW4gPSBmdW5jdGlvbiB1bmxpc3RlbihsaXN0ZW5lcikge1xuICAgIGFycmF5UmVtb3ZlKGxpc3RlbmVycyQxLCBsaXN0ZW5lcnMkMS5pbmRleE9mKGxpc3RlbmVyKSk7XG5cbiAgICAvLyBjbGVhbiB1cFxuICAgIGlmIChsaXN0ZW5lcnMkMS5sZW5ndGggPT09IDApIHtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Bhc3RlJywgaGFuZGxlUGFzdGUpO1xuICAgICAgbGlzdGVuaW5nID0gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIHZhciBjcmVhdGVQYXN0ZXIgPSBmdW5jdGlvbiBjcmVhdGVQYXN0ZXIoKSB7XG4gICAgdmFyIGNiID0gZnVuY3Rpb24gY2IoZmlsZXMpIHtcbiAgICAgIGFwaS5vbmxvYWQoZmlsZXMpO1xuICAgIH07XG5cbiAgICB2YXIgYXBpID0ge1xuICAgICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgdW5saXN0ZW4oY2IpO1xuICAgICAgfSxcbiAgICAgIG9ubG9hZDogZnVuY3Rpb24gb25sb2FkKCkge31cbiAgICB9O1xuXG4gICAgbGlzdGVuKGNiKTtcblxuICAgIHJldHVybiBhcGk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgdGhlIGZpbGUgdmlld1xuICAgKi9cbiAgdmFyIGNyZWF0ZSRkID0gZnVuY3Rpb24gY3JlYXRlKF9yZWYpIHtcbiAgICB2YXIgcm9vdCA9IF9yZWYucm9vdCxcbiAgICAgIHByb3BzID0gX3JlZi5wcm9wcztcbiAgICByb290LmVsZW1lbnQuaWQgPSAnZmlsZXBvbmQtLWFzc2lzdGFudC0nICsgcHJvcHMuaWQ7XG4gICAgYXR0cihyb290LmVsZW1lbnQsICdyb2xlJywgJ3N0YXR1cycpO1xuICAgIGF0dHIocm9vdC5lbGVtZW50LCAnYXJpYS1saXZlJywgJ3BvbGl0ZScpO1xuICAgIGF0dHIocm9vdC5lbGVtZW50LCAnYXJpYS1yZWxldmFudCcsICdhZGRpdGlvbnMnKTtcbiAgfTtcblxuICB2YXIgYWRkRmlsZXNOb3RpZmljYXRpb25UaW1lb3V0ID0gbnVsbDtcbiAgdmFyIG5vdGlmaWNhdGlvbkNsZWFyVGltZW91dCA9IG51bGw7XG5cbiAgdmFyIGZpbGVuYW1lcyA9IFtdO1xuXG4gIHZhciBhc3Npc3QgPSBmdW5jdGlvbiBhc3Npc3Qocm9vdCwgbWVzc2FnZSkge1xuICAgIHJvb3QuZWxlbWVudC50ZXh0Q29udGVudCA9IG1lc3NhZ2U7XG4gIH07XG5cbiAgdmFyIGNsZWFyJDEgPSBmdW5jdGlvbiBjbGVhcihyb290KSB7XG4gICAgcm9vdC5lbGVtZW50LnRleHRDb250ZW50ID0gJyc7XG4gIH07XG5cbiAgdmFyIGxpc3RNb2RpZmllZCA9IGZ1bmN0aW9uIGxpc3RNb2RpZmllZChyb290LCBmaWxlbmFtZSwgbGFiZWwpIHtcbiAgICB2YXIgdG90YWwgPSByb290LnF1ZXJ5KCdHRVRfVE9UQUxfSVRFTVMnKTtcbiAgICBhc3Npc3QoXG4gICAgICByb290LFxuICAgICAgbGFiZWwgK1xuICAgICAgICAnICcgK1xuICAgICAgICBmaWxlbmFtZSArXG4gICAgICAgICcsICcgK1xuICAgICAgICB0b3RhbCArXG4gICAgICAgICcgJyArXG4gICAgICAgICh0b3RhbCA9PT0gMVxuICAgICAgICAgID8gcm9vdC5xdWVyeSgnR0VUX0xBQkVMX0ZJTEVfQ09VTlRfU0lOR1VMQVInKVxuICAgICAgICAgIDogcm9vdC5xdWVyeSgnR0VUX0xBQkVMX0ZJTEVfQ09VTlRfUExVUkFMJykpXG4gICAgKTtcblxuICAgIC8vIGNsZWFyIGdyb3VwIGFmdGVyIHNldCBhbW91bnQgb2YgdGltZSBzbyB0aGUgc3RhdHVzIGlzIG5vdCByZWFkIHR3aWNlXG4gICAgY2xlYXJUaW1lb3V0KG5vdGlmaWNhdGlvbkNsZWFyVGltZW91dCk7XG4gICAgbm90aWZpY2F0aW9uQ2xlYXJUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIGNsZWFyJDEocm9vdCk7XG4gICAgfSwgMTUwMCk7XG4gIH07XG5cbiAgdmFyIGlzVXNpbmdGaWxlUG9uZCA9IGZ1bmN0aW9uIGlzVXNpbmdGaWxlUG9uZChyb290KSB7XG4gICAgcmV0dXJuIHJvb3QuZWxlbWVudC5wYXJlbnROb2RlLmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpO1xuICB9O1xuXG4gIHZhciBpdGVtQWRkZWQgPSBmdW5jdGlvbiBpdGVtQWRkZWQoX3JlZjIpIHtcbiAgICB2YXIgcm9vdCA9IF9yZWYyLnJvb3QsXG4gICAgICBhY3Rpb24gPSBfcmVmMi5hY3Rpb247XG4gICAgaWYgKCFpc1VzaW5nRmlsZVBvbmQocm9vdCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByb290LmVsZW1lbnQudGV4dENvbnRlbnQgPSAnJztcbiAgICB2YXIgaXRlbSA9IHJvb3QucXVlcnkoJ0dFVF9JVEVNJywgYWN0aW9uLmlkKTtcbiAgICBmaWxlbmFtZXMucHVzaChpdGVtLmZpbGVuYW1lKTtcblxuICAgIGNsZWFyVGltZW91dChhZGRGaWxlc05vdGlmaWNhdGlvblRpbWVvdXQpO1xuICAgIGFkZEZpbGVzTm90aWZpY2F0aW9uVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBsaXN0TW9kaWZpZWQoXG4gICAgICAgIHJvb3QsXG4gICAgICAgIGZpbGVuYW1lcy5qb2luKCcsICcpLFxuICAgICAgICByb290LnF1ZXJ5KCdHRVRfTEFCRUxfRklMRV9BRERFRCcpXG4gICAgICApO1xuXG4gICAgICBmaWxlbmFtZXMubGVuZ3RoID0gMDtcbiAgICB9LCA3NTApO1xuICB9O1xuXG4gIHZhciBpdGVtUmVtb3ZlZCA9IGZ1bmN0aW9uIGl0ZW1SZW1vdmVkKF9yZWYzKSB7XG4gICAgdmFyIHJvb3QgPSBfcmVmMy5yb290LFxuICAgICAgYWN0aW9uID0gX3JlZjMuYWN0aW9uO1xuICAgIGlmICghaXNVc2luZ0ZpbGVQb25kKHJvb3QpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGl0ZW0gPSBhY3Rpb24uaXRlbTtcbiAgICBsaXN0TW9kaWZpZWQocm9vdCwgaXRlbS5maWxlbmFtZSwgcm9vdC5xdWVyeSgnR0VUX0xBQkVMX0ZJTEVfUkVNT1ZFRCcpKTtcbiAgfTtcblxuICB2YXIgaXRlbVByb2Nlc3NlZCA9IGZ1bmN0aW9uIGl0ZW1Qcm9jZXNzZWQoX3JlZjQpIHtcbiAgICB2YXIgcm9vdCA9IF9yZWY0LnJvb3QsXG4gICAgICBhY3Rpb24gPSBfcmVmNC5hY3Rpb247XG4gICAgLy8gd2lsbCBhbHNvIG5vdGlmeSB0aGUgdXNlciB3aGVuIEZpbGVQb25kIGlzIG5vdCBiZWluZyB1c2VkLCBhcyB0aGUgdXNlciBtaWdodCBiZSBvY2N1cGllZCB3aXRoIG90aGVyIGFjdGl2aXRpZXMgd2hpbGUgdXBsb2FkaW5nIGEgZmlsZVxuXG4gICAgdmFyIGl0ZW0gPSByb290LnF1ZXJ5KCdHRVRfSVRFTScsIGFjdGlvbi5pZCk7XG4gICAgdmFyIGZpbGVuYW1lID0gaXRlbS5maWxlbmFtZTtcbiAgICB2YXIgbGFiZWwgPSByb290LnF1ZXJ5KCdHRVRfTEFCRUxfRklMRV9QUk9DRVNTSU5HX0NPTVBMRVRFJyk7XG5cbiAgICBhc3Npc3Qocm9vdCwgZmlsZW5hbWUgKyAnICcgKyBsYWJlbCk7XG4gIH07XG5cbiAgdmFyIGl0ZW1Qcm9jZXNzZWRVbmRvID0gZnVuY3Rpb24gaXRlbVByb2Nlc3NlZFVuZG8oX3JlZjUpIHtcbiAgICB2YXIgcm9vdCA9IF9yZWY1LnJvb3QsXG4gICAgICBhY3Rpb24gPSBfcmVmNS5hY3Rpb247XG4gICAgdmFyIGl0ZW0gPSByb290LnF1ZXJ5KCdHRVRfSVRFTScsIGFjdGlvbi5pZCk7XG4gICAgdmFyIGZpbGVuYW1lID0gaXRlbS5maWxlbmFtZTtcbiAgICB2YXIgbGFiZWwgPSByb290LnF1ZXJ5KCdHRVRfTEFCRUxfRklMRV9QUk9DRVNTSU5HX0FCT1JURUQnKTtcblxuICAgIGFzc2lzdChyb290LCBmaWxlbmFtZSArICcgJyArIGxhYmVsKTtcbiAgfTtcblxuICB2YXIgaXRlbUVycm9yID0gZnVuY3Rpb24gaXRlbUVycm9yKF9yZWY2KSB7XG4gICAgdmFyIHJvb3QgPSBfcmVmNi5yb290LFxuICAgICAgYWN0aW9uID0gX3JlZjYuYWN0aW9uO1xuICAgIHZhciBpdGVtID0gcm9vdC5xdWVyeSgnR0VUX0lURU0nLCBhY3Rpb24uaWQpO1xuICAgIHZhciBmaWxlbmFtZSA9IGl0ZW0uZmlsZW5hbWU7XG5cbiAgICAvLyB3aWxsIGFsc28gbm90aWZ5IHRoZSB1c2VyIHdoZW4gRmlsZVBvbmQgaXMgbm90IGJlaW5nIHVzZWQsIGFzIHRoZSB1c2VyIG1pZ2h0IGJlIG9jY3VwaWVkIHdpdGggb3RoZXIgYWN0aXZpdGllcyB3aGlsZSB1cGxvYWRpbmcgYSBmaWxlXG5cbiAgICBhc3Npc3Qocm9vdCwgYWN0aW9uLnN0YXR1cy5tYWluICsgJyAnICsgZmlsZW5hbWUgKyAnICcgKyBhY3Rpb24uc3RhdHVzLnN1Yik7XG4gIH07XG5cbiAgdmFyIGFzc2lzdGFudCA9IGNyZWF0ZVZpZXcoe1xuICAgIGNyZWF0ZTogY3JlYXRlJGQsXG4gICAgaWdub3JlUmVjdDogdHJ1ZSxcbiAgICBpZ25vcmVSZWN0VXBkYXRlOiB0cnVlLFxuICAgIHdyaXRlOiBjcmVhdGVSb3V0ZSh7XG4gICAgICBESURfTE9BRF9JVEVNOiBpdGVtQWRkZWQsXG4gICAgICBESURfUkVNT1ZFX0lURU06IGl0ZW1SZW1vdmVkLFxuICAgICAgRElEX0NPTVBMRVRFX0lURU1fUFJPQ0VTU0lORzogaXRlbVByb2Nlc3NlZCxcblxuICAgICAgRElEX0FCT1JUX0lURU1fUFJPQ0VTU0lORzogaXRlbVByb2Nlc3NlZFVuZG8sXG4gICAgICBESURfUkVWRVJUX0lURU1fUFJPQ0VTU0lORzogaXRlbVByb2Nlc3NlZFVuZG8sXG5cbiAgICAgIERJRF9USFJPV19JVEVNX1JFTU9WRV9FUlJPUjogaXRlbUVycm9yLFxuICAgICAgRElEX1RIUk9XX0lURU1fTE9BRF9FUlJPUjogaXRlbUVycm9yLFxuICAgICAgRElEX1RIUk9XX0lURU1fSU5WQUxJRDogaXRlbUVycm9yLFxuICAgICAgRElEX1RIUk9XX0lURU1fUFJPQ0VTU0lOR19FUlJPUjogaXRlbUVycm9yXG4gICAgfSksXG5cbiAgICB0YWc6ICdzcGFuJyxcbiAgICBuYW1lOiAnYXNzaXN0YW50J1xuICB9KTtcblxuICB2YXIgdG9DYW1lbHMgPSBmdW5jdGlvbiB0b0NhbWVscyhzdHJpbmcpIHtcbiAgICB2YXIgc2VwYXJhdG9yID1cbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJy0nO1xuICAgIHJldHVybiBzdHJpbmcucmVwbGFjZShuZXcgUmVnRXhwKHNlcGFyYXRvciArICcuJywgJ2cnKSwgZnVuY3Rpb24oc3ViKSB7XG4gICAgICByZXR1cm4gc3ViLmNoYXJBdCgxKS50b1VwcGVyQ2FzZSgpO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBkZWJvdW5jZSA9IGZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMpIHtcbiAgICB2YXIgaW50ZXJ2YWwgPVxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAxNjtcbiAgICB2YXIgaW1taWRpYXRlT25seSA9XG4gICAgICBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRydWU7XG4gICAgdmFyIGxhc3QgPSBEYXRlLm5vdygpO1xuICAgIHZhciB0aW1lb3V0ID0gbnVsbDtcblxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGZvciAoXG4gICAgICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7XG4gICAgICAgIF9rZXkgPCBfbGVuO1xuICAgICAgICBfa2V5KytcbiAgICAgICkge1xuICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuXG4gICAgICB2YXIgZGlzdCA9IERhdGUubm93KCkgLSBsYXN0O1xuXG4gICAgICB2YXIgZm4gPSBmdW5jdGlvbiBmbigpIHtcbiAgICAgICAgbGFzdCA9IERhdGUubm93KCk7XG4gICAgICAgIGZ1bmMuYXBwbHkodm9pZCAwLCBhcmdzKTtcbiAgICAgIH07XG5cbiAgICAgIGlmIChkaXN0IDwgaW50ZXJ2YWwpIHtcbiAgICAgICAgLy8gd2UgbmVlZCB0byBkZWxheSBieSB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIGludGVydmFsIGFuZCBkaXN0XG4gICAgICAgIC8vIGZvciBleGFtcGxlOiBpZiBkaXN0YW5jZSBpcyAxMCBtcyBhbmQgaW50ZXJ2YWwgaXMgMTYgbXMsXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gd2FpdCBhbiBhZGRpdGlvbmFsIDZtcyBiZWZvcmUgY2FsbGluZyB0aGUgZnVuY3Rpb24pXG4gICAgICAgIGlmICghaW1taWRpYXRlT25seSkge1xuICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZuLCBpbnRlcnZhbCAtIGRpc3QpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBnbyFcbiAgICAgICAgZm4oKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIHZhciBNQVhfRklMRVNfTElNSVQgPSAxMDAwMDAwO1xuXG4gIHZhciBwcmV2ZW50ID0gZnVuY3Rpb24gcHJldmVudChlKSB7XG4gICAgcmV0dXJuIGUucHJldmVudERlZmF1bHQoKTtcbiAgfTtcblxuICB2YXIgY3JlYXRlJGUgPSBmdW5jdGlvbiBjcmVhdGUoX3JlZikge1xuICAgIHZhciByb290ID0gX3JlZi5yb290LFxuICAgICAgcHJvcHMgPSBfcmVmLnByb3BzO1xuXG4gICAgLy8gQWRkIGlkXG4gICAgdmFyIGlkID0gcm9vdC5xdWVyeSgnR0VUX0lEJyk7XG4gICAgaWYgKGlkKSB7XG4gICAgICByb290LmVsZW1lbnQuaWQgPSBpZDtcbiAgICB9XG5cbiAgICAvLyBBZGQgY2xhc3NOYW1lXG4gICAgdmFyIGNsYXNzTmFtZSA9IHJvb3QucXVlcnkoJ0dFVF9DTEFTU19OQU1FJyk7XG4gICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgY2xhc3NOYW1lXG4gICAgICAgIC5zcGxpdCgnICcpXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgIHJldHVybiBuYW1lLmxlbmd0aDtcbiAgICAgICAgfSlcbiAgICAgICAgLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgIHJvb3QuZWxlbWVudC5jbGFzc0xpc3QuYWRkKG5hbWUpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBGaWVsZCBsYWJlbFxuICAgIHJvb3QucmVmLmxhYmVsID0gcm9vdC5hcHBlbmRDaGlsZFZpZXcoXG4gICAgICByb290LmNyZWF0ZUNoaWxkVmlldyhcbiAgICAgICAgZHJvcExhYmVsLFxuICAgICAgICBPYmplY3QuYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHRyYW5zbGF0ZVk6IG51bGwsXG4gICAgICAgICAgY2FwdGlvbjogcm9vdC5xdWVyeSgnR0VUX0xBQkVMX0lETEUnKVxuICAgICAgICB9KVxuICAgICAgKVxuICAgICk7XG5cbiAgICAvLyBMaXN0IG9mIGl0ZW1zXG4gICAgcm9vdC5yZWYubGlzdCA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KFxuICAgICAgcm9vdC5jcmVhdGVDaGlsZFZpZXcobGlzdFNjcm9sbGVyLCB7IHRyYW5zbGF0ZVk6IG51bGwgfSlcbiAgICApO1xuXG4gICAgLy8gQmFja2dyb3VuZCBwYW5lbFxuICAgIHJvb3QucmVmLnBhbmVsID0gcm9vdC5hcHBlbmRDaGlsZFZpZXcoXG4gICAgICByb290LmNyZWF0ZUNoaWxkVmlldyhwYW5lbCwgeyBuYW1lOiAncGFuZWwtcm9vdCcgfSlcbiAgICApO1xuXG4gICAgLy8gQXNzaXN0YW50IG5vdGlmaWVzIGFzc2lzdGl2ZSB0ZWNoIHdoZW4gY29udGVudCBjaGFuZ2VzXG4gICAgcm9vdC5yZWYuYXNzaXN0YW50ID0gcm9vdC5hcHBlbmRDaGlsZFZpZXcoXG4gICAgICByb290LmNyZWF0ZUNoaWxkVmlldyhhc3Npc3RhbnQsIE9iamVjdC5hc3NpZ24oe30sIHByb3BzKSlcbiAgICApO1xuXG4gICAgLy8gRGF0YVxuICAgIHJvb3QucmVmLmRhdGEgPSByb290LmFwcGVuZENoaWxkVmlldyhcbiAgICAgIHJvb3QuY3JlYXRlQ2hpbGRWaWV3KGRhdGEsIE9iamVjdC5hc3NpZ24oe30sIHByb3BzKSlcbiAgICApO1xuXG4gICAgLy8gTWVhc3VyZSAodGVzdHMgaWYgZml4ZWQgaGVpZ2h0IHdhcyBzZXQpXG4gICAgLy8gRE9DVFlQRSBuZWVkcyB0byBiZSBzZXQgZm9yIHRoaXMgdG8gd29ya1xuICAgIHJvb3QucmVmLm1lYXN1cmUgPSBjcmVhdGVFbGVtZW50JDEoJ2RpdicpO1xuICAgIHJvb3QucmVmLm1lYXN1cmUuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgIHJvb3QuZWxlbWVudC5hcHBlbmRDaGlsZChyb290LnJlZi5tZWFzdXJlKTtcblxuICAgIC8vIGluZm9ybWF0aW9uIG9uIHRoZSByb290IGhlaWdodCBvciBmaXhlZCBoZWlnaHQgc3RhdHVzXG4gICAgcm9vdC5yZWYuYm91bmRzID0gbnVsbDtcblxuICAgIC8vIGFwcGx5IGluaXRpYWwgc3R5bGUgcHJvcGVydGllc1xuICAgIHJvb3RcbiAgICAgIC5xdWVyeSgnR0VUX1NUWUxFUycpXG4gICAgICAuZmlsdGVyKGZ1bmN0aW9uKHN0eWxlKSB7XG4gICAgICAgIHJldHVybiAhaXNFbXB0eShzdHlsZS52YWx1ZSk7XG4gICAgICB9KVxuICAgICAgLm1hcChmdW5jdGlvbihfcmVmMikge1xuICAgICAgICB2YXIgbmFtZSA9IF9yZWYyLm5hbWUsXG4gICAgICAgICAgdmFsdWUgPSBfcmVmMi52YWx1ZTtcbiAgICAgICAgcm9vdC5lbGVtZW50LmRhdGFzZXRbbmFtZV0gPSB2YWx1ZTtcbiAgICAgIH0pO1xuXG4gICAgLy8gZGV0ZXJtaW5lIGlmIHdpZHRoIGNoYW5nZWRcbiAgICByb290LnJlZi53aWR0aFByZXZpb3VzID0gbnVsbDtcbiAgICByb290LnJlZi53aWR0aFVwZGF0ZWQgPSBkZWJvdW5jZShmdW5jdGlvbigpIHtcbiAgICAgIHJvb3QucmVmLnVwZGF0ZUhpc3RvcnkgPSBbXTtcbiAgICAgIHJvb3QuZGlzcGF0Y2goJ0RJRF9SRVNJWkVfUk9PVCcpO1xuICAgIH0sIDI1MCk7XG5cbiAgICAvLyBoaXN0b3J5IG9mIHVwZGF0ZXNcbiAgICByb290LnJlZi5wcmV2aW91c0FzcGVjdFJhdGlvID0gbnVsbDtcbiAgICByb290LnJlZi51cGRhdGVIaXN0b3J5ID0gW107XG5cbiAgICAvLyBwcmV2ZW50IHNjcm9sbGluZyBhbmQgem9vbWluZyBvbiBpT1MgKG9ubHkgaWYgc3VwcG9ydHMgcG9pbnRlciBldmVudHMsIGZvciB0aGVuIHdlIGNhbiBlbmFibGUgcmVvcmRlcilcbiAgICB2YXIgY2FuSG92ZXIgPSB3aW5kb3cubWF0Y2hNZWRpYSgnKHBvaW50ZXI6IGZpbmUpIGFuZCAoaG92ZXI6IGhvdmVyKScpXG4gICAgICAubWF0Y2hlcztcbiAgICB2YXIgaGFzUG9pbnRlckV2ZW50cyA9ICdQb2ludGVyRXZlbnQnIGluIHdpbmRvdztcbiAgICBpZiAocm9vdC5xdWVyeSgnR0VUX0FMTE9XX1JFT1JERVInKSAmJiBoYXNQb2ludGVyRXZlbnRzICYmICFjYW5Ib3Zlcikge1xuICAgICAgcm9vdC5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHByZXZlbnQsIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gICAgICByb290LmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZ2VzdHVyZXN0YXJ0JywgcHJldmVudCk7XG4gICAgfVxuXG4gICAgLy8gYWRkIGNyZWRpdHNcbiAgICB2YXIgY3JlZGl0cyA9IHJvb3QucXVlcnkoJ0dFVF9DUkVESVRTJyk7XG4gICAgdmFyIGhhc0NyZWRpdHMgPSBjcmVkaXRzLmxlbmd0aCA9PT0gMjtcbiAgICBpZiAoaGFzQ3JlZGl0cykge1xuICAgICAgdmFyIGZyYWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgICBmcmFnLmNsYXNzTmFtZSA9ICdmaWxlcG9uZC0tY3JlZGl0cyc7XG4gICAgICBmcmFnLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuICAgICAgZnJhZy5ocmVmID0gY3JlZGl0c1swXTtcbiAgICAgIGZyYWcudGFiaW5kZXggPSAtMTtcbiAgICAgIGZyYWcudGFyZ2V0ID0gJ19ibGFuayc7XG4gICAgICBmcmFnLnJlbCA9ICdub29wZW5lciBub3JlZmVycmVyJztcbiAgICAgIGZyYWcudGV4dENvbnRlbnQgPSBjcmVkaXRzWzFdO1xuICAgICAgcm9vdC5lbGVtZW50LmFwcGVuZENoaWxkKGZyYWcpO1xuICAgICAgcm9vdC5yZWYuY3JlZGl0cyA9IGZyYWc7XG4gICAgfVxuICB9O1xuXG4gIHZhciB3cml0ZSQ5ID0gZnVuY3Rpb24gd3JpdGUoX3JlZjMpIHtcbiAgICB2YXIgcm9vdCA9IF9yZWYzLnJvb3QsXG4gICAgICBwcm9wcyA9IF9yZWYzLnByb3BzLFxuICAgICAgYWN0aW9ucyA9IF9yZWYzLmFjdGlvbnM7XG5cbiAgICAvLyByb3V0ZSBhY3Rpb25zXG4gICAgcm91dGUkNSh7IHJvb3Q6IHJvb3QsIHByb3BzOiBwcm9wcywgYWN0aW9uczogYWN0aW9ucyB9KTtcblxuICAgIC8vIGFwcGx5IHN0eWxlIHByb3BlcnRpZXNcbiAgICBhY3Rpb25zXG4gICAgICAuZmlsdGVyKGZ1bmN0aW9uKGFjdGlvbikge1xuICAgICAgICByZXR1cm4gL15ESURfU0VUX1NUWUxFXy8udGVzdChhY3Rpb24udHlwZSk7XG4gICAgICB9KVxuICAgICAgLmZpbHRlcihmdW5jdGlvbihhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuICFpc0VtcHR5KGFjdGlvbi5kYXRhLnZhbHVlKTtcbiAgICAgIH0pXG4gICAgICAubWFwKGZ1bmN0aW9uKF9yZWY0KSB7XG4gICAgICAgIHZhciB0eXBlID0gX3JlZjQudHlwZSxcbiAgICAgICAgICBkYXRhID0gX3JlZjQuZGF0YTtcbiAgICAgICAgdmFyIG5hbWUgPSB0b0NhbWVscyh0eXBlLnN1YnN0cig4KS50b0xvd2VyQ2FzZSgpLCAnXycpO1xuICAgICAgICByb290LmVsZW1lbnQuZGF0YXNldFtuYW1lXSA9IGRhdGEudmFsdWU7XG4gICAgICAgIHJvb3QuaW52YWxpZGF0ZUxheW91dCgpO1xuICAgICAgfSk7XG5cbiAgICBpZiAocm9vdC5yZWN0LmVsZW1lbnQuaGlkZGVuKSByZXR1cm47XG5cbiAgICBpZiAocm9vdC5yZWN0LmVsZW1lbnQud2lkdGggIT09IHJvb3QucmVmLndpZHRoUHJldmlvdXMpIHtcbiAgICAgIHJvb3QucmVmLndpZHRoUHJldmlvdXMgPSByb290LnJlY3QuZWxlbWVudC53aWR0aDtcbiAgICAgIHJvb3QucmVmLndpZHRoVXBkYXRlZCgpO1xuICAgIH1cblxuICAgIC8vIGdldCBib3ggYm91bmRzLCB3ZSBkbyB0aGlzIG9ubHkgb25jZVxuICAgIHZhciBib3VuZHMgPSByb290LnJlZi5ib3VuZHM7XG4gICAgaWYgKCFib3VuZHMpIHtcbiAgICAgIGJvdW5kcyA9IHJvb3QucmVmLmJvdW5kcyA9IGNhbGN1bGF0ZVJvb3RCb3VuZGluZ0JveEhlaWdodChyb290KTtcblxuICAgICAgLy8gZGVzdHJveSBtZWFzdXJlIGVsZW1lbnRcbiAgICAgIHJvb3QuZWxlbWVudC5yZW1vdmVDaGlsZChyb290LnJlZi5tZWFzdXJlKTtcbiAgICAgIHJvb3QucmVmLm1lYXN1cmUgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIGdldCBxdWljayByZWZlcmVuY2VzIHRvIHZhcmlvdXMgaGlnaCBsZXZlbCBwYXJ0cyBvZiB0aGUgdXBsb2FkIHRvb2xcbiAgICB2YXIgX3Jvb3QkcmVmID0gcm9vdC5yZWYsXG4gICAgICBob3BwZXIgPSBfcm9vdCRyZWYuaG9wcGVyLFxuICAgICAgbGFiZWwgPSBfcm9vdCRyZWYubGFiZWwsXG4gICAgICBsaXN0ID0gX3Jvb3QkcmVmLmxpc3QsXG4gICAgICBwYW5lbCA9IF9yb290JHJlZi5wYW5lbDtcblxuICAgIC8vIHNldHMgY29ycmVjdCBzdGF0ZSB0byBob3BwZXIgc2NvcGVcbiAgICBpZiAoaG9wcGVyKSB7XG4gICAgICBob3BwZXIudXBkYXRlSG9wcGVyU3RhdGUoKTtcbiAgICB9XG5cbiAgICAvLyBib29sIHRvIGluZGljYXRlIGlmIHdlJ3JlIGZ1bGwgb3Igbm90XG4gICAgdmFyIGFzcGVjdFJhdGlvID0gcm9vdC5xdWVyeSgnR0VUX1BBTkVMX0FTUEVDVF9SQVRJTycpO1xuICAgIHZhciBpc011bHRpSXRlbSA9IHJvb3QucXVlcnkoJ0dFVF9BTExPV19NVUxUSVBMRScpO1xuICAgIHZhciB0b3RhbEl0ZW1zID0gcm9vdC5xdWVyeSgnR0VUX1RPVEFMX0lURU1TJyk7XG4gICAgdmFyIG1heEl0ZW1zID0gaXNNdWx0aUl0ZW1cbiAgICAgID8gcm9vdC5xdWVyeSgnR0VUX01BWF9GSUxFUycpIHx8IE1BWF9GSUxFU19MSU1JVFxuICAgICAgOiAxO1xuICAgIHZhciBhdE1heENhcGFjaXR5ID0gdG90YWxJdGVtcyA9PT0gbWF4SXRlbXM7XG5cbiAgICAvLyBhY3Rpb24gdXNlZCB0byBhZGQgaXRlbVxuICAgIHZhciBhZGRBY3Rpb24gPSBhY3Rpb25zLmZpbmQoZnVuY3Rpb24oYWN0aW9uKSB7XG4gICAgICByZXR1cm4gYWN0aW9uLnR5cGUgPT09ICdESURfQUREX0lURU0nO1xuICAgIH0pO1xuXG4gICAgLy8gaWYgcmVhY2hlZCBtYXggY2FwYWNpdHkgYW5kIHdlJ3ZlIGp1c3QgcmVhY2hlZCBpdFxuICAgIGlmIChhdE1heENhcGFjaXR5ICYmIGFkZEFjdGlvbikge1xuICAgICAgLy8gZ2V0IGludGVyYWN0aW9uIHR5cGVcbiAgICAgIHZhciBpbnRlcmFjdGlvbk1ldGhvZCA9IGFkZEFjdGlvbi5kYXRhLmludGVyYWN0aW9uTWV0aG9kO1xuXG4gICAgICAvLyBoaWRlIGxhYmVsXG4gICAgICBsYWJlbC5vcGFjaXR5ID0gMDtcblxuICAgICAgaWYgKGlzTXVsdGlJdGVtKSB7XG4gICAgICAgIGxhYmVsLnRyYW5zbGF0ZVkgPSAtNDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaW50ZXJhY3Rpb25NZXRob2QgPT09IEludGVyYWN0aW9uTWV0aG9kLkFQSSkge1xuICAgICAgICAgIGxhYmVsLnRyYW5zbGF0ZVggPSA0MDtcbiAgICAgICAgfSBlbHNlIGlmIChpbnRlcmFjdGlvbk1ldGhvZCA9PT0gSW50ZXJhY3Rpb25NZXRob2QuQlJPV1NFKSB7XG4gICAgICAgICAgbGFiZWwudHJhbnNsYXRlWSA9IDQwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxhYmVsLnRyYW5zbGF0ZVkgPSAzMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWF0TWF4Q2FwYWNpdHkpIHtcbiAgICAgIGxhYmVsLm9wYWNpdHkgPSAxO1xuICAgICAgbGFiZWwudHJhbnNsYXRlWCA9IDA7XG4gICAgICBsYWJlbC50cmFuc2xhdGVZID0gMDtcbiAgICB9XG5cbiAgICB2YXIgbGlzdEl0ZW1NYXJnaW4gPSBjYWxjdWxhdGVMaXN0SXRlbU1hcmdpbihyb290KTtcblxuICAgIHZhciBsaXN0SGVpZ2h0ID0gY2FsY3VsYXRlTGlzdEhlaWdodChyb290KTtcblxuICAgIHZhciBsYWJlbEhlaWdodCA9IGxhYmVsLnJlY3QuZWxlbWVudC5oZWlnaHQ7XG4gICAgdmFyIGN1cnJlbnRMYWJlbEhlaWdodCA9ICFpc011bHRpSXRlbSB8fCBhdE1heENhcGFjaXR5ID8gMCA6IGxhYmVsSGVpZ2h0O1xuXG4gICAgdmFyIGxpc3RNYXJnaW5Ub3AgPSBhdE1heENhcGFjaXR5ID8gbGlzdC5yZWN0LmVsZW1lbnQubWFyZ2luVG9wIDogMDtcbiAgICB2YXIgbGlzdE1hcmdpbkJvdHRvbSA9XG4gICAgICB0b3RhbEl0ZW1zID09PSAwID8gMCA6IGxpc3QucmVjdC5lbGVtZW50Lm1hcmdpbkJvdHRvbTtcblxuICAgIHZhciB2aXN1YWxIZWlnaHQgPVxuICAgICAgY3VycmVudExhYmVsSGVpZ2h0ICsgbGlzdE1hcmdpblRvcCArIGxpc3RIZWlnaHQudmlzdWFsICsgbGlzdE1hcmdpbkJvdHRvbTtcbiAgICB2YXIgYm91bmRzSGVpZ2h0ID1cbiAgICAgIGN1cnJlbnRMYWJlbEhlaWdodCArIGxpc3RNYXJnaW5Ub3AgKyBsaXN0SGVpZ2h0LmJvdW5kcyArIGxpc3RNYXJnaW5Cb3R0b207XG5cbiAgICAvLyBsaW5rIGxpc3QgdG8gbGFiZWwgYm90dG9tIHBvc2l0aW9uXG4gICAgbGlzdC50cmFuc2xhdGVZID1cbiAgICAgIE1hdGgubWF4KDAsIGN1cnJlbnRMYWJlbEhlaWdodCAtIGxpc3QucmVjdC5lbGVtZW50Lm1hcmdpblRvcCkgLVxuICAgICAgbGlzdEl0ZW1NYXJnaW4udG9wO1xuXG4gICAgaWYgKGFzcGVjdFJhdGlvKSB7XG4gICAgICAvLyBmaXhlZCBhc3BlY3QgcmF0aW9cblxuICAgICAgLy8gY2FsY3VsYXRlIGhlaWdodCBiYXNlZCBvbiB3aWR0aFxuICAgICAgdmFyIHdpZHRoID0gcm9vdC5yZWN0LmVsZW1lbnQud2lkdGg7XG4gICAgICB2YXIgaGVpZ2h0ID0gd2lkdGggKiBhc3BlY3RSYXRpbztcblxuICAgICAgLy8gY2xlYXIgaGlzdG9yeSBpZiBhc3BlY3QgcmF0aW8gaGFzIGNoYW5nZWRcbiAgICAgIGlmIChhc3BlY3RSYXRpbyAhPT0gcm9vdC5yZWYucHJldmlvdXNBc3BlY3RSYXRpbykge1xuICAgICAgICByb290LnJlZi5wcmV2aW91c0FzcGVjdFJhdGlvID0gYXNwZWN0UmF0aW87XG4gICAgICAgIHJvb3QucmVmLnVwZGF0ZUhpc3RvcnkgPSBbXTtcbiAgICAgIH1cblxuICAgICAgLy8gcmVtZW1iZXIgdGhpcyB3aWR0aFxuICAgICAgdmFyIGhpc3RvcnkgPSByb290LnJlZi51cGRhdGVIaXN0b3J5O1xuICAgICAgaGlzdG9yeS5wdXNoKHdpZHRoKTtcblxuICAgICAgdmFyIE1BWF9CT1VOQ0VTID0gMjtcbiAgICAgIGlmIChoaXN0b3J5Lmxlbmd0aCA+IE1BWF9CT1VOQ0VTICogMikge1xuICAgICAgICB2YXIgbCA9IGhpc3RvcnkubGVuZ3RoO1xuICAgICAgICB2YXIgYm90dG9tID0gbCAtIDEwO1xuICAgICAgICB2YXIgYm91bmNlcyA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSBsOyBpID49IGJvdHRvbTsgaS0tKSB7XG4gICAgICAgICAgaWYgKGhpc3RvcnlbaV0gPT09IGhpc3RvcnlbaSAtIDJdKSB7XG4gICAgICAgICAgICBib3VuY2VzKys7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGJvdW5jZXMgPj0gTUFYX0JPVU5DRVMpIHtcbiAgICAgICAgICAgIC8vIGRvbnQgYWRqdXN0IGhlaWdodFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBmaXggaGVpZ2h0IG9mIHBhbmVsIHNvIGl0IGFkaGVyZXMgdG8gYXNwZWN0IHJhdGlvXG4gICAgICBwYW5lbC5zY2FsYWJsZSA9IGZhbHNlO1xuICAgICAgcGFuZWwuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICAvLyBhdmFpbGFibGUgaGVpZ2h0IGZvciBsaXN0XG4gICAgICB2YXIgbGlzdEF2YWlsYWJsZUhlaWdodCA9XG4gICAgICAgIC8vIHRoZSBoZWlnaHQgb2YgdGhlIHBhbmVsIG1pbnVzIHRoZSBsYWJlbCBoZWlnaHRcbiAgICAgICAgaGVpZ2h0IC1cbiAgICAgICAgY3VycmVudExhYmVsSGVpZ2h0IC1cbiAgICAgICAgLy8gdGhlIHJvb20gd2UgbGVhdmUgb3BlbiBiZXR3ZWVuIHRoZSBlbmQgb2YgdGhlIGxpc3QgYW5kIHRoZSBwYW5lbCBib3R0b21cbiAgICAgICAgKGxpc3RNYXJnaW5Cb3R0b20gLSBsaXN0SXRlbU1hcmdpbi5ib3R0b20pIC1cbiAgICAgICAgLy8gaWYgd2UncmUgZnVsbCB3ZSBuZWVkIHRvIGxlYXZlIHNvbWUgcm9vbSBiZXR3ZWVuIHRoZSB0b3Agb2YgdGhlIHBhbmVsIGFuZCB0aGUgbGlzdFxuICAgICAgICAoYXRNYXhDYXBhY2l0eSA/IGxpc3RNYXJnaW5Ub3AgOiAwKTtcblxuICAgICAgaWYgKGxpc3RIZWlnaHQudmlzdWFsID4gbGlzdEF2YWlsYWJsZUhlaWdodCkge1xuICAgICAgICBsaXN0Lm92ZXJmbG93ID0gbGlzdEF2YWlsYWJsZUhlaWdodDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3Qub3ZlcmZsb3cgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyBzZXQgY29udGFpbmVyIGJvdW5kcyAoc28gcHVzaGVzIHNpYmxpbmdzIGRvd253YXJkcylcbiAgICAgIHJvb3QuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIH0gZWxzZSBpZiAoYm91bmRzLmZpeGVkSGVpZ2h0KSB7XG4gICAgICAvLyBmaXhlZCBoZWlnaHRcblxuICAgICAgLy8gZml4IGhlaWdodCBvZiBwYW5lbFxuICAgICAgcGFuZWwuc2NhbGFibGUgPSBmYWxzZTtcblxuICAgICAgLy8gYXZhaWxhYmxlIGhlaWdodCBmb3IgbGlzdFxuICAgICAgdmFyIF9saXN0QXZhaWxhYmxlSGVpZ2h0ID1cbiAgICAgICAgLy8gdGhlIGhlaWdodCBvZiB0aGUgcGFuZWwgbWludXMgdGhlIGxhYmVsIGhlaWdodFxuICAgICAgICBib3VuZHMuZml4ZWRIZWlnaHQgLVxuICAgICAgICBjdXJyZW50TGFiZWxIZWlnaHQgLVxuICAgICAgICAvLyB0aGUgcm9vbSB3ZSBsZWF2ZSBvcGVuIGJldHdlZW4gdGhlIGVuZCBvZiB0aGUgbGlzdCBhbmQgdGhlIHBhbmVsIGJvdHRvbVxuICAgICAgICAobGlzdE1hcmdpbkJvdHRvbSAtIGxpc3RJdGVtTWFyZ2luLmJvdHRvbSkgLVxuICAgICAgICAvLyBpZiB3ZSdyZSBmdWxsIHdlIG5lZWQgdG8gbGVhdmUgc29tZSByb29tIGJldHdlZW4gdGhlIHRvcCBvZiB0aGUgcGFuZWwgYW5kIHRoZSBsaXN0XG4gICAgICAgIChhdE1heENhcGFjaXR5ID8gbGlzdE1hcmdpblRvcCA6IDApO1xuXG4gICAgICAvLyBzZXQgbGlzdCBoZWlnaHRcbiAgICAgIGlmIChsaXN0SGVpZ2h0LnZpc3VhbCA+IF9saXN0QXZhaWxhYmxlSGVpZ2h0KSB7XG4gICAgICAgIGxpc3Qub3ZlcmZsb3cgPSBfbGlzdEF2YWlsYWJsZUhlaWdodDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3Qub3ZlcmZsb3cgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyBubyBuZWVkIHRvIHNldCBjb250YWluZXIgYm91bmRzIGFzIHRoZXNlIGFyZSBoYW5kbGVzIGJ5IENTUyBmaXhlZCBoZWlnaHRcbiAgICB9IGVsc2UgaWYgKGJvdW5kcy5jYXBwZWRIZWlnaHQpIHtcbiAgICAgIC8vIG1heC1oZWlnaHRcblxuICAgICAgLy8gbm90IGEgZml4ZWQgaGVpZ2h0IHBhbmVsXG4gICAgICB2YXIgaXNDYXBwZWRIZWlnaHQgPSB2aXN1YWxIZWlnaHQgPj0gYm91bmRzLmNhcHBlZEhlaWdodDtcbiAgICAgIHZhciBwYW5lbEhlaWdodCA9IE1hdGgubWluKGJvdW5kcy5jYXBwZWRIZWlnaHQsIHZpc3VhbEhlaWdodCk7XG4gICAgICBwYW5lbC5zY2FsYWJsZSA9IHRydWU7XG4gICAgICBwYW5lbC5oZWlnaHQgPSBpc0NhcHBlZEhlaWdodFxuICAgICAgICA/IHBhbmVsSGVpZ2h0XG4gICAgICAgIDogcGFuZWxIZWlnaHQgLSBsaXN0SXRlbU1hcmdpbi50b3AgLSBsaXN0SXRlbU1hcmdpbi5ib3R0b207XG5cbiAgICAgIC8vIGF2YWlsYWJsZSBoZWlnaHQgZm9yIGxpc3RcbiAgICAgIHZhciBfbGlzdEF2YWlsYWJsZUhlaWdodDIgPVxuICAgICAgICAvLyB0aGUgaGVpZ2h0IG9mIHRoZSBwYW5lbCBtaW51cyB0aGUgbGFiZWwgaGVpZ2h0XG4gICAgICAgIHBhbmVsSGVpZ2h0IC1cbiAgICAgICAgY3VycmVudExhYmVsSGVpZ2h0IC1cbiAgICAgICAgLy8gdGhlIHJvb20gd2UgbGVhdmUgb3BlbiBiZXR3ZWVuIHRoZSBlbmQgb2YgdGhlIGxpc3QgYW5kIHRoZSBwYW5lbCBib3R0b21cbiAgICAgICAgKGxpc3RNYXJnaW5Cb3R0b20gLSBsaXN0SXRlbU1hcmdpbi5ib3R0b20pIC1cbiAgICAgICAgLy8gaWYgd2UncmUgZnVsbCB3ZSBuZWVkIHRvIGxlYXZlIHNvbWUgcm9vbSBiZXR3ZWVuIHRoZSB0b3Agb2YgdGhlIHBhbmVsIGFuZCB0aGUgbGlzdFxuICAgICAgICAoYXRNYXhDYXBhY2l0eSA/IGxpc3RNYXJnaW5Ub3AgOiAwKTtcblxuICAgICAgLy8gc2V0IGxpc3QgaGVpZ2h0IChpZiBpcyBvdmVyZmxvd2luZylcbiAgICAgIGlmIChcbiAgICAgICAgdmlzdWFsSGVpZ2h0ID4gYm91bmRzLmNhcHBlZEhlaWdodCAmJlxuICAgICAgICBsaXN0SGVpZ2h0LnZpc3VhbCA+IF9saXN0QXZhaWxhYmxlSGVpZ2h0MlxuICAgICAgKSB7XG4gICAgICAgIGxpc3Qub3ZlcmZsb3cgPSBfbGlzdEF2YWlsYWJsZUhlaWdodDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0Lm92ZXJmbG93ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gc2V0IGNvbnRhaW5lciBib3VuZHMgKHNvIHB1c2hlcyBzaWJsaW5ncyBkb3dud2FyZHMpXG4gICAgICByb290LmhlaWdodCA9IE1hdGgubWluKFxuICAgICAgICBib3VuZHMuY2FwcGVkSGVpZ2h0LFxuICAgICAgICBib3VuZHNIZWlnaHQgLSBsaXN0SXRlbU1hcmdpbi50b3AgLSBsaXN0SXRlbU1hcmdpbi5ib3R0b21cbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGZsZXhpYmxlIGhlaWdodFxuXG4gICAgICAvLyBub3QgYSBmaXhlZCBoZWlnaHQgcGFuZWxcbiAgICAgIHZhciBpdGVtTWFyZ2luID1cbiAgICAgICAgdG90YWxJdGVtcyA+IDAgPyBsaXN0SXRlbU1hcmdpbi50b3AgKyBsaXN0SXRlbU1hcmdpbi5ib3R0b20gOiAwO1xuICAgICAgcGFuZWwuc2NhbGFibGUgPSB0cnVlO1xuICAgICAgcGFuZWwuaGVpZ2h0ID0gTWF0aC5tYXgobGFiZWxIZWlnaHQsIHZpc3VhbEhlaWdodCAtIGl0ZW1NYXJnaW4pO1xuXG4gICAgICAvLyBzZXQgY29udGFpbmVyIGJvdW5kcyAoc28gcHVzaGVzIHNpYmxpbmdzIGRvd253YXJkcylcbiAgICAgIHJvb3QuaGVpZ2h0ID0gTWF0aC5tYXgobGFiZWxIZWlnaHQsIGJvdW5kc0hlaWdodCAtIGl0ZW1NYXJnaW4pO1xuICAgIH1cblxuICAgIC8vIG1vdmUgY3JlZGl0cyB0byBib3R0b21cbiAgICBpZiAocm9vdC5yZWYuY3JlZGl0cyAmJiBwYW5lbC5oZWlnaHRDdXJyZW50KVxuICAgICAgcm9vdC5yZWYuY3JlZGl0cy5zdHlsZS50cmFuc2Zvcm0gPVxuICAgICAgICAndHJhbnNsYXRlWSgnICsgcGFuZWwuaGVpZ2h0Q3VycmVudCArICdweCknO1xuICB9O1xuXG4gIHZhciBjYWxjdWxhdGVMaXN0SXRlbU1hcmdpbiA9IGZ1bmN0aW9uIGNhbGN1bGF0ZUxpc3RJdGVtTWFyZ2luKHJvb3QpIHtcbiAgICB2YXIgaXRlbSA9IHJvb3QucmVmLmxpc3QuY2hpbGRWaWV3c1swXS5jaGlsZFZpZXdzWzBdO1xuICAgIHJldHVybiBpdGVtXG4gICAgICA/IHtcbiAgICAgICAgICB0b3A6IGl0ZW0ucmVjdC5lbGVtZW50Lm1hcmdpblRvcCxcbiAgICAgICAgICBib3R0b206IGl0ZW0ucmVjdC5lbGVtZW50Lm1hcmdpbkJvdHRvbVxuICAgICAgICB9XG4gICAgICA6IHtcbiAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgYm90dG9tOiAwXG4gICAgICAgIH07XG4gIH07XG5cbiAgdmFyIGNhbGN1bGF0ZUxpc3RIZWlnaHQgPSBmdW5jdGlvbiBjYWxjdWxhdGVMaXN0SGVpZ2h0KHJvb3QpIHtcbiAgICB2YXIgdmlzdWFsID0gMDtcbiAgICB2YXIgYm91bmRzID0gMDtcblxuICAgIC8vIGdldCBmaWxlIGxpc3QgcmVmZXJlbmNlXG4gICAgdmFyIHNjcm9sbExpc3QgPSByb290LnJlZi5saXN0O1xuICAgIHZhciBpdGVtTGlzdCA9IHNjcm9sbExpc3QuY2hpbGRWaWV3c1swXTtcbiAgICB2YXIgdmlzaWJsZUNoaWxkcmVuID0gaXRlbUxpc3QuY2hpbGRWaWV3cy5maWx0ZXIoZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgIHJldHVybiBjaGlsZC5yZWN0LmVsZW1lbnQuaGVpZ2h0O1xuICAgIH0pO1xuICAgIHZhciBjaGlsZHJlbiA9IHJvb3RcbiAgICAgIC5xdWVyeSgnR0VUX0FDVElWRV9JVEVNUycpXG4gICAgICAubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIHZpc2libGVDaGlsZHJlbi5maW5kKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgcmV0dXJuIGNoaWxkLmlkID09PSBpdGVtLmlkO1xuICAgICAgICB9KTtcbiAgICAgIH0pXG4gICAgICAuZmlsdGVyKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICB9KTtcblxuICAgIC8vIG5vIGNoaWxkcmVuLCBkb25lIVxuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDApIHJldHVybiB7IHZpc3VhbDogdmlzdWFsLCBib3VuZHM6IGJvdW5kcyB9O1xuXG4gICAgdmFyIGhvcml6b250YWxTcGFjZSA9IGl0ZW1MaXN0LnJlY3QuZWxlbWVudC53aWR0aDtcbiAgICB2YXIgZHJhZ0luZGV4ID0gZ2V0SXRlbUluZGV4QnlQb3NpdGlvbihcbiAgICAgIGl0ZW1MaXN0LFxuICAgICAgY2hpbGRyZW4sXG4gICAgICBzY3JvbGxMaXN0LmRyYWdDb29yZGluYXRlc1xuICAgICk7XG5cbiAgICB2YXIgY2hpbGRSZWN0ID0gY2hpbGRyZW5bMF0ucmVjdC5lbGVtZW50O1xuXG4gICAgdmFyIGl0ZW1WZXJ0aWNhbE1hcmdpbiA9IGNoaWxkUmVjdC5tYXJnaW5Ub3AgKyBjaGlsZFJlY3QubWFyZ2luQm90dG9tO1xuICAgIHZhciBpdGVtSG9yaXpvbnRhbE1hcmdpbiA9IGNoaWxkUmVjdC5tYXJnaW5MZWZ0ICsgY2hpbGRSZWN0Lm1hcmdpblJpZ2h0O1xuXG4gICAgdmFyIGl0ZW1XaWR0aCA9IGNoaWxkUmVjdC53aWR0aCArIGl0ZW1Ib3Jpem9udGFsTWFyZ2luO1xuICAgIHZhciBpdGVtSGVpZ2h0ID0gY2hpbGRSZWN0LmhlaWdodCArIGl0ZW1WZXJ0aWNhbE1hcmdpbjtcblxuICAgIHZhciBuZXdJdGVtID0gdHlwZW9mIGRyYWdJbmRleCAhPT0gJ3VuZGVmaW5lZCcgJiYgZHJhZ0luZGV4ID49IDAgPyAxIDogMDtcbiAgICB2YXIgcmVtb3ZlZEl0ZW0gPSBjaGlsZHJlbi5maW5kKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICByZXR1cm4gY2hpbGQubWFya2VkRm9yUmVtb3ZhbCAmJiBjaGlsZC5vcGFjaXR5IDwgMC40NTtcbiAgICB9KVxuICAgICAgPyAtMVxuICAgICAgOiAwO1xuICAgIHZhciB2ZXJ0aWNhbEl0ZW1Db3VudCA9IGNoaWxkcmVuLmxlbmd0aCArIG5ld0l0ZW0gKyByZW1vdmVkSXRlbTtcbiAgICB2YXIgaXRlbXNQZXJSb3cgPSBNYXRoLnJvdW5kKGhvcml6b250YWxTcGFjZSAvIGl0ZW1XaWR0aCk7XG5cbiAgICAvLyBzdGFja1xuICAgIGlmIChpdGVtc1BlclJvdyA9PT0gMSkge1xuICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIHZhciBoZWlnaHQgPSBpdGVtLnJlY3QuZWxlbWVudC5oZWlnaHQgKyBpdGVtVmVydGljYWxNYXJnaW47XG4gICAgICAgIGJvdW5kcyArPSBoZWlnaHQ7XG4gICAgICAgIHZpc3VhbCArPSBoZWlnaHQgKiBpdGVtLm9wYWNpdHk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gZ3JpZFxuICAgIGVsc2Uge1xuICAgICAgYm91bmRzID0gTWF0aC5jZWlsKHZlcnRpY2FsSXRlbUNvdW50IC8gaXRlbXNQZXJSb3cpICogaXRlbUhlaWdodDtcbiAgICAgIHZpc3VhbCA9IGJvdW5kcztcbiAgICB9XG5cbiAgICByZXR1cm4geyB2aXN1YWw6IHZpc3VhbCwgYm91bmRzOiBib3VuZHMgfTtcbiAgfTtcblxuICB2YXIgY2FsY3VsYXRlUm9vdEJvdW5kaW5nQm94SGVpZ2h0ID0gZnVuY3Rpb24gY2FsY3VsYXRlUm9vdEJvdW5kaW5nQm94SGVpZ2h0KFxuICAgIHJvb3RcbiAgKSB7XG4gICAgdmFyIGhlaWdodCA9IHJvb3QucmVmLm1lYXN1cmVIZWlnaHQgfHwgbnVsbDtcbiAgICB2YXIgY2FwcGVkSGVpZ2h0ID0gcGFyc2VJbnQocm9vdC5zdHlsZS5tYXhIZWlnaHQsIDEwKSB8fCBudWxsO1xuICAgIHZhciBmaXhlZEhlaWdodCA9IGhlaWdodCA9PT0gMCA/IG51bGwgOiBoZWlnaHQ7XG5cbiAgICByZXR1cm4ge1xuICAgICAgY2FwcGVkSGVpZ2h0OiBjYXBwZWRIZWlnaHQsXG4gICAgICBmaXhlZEhlaWdodDogZml4ZWRIZWlnaHRcbiAgICB9O1xuICB9O1xuXG4gIHZhciBleGNlZWRzTWF4RmlsZXMgPSBmdW5jdGlvbiBleGNlZWRzTWF4RmlsZXMocm9vdCwgaXRlbXMpIHtcbiAgICB2YXIgYWxsb3dSZXBsYWNlID0gcm9vdC5xdWVyeSgnR0VUX0FMTE9XX1JFUExBQ0UnKTtcbiAgICB2YXIgYWxsb3dNdWx0aXBsZSA9IHJvb3QucXVlcnkoJ0dFVF9BTExPV19NVUxUSVBMRScpO1xuICAgIHZhciB0b3RhbEl0ZW1zID0gcm9vdC5xdWVyeSgnR0VUX1RPVEFMX0lURU1TJyk7XG4gICAgdmFyIG1heEl0ZW1zID0gcm9vdC5xdWVyeSgnR0VUX01BWF9GSUxFUycpO1xuXG4gICAgLy8gdG90YWwgYW1vdW50IG9mIGl0ZW1zIGJlaW5nIGRyYWdnZWRcbiAgICB2YXIgdG90YWxCcm93c2VJdGVtcyA9IGl0ZW1zLmxlbmd0aDtcblxuICAgIC8vIGlmIGRvZXMgbm90IGFsbG93IG11bHRpcGxlIGl0ZW1zIGFuZCBkcmFnZ2luZyBtb3JlIHRoYW4gb25lIGl0ZW1cbiAgICBpZiAoIWFsbG93TXVsdGlwbGUgJiYgdG90YWxCcm93c2VJdGVtcyA+IDEpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIGxpbWl0IG1heCBpdGVtcyB0byBvbmUgaWYgbm90IGFsbG93ZWQgdG8gZHJvcCBtdWx0aXBsZSBpdGVtc1xuICAgIG1heEl0ZW1zID0gYWxsb3dNdWx0aXBsZSA/IG1heEl0ZW1zIDogYWxsb3dSZXBsYWNlID8gbWF4SXRlbXMgOiAxO1xuXG4gICAgLy8gbm8gbW9yZSByb29tP1xuICAgIHZhciBoYXNNYXhJdGVtcyA9IGlzSW50KG1heEl0ZW1zKTtcbiAgICBpZiAoaGFzTWF4SXRlbXMgJiYgdG90YWxJdGVtcyArIHRvdGFsQnJvd3NlSXRlbXMgPiBtYXhJdGVtcykge1xuICAgICAgcm9vdC5kaXNwYXRjaCgnRElEX1RIUk9XX01BWF9GSUxFUycsIHtcbiAgICAgICAgc291cmNlOiBpdGVtcyxcbiAgICAgICAgZXJyb3I6IGNyZWF0ZVJlc3BvbnNlKCd3YXJuaW5nJywgMCwgJ01heCBmaWxlcycpXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIHZhciBnZXREcmFnSW5kZXggPSBmdW5jdGlvbiBnZXREcmFnSW5kZXgobGlzdCwgY2hpbGRyZW4sIHBvc2l0aW9uKSB7XG4gICAgdmFyIGl0ZW1MaXN0ID0gbGlzdC5jaGlsZFZpZXdzWzBdO1xuICAgIHJldHVybiBnZXRJdGVtSW5kZXhCeVBvc2l0aW9uKGl0ZW1MaXN0LCBjaGlsZHJlbiwge1xuICAgICAgbGVmdDogcG9zaXRpb24uc2NvcGVMZWZ0IC0gaXRlbUxpc3QucmVjdC5lbGVtZW50LmxlZnQsXG4gICAgICB0b3A6XG4gICAgICAgIHBvc2l0aW9uLnNjb3BlVG9wIC1cbiAgICAgICAgKGxpc3QucmVjdC5vdXRlci50b3AgK1xuICAgICAgICAgIGxpc3QucmVjdC5lbGVtZW50Lm1hcmdpblRvcCArXG4gICAgICAgICAgbGlzdC5yZWN0LmVsZW1lbnQuc2Nyb2xsVG9wKVxuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFbmFibGUgb3IgZGlzYWJsZSBmaWxlIGRyb3AgZnVuY3Rpb25hbGl0eVxuICAgKi9cbiAgdmFyIHRvZ2dsZURyb3AgPSBmdW5jdGlvbiB0b2dnbGVEcm9wKHJvb3QpIHtcbiAgICB2YXIgaXNBbGxvd2VkID0gcm9vdC5xdWVyeSgnR0VUX0FMTE9XX0RST1AnKTtcbiAgICB2YXIgaXNEaXNhYmxlZCA9IHJvb3QucXVlcnkoJ0dFVF9ESVNBQkxFRCcpO1xuICAgIHZhciBlbmFibGVkID0gaXNBbGxvd2VkICYmICFpc0Rpc2FibGVkO1xuICAgIGlmIChlbmFibGVkICYmICFyb290LnJlZi5ob3BwZXIpIHtcbiAgICAgIHZhciBob3BwZXIgPSBjcmVhdGVIb3BwZXIoXG4gICAgICAgIHJvb3QuZWxlbWVudCxcbiAgICAgICAgZnVuY3Rpb24oaXRlbXMpIHtcbiAgICAgICAgICAvLyBhbGxvdyBxdWljayB2YWxpZGF0aW9uIG9mIGRyb3BwZWQgaXRlbXNcbiAgICAgICAgICB2YXIgYmVmb3JlRHJvcEZpbGUgPVxuICAgICAgICAgICAgcm9vdC5xdWVyeSgnR0VUX0JFRk9SRV9EUk9QX0ZJTEUnKSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgIC8vIGFsbCBpdGVtcyBzaG91bGQgYmUgdmFsaWRhdGVkIGJ5IGFsbCBmaWx0ZXJzIGFzIHZhbGlkXG4gICAgICAgICAgdmFyIGRyb3BWYWxpZGF0aW9uID0gcm9vdC5xdWVyeSgnR0VUX0RST1BfVkFMSURBVElPTicpO1xuICAgICAgICAgIHJldHVybiBkcm9wVmFsaWRhdGlvblxuICAgICAgICAgICAgPyBpdGVtcy5ldmVyeShmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgIGFwcGx5RmlsdGVycygnQUxMT1dfSE9QUEVSX0lURU0nLCBpdGVtLCB7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiByb290LnF1ZXJ5XG4gICAgICAgICAgICAgICAgICB9KS5ldmVyeShmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIH0pICYmIGJlZm9yZURyb3BGaWxlKGl0ZW0pXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIDogdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGZpbHRlckl0ZW1zOiBmdW5jdGlvbiBmaWx0ZXJJdGVtcyhpdGVtcykge1xuICAgICAgICAgICAgdmFyIGlnbm9yZWRGaWxlcyA9IHJvb3QucXVlcnkoJ0dFVF9JR05PUkVEX0ZJTEVTJyk7XG4gICAgICAgICAgICByZXR1cm4gaXRlbXMuZmlsdGVyKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgaWYgKGlzRmlsZShpdGVtKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhaWdub3JlZEZpbGVzLmluY2x1ZGVzKGl0ZW0ubmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY2F0Y2hlc0Ryb3BzT25QYWdlOiByb290LnF1ZXJ5KCdHRVRfRFJPUF9PTl9QQUdFJyksXG4gICAgICAgICAgcmVxdWlyZXNEcm9wT25FbGVtZW50OiByb290LnF1ZXJ5KCdHRVRfRFJPUF9PTl9FTEVNRU5UJylcbiAgICAgICAgfVxuICAgICAgKTtcblxuICAgICAgaG9wcGVyLm9ubG9hZCA9IGZ1bmN0aW9uKGl0ZW1zLCBwb3NpdGlvbikge1xuICAgICAgICAvLyBnZXQgaXRlbSBjaGlsZHJlbiBlbGVtZW50cyBhbmQgc29ydCBiYXNlZCBvbiBsaXN0IHNvcnRcbiAgICAgICAgdmFyIGxpc3QgPSByb290LnJlZi5saXN0LmNoaWxkVmlld3NbMF07XG4gICAgICAgIHZhciB2aXNpYmxlQ2hpbGRyZW4gPSBsaXN0LmNoaWxkVmlld3MuZmlsdGVyKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgcmV0dXJuIGNoaWxkLnJlY3QuZWxlbWVudC5oZWlnaHQ7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSByb290XG4gICAgICAgICAgLnF1ZXJ5KCdHRVRfQUNUSVZFX0lURU1TJylcbiAgICAgICAgICAubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiB2aXNpYmxlQ2hpbGRyZW4uZmluZChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgICByZXR1cm4gY2hpbGQuaWQgPT09IGl0ZW0uaWQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgYXBwbHlGaWx0ZXJDaGFpbignQUREX0lURU1TJywgaXRlbXMsIHsgZGlzcGF0Y2g6IHJvb3QuZGlzcGF0Y2ggfSkudGhlbihcbiAgICAgICAgICBmdW5jdGlvbihxdWV1ZSkge1xuICAgICAgICAgICAgLy8gdGhlc2UgZmlsZXMgZG9uJ3QgZml0IHNvIHN0b3AgaGVyZVxuICAgICAgICAgICAgaWYgKGV4Y2VlZHNNYXhGaWxlcyhyb290LCBxdWV1ZSkpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgLy8gZ29cbiAgICAgICAgICAgIHJvb3QuZGlzcGF0Y2goJ0FERF9JVEVNUycsIHtcbiAgICAgICAgICAgICAgaXRlbXM6IHF1ZXVlLFxuICAgICAgICAgICAgICBpbmRleDogZ2V0RHJhZ0luZGV4KHJvb3QucmVmLmxpc3QsIGNoaWxkcmVuLCBwb3NpdGlvbiksXG4gICAgICAgICAgICAgIGludGVyYWN0aW9uTWV0aG9kOiBJbnRlcmFjdGlvbk1ldGhvZC5EUk9QXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAgICAgcm9vdC5kaXNwYXRjaCgnRElEX0RST1AnLCB7IHBvc2l0aW9uOiBwb3NpdGlvbiB9KTtcblxuICAgICAgICByb290LmRpc3BhdGNoKCdESURfRU5EX0RSQUcnLCB7IHBvc2l0aW9uOiBwb3NpdGlvbiB9KTtcbiAgICAgIH07XG5cbiAgICAgIGhvcHBlci5vbmRyYWdzdGFydCA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgIHJvb3QuZGlzcGF0Y2goJ0RJRF9TVEFSVF9EUkFHJywgeyBwb3NpdGlvbjogcG9zaXRpb24gfSk7XG4gICAgICB9O1xuXG4gICAgICBob3BwZXIub25kcmFnID0gZGVib3VuY2UoZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgICAgICAgcm9vdC5kaXNwYXRjaCgnRElEX0RSQUcnLCB7IHBvc2l0aW9uOiBwb3NpdGlvbiB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBob3BwZXIub25kcmFnZW5kID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgICAgICAgcm9vdC5kaXNwYXRjaCgnRElEX0VORF9EUkFHJywgeyBwb3NpdGlvbjogcG9zaXRpb24gfSk7XG4gICAgICB9O1xuXG4gICAgICByb290LnJlZi5ob3BwZXIgPSBob3BwZXI7XG5cbiAgICAgIHJvb3QucmVmLmRyaXAgPSByb290LmFwcGVuZENoaWxkVmlldyhyb290LmNyZWF0ZUNoaWxkVmlldyhkcmlwKSk7XG4gICAgfSBlbHNlIGlmICghZW5hYmxlZCAmJiByb290LnJlZi5ob3BwZXIpIHtcbiAgICAgIHJvb3QucmVmLmhvcHBlci5kZXN0cm95KCk7XG4gICAgICByb290LnJlZi5ob3BwZXIgPSBudWxsO1xuICAgICAgcm9vdC5yZW1vdmVDaGlsZFZpZXcocm9vdC5yZWYuZHJpcCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBFbmFibGUgb3IgZGlzYWJsZSBicm93c2UgZnVuY3Rpb25hbGl0eVxuICAgKi9cbiAgdmFyIHRvZ2dsZUJyb3dzZSA9IGZ1bmN0aW9uIHRvZ2dsZUJyb3dzZShyb290LCBwcm9wcykge1xuICAgIHZhciBpc0FsbG93ZWQgPSByb290LnF1ZXJ5KCdHRVRfQUxMT1dfQlJPV1NFJyk7XG4gICAgdmFyIGlzRGlzYWJsZWQgPSByb290LnF1ZXJ5KCdHRVRfRElTQUJMRUQnKTtcbiAgICB2YXIgZW5hYmxlZCA9IGlzQWxsb3dlZCAmJiAhaXNEaXNhYmxlZDtcbiAgICBpZiAoZW5hYmxlZCAmJiAhcm9vdC5yZWYuYnJvd3Nlcikge1xuICAgICAgcm9vdC5yZWYuYnJvd3NlciA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KFxuICAgICAgICByb290LmNyZWF0ZUNoaWxkVmlldyhcbiAgICAgICAgICBicm93c2VyLFxuICAgICAgICAgIE9iamVjdC5hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgICBvbmxvYWQ6IGZ1bmN0aW9uIG9ubG9hZChpdGVtcykge1xuICAgICAgICAgICAgICBhcHBseUZpbHRlckNoYWluKCdBRERfSVRFTVMnLCBpdGVtcywge1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoOiByb290LmRpc3BhdGNoXG4gICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24ocXVldWUpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGVzZSBmaWxlcyBkb24ndCBmaXQgc28gc3RvcCBoZXJlXG4gICAgICAgICAgICAgICAgaWYgKGV4Y2VlZHNNYXhGaWxlcyhyb290LCBxdWV1ZSkpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgICAgIC8vIGFkZCBpdGVtcyFcbiAgICAgICAgICAgICAgICByb290LmRpc3BhdGNoKCdBRERfSVRFTVMnLCB7XG4gICAgICAgICAgICAgICAgICBpdGVtczogcXVldWUsXG4gICAgICAgICAgICAgICAgICBpbmRleDogLTEsXG4gICAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbk1ldGhvZDogSW50ZXJhY3Rpb25NZXRob2QuQlJPV1NFXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICksXG5cbiAgICAgICAgMFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKCFlbmFibGVkICYmIHJvb3QucmVmLmJyb3dzZXIpIHtcbiAgICAgIHJvb3QucmVtb3ZlQ2hpbGRWaWV3KHJvb3QucmVmLmJyb3dzZXIpO1xuICAgICAgcm9vdC5yZWYuYnJvd3NlciA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBFbmFibGUgb3IgZGlzYWJsZSBwYXN0ZSBmdW5jdGlvbmFsaXR5XG4gICAqL1xuICB2YXIgdG9nZ2xlUGFzdGUgPSBmdW5jdGlvbiB0b2dnbGVQYXN0ZShyb290KSB7XG4gICAgdmFyIGlzQWxsb3dlZCA9IHJvb3QucXVlcnkoJ0dFVF9BTExPV19QQVNURScpO1xuICAgIHZhciBpc0Rpc2FibGVkID0gcm9vdC5xdWVyeSgnR0VUX0RJU0FCTEVEJyk7XG4gICAgdmFyIGVuYWJsZWQgPSBpc0FsbG93ZWQgJiYgIWlzRGlzYWJsZWQ7XG4gICAgaWYgKGVuYWJsZWQgJiYgIXJvb3QucmVmLnBhc3Rlcikge1xuICAgICAgcm9vdC5yZWYucGFzdGVyID0gY3JlYXRlUGFzdGVyKCk7XG4gICAgICByb290LnJlZi5wYXN0ZXIub25sb2FkID0gZnVuY3Rpb24oaXRlbXMpIHtcbiAgICAgICAgYXBwbHlGaWx0ZXJDaGFpbignQUREX0lURU1TJywgaXRlbXMsIHsgZGlzcGF0Y2g6IHJvb3QuZGlzcGF0Y2ggfSkudGhlbihcbiAgICAgICAgICBmdW5jdGlvbihxdWV1ZSkge1xuICAgICAgICAgICAgLy8gdGhlc2UgZmlsZXMgZG9uJ3QgZml0IHNvIHN0b3AgaGVyZVxuICAgICAgICAgICAgaWYgKGV4Y2VlZHNNYXhGaWxlcyhyb290LCBxdWV1ZSkpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgLy8gYWRkIGl0ZW1zIVxuICAgICAgICAgICAgcm9vdC5kaXNwYXRjaCgnQUREX0lURU1TJywge1xuICAgICAgICAgICAgICBpdGVtczogcXVldWUsXG4gICAgICAgICAgICAgIGluZGV4OiAtMSxcbiAgICAgICAgICAgICAgaW50ZXJhY3Rpb25NZXRob2Q6IEludGVyYWN0aW9uTWV0aG9kLlBBU1RFXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoIWVuYWJsZWQgJiYgcm9vdC5yZWYucGFzdGVyKSB7XG4gICAgICByb290LnJlZi5wYXN0ZXIuZGVzdHJveSgpO1xuICAgICAgcm9vdC5yZWYucGFzdGVyID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJvdXRlIGFjdGlvbnNcbiAgICovXG4gIHZhciByb3V0ZSQ1ID0gY3JlYXRlUm91dGUoe1xuICAgIERJRF9TRVRfQUxMT1dfQlJPV1NFOiBmdW5jdGlvbiBESURfU0VUX0FMTE9XX0JST1dTRShfcmVmNSkge1xuICAgICAgdmFyIHJvb3QgPSBfcmVmNS5yb290LFxuICAgICAgICBwcm9wcyA9IF9yZWY1LnByb3BzO1xuICAgICAgdG9nZ2xlQnJvd3NlKHJvb3QsIHByb3BzKTtcbiAgICB9LFxuICAgIERJRF9TRVRfQUxMT1dfRFJPUDogZnVuY3Rpb24gRElEX1NFVF9BTExPV19EUk9QKF9yZWY2KSB7XG4gICAgICB2YXIgcm9vdCA9IF9yZWY2LnJvb3Q7XG4gICAgICB0b2dnbGVEcm9wKHJvb3QpO1xuICAgIH0sXG4gICAgRElEX1NFVF9BTExPV19QQVNURTogZnVuY3Rpb24gRElEX1NFVF9BTExPV19QQVNURShfcmVmNykge1xuICAgICAgdmFyIHJvb3QgPSBfcmVmNy5yb290O1xuICAgICAgdG9nZ2xlUGFzdGUocm9vdCk7XG4gICAgfSxcbiAgICBESURfU0VUX0RJU0FCTEVEOiBmdW5jdGlvbiBESURfU0VUX0RJU0FCTEVEKF9yZWY4KSB7XG4gICAgICB2YXIgcm9vdCA9IF9yZWY4LnJvb3QsXG4gICAgICAgIHByb3BzID0gX3JlZjgucHJvcHM7XG4gICAgICB0b2dnbGVEcm9wKHJvb3QpO1xuICAgICAgdG9nZ2xlUGFzdGUocm9vdCk7XG4gICAgICB0b2dnbGVCcm93c2Uocm9vdCwgcHJvcHMpO1xuICAgICAgdmFyIGlzRGlzYWJsZWQgPSByb290LnF1ZXJ5KCdHRVRfRElTQUJMRUQnKTtcbiAgICAgIGlmIChpc0Rpc2FibGVkKSB7XG4gICAgICAgIHJvb3QuZWxlbWVudC5kYXRhc2V0LmRpc2FibGVkID0gJ2Rpc2FibGVkJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRlbGV0ZSByb290LmVsZW1lbnQuZGF0YXNldC5kaXNhYmxlZDsgPD0gdGhpcyBkb2VzIG5vdCB3b3JrIG9uIGlPUyAxMFxuICAgICAgICByb290LmVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdkYXRhLWRpc2FibGVkJyk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICB2YXIgcm9vdCA9IGNyZWF0ZVZpZXcoe1xuICAgIG5hbWU6ICdyb290JyxcbiAgICByZWFkOiBmdW5jdGlvbiByZWFkKF9yZWY5KSB7XG4gICAgICB2YXIgcm9vdCA9IF9yZWY5LnJvb3Q7XG4gICAgICBpZiAocm9vdC5yZWYubWVhc3VyZSkge1xuICAgICAgICByb290LnJlZi5tZWFzdXJlSGVpZ2h0ID0gcm9vdC5yZWYubWVhc3VyZS5vZmZzZXRIZWlnaHQ7XG4gICAgICB9XG4gICAgfSxcbiAgICBjcmVhdGU6IGNyZWF0ZSRlLFxuICAgIHdyaXRlOiB3cml0ZSQ5LFxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koX3JlZjEwKSB7XG4gICAgICB2YXIgcm9vdCA9IF9yZWYxMC5yb290O1xuICAgICAgaWYgKHJvb3QucmVmLnBhc3Rlcikge1xuICAgICAgICByb290LnJlZi5wYXN0ZXIuZGVzdHJveSgpO1xuICAgICAgfVxuICAgICAgaWYgKHJvb3QucmVmLmhvcHBlcikge1xuICAgICAgICByb290LnJlZi5ob3BwZXIuZGVzdHJveSgpO1xuICAgICAgfVxuICAgICAgcm9vdC5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHByZXZlbnQpO1xuICAgICAgcm9vdC5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2dlc3R1cmVzdGFydCcsIHByZXZlbnQpO1xuICAgIH0sXG4gICAgbWl4aW5zOiB7XG4gICAgICBzdHlsZXM6IFsnaGVpZ2h0J11cbiAgICB9XG4gIH0pO1xuXG4gIC8vIGNyZWF0ZXMgdGhlIGFwcFxuICB2YXIgY3JlYXRlQXBwID0gZnVuY3Rpb24gY3JlYXRlQXBwKCkge1xuICAgIHZhciBpbml0aWFsT3B0aW9ucyA9XG4gICAgICBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIC8vIGxldCBlbGVtZW50XG4gICAgdmFyIG9yaWdpbmFsRWxlbWVudCA9IG51bGw7XG5cbiAgICAvLyBnZXQgZGVmYXVsdCBvcHRpb25zXG4gICAgdmFyIGRlZmF1bHRPcHRpb25zID0gZ2V0T3B0aW9ucygpO1xuXG4gICAgLy8gY3JlYXRlIHRoZSBkYXRhIHN0b3JlLCB0aGlzIHdpbGwgY29udGFpbiBhbGwgb3VyIGFwcCBpbmZvXG4gICAgdmFyIHN0b3JlID0gY3JlYXRlU3RvcmUoXG4gICAgICAvLyBpbml0aWFsIHN0YXRlIChzaG91bGQgYmUgc2VyaWFsaXphYmxlKVxuICAgICAgY3JlYXRlSW5pdGlhbFN0YXRlKGRlZmF1bHRPcHRpb25zKSxcblxuICAgICAgLy8gcXVlcmllc1xuICAgICAgW3F1ZXJpZXMsIGNyZWF0ZU9wdGlvblF1ZXJpZXMoZGVmYXVsdE9wdGlvbnMpXSxcblxuICAgICAgLy8gYWN0aW9uIGhhbmRsZXJzXG4gICAgICBbYWN0aW9ucywgY3JlYXRlT3B0aW9uQWN0aW9ucyhkZWZhdWx0T3B0aW9ucyldXG4gICAgKTtcblxuICAgIC8vIHNldCBpbml0aWFsIG9wdGlvbnNcbiAgICBzdG9yZS5kaXNwYXRjaCgnU0VUX09QVElPTlMnLCB7IG9wdGlvbnM6IGluaXRpYWxPcHRpb25zIH0pO1xuXG4gICAgLy8ga2ljayB0aHJlYWQgaWYgdmlzaWJpbGl0eSBjaGFuZ2VzXG4gICAgdmFyIHZpc2liaWxpdHlIYW5kbGVyID0gZnVuY3Rpb24gdmlzaWJpbGl0eUhhbmRsZXIoKSB7XG4gICAgICBpZiAoZG9jdW1lbnQuaGlkZGVuKSByZXR1cm47XG4gICAgICBzdG9yZS5kaXNwYXRjaCgnS0lDSycpO1xuICAgIH07XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIHZpc2liaWxpdHlIYW5kbGVyKTtcblxuICAgIC8vIHJlLXJlbmRlciBvbiB3aW5kb3cgcmVzaXplIHN0YXJ0IGFuZCBmaW5pc2hcbiAgICB2YXIgcmVzaXplRG9uZVRpbWVyID0gbnVsbDtcbiAgICB2YXIgaXNSZXNpemluZyA9IGZhbHNlO1xuICAgIHZhciBpc1Jlc2l6aW5nSG9yaXpvbnRhbGx5ID0gZmFsc2U7XG4gICAgdmFyIGluaXRpYWxXaW5kb3dXaWR0aCA9IG51bGw7XG4gICAgdmFyIGN1cnJlbnRXaW5kb3dXaWR0aCA9IG51bGw7XG4gICAgdmFyIHJlc2l6ZUhhbmRsZXIgPSBmdW5jdGlvbiByZXNpemVIYW5kbGVyKCkge1xuICAgICAgaWYgKCFpc1Jlc2l6aW5nKSB7XG4gICAgICAgIGlzUmVzaXppbmcgPSB0cnVlO1xuICAgICAgfVxuICAgICAgY2xlYXJUaW1lb3V0KHJlc2l6ZURvbmVUaW1lcik7XG4gICAgICByZXNpemVEb25lVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBpc1Jlc2l6aW5nID0gZmFsc2U7XG4gICAgICAgIGluaXRpYWxXaW5kb3dXaWR0aCA9IG51bGw7XG4gICAgICAgIGN1cnJlbnRXaW5kb3dXaWR0aCA9IG51bGw7XG4gICAgICAgIGlmIChpc1Jlc2l6aW5nSG9yaXpvbnRhbGx5KSB7XG4gICAgICAgICAgaXNSZXNpemluZ0hvcml6b250YWxseSA9IGZhbHNlO1xuICAgICAgICAgIHN0b3JlLmRpc3BhdGNoKCdESURfU1RPUF9SRVNJWkUnKTtcbiAgICAgICAgfVxuICAgICAgfSwgNTAwKTtcbiAgICB9O1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCByZXNpemVIYW5kbGVyKTtcblxuICAgIC8vIHJlbmRlciBpbml0aWFsIHZpZXdcbiAgICB2YXIgdmlldyA9IHJvb3Qoc3RvcmUsIHsgaWQ6IGdldFVuaXF1ZUlkKCkgfSk7XG5cbiAgICAvL1xuICAgIC8vIFBSSVZBVEUgQVBJIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvL1xuICAgIHZhciBpc1Jlc3RpbmcgPSBmYWxzZTtcbiAgICB2YXIgaXNIaWRkZW4gPSBmYWxzZTtcblxuICAgIHZhciByZWFkV3JpdGVBcGkgPSB7XG4gICAgICAvLyBuZWNlc3NhcnkgZm9yIHVwZGF0ZSBsb29wXG5cbiAgICAgIC8qKlxuICAgICAgICogUmVhZHMgZnJvbSBkb20gKG5ldmVyIGNhbGwgbWFudWFsbHkpXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG4gICAgICBfcmVhZDogZnVuY3Rpb24gX3JlYWQoKSB7XG4gICAgICAgIC8vIHRlc3QgaWYgd2UncmUgcmVzaXppbmcgaG9yaXpvbnRhbGx5XG4gICAgICAgIC8vIFRPRE86IHNlZSBpZiB3ZSBjYW4gb3B0aW1pemUgdGhpcyBieSBtZWFzdXJpbmcgcm9vdCByZWN0XG4gICAgICAgIGlmIChpc1Jlc2l6aW5nKSB7XG4gICAgICAgICAgY3VycmVudFdpbmRvd1dpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICAgICAgaWYgKCFpbml0aWFsV2luZG93V2lkdGgpIHtcbiAgICAgICAgICAgIGluaXRpYWxXaW5kb3dXaWR0aCA9IGN1cnJlbnRXaW5kb3dXaWR0aDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhaXNSZXNpemluZ0hvcml6b250YWxseSAmJlxuICAgICAgICAgICAgY3VycmVudFdpbmRvd1dpZHRoICE9PSBpbml0aWFsV2luZG93V2lkdGhcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHN0b3JlLmRpc3BhdGNoKCdESURfU1RBUlRfUkVTSVpFJyk7XG4gICAgICAgICAgICBpc1Jlc2l6aW5nSG9yaXpvbnRhbGx5ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNIaWRkZW4gJiYgaXNSZXN0aW5nKSB7XG4gICAgICAgICAgLy8gdGVzdCBpZiBpcyBubyBsb25nZXIgaGlkZGVuXG4gICAgICAgICAgaXNSZXN0aW5nID0gdmlldy5lbGVtZW50Lm9mZnNldFBhcmVudCA9PT0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHJlc3RpbmcsIG5vIG5lZWQgdG8gcmVhZCBhcyBudW1iZXJzIHdpbGwgc3RpbGwgYWxsIGJlIGNvcnJlY3RcbiAgICAgICAgaWYgKGlzUmVzdGluZykgcmV0dXJuO1xuXG4gICAgICAgIC8vIHJlYWQgdmlldyBkYXRhXG4gICAgICAgIHZpZXcuX3JlYWQoKTtcblxuICAgICAgICAvLyBpZiBpcyBoaWRkZW4gd2UgbmVlZCB0byBrbm93IHNvIHdlIGV4aXQgcmVzdCBtb2RlIHdoZW4gcmV2ZWFsZWRcbiAgICAgICAgaXNIaWRkZW4gPSB2aWV3LnJlY3QuZWxlbWVudC5oaWRkZW47XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFdyaXRlcyB0byBkb20gKG5ldmVyIGNhbGwgbWFudWFsbHkpXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG4gICAgICBfd3JpdGU6IGZ1bmN0aW9uIF93cml0ZSh0cykge1xuICAgICAgICAvLyBnZXQgYWxsIGFjdGlvbnMgZnJvbSBzdG9yZVxuICAgICAgICB2YXIgYWN0aW9ucyA9IHN0b3JlXG4gICAgICAgICAgLnByb2Nlc3NBY3Rpb25RdWV1ZSgpXG5cbiAgICAgICAgICAvLyBmaWx0ZXIgb3V0IHNldCBhY3Rpb25zICh0aGVzZSB3aWxsIGF1dG9tYXRpY2FsbHkgdHJpZ2dlciBESURfU0VUKVxuICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oYWN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gIS9eU0VUXy8udGVzdChhY3Rpb24udHlwZSk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gaWYgd2FzIGlkbGluZyBhbmQgbm8gYWN0aW9ucyBzdG9wIGhlcmVcbiAgICAgICAgaWYgKGlzUmVzdGluZyAmJiAhYWN0aW9ucy5sZW5ndGgpIHJldHVybjtcblxuICAgICAgICAvLyBzb21lIGFjdGlvbnMgbWlnaHQgdHJpZ2dlciBldmVudHNcbiAgICAgICAgcm91dGVBY3Rpb25zVG9FdmVudHMoYWN0aW9ucyk7XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSB2aWV3XG4gICAgICAgIGlzUmVzdGluZyA9IHZpZXcuX3dyaXRlKHRzLCBhY3Rpb25zLCBpc1Jlc2l6aW5nSG9yaXpvbnRhbGx5KTtcblxuICAgICAgICAvLyB3aWxsIGNsZWFuIHVwIGFsbCBhcmNoaXZlZCBpdGVtc1xuICAgICAgICByZW1vdmVSZWxlYXNlZEl0ZW1zKHN0b3JlLnF1ZXJ5KCdHRVRfSVRFTVMnKSk7XG5cbiAgICAgICAgLy8gbm93IGlkbGluZ1xuICAgICAgICBpZiAoaXNSZXN0aW5nKSB7XG4gICAgICAgICAgc3RvcmUucHJvY2Vzc0Rpc3BhdGNoUXVldWUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvL1xuICAgIC8vIEVYUE9TRSBFVkVOVFMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vXG4gICAgdmFyIGNyZWF0ZUV2ZW50ID0gZnVuY3Rpb24gY3JlYXRlRXZlbnQobmFtZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgLy8gY3JlYXRlIGRlZmF1bHQgZXZlbnRcbiAgICAgICAgdmFyIGV2ZW50ID0ge1xuICAgICAgICAgIHR5cGU6IG5hbWVcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBubyBkYXRhIHRvIGFkZFxuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb3B5IHJlbGV2YW50IHByb3BzXG4gICAgICAgIGlmIChkYXRhLmhhc093blByb3BlcnR5KCdlcnJvcicpKSB7XG4gICAgICAgICAgZXZlbnQuZXJyb3IgPSBkYXRhLmVycm9yID8gT2JqZWN0LmFzc2lnbih7fSwgZGF0YS5lcnJvcikgOiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRhdGEuc3RhdHVzKSB7XG4gICAgICAgICAgZXZlbnQuc3RhdHVzID0gT2JqZWN0LmFzc2lnbih7fSwgZGF0YS5zdGF0dXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRhdGEuZmlsZSkge1xuICAgICAgICAgIGV2ZW50Lm91dHB1dCA9IGRhdGEuZmlsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG9ubHkgc291cmNlIGlzIGF2YWlsYWJsZSwgZWxzZSBhZGQgaXRlbSBpZiBwb3NzaWJsZVxuICAgICAgICBpZiAoZGF0YS5zb3VyY2UpIHtcbiAgICAgICAgICBldmVudC5maWxlID0gZGF0YS5zb3VyY2U7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YS5pdGVtIHx8IGRhdGEuaWQpIHtcbiAgICAgICAgICB2YXIgaXRlbSA9IGRhdGEuaXRlbSA/IGRhdGEuaXRlbSA6IHN0b3JlLnF1ZXJ5KCdHRVRfSVRFTScsIGRhdGEuaWQpO1xuICAgICAgICAgIGV2ZW50LmZpbGUgPSBpdGVtID8gY3JlYXRlSXRlbUFQSShpdGVtKSA6IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtYXAgYWxsIGl0ZW1zIGluIGEgcG9zc2libGUgaXRlbXMgYXJyYXlcbiAgICAgICAgaWYgKGRhdGEuaXRlbXMpIHtcbiAgICAgICAgICBldmVudC5pdGVtcyA9IGRhdGEuaXRlbXMubWFwKGNyZWF0ZUl0ZW1BUEkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdGhpcyBpcyBhIHByb2dyZXNzIGV2ZW50IGFkZCB0aGUgcHJvZ3Jlc3MgYW1vdW50XG4gICAgICAgIGlmICgvcHJvZ3Jlc3MvLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICBldmVudC5wcm9ncmVzcyA9IGRhdGEucHJvZ3Jlc3M7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb3B5IHJlbGV2YW50IHByb3BzXG4gICAgICAgIGlmIChkYXRhLmhhc093blByb3BlcnR5KCdvcmlnaW4nKSAmJiBkYXRhLmhhc093blByb3BlcnR5KCd0YXJnZXQnKSkge1xuICAgICAgICAgIGV2ZW50Lm9yaWdpbiA9IGRhdGEub3JpZ2luO1xuICAgICAgICAgIGV2ZW50LnRhcmdldCA9IGRhdGEudGFyZ2V0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGV2ZW50Um91dGVzID0ge1xuICAgICAgRElEX0RFU1RST1k6IGNyZWF0ZUV2ZW50KCdkZXN0cm95JyksXG5cbiAgICAgIERJRF9JTklUOiBjcmVhdGVFdmVudCgnaW5pdCcpLFxuXG4gICAgICBESURfVEhST1dfTUFYX0ZJTEVTOiBjcmVhdGVFdmVudCgnd2FybmluZycpLFxuXG4gICAgICBESURfSU5JVF9JVEVNOiBjcmVhdGVFdmVudCgnaW5pdGZpbGUnKSxcbiAgICAgIERJRF9TVEFSVF9JVEVNX0xPQUQ6IGNyZWF0ZUV2ZW50KCdhZGRmaWxlc3RhcnQnKSxcbiAgICAgIERJRF9VUERBVEVfSVRFTV9MT0FEX1BST0dSRVNTOiBjcmVhdGVFdmVudCgnYWRkZmlsZXByb2dyZXNzJyksXG4gICAgICBESURfTE9BRF9JVEVNOiBjcmVhdGVFdmVudCgnYWRkZmlsZScpLFxuXG4gICAgICBESURfVEhST1dfSVRFTV9JTlZBTElEOiBbY3JlYXRlRXZlbnQoJ2Vycm9yJyksIGNyZWF0ZUV2ZW50KCdhZGRmaWxlJyldLFxuXG4gICAgICBESURfVEhST1dfSVRFTV9MT0FEX0VSUk9SOiBbY3JlYXRlRXZlbnQoJ2Vycm9yJyksIGNyZWF0ZUV2ZW50KCdhZGRmaWxlJyldLFxuXG4gICAgICBESURfVEhST1dfSVRFTV9SRU1PVkVfRVJST1I6IFtcbiAgICAgICAgY3JlYXRlRXZlbnQoJ2Vycm9yJyksXG4gICAgICAgIGNyZWF0ZUV2ZW50KCdyZW1vdmVmaWxlJylcbiAgICAgIF0sXG5cbiAgICAgIERJRF9QUkVQQVJFX09VVFBVVDogY3JlYXRlRXZlbnQoJ3ByZXBhcmVmaWxlJyksXG5cbiAgICAgIERJRF9TVEFSVF9JVEVNX1BST0NFU1NJTkc6IGNyZWF0ZUV2ZW50KCdwcm9jZXNzZmlsZXN0YXJ0JyksXG4gICAgICBESURfVVBEQVRFX0lURU1fUFJPQ0VTU19QUk9HUkVTUzogY3JlYXRlRXZlbnQoJ3Byb2Nlc3NmaWxlcHJvZ3Jlc3MnKSxcbiAgICAgIERJRF9BQk9SVF9JVEVNX1BST0NFU1NJTkc6IGNyZWF0ZUV2ZW50KCdwcm9jZXNzZmlsZWFib3J0JyksXG4gICAgICBESURfQ09NUExFVEVfSVRFTV9QUk9DRVNTSU5HOiBjcmVhdGVFdmVudCgncHJvY2Vzc2ZpbGUnKSxcbiAgICAgIERJRF9DT01QTEVURV9JVEVNX1BST0NFU1NJTkdfQUxMOiBjcmVhdGVFdmVudCgncHJvY2Vzc2ZpbGVzJyksXG4gICAgICBESURfUkVWRVJUX0lURU1fUFJPQ0VTU0lORzogY3JlYXRlRXZlbnQoJ3Byb2Nlc3NmaWxlcmV2ZXJ0JyksXG5cbiAgICAgIERJRF9USFJPV19JVEVNX1BST0NFU1NJTkdfRVJST1I6IFtcbiAgICAgICAgY3JlYXRlRXZlbnQoJ2Vycm9yJyksXG4gICAgICAgIGNyZWF0ZUV2ZW50KCdwcm9jZXNzZmlsZScpXG4gICAgICBdLFxuXG4gICAgICBESURfUkVNT1ZFX0lURU06IGNyZWF0ZUV2ZW50KCdyZW1vdmVmaWxlJyksXG5cbiAgICAgIERJRF9VUERBVEVfSVRFTVM6IGNyZWF0ZUV2ZW50KCd1cGRhdGVmaWxlcycpLFxuXG4gICAgICBESURfQUNUSVZBVEVfSVRFTTogY3JlYXRlRXZlbnQoJ2FjdGl2YXRlZmlsZScpLFxuXG4gICAgICBESURfUkVPUkRFUl9JVEVNUzogY3JlYXRlRXZlbnQoJ3Jlb3JkZXJmaWxlcycpXG4gICAgfTtcblxuICAgIHZhciBleHBvc2VFdmVudCA9IGZ1bmN0aW9uIGV4cG9zZUV2ZW50KGV2ZW50KSB7XG4gICAgICAvLyBjcmVhdGUgZXZlbnQgb2JqZWN0IHRvIGJlIGRpc3BhdGNoZWRcbiAgICAgIHZhciBkZXRhaWwgPSBPYmplY3QuYXNzaWduKHsgcG9uZDogZXhwb3J0cyB9LCBldmVudCk7XG4gICAgICBkZWxldGUgZGV0YWlsLnR5cGU7XG4gICAgICB2aWV3LmVsZW1lbnQuZGlzcGF0Y2hFdmVudChcbiAgICAgICAgbmV3IEN1c3RvbUV2ZW50KCdGaWxlUG9uZDonICsgZXZlbnQudHlwZSwge1xuICAgICAgICAgIC8vIGV2ZW50IGluZm9cbiAgICAgICAgICBkZXRhaWw6IGRldGFpbCxcblxuICAgICAgICAgIC8vIGV2ZW50IGJlaGF2aW91clxuICAgICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb21wb3NlZDogdHJ1ZSAvLyB0cmlnZ2VycyBsaXN0ZW5lcnMgb3V0c2lkZSBvZiBzaGFkb3cgcm9vdFxuICAgICAgICB9KVxuICAgICAgKTtcblxuICAgICAgLy8gZXZlbnQgb2JqZWN0IHRvIHBhcmFtcyB1c2VkIGZvciBgb24oKWAgZXZlbnQgaGFuZGxlcnMgYW5kIGNhbGxiYWNrcyBgb25pbml0KClgXG4gICAgICB2YXIgcGFyYW1zID0gW107XG5cbiAgICAgIC8vIGlmIGlzIHBvc3NpYmxlIGVycm9yIGV2ZW50LCBtYWtlIGl0IHRoZSBmaXJzdCBwYXJhbVxuICAgICAgaWYgKGV2ZW50Lmhhc093blByb3BlcnR5KCdlcnJvcicpKSB7XG4gICAgICAgIHBhcmFtcy5wdXNoKGV2ZW50LmVycm9yKTtcbiAgICAgIH1cblxuICAgICAgLy8gZmlsZSBpcyBhbHdheXMgc2VjdGlvblxuICAgICAgaWYgKGV2ZW50Lmhhc093blByb3BlcnR5KCdmaWxlJykpIHtcbiAgICAgICAgcGFyYW1zLnB1c2goZXZlbnQuZmlsZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGFwcGVuZCBvdGhlciBwcm9wc1xuICAgICAgdmFyIGZpbHRlcmVkID0gWyd0eXBlJywgJ2Vycm9yJywgJ2ZpbGUnXTtcbiAgICAgIE9iamVjdC5rZXlzKGV2ZW50KVxuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgIHJldHVybiAhZmlsdGVyZWQuaW5jbHVkZXMoa2V5KTtcbiAgICAgICAgfSlcbiAgICAgICAgLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIHBhcmFtcy5wdXNoKGV2ZW50W2tleV0pO1xuICAgICAgICB9KTtcblxuICAgICAgLy8gb24odHlwZSwgKCkgPT4geyB9KVxuICAgICAgZXhwb3J0cy5maXJlLmFwcGx5KGV4cG9ydHMsIFtldmVudC50eXBlXS5jb25jYXQocGFyYW1zKSk7XG5cbiAgICAgIC8vIG9uaW5pdCA9ICgpID0+IHt9XG4gICAgICB2YXIgaGFuZGxlciA9IHN0b3JlLnF1ZXJ5KCdHRVRfT04nICsgZXZlbnQudHlwZS50b1VwcGVyQ2FzZSgpKTtcbiAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgIGhhbmRsZXIuYXBwbHkodm9pZCAwLCBwYXJhbXMpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgcm91dGVBY3Rpb25zVG9FdmVudHMgPSBmdW5jdGlvbiByb3V0ZUFjdGlvbnNUb0V2ZW50cyhhY3Rpb25zKSB7XG4gICAgICBpZiAoIWFjdGlvbnMubGVuZ3RoKSByZXR1cm47XG4gICAgICBhY3Rpb25zXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oYWN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIGV2ZW50Um91dGVzW2FjdGlvbi50eXBlXTtcbiAgICAgICAgfSlcbiAgICAgICAgLmZvckVhY2goZnVuY3Rpb24oYWN0aW9uKSB7XG4gICAgICAgICAgdmFyIHJvdXRlcyA9IGV2ZW50Um91dGVzW2FjdGlvbi50eXBlXTtcbiAgICAgICAgICAoQXJyYXkuaXNBcnJheShyb3V0ZXMpID8gcm91dGVzIDogW3JvdXRlc10pLmZvckVhY2goZnVuY3Rpb24ocm91dGUpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXNuJ3QgZmFudGFzdGljLCBidXQgYmVjYXVzZSBvZiB0aGUgc3RhY2tpbmcgb2Ygc2V0dGltZW91dHMgcGx1Z2lucyBjYW4gaGFuZGxlIHRoZSBkaWRfbG9hZCBiZWZvcmUgdGhlIGRpZF9pbml0XG4gICAgICAgICAgICBpZiAoYWN0aW9uLnR5cGUgPT09ICdESURfSU5JVF9JVEVNJykge1xuICAgICAgICAgICAgICBleHBvc2VFdmVudChyb3V0ZShhY3Rpb24uZGF0YSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBleHBvc2VFdmVudChyb3V0ZShhY3Rpb24uZGF0YSkpO1xuICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vXG4gICAgLy8gUFVCTElDIEFQSSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy9cbiAgICB2YXIgc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgcmV0dXJuIHN0b3JlLmRpc3BhdGNoKCdTRVRfT1BUSU9OUycsIHsgb3B0aW9uczogb3B0aW9ucyB9KTtcbiAgICB9O1xuXG4gICAgdmFyIGdldEZpbGUgPSBmdW5jdGlvbiBnZXRGaWxlKHF1ZXJ5KSB7XG4gICAgICByZXR1cm4gc3RvcmUucXVlcnkoJ0dFVF9BQ1RJVkVfSVRFTScsIHF1ZXJ5KTtcbiAgICB9O1xuXG4gICAgdmFyIHByZXBhcmVGaWxlID0gZnVuY3Rpb24gcHJlcGFyZUZpbGUocXVlcnkpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgc3RvcmUuZGlzcGF0Y2goJ1JFUVVFU1RfSVRFTV9QUkVQQVJFJywge1xuICAgICAgICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiBzdWNjZXNzKGl0ZW0pIHtcbiAgICAgICAgICAgIHJlc29sdmUoaXRlbSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBmYWlsdXJlOiBmdW5jdGlvbiBmYWlsdXJlKGVycm9yKSB7XG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIGFkZEZpbGUgPSBmdW5jdGlvbiBhZGRGaWxlKHNvdXJjZSkge1xuICAgICAgdmFyIG9wdGlvbnMgPVxuICAgICAgICBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBhZGRGaWxlcyhbeyBzb3VyY2U6IHNvdXJjZSwgb3B0aW9uczogb3B0aW9ucyB9XSwge1xuICAgICAgICAgIGluZGV4OiBvcHRpb25zLmluZGV4XG4gICAgICAgIH0pXG4gICAgICAgICAgLnRoZW4oZnVuY3Rpb24oaXRlbXMpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGl0ZW1zICYmIGl0ZW1zWzBdKTtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5jYXRjaChyZWplY3QpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBpc0ZpbGVQb25kRmlsZSA9IGZ1bmN0aW9uIGlzRmlsZVBvbmRGaWxlKG9iaikge1xuICAgICAgcmV0dXJuIG9iai5maWxlICYmIG9iai5pZDtcbiAgICB9O1xuXG4gICAgdmFyIHJlbW92ZUZpbGUgPSBmdW5jdGlvbiByZW1vdmVGaWxlKHF1ZXJ5LCBvcHRpb25zKSB7XG4gICAgICAvLyBpZiBvbmx5IHBhc3NlZCBvcHRpb25zXG4gICAgICBpZiAodHlwZW9mIHF1ZXJ5ID09PSAnb2JqZWN0JyAmJiAhaXNGaWxlUG9uZEZpbGUocXVlcnkpICYmICFvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBxdWVyeTtcbiAgICAgICAgcXVlcnkgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIC8vIHJlcXVlc3QgaXRlbSByZW1vdmFsXG4gICAgICBzdG9yZS5kaXNwYXRjaChcbiAgICAgICAgJ1JFTU9WRV9JVEVNJyxcbiAgICAgICAgT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywgeyBxdWVyeTogcXVlcnkgfSlcbiAgICAgICk7XG5cbiAgICAgIC8vIHNlZSBpZiBpdGVtIGhhcyBiZWVuIHJlbW92ZWRcbiAgICAgIHJldHVybiBzdG9yZS5xdWVyeSgnR0VUX0FDVElWRV9JVEVNJywgcXVlcnkpID09PSBudWxsO1xuICAgIH07XG5cbiAgICB2YXIgYWRkRmlsZXMgPSBmdW5jdGlvbiBhZGRGaWxlcygpIHtcbiAgICAgIGZvciAoXG4gICAgICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7XG4gICAgICAgIF9rZXkgPCBfbGVuO1xuICAgICAgICBfa2V5KytcbiAgICAgICkge1xuICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgc291cmNlcyA9IFtdO1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHt9O1xuXG4gICAgICAgIC8vIHVzZXIgcGFzc2VkIGEgc291cmNlcyBhcnJheVxuICAgICAgICBpZiAoaXNBcnJheShhcmdzWzBdKSkge1xuICAgICAgICAgIHNvdXJjZXMucHVzaC5hcHBseShzb3VyY2VzLCBhcmdzWzBdKTtcbiAgICAgICAgICBPYmplY3QuYXNzaWduKG9wdGlvbnMsIGFyZ3NbMV0gfHwge30pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHVzZXIgcGFzc2VkIHNvdXJjZXMgYXMgYXJndW1lbnRzLCBsYXN0IG9uZSBtaWdodCBiZSBvcHRpb25zIG9iamVjdFxuICAgICAgICAgIHZhciBsYXN0QXJndW1lbnQgPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV07XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgdHlwZW9mIGxhc3RBcmd1bWVudCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICEobGFzdEFyZ3VtZW50IGluc3RhbmNlb2YgQmxvYilcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ob3B0aW9ucywgYXJncy5wb3AoKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gYWRkIHJlc3QgdG8gc291cmNlc1xuICAgICAgICAgIHNvdXJjZXMucHVzaC5hcHBseShzb3VyY2VzLCBhcmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0b3JlLmRpc3BhdGNoKCdBRERfSVRFTVMnLCB7XG4gICAgICAgICAgaXRlbXM6IHNvdXJjZXMsXG4gICAgICAgICAgaW5kZXg6IG9wdGlvbnMuaW5kZXgsXG4gICAgICAgICAgaW50ZXJhY3Rpb25NZXRob2Q6IEludGVyYWN0aW9uTWV0aG9kLkFQSSxcbiAgICAgICAgICBzdWNjZXNzOiByZXNvbHZlLFxuICAgICAgICAgIGZhaWx1cmU6IHJlamVjdFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0RmlsZXMgPSBmdW5jdGlvbiBnZXRGaWxlcygpIHtcbiAgICAgIHJldHVybiBzdG9yZS5xdWVyeSgnR0VUX0FDVElWRV9JVEVNUycpO1xuICAgIH07XG5cbiAgICB2YXIgcHJvY2Vzc0ZpbGUgPSBmdW5jdGlvbiBwcm9jZXNzRmlsZShxdWVyeSkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBzdG9yZS5kaXNwYXRjaCgnUkVRVUVTVF9JVEVNX1BST0NFU1NJTkcnLCB7XG4gICAgICAgICAgcXVlcnk6IHF1ZXJ5LFxuICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIHN1Y2Nlc3MoaXRlbSkge1xuICAgICAgICAgICAgcmVzb2x2ZShpdGVtKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGZhaWx1cmU6IGZ1bmN0aW9uIGZhaWx1cmUoZXJyb3IpIHtcbiAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgcHJlcGFyZUZpbGVzID0gZnVuY3Rpb24gcHJlcGFyZUZpbGVzKCkge1xuICAgICAgZm9yIChcbiAgICAgICAgdmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDtcbiAgICAgICAgX2tleTIgPCBfbGVuMjtcbiAgICAgICAgX2tleTIrK1xuICAgICAgKSB7XG4gICAgICAgIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cbiAgICAgIHZhciBxdWVyaWVzID0gQXJyYXkuaXNBcnJheShhcmdzWzBdKSA/IGFyZ3NbMF0gOiBhcmdzO1xuICAgICAgdmFyIGl0ZW1zID0gcXVlcmllcy5sZW5ndGggPyBxdWVyaWVzIDogZ2V0RmlsZXMoKTtcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChpdGVtcy5tYXAocHJlcGFyZUZpbGUpKTtcbiAgICB9O1xuXG4gICAgdmFyIHByb2Nlc3NGaWxlcyA9IGZ1bmN0aW9uIHByb2Nlc3NGaWxlcygpIHtcbiAgICAgIGZvciAoXG4gICAgICAgIHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjMpLCBfa2V5MyA9IDA7XG4gICAgICAgIF9rZXkzIDwgX2xlbjM7XG4gICAgICAgIF9rZXkzKytcbiAgICAgICkge1xuICAgICAgICBhcmdzW19rZXkzXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gICAgICB9XG4gICAgICB2YXIgcXVlcmllcyA9IEFycmF5LmlzQXJyYXkoYXJnc1swXSkgPyBhcmdzWzBdIDogYXJncztcbiAgICAgIGlmICghcXVlcmllcy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGZpbGVzID0gZ2V0RmlsZXMoKS5maWx0ZXIoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAhKFxuICAgICAgICAgICAgICBpdGVtLnN0YXR1cyA9PT0gSXRlbVN0YXR1cy5JRExFICYmXG4gICAgICAgICAgICAgIGl0ZW0ub3JpZ2luID09PSBGaWxlT3JpZ2luLkxPQ0FMXG4gICAgICAgICAgICApICYmXG4gICAgICAgICAgICBpdGVtLnN0YXR1cyAhPT0gSXRlbVN0YXR1cy5QUk9DRVNTSU5HICYmXG4gICAgICAgICAgICBpdGVtLnN0YXR1cyAhPT0gSXRlbVN0YXR1cy5QUk9DRVNTSU5HX0NPTVBMRVRFICYmXG4gICAgICAgICAgICBpdGVtLnN0YXR1cyAhPT0gSXRlbVN0YXR1cy5QUk9DRVNTSU5HX1JFVkVSVF9FUlJPUlxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChmaWxlcy5tYXAocHJvY2Vzc0ZpbGUpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChxdWVyaWVzLm1hcChwcm9jZXNzRmlsZSkpO1xuICAgIH07XG5cbiAgICB2YXIgcmVtb3ZlRmlsZXMgPSBmdW5jdGlvbiByZW1vdmVGaWxlcygpIHtcbiAgICAgIGZvciAoXG4gICAgICAgIHZhciBfbGVuNCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjQpLCBfa2V5NCA9IDA7XG4gICAgICAgIF9rZXk0IDwgX2xlbjQ7XG4gICAgICAgIF9rZXk0KytcbiAgICAgICkge1xuICAgICAgICBhcmdzW19rZXk0XSA9IGFyZ3VtZW50c1tfa2V5NF07XG4gICAgICB9XG5cbiAgICAgIHZhciBxdWVyaWVzID0gQXJyYXkuaXNBcnJheShhcmdzWzBdKSA/IGFyZ3NbMF0gOiBhcmdzO1xuXG4gICAgICB2YXIgb3B0aW9ucztcbiAgICAgIGlmICh0eXBlb2YgcXVlcmllc1txdWVyaWVzLmxlbmd0aCAtIDFdID09PSAnb2JqZWN0Jykge1xuICAgICAgICBvcHRpb25zID0gcXVlcmllcy5wb3AoKTtcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcmdzWzBdKSkge1xuICAgICAgICBvcHRpb25zID0gYXJnc1sxXTtcbiAgICAgIH1cblxuICAgICAgdmFyIGZpbGVzID0gZ2V0RmlsZXMoKTtcblxuICAgICAgaWYgKCFxdWVyaWVzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFxuICAgICAgICAgIGZpbGVzLm1hcChmdW5jdGlvbihmaWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVtb3ZlRmlsZShmaWxlLCBvcHRpb25zKTtcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuXG4gICAgICAvLyB3aGVuIHJlbW92aW5nIGJ5IGluZGV4IHRoZSBpbmRleGVzIHNoaWZ0IGFmdGVyIGVhY2ggZmlsZSByZW1vdmFsIHNvIHdlIG5lZWQgdG8gY29udmVydCBpbmRleGVzIHRvIGlkc1xuICAgICAgdmFyIG1hcHBlZFF1ZXJpZXMgPSBxdWVyaWVzXG4gICAgICAgIC5tYXAoZnVuY3Rpb24ocXVlcnkpIHtcbiAgICAgICAgICByZXR1cm4gaXNOdW1iZXIocXVlcnkpXG4gICAgICAgICAgICA/IGZpbGVzW3F1ZXJ5XVxuICAgICAgICAgICAgICA/IGZpbGVzW3F1ZXJ5XS5pZFxuICAgICAgICAgICAgICA6IG51bGxcbiAgICAgICAgICAgIDogcXVlcnk7XG4gICAgICAgIH0pXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24ocXVlcnkpIHtcbiAgICAgICAgICByZXR1cm4gcXVlcnk7XG4gICAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gbWFwcGVkUXVlcmllcy5tYXAoZnVuY3Rpb24ocSkge1xuICAgICAgICByZXR1cm4gcmVtb3ZlRmlsZShxLCBvcHRpb25zKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgZXhwb3J0cyA9IE9iamVjdC5hc3NpZ24oXG4gICAgICB7fSxcblxuICAgICAgb24oKSxcbiAgICAgIHt9LFxuXG4gICAgICByZWFkV3JpdGVBcGksXG4gICAgICB7fSxcblxuICAgICAgY3JlYXRlT3B0aW9uQVBJKHN0b3JlLCBkZWZhdWx0T3B0aW9ucyksXG4gICAgICB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPdmVycmlkZSBvcHRpb25zIGRlZmluZWQgaW4gb3B0aW9ucyBvYmplY3RcbiAgICAgICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgICAgICovXG4gICAgICAgIHNldE9wdGlvbnM6IHNldE9wdGlvbnMsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIExvYWQgdGhlIGdpdmVuIGZpbGVcbiAgICAgICAgICogQHBhcmFtIHNvdXJjZSAtIHRoZSBzb3VyY2Ugb2YgdGhlIGZpbGUgKGVpdGhlciBhIEZpbGUsIGJhc2U2NCBkYXRhIHVyaSBvciB1cmwpXG4gICAgICAgICAqIEBwYXJhbSBvcHRpb25zIC0gb2JqZWN0LCB7IGluZGV4OiAwIH1cbiAgICAgICAgICovXG4gICAgICAgIGFkZEZpbGU6IGFkZEZpbGUsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIExvYWQgdGhlIGdpdmVuIGZpbGVzXG4gICAgICAgICAqIEBwYXJhbSBzb3VyY2VzIC0gdGhlIHNvdXJjZXMgb2YgdGhlIGZpbGVzIHRvIGxvYWRcbiAgICAgICAgICogQHBhcmFtIG9wdGlvbnMgLSBvYmplY3QsIHsgaW5kZXg6IDAgfVxuICAgICAgICAgKi9cbiAgICAgICAgYWRkRmlsZXM6IGFkZEZpbGVzLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBmaWxlIG9iamVjdHMgbWF0Y2hpbmcgdGhlIGdpdmVuIHF1ZXJ5XG4gICAgICAgICAqIEBwYXJhbSBxdWVyeSB7IHN0cmluZywgbnVtYmVyLCBudWxsIH1cbiAgICAgICAgICovXG4gICAgICAgIGdldEZpbGU6IGdldEZpbGUsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwbG9hZCBmaWxlIHdpdGggZ2l2ZW4gbmFtZVxuICAgICAgICAgKiBAcGFyYW0gcXVlcnkgeyBzdHJpbmcsIG51bWJlciwgbnVsbCAgfVxuICAgICAgICAgKi9cbiAgICAgICAgcHJvY2Vzc0ZpbGU6IHByb2Nlc3NGaWxlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXF1ZXN0IHByZXBhcmUgb3V0cHV0IGZvciBmaWxlIHdpdGggZ2l2ZW4gbmFtZVxuICAgICAgICAgKiBAcGFyYW0gcXVlcnkgeyBzdHJpbmcsIG51bWJlciwgbnVsbCAgfVxuICAgICAgICAgKi9cbiAgICAgICAgcHJlcGFyZUZpbGU6IHByZXBhcmVGaWxlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmVzIGEgZmlsZSBieSBpdHMgbmFtZVxuICAgICAgICAgKiBAcGFyYW0gcXVlcnkgeyBzdHJpbmcsIG51bWJlciwgbnVsbCAgfVxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlRmlsZTogcmVtb3ZlRmlsZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogTW92ZXMgYSBmaWxlIHRvIGEgbmV3IGxvY2F0aW9uIGluIHRoZSBmaWxlcyBsaXN0XG4gICAgICAgICAqL1xuICAgICAgICBtb3ZlRmlsZTogZnVuY3Rpb24gbW92ZUZpbGUocXVlcnksIGluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuIHN0b3JlLmRpc3BhdGNoKCdNT1ZFX0lURU0nLCB7IHF1ZXJ5OiBxdWVyeSwgaW5kZXg6IGluZGV4IH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGFsbCBmaWxlcyAod3JhcHBlZCBpbiBwdWJsaWMgYXBpKVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0RmlsZXM6IGdldEZpbGVzLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdGFydHMgdXBsb2FkaW5nIGFsbCBmaWxlc1xuICAgICAgICAgKi9cbiAgICAgICAgcHJvY2Vzc0ZpbGVzOiBwcm9jZXNzRmlsZXMsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsZWFycyBhbGwgZmlsZXMgZnJvbSB0aGUgZmlsZXMgbGlzdFxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlRmlsZXM6IHJlbW92ZUZpbGVzLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdGFydHMgcHJlcGFyaW5nIG91dHB1dCBvZiBhbGwgZmlsZXNcbiAgICAgICAgICovXG4gICAgICAgIHByZXBhcmVGaWxlczogcHJlcGFyZUZpbGVzLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTb3J0IGxpc3Qgb2YgZmlsZXNcbiAgICAgICAgICovXG4gICAgICAgIHNvcnQ6IGZ1bmN0aW9uIHNvcnQoY29tcGFyZSkge1xuICAgICAgICAgIHJldHVybiBzdG9yZS5kaXNwYXRjaCgnU09SVCcsIHsgY29tcGFyZTogY29tcGFyZSB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQnJvd3NlIHRoZSBmaWxlIHN5c3RlbSBmb3IgYSBmaWxlXG4gICAgICAgICAqL1xuICAgICAgICBicm93c2U6IGZ1bmN0aW9uIGJyb3dzZSgpIHtcbiAgICAgICAgICAvLyBuZWVkcyB0byBiZSB0cmlnZ2VyIGRpcmVjdGx5IGFzIHVzZXIgYWN0aW9uIG5lZWRzIHRvIGJlIHRyYWNlYWJsZSAoaXMgbm90IHRyYWNlYWJsZSBpbiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUpXG4gICAgICAgICAgdmFyIGlucHV0ID0gdmlldy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2lucHV0W3R5cGU9ZmlsZV0nKTtcbiAgICAgICAgICBpZiAoaW5wdXQpIHtcbiAgICAgICAgICAgIGlucHV0LmNsaWNrKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXN0cm95cyB0aGUgYXBwXG4gICAgICAgICAqL1xuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICAgIC8vIHJlcXVlc3QgZGVzdHJ1Y3Rpb25cbiAgICAgICAgICBleHBvcnRzLmZpcmUoJ2Rlc3Ryb3knLCB2aWV3LmVsZW1lbnQpO1xuXG4gICAgICAgICAgLy8gc3RvcCBhY3RpdmUgcHJvY2Vzc2VzIChmaWxlIHVwbG9hZHMsIGZldGNoZXMsIHN0dWZmIGxpa2UgdGhhdClcbiAgICAgICAgICAvLyBsb29wIG92ZXIgaXRlbXMgYW5kIGRlcGVuZGluZyBvbiBzdGF0ZXMgY2FsbCBhYm9ydCBmb3Igb25nb2luZyBwcm9jZXNzZXNcbiAgICAgICAgICBzdG9yZS5kaXNwYXRjaCgnQUJPUlRfQUxMJyk7XG5cbiAgICAgICAgICAvLyBkZXN0cm95IHZpZXdcbiAgICAgICAgICB2aWV3Ll9kZXN0cm95KCk7XG5cbiAgICAgICAgICAvLyBzdG9wIGxpc3RlbmluZyB0byByZXNpemVcbiAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgcmVzaXplSGFuZGxlcik7XG5cbiAgICAgICAgICAvLyBzdG9wIGxpc3RlbmluZyB0byB0aGUgdmlzaWJsaXR5Y2hhbmdlIGV2ZW50XG4gICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIHZpc2liaWxpdHlIYW5kbGVyKTtcblxuICAgICAgICAgIC8vIGRpc3BhdGNoIGRlc3Ryb3lcbiAgICAgICAgICBzdG9yZS5kaXNwYXRjaCgnRElEX0RFU1RST1knKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5zZXJ0cyB0aGUgcGx1Z2luIGJlZm9yZSB0aGUgdGFyZ2V0IGVsZW1lbnRcbiAgICAgICAgICovXG4gICAgICAgIGluc2VydEJlZm9yZTogZnVuY3Rpb24gaW5zZXJ0QmVmb3JlJDEoZWxlbWVudCkge1xuICAgICAgICAgIHJldHVybiBpbnNlcnRCZWZvcmUodmlldy5lbGVtZW50LCBlbGVtZW50KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5zZXJ0cyB0aGUgcGx1Z2luIGFmdGVyIHRoZSB0YXJnZXQgZWxlbWVudFxuICAgICAgICAgKi9cbiAgICAgICAgaW5zZXJ0QWZ0ZXI6IGZ1bmN0aW9uIGluc2VydEFmdGVyJDEoZWxlbWVudCkge1xuICAgICAgICAgIHJldHVybiBpbnNlcnRBZnRlcih2aWV3LmVsZW1lbnQsIGVsZW1lbnQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcHBlbmRzIHRoZSBwbHVnaW4gdG8gdGhlIHRhcmdldCBlbGVtZW50XG4gICAgICAgICAqL1xuICAgICAgICBhcHBlbmRUbzogZnVuY3Rpb24gYXBwZW5kVG8oZWxlbWVudCkge1xuICAgICAgICAgIHJldHVybiBlbGVtZW50LmFwcGVuZENoaWxkKHZpZXcuZWxlbWVudCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlcGxhY2VzIGFuIGVsZW1lbnQgd2l0aCB0aGUgYXBwXG4gICAgICAgICAqL1xuICAgICAgICByZXBsYWNlRWxlbWVudDogZnVuY3Rpb24gcmVwbGFjZUVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgICAgIC8vIGluc2VydCB0aGUgYXBwIGJlZm9yZSB0aGUgZWxlbWVudFxuICAgICAgICAgIGluc2VydEJlZm9yZSh2aWV3LmVsZW1lbnQsIGVsZW1lbnQpO1xuXG4gICAgICAgICAgLy8gcmVtb3ZlIHRoZSBvcmlnaW5hbCBlbGVtZW50XG4gICAgICAgICAgZWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsZW1lbnQpO1xuXG4gICAgICAgICAgLy8gcmVtZW1iZXIgb3JpZ2luYWwgZWxlbWVudFxuICAgICAgICAgIG9yaWdpbmFsRWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc3RvcmVzIHRoZSBvcmlnaW5hbCBlbGVtZW50XG4gICAgICAgICAqL1xuICAgICAgICByZXN0b3JlRWxlbWVudDogZnVuY3Rpb24gcmVzdG9yZUVsZW1lbnQoKSB7XG4gICAgICAgICAgaWYgKCFvcmlnaW5hbEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybjsgLy8gbm8gZWxlbWVudCB0byByZXN0b3JlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gcmVzdG9yZSBvcmlnaW5hbCBlbGVtZW50XG4gICAgICAgICAgaW5zZXJ0QWZ0ZXIob3JpZ2luYWxFbGVtZW50LCB2aWV3LmVsZW1lbnQpO1xuXG4gICAgICAgICAgLy8gcmVtb3ZlIG91ciBlbGVtZW50XG4gICAgICAgICAgdmlldy5lbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodmlldy5lbGVtZW50KTtcblxuICAgICAgICAgIC8vIHJlbW92ZSByZWZlcmVuY2VcbiAgICAgICAgICBvcmlnaW5hbEVsZW1lbnQgPSBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGFwcCByb290IGlzIGF0dGFjaGVkIHRvIGdpdmVuIGVsZW1lbnRcbiAgICAgICAgICogQHBhcmFtIGVsZW1lbnRcbiAgICAgICAgICovXG4gICAgICAgIGlzQXR0YWNoZWRUbzogZnVuY3Rpb24gaXNBdHRhY2hlZFRvKGVsZW1lbnQpIHtcbiAgICAgICAgICByZXR1cm4gdmlldy5lbGVtZW50ID09PSBlbGVtZW50IHx8IG9yaWdpbmFsRWxlbWVudCA9PT0gZWxlbWVudDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgcm9vdCBlbGVtZW50XG4gICAgICAgICAqL1xuICAgICAgICBlbGVtZW50OiB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdmlldy5lbGVtZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgY3VycmVudCBwb25kIHN0YXR1c1xuICAgICAgICAgKi9cbiAgICAgICAgc3RhdHVzOiB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RvcmUucXVlcnkoJ0dFVF9TVEFUVVMnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApO1xuXG4gICAgLy8gRG9uZSFcbiAgICBzdG9yZS5kaXNwYXRjaCgnRElEX0lOSVQnKTtcblxuICAgIC8vIGNyZWF0ZSBhY3R1YWwgYXBpIG9iamVjdFxuICAgIHJldHVybiBjcmVhdGVPYmplY3QoZXhwb3J0cyk7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUFwcE9iamVjdCA9IGZ1bmN0aW9uIGNyZWF0ZUFwcE9iamVjdCgpIHtcbiAgICB2YXIgY3VzdG9tT3B0aW9ucyA9XG4gICAgICBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIC8vIGRlZmF1bHQgb3B0aW9uc1xuICAgIHZhciBkZWZhdWx0T3B0aW9ucyA9IHt9O1xuICAgIGZvcmluKGdldE9wdGlvbnMoKSwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgZGVmYXVsdE9wdGlvbnNba2V5XSA9IHZhbHVlWzBdO1xuICAgIH0pO1xuXG4gICAgLy8gc2V0IGFwcCBvcHRpb25zXG4gICAgdmFyIGFwcCA9IGNyZWF0ZUFwcChcbiAgICAgIE9iamVjdC5hc3NpZ24oXG4gICAgICAgIHt9LFxuXG4gICAgICAgIGRlZmF1bHRPcHRpb25zLFxuICAgICAgICB7fSxcblxuICAgICAgICBjdXN0b21PcHRpb25zXG4gICAgICApXG4gICAgKTtcblxuICAgIC8vIHJldHVybiB0aGUgcGx1Z2luIGluc3RhbmNlXG4gICAgcmV0dXJuIGFwcDtcbiAgfTtcblxuICB2YXIgbG93ZXJDYXNlRmlyc3RMZXR0ZXIgPSBmdW5jdGlvbiBsb3dlckNhc2VGaXJzdExldHRlcihzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpICsgc3RyaW5nLnNsaWNlKDEpO1xuICB9O1xuXG4gIHZhciBhdHRyaWJ1dGVOYW1lVG9Qcm9wZXJ0eU5hbWUgPSBmdW5jdGlvbiBhdHRyaWJ1dGVOYW1lVG9Qcm9wZXJ0eU5hbWUoXG4gICAgYXR0cmlidXRlTmFtZVxuICApIHtcbiAgICByZXR1cm4gdG9DYW1lbHMoYXR0cmlidXRlTmFtZS5yZXBsYWNlKC9eZGF0YS0vLCAnJykpO1xuICB9O1xuXG4gIHZhciBtYXBPYmplY3QgPSBmdW5jdGlvbiBtYXBPYmplY3Qob2JqZWN0LCBwcm9wZXJ0eU1hcCkge1xuICAgIC8vIHJlbW92ZSB1bndhbnRlZFxuICAgIGZvcmluKHByb3BlcnR5TWFwLCBmdW5jdGlvbihzZWxlY3RvciwgbWFwcGluZykge1xuICAgICAgZm9yaW4ob2JqZWN0LCBmdW5jdGlvbihwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICAgICAgLy8gY3JlYXRlIHJlZ2V4cCBzaG9ydGN1dFxuICAgICAgICB2YXIgc2VsZWN0b3JSZWdFeHAgPSBuZXcgUmVnRXhwKHNlbGVjdG9yKTtcblxuICAgICAgICAvLyB0ZXN0cyBpZlxuICAgICAgICB2YXIgbWF0Y2hlcyA9IHNlbGVjdG9yUmVnRXhwLnRlc3QocHJvcGVydHkpO1xuXG4gICAgICAgIC8vIG5vIG1hdGNoLCBza2lwXG4gICAgICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHRoZXJlJ3MgYSBtYXBwaW5nLCB0aGUgb3JpZ2luYWwgcHJvcGVydHkgaXMgYWx3YXlzIHJlbW92ZWRcbiAgICAgICAgZGVsZXRlIG9iamVjdFtwcm9wZXJ0eV07XG5cbiAgICAgICAgLy8gc2hvdWxkIG9ubHkgcmVtb3ZlLCB3ZSBkb25lIVxuICAgICAgICBpZiAobWFwcGluZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtb3ZlIHZhbHVlIHRvIG5ldyBwcm9wZXJ0eVxuICAgICAgICBpZiAoaXNTdHJpbmcobWFwcGluZykpIHtcbiAgICAgICAgICBvYmplY3RbbWFwcGluZ10gPSB2YWx1ZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtb3ZlIHRvIGdyb3VwXG4gICAgICAgIHZhciBncm91cCA9IG1hcHBpbmcuZ3JvdXA7XG4gICAgICAgIGlmIChpc09iamVjdChtYXBwaW5nKSAmJiAhb2JqZWN0W2dyb3VwXSkge1xuICAgICAgICAgIG9iamVjdFtncm91cF0gPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iamVjdFtncm91cF1bXG4gICAgICAgICAgbG93ZXJDYXNlRmlyc3RMZXR0ZXIocHJvcGVydHkucmVwbGFjZShzZWxlY3RvclJlZ0V4cCwgJycpKVxuICAgICAgICBdID0gdmFsdWU7XG4gICAgICB9KTtcblxuICAgICAgLy8gZG8gc3VibWFwcGluZ1xuICAgICAgaWYgKG1hcHBpbmcubWFwcGluZykge1xuICAgICAgICBtYXBPYmplY3Qob2JqZWN0W21hcHBpbmcuZ3JvdXBdLCBtYXBwaW5nLm1hcHBpbmcpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHZhciBnZXRBdHRyaWJ1dGVzQXNPYmplY3QgPSBmdW5jdGlvbiBnZXRBdHRyaWJ1dGVzQXNPYmplY3Qobm9kZSkge1xuICAgIHZhciBhdHRyaWJ1dGVNYXBwaW5nID1cbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgLy8gdHVybiBhdHRyaWJ1dGVzIGludG8gb2JqZWN0XG4gICAgdmFyIGF0dHJpYnV0ZXMgPSBbXTtcbiAgICBmb3Jpbihub2RlLmF0dHJpYnV0ZXMsIGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICBhdHRyaWJ1dGVzLnB1c2gobm9kZS5hdHRyaWJ1dGVzW2luZGV4XSk7XG4gICAgfSk7XG5cbiAgICB2YXIgb3V0cHV0ID0gYXR0cmlidXRlc1xuICAgICAgLmZpbHRlcihmdW5jdGlvbihhdHRyaWJ1dGUpIHtcbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZS5uYW1lO1xuICAgICAgfSlcbiAgICAgIC5yZWR1Y2UoZnVuY3Rpb24ob2JqLCBhdHRyaWJ1dGUpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXR0cihub2RlLCBhdHRyaWJ1dGUubmFtZSk7XG5cbiAgICAgICAgb2JqW2F0dHJpYnV0ZU5hbWVUb1Byb3BlcnR5TmFtZShhdHRyaWJ1dGUubmFtZSldID1cbiAgICAgICAgICB2YWx1ZSA9PT0gYXR0cmlidXRlLm5hbWUgPyB0cnVlIDogdmFsdWU7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgICB9LCB7fSk7XG5cbiAgICAvLyBkbyBtYXBwaW5nIG9mIG9iamVjdCBwcm9wZXJ0aWVzXG4gICAgbWFwT2JqZWN0KG91dHB1dCwgYXR0cmlidXRlTWFwcGluZyk7XG5cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9O1xuXG4gIHZhciBjcmVhdGVBcHBBdEVsZW1lbnQgPSBmdW5jdGlvbiBjcmVhdGVBcHBBdEVsZW1lbnQoZWxlbWVudCkge1xuICAgIHZhciBvcHRpb25zID1cbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAvLyBob3cgYXR0cmlidXRlcyBvZiB0aGUgaW5wdXQgZWxlbWVudCBhcmUgbWFwcGVkIHRvIHRoZSBvcHRpb25zIGZvciB0aGUgcGx1Z2luXG4gICAgdmFyIGF0dHJpYnV0ZU1hcHBpbmcgPSB7XG4gICAgICAvLyB0cmFuc2xhdGUgdG8gb3RoZXIgbmFtZVxuICAgICAgJ15jbGFzcyQnOiAnY2xhc3NOYW1lJyxcbiAgICAgICdebXVsdGlwbGUkJzogJ2FsbG93TXVsdGlwbGUnLFxuICAgICAgJ15jYXB0dXJlJCc6ICdjYXB0dXJlTWV0aG9kJyxcbiAgICAgICded2Via2l0ZGlyZWN0b3J5JCc6ICdhbGxvd0RpcmVjdG9yaWVzT25seScsXG5cbiAgICAgIC8vIGdyb3VwIHVuZGVyIHNpbmdsZSBwcm9wZXJ0eVxuICAgICAgJ15zZXJ2ZXInOiB7XG4gICAgICAgIGdyb3VwOiAnc2VydmVyJyxcbiAgICAgICAgbWFwcGluZzoge1xuICAgICAgICAgICdecHJvY2Vzcyc6IHtcbiAgICAgICAgICAgIGdyb3VwOiAncHJvY2VzcydcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgJ15yZXZlcnQnOiB7XG4gICAgICAgICAgICBncm91cDogJ3JldmVydCdcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgJ15mZXRjaCc6IHtcbiAgICAgICAgICAgIGdyb3VwOiAnZmV0Y2gnXG4gICAgICAgICAgfSxcblxuICAgICAgICAgICdecmVzdG9yZSc6IHtcbiAgICAgICAgICAgIGdyb3VwOiAncmVzdG9yZSdcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgJ15sb2FkJzoge1xuICAgICAgICAgICAgZ3JvdXA6ICdsb2FkJ1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLy8gZG9uJ3QgaW5jbHVkZSBpbiBvYmplY3RcbiAgICAgICdedHlwZSQnOiBmYWxzZSxcbiAgICAgICdeZmlsZXMkJzogZmFsc2VcbiAgICB9O1xuXG4gICAgLy8gYWRkIGFkZGl0aW9uYWwgb3B0aW9uIHRyYW5zbGF0b3JzXG4gICAgYXBwbHlGaWx0ZXJzKCdTRVRfQVRUUklCVVRFX1RPX09QVElPTl9NQVAnLCBhdHRyaWJ1dGVNYXBwaW5nKTtcblxuICAgIC8vIGNyZWF0ZSBmaW5hbCBvcHRpb25zIG9iamVjdCBieSBzZXR0aW5nIG9wdGlvbnMgb2JqZWN0IGFuZCB0aGVuIG92ZXJyaWRpbmcgb3B0aW9ucyBzdXBwbGllZCBvbiBlbGVtZW50XG4gICAgdmFyIG1lcmdlZE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcblxuICAgIHZhciBhdHRyaWJ1dGVPcHRpb25zID0gZ2V0QXR0cmlidXRlc0FzT2JqZWN0KFxuICAgICAgZWxlbWVudC5ub2RlTmFtZSA9PT0gJ0ZJRUxEU0VUJ1xuICAgICAgICA/IGVsZW1lbnQucXVlcnlTZWxlY3RvcignaW5wdXRbdHlwZT1maWxlXScpXG4gICAgICAgIDogZWxlbWVudCxcbiAgICAgIGF0dHJpYnV0ZU1hcHBpbmdcbiAgICApO1xuXG4gICAgLy8gbWVyZ2Ugd2l0aCBvcHRpb25zIG9iamVjdFxuICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZU9wdGlvbnMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICBpZiAoaXNPYmplY3QoYXR0cmlidXRlT3B0aW9uc1trZXldKSkge1xuICAgICAgICBpZiAoIWlzT2JqZWN0KG1lcmdlZE9wdGlvbnNba2V5XSkpIHtcbiAgICAgICAgICBtZXJnZWRPcHRpb25zW2tleV0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuYXNzaWduKG1lcmdlZE9wdGlvbnNba2V5XSwgYXR0cmlidXRlT3B0aW9uc1trZXldKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1lcmdlZE9wdGlvbnNba2V5XSA9IGF0dHJpYnV0ZU9wdGlvbnNba2V5XTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIGlmIHBhcmVudCBpcyBhIGZpZWxkc2V0LCBnZXQgZmlsZXMgZnJvbSBwYXJlbnQgYnkgc2VsZWN0aW5nIGFsbCBpbnB1dCBmaWVsZHMgdGhhdCBhcmUgbm90IGZpbGUgdXBsb2FkIGZpZWxkc1xuICAgIC8vIHRoZXNlIHdpbGwgdGhlbiBiZSBhdXRvbWF0aWNhbGx5IHNldCB0byB0aGUgaW5pdGlhbCBmaWxlc1xuICAgIG1lcmdlZE9wdGlvbnMuZmlsZXMgPSAob3B0aW9ucy5maWxlcyB8fCBbXSkuY29uY2F0KFxuICAgICAgQXJyYXkuZnJvbShlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0Om5vdChbdHlwZT1maWxlXSknKSkubWFwKFxuICAgICAgICBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzb3VyY2U6IGlucHV0LnZhbHVlLFxuICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICB0eXBlOiBpbnB1dC5kYXRhc2V0LnR5cGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICApXG4gICAgKTtcblxuICAgIC8vIGJ1aWxkIHBsdWdpblxuICAgIHZhciBhcHAgPSBjcmVhdGVBcHBPYmplY3QobWVyZ2VkT3B0aW9ucyk7XG5cbiAgICAvLyBhZGQgYWxyZWFkeSBzZWxlY3RlZCBmaWxlc1xuICAgIGlmIChlbGVtZW50LmZpbGVzKSB7XG4gICAgICBBcnJheS5mcm9tKGVsZW1lbnQuZmlsZXMpLmZvckVhY2goZnVuY3Rpb24oZmlsZSkge1xuICAgICAgICBhcHAuYWRkRmlsZShmaWxlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIHJlcGxhY2UgdGhlIHRhcmdldCBlbGVtZW50XG4gICAgYXBwLnJlcGxhY2VFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgLy8gZXhwb3NlXG4gICAgcmV0dXJuIGFwcDtcbiAgfTtcblxuICAvLyBpZiBhbiBlbGVtZW50IGlzIHBhc3NlZCwgd2UgY3JlYXRlIHRoZSBpbnN0YW5jZSBhdCB0aGF0IGVsZW1lbnQsIGlmIG5vdCwgd2UganVzdCBjcmVhdGUgYW4gdXAgb2JqZWN0XG4gIHZhciBjcmVhdGVBcHAkMSA9IGZ1bmN0aW9uIGNyZWF0ZUFwcCgpIHtcbiAgICByZXR1cm4gaXNOb2RlKGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXSlcbiAgICAgID8gY3JlYXRlQXBwQXRFbGVtZW50LmFwcGx5KHZvaWQgMCwgYXJndW1lbnRzKVxuICAgICAgOiBjcmVhdGVBcHBPYmplY3QuYXBwbHkodm9pZCAwLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIHZhciBQUklWQVRFX01FVEhPRFMgPSBbJ2ZpcmUnLCAnX3JlYWQnLCAnX3dyaXRlJ107XG5cbiAgdmFyIGNyZWF0ZUFwcEFQSSA9IGZ1bmN0aW9uIGNyZWF0ZUFwcEFQSShhcHApIHtcbiAgICB2YXIgYXBpID0ge307XG5cbiAgICBjb3B5T2JqZWN0UHJvcGVydGllc1RvT2JqZWN0KGFwcCwgYXBpLCBQUklWQVRFX01FVEhPRFMpO1xuXG4gICAgcmV0dXJuIGFwaTtcbiAgfTtcblxuICAvKipcbiAgICogUmVwbGFjZXMgcGxhY2Vob2xkZXJzIGluIGdpdmVuIHN0cmluZyB3aXRoIHJlcGxhY2VtZW50c1xuICAgKiBAcGFyYW0gc3RyaW5nIC0gXCJGb28ge2Jhcn1cIlwiXG4gICAqIEBwYXJhbSByZXBsYWNlbWVudHMgLSB7IFwiYmFyXCI6IDEwIH1cbiAgICovXG4gIHZhciByZXBsYWNlSW5TdHJpbmcgPSBmdW5jdGlvbiByZXBsYWNlSW5TdHJpbmcoc3RyaW5nLCByZXBsYWNlbWVudHMpIHtcbiAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoLyg/OnsoW2EtekEtWl0rKX0pL2csIGZ1bmN0aW9uKG1hdGNoLCBncm91cCkge1xuICAgICAgcmV0dXJuIHJlcGxhY2VtZW50c1tncm91cF07XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZVdvcmtlciA9IGZ1bmN0aW9uIGNyZWF0ZVdvcmtlcihmbikge1xuICAgIHZhciB3b3JrZXJCbG9iID0gbmV3IEJsb2IoWycoJywgZm4udG9TdHJpbmcoKSwgJykoKSddLCB7XG4gICAgICB0eXBlOiAnYXBwbGljYXRpb24vamF2YXNjcmlwdCdcbiAgICB9KTtcblxuICAgIHZhciB3b3JrZXJVUkwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKHdvcmtlckJsb2IpO1xuICAgIHZhciB3b3JrZXIgPSBuZXcgV29ya2VyKHdvcmtlclVSTCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHJhbnNmZXI6IGZ1bmN0aW9uIHRyYW5zZmVyKG1lc3NhZ2UsIGNiKSB7fSxcbiAgICAgIHBvc3Q6IGZ1bmN0aW9uIHBvc3QobWVzc2FnZSwgY2IsIHRyYW5zZmVyTGlzdCkge1xuICAgICAgICB2YXIgaWQgPSBnZXRVbmlxdWVJZCgpO1xuXG4gICAgICAgIHdvcmtlci5vbm1lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgaWYgKGUuZGF0YS5pZCA9PT0gaWQpIHtcbiAgICAgICAgICAgIGNiKGUuZGF0YS5tZXNzYWdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2VcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgdHJhbnNmZXJMaXN0XG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgdGVybWluYXRlOiBmdW5jdGlvbiB0ZXJtaW5hdGUoKSB7XG4gICAgICAgIHdvcmtlci50ZXJtaW5hdGUoKTtcbiAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTCh3b3JrZXJVUkwpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgdmFyIGxvYWRJbWFnZSA9IGZ1bmN0aW9uIGxvYWRJbWFnZSh1cmwpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgICBpbWcub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlc29sdmUoaW1nKTtcbiAgICAgIH07XG4gICAgICBpbWcub25lcnJvciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfTtcbiAgICAgIGltZy5zcmMgPSB1cmw7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIHJlbmFtZUZpbGUgPSBmdW5jdGlvbiByZW5hbWVGaWxlKGZpbGUsIG5hbWUpIHtcbiAgICB2YXIgcmVuYW1lZEZpbGUgPSBmaWxlLnNsaWNlKDAsIGZpbGUuc2l6ZSwgZmlsZS50eXBlKTtcbiAgICByZW5hbWVkRmlsZS5sYXN0TW9kaWZpZWREYXRlID0gZmlsZS5sYXN0TW9kaWZpZWREYXRlO1xuICAgIHJlbmFtZWRGaWxlLm5hbWUgPSBuYW1lO1xuICAgIHJldHVybiByZW5hbWVkRmlsZTtcbiAgfTtcblxuICB2YXIgY29weUZpbGUgPSBmdW5jdGlvbiBjb3B5RmlsZShmaWxlKSB7XG4gICAgcmV0dXJuIHJlbmFtZUZpbGUoZmlsZSwgZmlsZS5uYW1lKTtcbiAgfTtcblxuICAvLyBhbHJlYWR5IHJlZ2lzdGVyZWQgcGx1Z2lucyAoY2FuJ3QgcmVnaXN0ZXIgdHdpY2UpXG4gIHZhciByZWdpc3RlcmVkUGx1Z2lucyA9IFtdO1xuXG4gIC8vIHBhc3MgdXRpbHMgdG8gcGx1Z2luXG4gIHZhciBjcmVhdGVBcHBQbHVnaW4gPSBmdW5jdGlvbiBjcmVhdGVBcHBQbHVnaW4ocGx1Z2luKSB7XG4gICAgLy8gYWxyZWFkeSByZWdpc3RlcmVkXG4gICAgaWYgKHJlZ2lzdGVyZWRQbHVnaW5zLmluY2x1ZGVzKHBsdWdpbikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyByZW1lbWJlciB0aGlzIHBsdWdpblxuICAgIHJlZ2lzdGVyZWRQbHVnaW5zLnB1c2gocGx1Z2luKTtcblxuICAgIC8vIHNldHVwIVxuICAgIHZhciBwbHVnaW5PdXRsaW5lID0gcGx1Z2luKHtcbiAgICAgIGFkZEZpbHRlcjogYWRkRmlsdGVyLFxuICAgICAgdXRpbHM6IHtcbiAgICAgICAgVHlwZTogVHlwZSxcbiAgICAgICAgZm9yaW46IGZvcmluLFxuICAgICAgICBpc1N0cmluZzogaXNTdHJpbmcsXG4gICAgICAgIGlzRmlsZTogaXNGaWxlLFxuICAgICAgICB0b05hdHVyYWxGaWxlU2l6ZTogdG9OYXR1cmFsRmlsZVNpemUsXG4gICAgICAgIHJlcGxhY2VJblN0cmluZzogcmVwbGFjZUluU3RyaW5nLFxuICAgICAgICBnZXRFeHRlbnNpb25Gcm9tRmlsZW5hbWU6IGdldEV4dGVuc2lvbkZyb21GaWxlbmFtZSxcbiAgICAgICAgZ2V0RmlsZW5hbWVXaXRob3V0RXh0ZW5zaW9uOiBnZXRGaWxlbmFtZVdpdGhvdXRFeHRlbnNpb24sXG4gICAgICAgIGd1ZXNzdGltYXRlTWltZVR5cGU6IGd1ZXNzdGltYXRlTWltZVR5cGUsXG4gICAgICAgIGdldEZpbGVGcm9tQmxvYjogZ2V0RmlsZUZyb21CbG9iLFxuICAgICAgICBnZXRGaWxlbmFtZUZyb21VUkw6IGdldEZpbGVuYW1lRnJvbVVSTCxcbiAgICAgICAgY3JlYXRlUm91dGU6IGNyZWF0ZVJvdXRlLFxuICAgICAgICBjcmVhdGVXb3JrZXI6IGNyZWF0ZVdvcmtlcixcbiAgICAgICAgY3JlYXRlVmlldzogY3JlYXRlVmlldyxcbiAgICAgICAgY3JlYXRlSXRlbUFQSTogY3JlYXRlSXRlbUFQSSxcbiAgICAgICAgbG9hZEltYWdlOiBsb2FkSW1hZ2UsXG4gICAgICAgIGNvcHlGaWxlOiBjb3B5RmlsZSxcbiAgICAgICAgcmVuYW1lRmlsZTogcmVuYW1lRmlsZSxcbiAgICAgICAgY3JlYXRlQmxvYjogY3JlYXRlQmxvYixcbiAgICAgICAgYXBwbHlGaWx0ZXJDaGFpbjogYXBwbHlGaWx0ZXJDaGFpbixcbiAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgZ2V0TnVtZXJpY0FzcGVjdFJhdGlvRnJvbVN0cmluZzogZ2V0TnVtZXJpY0FzcGVjdFJhdGlvRnJvbVN0cmluZ1xuICAgICAgfSxcblxuICAgICAgdmlld3M6IHtcbiAgICAgICAgZmlsZUFjdGlvbkJ1dHRvbjogZmlsZUFjdGlvbkJ1dHRvblxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gYWRkIHBsdWdpbiBvcHRpb25zIHRvIGRlZmF1bHQgb3B0aW9uc1xuICAgIGV4dGVuZERlZmF1bHRPcHRpb25zKHBsdWdpbk91dGxpbmUub3B0aW9ucyk7XG4gIH07XG5cbiAgLy8gZmVhdHVyZSBkZXRlY3Rpb24gdXNlZCBieSBzdXBwb3J0ZWQoKSBtZXRob2RcbiAgdmFyIGlzT3BlcmFNaW5pID0gZnVuY3Rpb24gaXNPcGVyYU1pbmkoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh3aW5kb3cub3BlcmFtaW5pKSA9PT0gJ1tvYmplY3QgT3BlcmFNaW5pXSdcbiAgICApO1xuICB9O1xuICB2YXIgaGFzUHJvbWlzZXMgPSBmdW5jdGlvbiBoYXNQcm9taXNlcygpIHtcbiAgICByZXR1cm4gJ1Byb21pc2UnIGluIHdpbmRvdztcbiAgfTtcbiAgdmFyIGhhc0Jsb2JTbGljZSA9IGZ1bmN0aW9uIGhhc0Jsb2JTbGljZSgpIHtcbiAgICByZXR1cm4gJ3NsaWNlJyBpbiBCbG9iLnByb3RvdHlwZTtcbiAgfTtcbiAgdmFyIGhhc0NyZWF0ZU9iamVjdFVSTCA9IGZ1bmN0aW9uIGhhc0NyZWF0ZU9iamVjdFVSTCgpIHtcbiAgICByZXR1cm4gJ1VSTCcgaW4gd2luZG93ICYmICdjcmVhdGVPYmplY3RVUkwnIGluIHdpbmRvdy5VUkw7XG4gIH07XG4gIHZhciBoYXNWaXNpYmlsaXR5ID0gZnVuY3Rpb24gaGFzVmlzaWJpbGl0eSgpIHtcbiAgICByZXR1cm4gJ3Zpc2liaWxpdHlTdGF0ZScgaW4gZG9jdW1lbnQ7XG4gIH07XG4gIHZhciBoYXNUaW1pbmcgPSBmdW5jdGlvbiBoYXNUaW1pbmcoKSB7XG4gICAgcmV0dXJuICdwZXJmb3JtYW5jZScgaW4gd2luZG93O1xuICB9OyAvLyBpT1MgOC54XG4gIHZhciBoYXNDU1NTdXBwb3J0cyA9IGZ1bmN0aW9uIGhhc0NTU1N1cHBvcnRzKCkge1xuICAgIHJldHVybiAnc3VwcG9ydHMnIGluICh3aW5kb3cuQ1NTIHx8IHt9KTtcbiAgfTsgLy8gdXNlIHRvIGRldGVjdCBTYWZhcmkgOStcbiAgdmFyIGlzSUUxMSA9IGZ1bmN0aW9uIGlzSUUxMSgpIHtcbiAgICByZXR1cm4gL01TSUV8VHJpZGVudC8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIH07XG5cbiAgdmFyIHN1cHBvcnRlZCA9IChmdW5jdGlvbigpIHtcbiAgICAvLyBSdW5zIGltbWVkaWF0ZWx5IGFuZCB0aGVuIHJlbWVtYmVycyByZXN1bHQgZm9yIHN1YnNlcXVlbnQgY2FsbHNcbiAgICB2YXIgaXNTdXBwb3J0ZWQgPVxuICAgICAgLy8gSGFzIHRvIGJlIGEgYnJvd3NlclxuICAgICAgaXNCcm93c2VyKCkgJiZcbiAgICAgIC8vIENhbid0IHJ1biBvbiBPcGVyYSBNaW5pIGR1ZSB0byBsYWNrIG9mIGV2ZXJ5dGhpbmdcbiAgICAgICFpc09wZXJhTWluaSgpICYmXG4gICAgICAvLyBSZXF1aXJlIHRoZXNlIEFQSXMgdG8gZmVhdHVyZSBkZXRlY3QgYSBtb2Rlcm4gYnJvd3NlclxuICAgICAgaGFzVmlzaWJpbGl0eSgpICYmXG4gICAgICBoYXNQcm9taXNlcygpICYmXG4gICAgICBoYXNCbG9iU2xpY2UoKSAmJlxuICAgICAgaGFzQ3JlYXRlT2JqZWN0VVJMKCkgJiZcbiAgICAgIGhhc1RpbWluZygpICYmXG4gICAgICAvLyBkb2Vzbid0IG5lZWQgQ1NTU3VwcG9ydHMgYnV0IGlzIGEgZ29vZCB3YXkgdG8gZGV0ZWN0IFNhZmFyaSA5KyAod2UgZG8gd2FudCB0byBzdXBwb3J0IElFMTEgdGhvdWdoKVxuICAgICAgKGhhc0NTU1N1cHBvcnRzKCkgfHwgaXNJRTExKCkpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGlzU3VwcG9ydGVkO1xuICAgIH07XG4gIH0pKCk7XG5cbiAgLyoqXG4gICAqIFBsdWdpbiBpbnRlcm5hbCBzdGF0ZSAob3ZlciBhbGwgaW5zdGFuY2VzKVxuICAgKi9cbiAgdmFyIHN0YXRlID0ge1xuICAgIC8vIGFjdGl2ZSBhcHAgaW5zdGFuY2VzLCB1c2VkIHRvIHJlZHJhdyB0aGUgYXBwcyBhbmQgdG8gZmluZCB0aGUgbGF0ZXJcbiAgICBhcHBzOiBbXVxuICB9O1xuXG4gIC8vIHBsdWdpbiBuYW1lXG4gIHZhciBuYW1lID0gJ2ZpbGVwb25kJztcblxuICAvKipcbiAgICogUHVibGljIFBsdWdpbiBtZXRob2RzXG4gICAqL1xuICB2YXIgZm4gPSBmdW5jdGlvbiBmbigpIHt9O1xuICBleHBvcnRzLlN0YXR1cyA9IHt9O1xuICBleHBvcnRzLkZpbGVTdGF0dXMgPSB7fTtcbiAgZXhwb3J0cy5GaWxlT3JpZ2luID0ge307XG4gIGV4cG9ydHMuT3B0aW9uVHlwZXMgPSB7fTtcbiAgZXhwb3J0cy5jcmVhdGUgPSBmbjtcbiAgZXhwb3J0cy5kZXN0cm95ID0gZm47XG4gIGV4cG9ydHMucGFyc2UgPSBmbjtcbiAgZXhwb3J0cy5maW5kID0gZm47XG4gIGV4cG9ydHMucmVnaXN0ZXJQbHVnaW4gPSBmbjtcbiAgZXhwb3J0cy5nZXRPcHRpb25zID0gZm47XG4gIGV4cG9ydHMuc2V0T3B0aW9ucyA9IGZuO1xuXG4gIC8vIGlmIG5vdCBzdXBwb3J0ZWQsIG5vIEFQSVxuICBpZiAoc3VwcG9ydGVkKCkpIHtcbiAgICAvLyBzdGFydCBwYWludGVyIGFuZCBmaXJlIGxvYWQgZXZlbnRcbiAgICBjcmVhdGVQYWludGVyKFxuICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgIHN0YXRlLmFwcHMuZm9yRWFjaChmdW5jdGlvbihhcHApIHtcbiAgICAgICAgICByZXR1cm4gYXBwLl9yZWFkKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGZ1bmN0aW9uKHRzKSB7XG4gICAgICAgIHN0YXRlLmFwcHMuZm9yRWFjaChmdW5jdGlvbihhcHApIHtcbiAgICAgICAgICByZXR1cm4gYXBwLl93cml0ZSh0cyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICk7XG5cbiAgICAvLyBmaXJlIGxvYWRlZCBldmVudCBzbyB3ZSBrbm93IHdoZW4gRmlsZVBvbmQgaXMgYXZhaWxhYmxlXG4gICAgdmFyIGRpc3BhdGNoID0gZnVuY3Rpb24gZGlzcGF0Y2goKSB7XG4gICAgICAvLyBsZXQgb3RoZXJzIGtub3cgd2UgaGF2ZSBhcmVhIHJlYWR5XG4gICAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KFxuICAgICAgICBuZXcgQ3VzdG9tRXZlbnQoJ0ZpbGVQb25kOmxvYWRlZCcsIHtcbiAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgIHN1cHBvcnRlZDogc3VwcG9ydGVkLFxuICAgICAgICAgICAgY3JlYXRlOiBleHBvcnRzLmNyZWF0ZSxcbiAgICAgICAgICAgIGRlc3Ryb3k6IGV4cG9ydHMuZGVzdHJveSxcbiAgICAgICAgICAgIHBhcnNlOiBleHBvcnRzLnBhcnNlLFxuICAgICAgICAgICAgZmluZDogZXhwb3J0cy5maW5kLFxuICAgICAgICAgICAgcmVnaXN0ZXJQbHVnaW46IGV4cG9ydHMucmVnaXN0ZXJQbHVnaW4sXG4gICAgICAgICAgICBzZXRPcHRpb25zOiBleHBvcnRzLnNldE9wdGlvbnNcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApO1xuXG4gICAgICAvLyBjbGVhbiB1cCBldmVudFxuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGRpc3BhdGNoKTtcbiAgICB9O1xuXG4gICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgIT09ICdsb2FkaW5nJykge1xuICAgICAgLy8gbW92ZSB0byBiYWNrIG9mIGV4ZWN1dGlvbiBxdWV1ZSwgRmlsZVBvbmQgc2hvdWxkIGhhdmUgYmVlbiBleHBvcnRlZCBieSB0aGVuXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZGlzcGF0Y2goKTtcbiAgICAgIH0sIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgZGlzcGF0Y2gpO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZXMgdGhlIE9wdGlvblR5cGVzIG9iamVjdCBiYXNlZCBvbiB0aGUgY3VycmVudCBvcHRpb25zXG4gICAgdmFyIHVwZGF0ZU9wdGlvblR5cGVzID0gZnVuY3Rpb24gdXBkYXRlT3B0aW9uVHlwZXMoKSB7XG4gICAgICByZXR1cm4gZm9yaW4oZ2V0T3B0aW9ucygpLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgIGV4cG9ydHMuT3B0aW9uVHlwZXNba2V5XSA9IHZhbHVlWzFdO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGV4cG9ydHMuU3RhdHVzID0gT2JqZWN0LmFzc2lnbih7fSwgU3RhdHVzKTtcbiAgICBleHBvcnRzLkZpbGVPcmlnaW4gPSBPYmplY3QuYXNzaWduKHt9LCBGaWxlT3JpZ2luKTtcbiAgICBleHBvcnRzLkZpbGVTdGF0dXMgPSBPYmplY3QuYXNzaWduKHt9LCBJdGVtU3RhdHVzKTtcblxuICAgIGV4cG9ydHMuT3B0aW9uVHlwZXMgPSB7fTtcbiAgICB1cGRhdGVPcHRpb25UeXBlcygpO1xuXG4gICAgLy8gY3JlYXRlIG1ldGhvZCwgY3JlYXRlcyBhcHBzIGFuZCBhZGRzIHRoZW0gdG8gdGhlIGFwcCBhcnJheVxuICAgIGV4cG9ydHMuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgICAgdmFyIGFwcCA9IGNyZWF0ZUFwcCQxLmFwcGx5KHZvaWQgMCwgYXJndW1lbnRzKTtcbiAgICAgIGFwcC5vbignZGVzdHJveScsIGV4cG9ydHMuZGVzdHJveSk7XG4gICAgICBzdGF0ZS5hcHBzLnB1c2goYXBwKTtcbiAgICAgIHJldHVybiBjcmVhdGVBcHBBUEkoYXBwKTtcbiAgICB9O1xuXG4gICAgLy8gZGVzdHJveXMgYXBwcyBhbmQgcmVtb3ZlcyB0aGVtIGZyb20gdGhlIGFwcCBhcnJheVxuICAgIGV4cG9ydHMuZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koaG9vaykge1xuICAgICAgLy8gcmV0dXJucyB0cnVlIGlmIHRoZSBhcHAgd2FzIGRlc3Ryb3llZCBzdWNjZXNzZnVsbHlcbiAgICAgIHZhciBpbmRleFRvUmVtb3ZlID0gc3RhdGUuYXBwcy5maW5kSW5kZXgoZnVuY3Rpb24oYXBwKSB7XG4gICAgICAgIHJldHVybiBhcHAuaXNBdHRhY2hlZFRvKGhvb2spO1xuICAgICAgfSk7XG4gICAgICBpZiAoaW5kZXhUb1JlbW92ZSA+PSAwKSB7XG4gICAgICAgIC8vIHJlbW92ZSBmcm9tIGFwcHNcbiAgICAgICAgdmFyIGFwcCA9IHN0YXRlLmFwcHMuc3BsaWNlKGluZGV4VG9SZW1vdmUsIDEpWzBdO1xuXG4gICAgICAgIC8vIHJlc3RvcmUgb3JpZ2luYWwgZG9tIGVsZW1lbnRcbiAgICAgICAgYXBwLnJlc3RvcmVFbGVtZW50KCk7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLy8gcGFyc2VzIHRoZSBnaXZlbiBjb250ZXh0IGZvciBwbHVnaW5zIChkb2VzIG5vdCBpbmNsdWRlIHRoZSBjb250ZXh0IGVsZW1lbnQgaXRzZWxmKVxuICAgIGV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbiBwYXJzZShjb250ZXh0KSB7XG4gICAgICAvLyBnZXQgYWxsIHBvc3NpYmxlIGhvb2tzXG4gICAgICB2YXIgbWF0Y2hlZEhvb2tzID0gQXJyYXkuZnJvbShjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoJy4nICsgbmFtZSkpO1xuXG4gICAgICAvLyBmaWx0ZXIgb3V0IGFscmVhZHkgYWN0aXZlIGhvb2tzXG4gICAgICB2YXIgbmV3SG9va3MgPSBtYXRjaGVkSG9va3MuZmlsdGVyKGZ1bmN0aW9uKG5ld0hvb2spIHtcbiAgICAgICAgcmV0dXJuICFzdGF0ZS5hcHBzLmZpbmQoZnVuY3Rpb24oYXBwKSB7XG4gICAgICAgICAgcmV0dXJuIGFwcC5pc0F0dGFjaGVkVG8obmV3SG9vayk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIGNyZWF0ZSBuZXcgaW5zdGFuY2UgZm9yIGVhY2ggaG9va1xuICAgICAgcmV0dXJuIG5ld0hvb2tzLm1hcChmdW5jdGlvbihob29rKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLmNyZWF0ZShob29rKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyByZXR1cm5zIGFuIGFwcCBiYXNlZCBvbiB0aGUgZ2l2ZW4gZWxlbWVudCBob29rXG4gICAgZXhwb3J0cy5maW5kID0gZnVuY3Rpb24gZmluZChob29rKSB7XG4gICAgICB2YXIgYXBwID0gc3RhdGUuYXBwcy5maW5kKGZ1bmN0aW9uKGFwcCkge1xuICAgICAgICByZXR1cm4gYXBwLmlzQXR0YWNoZWRUbyhob29rKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKCFhcHApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3JlYXRlQXBwQVBJKGFwcCk7XG4gICAgfTtcblxuICAgIC8vIGFkZHMgYSBwbHVnaW4gZXh0ZW5zaW9uXG4gICAgZXhwb3J0cy5yZWdpc3RlclBsdWdpbiA9IGZ1bmN0aW9uIHJlZ2lzdGVyUGx1Z2luKCkge1xuICAgICAgZm9yIChcbiAgICAgICAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwbHVnaW5zID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDtcbiAgICAgICAgX2tleSA8IF9sZW47XG4gICAgICAgIF9rZXkrK1xuICAgICAgKSB7XG4gICAgICAgIHBsdWdpbnNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIC8vIHJlZ2lzdGVyIHBsdWdpbnNcbiAgICAgIHBsdWdpbnMuZm9yRWFjaChjcmVhdGVBcHBQbHVnaW4pO1xuXG4gICAgICAvLyB1cGRhdGUgT3B0aW9uVHlwZXMsIGVhY2ggcGx1Z2luIG1pZ2h0IGhhdmUgZXh0ZW5kZWQgdGhlIGRlZmF1bHQgb3B0aW9uc1xuICAgICAgdXBkYXRlT3B0aW9uVHlwZXMoKTtcbiAgICB9O1xuXG4gICAgZXhwb3J0cy5nZXRPcHRpb25zID0gZnVuY3Rpb24gZ2V0T3B0aW9ucyQxKCkge1xuICAgICAgdmFyIG9wdHMgPSB7fTtcbiAgICAgIGZvcmluKGdldE9wdGlvbnMoKSwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICBvcHRzW2tleV0gPSB2YWx1ZVswXTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG9wdHM7XG4gICAgfTtcblxuICAgIGV4cG9ydHMuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIHNldE9wdGlvbnMkMShvcHRzKSB7XG4gICAgICBpZiAoaXNPYmplY3Qob3B0cykpIHtcbiAgICAgICAgLy8gdXBkYXRlIGV4aXN0aW5nIHBsdWdpbnNcbiAgICAgICAgc3RhdGUuYXBwcy5mb3JFYWNoKGZ1bmN0aW9uKGFwcCkge1xuICAgICAgICAgIGFwcC5zZXRPcHRpb25zKG9wdHMpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBvdmVycmlkZSBkZWZhdWx0c1xuICAgICAgICBzZXRPcHRpb25zKG9wdHMpO1xuICAgICAgfVxuXG4gICAgICAvLyByZXR1cm4gbmV3IG9wdGlvbnNcbiAgICAgIHJldHVybiBleHBvcnRzLmdldE9wdGlvbnMoKTtcbiAgICB9O1xuICB9XG5cbiAgZXhwb3J0cy5zdXBwb3J0ZWQgPSBzdXBwb3J0ZWQ7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn0pO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/filepond/dist/filepond.js\n");

/***/ }),

/***/ "./node_modules/filepond/locale/de-de.js":
/*!***********************************************!*\
  !*** ./node_modules/filepond/locale/de-de.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    labelIdle: 'Dateien ablegen oder <span class=\"filepond--label-action\"> auswählen </span>',\n    labelInvalidField: 'Feld beinhaltet ungültige Dateien',\n    labelFileWaitingForSize: 'Dateigröße berechnen',\n    labelFileSizeNotAvailable: 'Dateigröße nicht verfügbar',\n    labelFileLoading: 'Laden',\n    labelFileLoadError: 'Fehler beim Laden',\n    labelFileProcessing: 'Upload läuft',\n    labelFileProcessingComplete: 'Upload abgeschlossen',\n    labelFileProcessingAborted: 'Upload abgebrochen',\n    labelFileProcessingError: 'Fehler beim Upload',\n    labelFileProcessingRevertError: 'Fehler beim Wiederherstellen',\n    labelFileRemoveError: 'Fehler beim Löschen',\n    labelTapToCancel: 'abbrechen',\n    labelTapToRetry: 'erneut versuchen',\n    labelTapToUndo: 'rückgängig',\n    labelButtonRemoveItem: 'Entfernen',\n    labelButtonAbortItemLoad: 'Verwerfen',\n    labelButtonRetryItemLoad: 'Erneut versuchen',\n    labelButtonAbortItemProcessing: 'Abbrechen',\n    labelButtonUndoItemProcessing: 'Rückgängig',\n    labelButtonRetryItemProcessing: 'Erneut versuchen',\n    labelButtonProcessItem: 'Upload',\n    labelMaxFileSizeExceeded: 'Datei ist zu groß',\n    labelMaxFileSize: 'Maximale Dateigröße: {filesize}',\n    labelMaxTotalFileSizeExceeded: 'Maximale gesamte Dateigröße überschritten',\n    labelMaxTotalFileSize: 'Maximale gesamte Dateigröße: {filesize}',\n    labelFileTypeNotAllowed: 'Dateityp ungültig',\n    fileValidateTypeLabelExpectedTypes: 'Erwartet {allButLastType} oder {lastType}',\n    imageValidateSizeLabelFormatError: 'Bildtyp nicht unterstützt',\n    imageValidateSizeLabelImageSizeTooSmall: 'Bild ist zu klein',\n    imageValidateSizeLabelImageSizeTooBig: 'Bild ist zu groß',\n    imageValidateSizeLabelExpectedMinSize: 'Mindestgröße: {minWidth} × {minHeight}',\n    imageValidateSizeLabelExpectedMaxSize: 'Maximale Größe: {maxWidth} × {maxHeight}',\n    imageValidateSizeLabelImageResolutionTooLow: 'Auflösung ist zu niedrig',\n    imageValidateSizeLabelImageResolutionTooHigh: 'Auflösung ist zu hoch',\n    imageValidateSizeLabelExpectedMinResolution: 'Mindestauflösung: {minResolution}',\n    imageValidateSizeLabelExpectedMaxResolution: 'Maximale Auflösung: {maxResolution}'\n  });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmlsZXBvbmQvbG9jYWxlL2RlLWRlLmpzP2UwMzMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsU0FBUztBQUN0RDtBQUNBLDBEQUEwRCxTQUFTO0FBQ25FO0FBQ0EsbURBQW1ELGVBQWUsT0FBTyxTQUFTO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxTQUFTLElBQUksVUFBVTtBQUNsRiw2REFBNkQsU0FBUyxJQUFJLFVBQVU7QUFDcEY7QUFDQTtBQUNBLHFFQUFxRSxjQUFjO0FBQ25GLHVFQUF1RSxjQUFjO0FBQ3JGLEdBQUciLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmlsZXBvbmQvbG9jYWxlL2RlLWRlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQge1xuICAgIGxhYmVsSWRsZTogJ0RhdGVpZW4gYWJsZWdlbiBvZGVyIDxzcGFuIGNsYXNzPVwiZmlsZXBvbmQtLWxhYmVsLWFjdGlvblwiPiBhdXN3w6RobGVuIDwvc3Bhbj4nLFxuICAgIGxhYmVsSW52YWxpZEZpZWxkOiAnRmVsZCBiZWluaGFsdGV0IHVuZ8O8bHRpZ2UgRGF0ZWllbicsXG4gICAgbGFiZWxGaWxlV2FpdGluZ0ZvclNpemU6ICdEYXRlaWdyw7bDn2UgYmVyZWNobmVuJyxcbiAgICBsYWJlbEZpbGVTaXplTm90QXZhaWxhYmxlOiAnRGF0ZWlncsO2w59lIG5pY2h0IHZlcmbDvGdiYXInLFxuICAgIGxhYmVsRmlsZUxvYWRpbmc6ICdMYWRlbicsXG4gICAgbGFiZWxGaWxlTG9hZEVycm9yOiAnRmVobGVyIGJlaW0gTGFkZW4nLFxuICAgIGxhYmVsRmlsZVByb2Nlc3Npbmc6ICdVcGxvYWQgbMOkdWZ0JyxcbiAgICBsYWJlbEZpbGVQcm9jZXNzaW5nQ29tcGxldGU6ICdVcGxvYWQgYWJnZXNjaGxvc3NlbicsXG4gICAgbGFiZWxGaWxlUHJvY2Vzc2luZ0Fib3J0ZWQ6ICdVcGxvYWQgYWJnZWJyb2NoZW4nLFxuICAgIGxhYmVsRmlsZVByb2Nlc3NpbmdFcnJvcjogJ0ZlaGxlciBiZWltIFVwbG9hZCcsXG4gICAgbGFiZWxGaWxlUHJvY2Vzc2luZ1JldmVydEVycm9yOiAnRmVobGVyIGJlaW0gV2llZGVyaGVyc3RlbGxlbicsXG4gICAgbGFiZWxGaWxlUmVtb3ZlRXJyb3I6ICdGZWhsZXIgYmVpbSBMw7ZzY2hlbicsXG4gICAgbGFiZWxUYXBUb0NhbmNlbDogJ2FiYnJlY2hlbicsXG4gICAgbGFiZWxUYXBUb1JldHJ5OiAnZXJuZXV0IHZlcnN1Y2hlbicsXG4gICAgbGFiZWxUYXBUb1VuZG86ICdyw7xja2fDpG5naWcnLFxuICAgIGxhYmVsQnV0dG9uUmVtb3ZlSXRlbTogJ0VudGZlcm5lbicsXG4gICAgbGFiZWxCdXR0b25BYm9ydEl0ZW1Mb2FkOiAnVmVyd2VyZmVuJyxcbiAgICBsYWJlbEJ1dHRvblJldHJ5SXRlbUxvYWQ6ICdFcm5ldXQgdmVyc3VjaGVuJyxcbiAgICBsYWJlbEJ1dHRvbkFib3J0SXRlbVByb2Nlc3Npbmc6ICdBYmJyZWNoZW4nLFxuICAgIGxhYmVsQnV0dG9uVW5kb0l0ZW1Qcm9jZXNzaW5nOiAnUsO8Y2tnw6RuZ2lnJyxcbiAgICBsYWJlbEJ1dHRvblJldHJ5SXRlbVByb2Nlc3Npbmc6ICdFcm5ldXQgdmVyc3VjaGVuJyxcbiAgICBsYWJlbEJ1dHRvblByb2Nlc3NJdGVtOiAnVXBsb2FkJyxcbiAgICBsYWJlbE1heEZpbGVTaXplRXhjZWVkZWQ6ICdEYXRlaSBpc3QgenUgZ3Jvw58nLFxuICAgIGxhYmVsTWF4RmlsZVNpemU6ICdNYXhpbWFsZSBEYXRlaWdyw7bDn2U6IHtmaWxlc2l6ZX0nLFxuICAgIGxhYmVsTWF4VG90YWxGaWxlU2l6ZUV4Y2VlZGVkOiAnTWF4aW1hbGUgZ2VzYW10ZSBEYXRlaWdyw7bDn2Ugw7xiZXJzY2hyaXR0ZW4nLFxuICAgIGxhYmVsTWF4VG90YWxGaWxlU2l6ZTogJ01heGltYWxlIGdlc2FtdGUgRGF0ZWlncsO2w59lOiB7ZmlsZXNpemV9JyxcbiAgICBsYWJlbEZpbGVUeXBlTm90QWxsb3dlZDogJ0RhdGVpdHlwIHVuZ8O8bHRpZycsXG4gICAgZmlsZVZhbGlkYXRlVHlwZUxhYmVsRXhwZWN0ZWRUeXBlczogJ0Vyd2FydGV0IHthbGxCdXRMYXN0VHlwZX0gb2RlciB7bGFzdFR5cGV9JyxcbiAgICBpbWFnZVZhbGlkYXRlU2l6ZUxhYmVsRm9ybWF0RXJyb3I6ICdCaWxkdHlwIG5pY2h0IHVudGVyc3TDvHR6dCcsXG4gICAgaW1hZ2VWYWxpZGF0ZVNpemVMYWJlbEltYWdlU2l6ZVRvb1NtYWxsOiAnQmlsZCBpc3QgenUga2xlaW4nLFxuICAgIGltYWdlVmFsaWRhdGVTaXplTGFiZWxJbWFnZVNpemVUb29CaWc6ICdCaWxkIGlzdCB6dSBncm/DnycsXG4gICAgaW1hZ2VWYWxpZGF0ZVNpemVMYWJlbEV4cGVjdGVkTWluU2l6ZTogJ01pbmRlc3RncsO2w59lOiB7bWluV2lkdGh9IMOXIHttaW5IZWlnaHR9JyxcbiAgICBpbWFnZVZhbGlkYXRlU2l6ZUxhYmVsRXhwZWN0ZWRNYXhTaXplOiAnTWF4aW1hbGUgR3LDtsOfZToge21heFdpZHRofSDDlyB7bWF4SGVpZ2h0fScsXG4gICAgaW1hZ2VWYWxpZGF0ZVNpemVMYWJlbEltYWdlUmVzb2x1dGlvblRvb0xvdzogJ0F1ZmzDtnN1bmcgaXN0IHp1IG5pZWRyaWcnLFxuICAgIGltYWdlVmFsaWRhdGVTaXplTGFiZWxJbWFnZVJlc29sdXRpb25Ub29IaWdoOiAnQXVmbMO2c3VuZyBpc3QgenUgaG9jaCcsXG4gICAgaW1hZ2VWYWxpZGF0ZVNpemVMYWJlbEV4cGVjdGVkTWluUmVzb2x1dGlvbjogJ01pbmRlc3RhdWZsw7ZzdW5nOiB7bWluUmVzb2x1dGlvbn0nLFxuICAgIGltYWdlVmFsaWRhdGVTaXplTGFiZWxFeHBlY3RlZE1heFJlc29sdXRpb246ICdNYXhpbWFsZSBBdWZsw7ZzdW5nOiB7bWF4UmVzb2x1dGlvbn0nXG4gIH07Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/filepond/locale/de-de.js\n");

/***/ }),

/***/ "./node_modules/numeral/numeral.js":
/*!*****************************************!*\
  !*** ./node_modules/numeral/numeral.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! @preserve\n * numeral.js\n * version : 2.0.6\n * author : Adam Draper\n * license : MIT\n * http://adamwdraper.github.com/Numeral-js/\n */\n\n(function (global, factory) {\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n}(this, function () {\n    /************************************\n        Variables\n    ************************************/\n\n    var numeral,\n        _,\n        VERSION = '2.0.6',\n        formats = {},\n        locales = {},\n        defaults = {\n            currentLocale: 'en',\n            zeroFormat: null,\n            nullFormat: null,\n            defaultFormat: '0,0',\n            scalePercentBy100: true\n        },\n        options = {\n            currentLocale: defaults.currentLocale,\n            zeroFormat: defaults.zeroFormat,\n            nullFormat: defaults.nullFormat,\n            defaultFormat: defaults.defaultFormat,\n            scalePercentBy100: defaults.scalePercentBy100\n        };\n\n\n    /************************************\n        Constructors\n    ************************************/\n\n    // Numeral prototype object\n    function Numeral(input, number) {\n        this._input = input;\n\n        this._value = number;\n    }\n\n    numeral = function(input) {\n        var value,\n            kind,\n            unformatFunction,\n            regexp;\n\n        if (numeral.isNumeral(input)) {\n            value = input.value();\n        } else if (input === 0 || typeof input === 'undefined') {\n            value = 0;\n        } else if (input === null || _.isNaN(input)) {\n            value = null;\n        } else if (typeof input === 'string') {\n            if (options.zeroFormat && input === options.zeroFormat) {\n                value = 0;\n            } else if (options.nullFormat && input === options.nullFormat || !input.replace(/[^0-9]+/g, '').length) {\n                value = null;\n            } else {\n                for (kind in formats) {\n                    regexp = typeof formats[kind].regexps.unformat === 'function' ? formats[kind].regexps.unformat() : formats[kind].regexps.unformat;\n\n                    if (regexp && input.match(regexp)) {\n                        unformatFunction = formats[kind].unformat;\n\n                        break;\n                    }\n                }\n\n                unformatFunction = unformatFunction || numeral._.stringToNumber;\n\n                value = unformatFunction(input);\n            }\n        } else {\n            value = Number(input)|| null;\n        }\n\n        return new Numeral(input, value);\n    };\n\n    // version number\n    numeral.version = VERSION;\n\n    // compare numeral object\n    numeral.isNumeral = function(obj) {\n        return obj instanceof Numeral;\n    };\n\n    // helper functions\n    numeral._ = _ = {\n        // formats numbers separators, decimals places, signs, abbreviations\n        numberToFormat: function(value, format, roundingFunction) {\n            var locale = locales[numeral.options.currentLocale],\n                negP = false,\n                optDec = false,\n                leadingCount = 0,\n                abbr = '',\n                trillion = 1000000000000,\n                billion = 1000000000,\n                million = 1000000,\n                thousand = 1000,\n                decimal = '',\n                neg = false,\n                abbrForce, // force abbreviation\n                abs,\n                min,\n                max,\n                power,\n                int,\n                precision,\n                signed,\n                thousands,\n                output;\n\n            // make sure we never format a null value\n            value = value || 0;\n\n            abs = Math.abs(value);\n\n            // see if we should use parentheses for negative number or if we should prefix with a sign\n            // if both are present we default to parentheses\n            if (numeral._.includes(format, '(')) {\n                negP = true;\n                format = format.replace(/[\\(|\\)]/g, '');\n            } else if (numeral._.includes(format, '+') || numeral._.includes(format, '-')) {\n                signed = numeral._.includes(format, '+') ? format.indexOf('+') : value < 0 ? format.indexOf('-') : -1;\n                format = format.replace(/[\\+|\\-]/g, '');\n            }\n\n            // see if abbreviation is wanted\n            if (numeral._.includes(format, 'a')) {\n                abbrForce = format.match(/a(k|m|b|t)?/);\n\n                abbrForce = abbrForce ? abbrForce[1] : false;\n\n                // check for space before abbreviation\n                if (numeral._.includes(format, ' a')) {\n                    abbr = ' ';\n                }\n\n                format = format.replace(new RegExp(abbr + 'a[kmbt]?'), '');\n\n                if (abs >= trillion && !abbrForce || abbrForce === 't') {\n                    // trillion\n                    abbr += locale.abbreviations.trillion;\n                    value = value / trillion;\n                } else if (abs < trillion && abs >= billion && !abbrForce || abbrForce === 'b') {\n                    // billion\n                    abbr += locale.abbreviations.billion;\n                    value = value / billion;\n                } else if (abs < billion && abs >= million && !abbrForce || abbrForce === 'm') {\n                    // million\n                    abbr += locale.abbreviations.million;\n                    value = value / million;\n                } else if (abs < million && abs >= thousand && !abbrForce || abbrForce === 'k') {\n                    // thousand\n                    abbr += locale.abbreviations.thousand;\n                    value = value / thousand;\n                }\n            }\n\n            // check for optional decimals\n            if (numeral._.includes(format, '[.]')) {\n                optDec = true;\n                format = format.replace('[.]', '.');\n            }\n\n            // break number and format\n            int = value.toString().split('.')[0];\n            precision = format.split('.')[1];\n            thousands = format.indexOf(',');\n            leadingCount = (format.split('.')[0].split(',')[0].match(/0/g) || []).length;\n\n            if (precision) {\n                if (numeral._.includes(precision, '[')) {\n                    precision = precision.replace(']', '');\n                    precision = precision.split('[');\n                    decimal = numeral._.toFixed(value, (precision[0].length + precision[1].length), roundingFunction, precision[1].length);\n                } else {\n                    decimal = numeral._.toFixed(value, precision.length, roundingFunction);\n                }\n\n                int = decimal.split('.')[0];\n\n                if (numeral._.includes(decimal, '.')) {\n                    decimal = locale.delimiters.decimal + decimal.split('.')[1];\n                } else {\n                    decimal = '';\n                }\n\n                if (optDec && Number(decimal.slice(1)) === 0) {\n                    decimal = '';\n                }\n            } else {\n                int = numeral._.toFixed(value, 0, roundingFunction);\n            }\n\n            // check abbreviation again after rounding\n            if (abbr && !abbrForce && Number(int) >= 1000 && abbr !== locale.abbreviations.trillion) {\n                int = String(Number(int) / 1000);\n\n                switch (abbr) {\n                    case locale.abbreviations.thousand:\n                        abbr = locale.abbreviations.million;\n                        break;\n                    case locale.abbreviations.million:\n                        abbr = locale.abbreviations.billion;\n                        break;\n                    case locale.abbreviations.billion:\n                        abbr = locale.abbreviations.trillion;\n                        break;\n                }\n            }\n\n\n            // format number\n            if (numeral._.includes(int, '-')) {\n                int = int.slice(1);\n                neg = true;\n            }\n\n            if (int.length < leadingCount) {\n                for (var i = leadingCount - int.length; i > 0; i--) {\n                    int = '0' + int;\n                }\n            }\n\n            if (thousands > -1) {\n                int = int.toString().replace(/(\\d)(?=(\\d{3})+(?!\\d))/g, '$1' + locale.delimiters.thousands);\n            }\n\n            if (format.indexOf('.') === 0) {\n                int = '';\n            }\n\n            output = int + decimal + (abbr ? abbr : '');\n\n            if (negP) {\n                output = (negP && neg ? '(' : '') + output + (negP && neg ? ')' : '');\n            } else {\n                if (signed >= 0) {\n                    output = signed === 0 ? (neg ? '-' : '+') + output : output + (neg ? '-' : '+');\n                } else if (neg) {\n                    output = '-' + output;\n                }\n            }\n\n            return output;\n        },\n        // unformats numbers separators, decimals places, signs, abbreviations\n        stringToNumber: function(string) {\n            var locale = locales[options.currentLocale],\n                stringOriginal = string,\n                abbreviations = {\n                    thousand: 3,\n                    million: 6,\n                    billion: 9,\n                    trillion: 12\n                },\n                abbreviation,\n                value,\n                i,\n                regexp;\n\n            if (options.zeroFormat && string === options.zeroFormat) {\n                value = 0;\n            } else if (options.nullFormat && string === options.nullFormat || !string.replace(/[^0-9]+/g, '').length) {\n                value = null;\n            } else {\n                value = 1;\n\n                if (locale.delimiters.decimal !== '.') {\n                    string = string.replace(/\\./g, '').replace(locale.delimiters.decimal, '.');\n                }\n\n                for (abbreviation in abbreviations) {\n                    regexp = new RegExp('[^a-zA-Z]' + locale.abbreviations[abbreviation] + '(?:\\\\)|(\\\\' + locale.currency.symbol + ')?(?:\\\\))?)?$');\n\n                    if (stringOriginal.match(regexp)) {\n                        value *= Math.pow(10, abbreviations[abbreviation]);\n                        break;\n                    }\n                }\n\n                // check for negative number\n                value *= (string.split('-').length + Math.min(string.split('(').length - 1, string.split(')').length - 1)) % 2 ? 1 : -1;\n\n                // remove non numbers\n                string = string.replace(/[^0-9\\.]+/g, '');\n\n                value *= Number(string);\n            }\n\n            return value;\n        },\n        isNaN: function(value) {\n            return typeof value === 'number' && isNaN(value);\n        },\n        includes: function(string, search) {\n            return string.indexOf(search) !== -1;\n        },\n        insert: function(string, subString, start) {\n            return string.slice(0, start) + subString + string.slice(start);\n        },\n        reduce: function(array, callback /*, initialValue*/) {\n            if (this === null) {\n                throw new TypeError('Array.prototype.reduce called on null or undefined');\n            }\n\n            if (typeof callback !== 'function') {\n                throw new TypeError(callback + ' is not a function');\n            }\n\n            var t = Object(array),\n                len = t.length >>> 0,\n                k = 0,\n                value;\n\n            if (arguments.length === 3) {\n                value = arguments[2];\n            } else {\n                while (k < len && !(k in t)) {\n                    k++;\n                }\n\n                if (k >= len) {\n                    throw new TypeError('Reduce of empty array with no initial value');\n                }\n\n                value = t[k++];\n            }\n            for (; k < len; k++) {\n                if (k in t) {\n                    value = callback(value, t[k], k, t);\n                }\n            }\n            return value;\n        },\n        /**\n         * Computes the multiplier necessary to make x >= 1,\n         * effectively eliminating miscalculations caused by\n         * finite precision.\n         */\n        multiplier: function (x) {\n            var parts = x.toString().split('.');\n\n            return parts.length < 2 ? 1 : Math.pow(10, parts[1].length);\n        },\n        /**\n         * Given a variable number of arguments, returns the maximum\n         * multiplier that must be used to normalize an operation involving\n         * all of them.\n         */\n        correctionFactor: function () {\n            var args = Array.prototype.slice.call(arguments);\n\n            return args.reduce(function(accum, next) {\n                var mn = _.multiplier(next);\n                return accum > mn ? accum : mn;\n            }, 1);\n        },\n        /**\n         * Implementation of toFixed() that treats floats more like decimals\n         *\n         * Fixes binary rounding issues (eg. (0.615).toFixed(2) === '0.61') that present\n         * problems for accounting- and finance-related software.\n         */\n        toFixed: function(value, maxDecimals, roundingFunction, optionals) {\n            var splitValue = value.toString().split('.'),\n                minDecimals = maxDecimals - (optionals || 0),\n                boundedPrecision,\n                optionalsRegExp,\n                power,\n                output;\n\n            // Use the smallest precision value possible to avoid errors from floating point representation\n            if (splitValue.length === 2) {\n              boundedPrecision = Math.min(Math.max(splitValue[1].length, minDecimals), maxDecimals);\n            } else {\n              boundedPrecision = minDecimals;\n            }\n\n            power = Math.pow(10, boundedPrecision);\n\n            // Multiply up by precision, round accurately, then divide and use native toFixed():\n            output = (roundingFunction(value + 'e+' + boundedPrecision) / power).toFixed(boundedPrecision);\n\n            if (optionals > maxDecimals - boundedPrecision) {\n                optionalsRegExp = new RegExp('\\\\.?0{1,' + (optionals - (maxDecimals - boundedPrecision)) + '}$');\n                output = output.replace(optionalsRegExp, '');\n            }\n\n            return output;\n        }\n    };\n\n    // avaliable options\n    numeral.options = options;\n\n    // avaliable formats\n    numeral.formats = formats;\n\n    // avaliable formats\n    numeral.locales = locales;\n\n    // This function sets the current locale.  If\n    // no arguments are passed in, it will simply return the current global\n    // locale key.\n    numeral.locale = function(key) {\n        if (key) {\n            options.currentLocale = key.toLowerCase();\n        }\n\n        return options.currentLocale;\n    };\n\n    // This function provides access to the loaded locale data.  If\n    // no arguments are passed in, it will simply return the current\n    // global locale object.\n    numeral.localeData = function(key) {\n        if (!key) {\n            return locales[options.currentLocale];\n        }\n\n        key = key.toLowerCase();\n\n        if (!locales[key]) {\n            throw new Error('Unknown locale : ' + key);\n        }\n\n        return locales[key];\n    };\n\n    numeral.reset = function() {\n        for (var property in defaults) {\n            options[property] = defaults[property];\n        }\n    };\n\n    numeral.zeroFormat = function(format) {\n        options.zeroFormat = typeof(format) === 'string' ? format : null;\n    };\n\n    numeral.nullFormat = function (format) {\n        options.nullFormat = typeof(format) === 'string' ? format : null;\n    };\n\n    numeral.defaultFormat = function(format) {\n        options.defaultFormat = typeof(format) === 'string' ? format : '0.0';\n    };\n\n    numeral.register = function(type, name, format) {\n        name = name.toLowerCase();\n\n        if (this[type + 's'][name]) {\n            throw new TypeError(name + ' ' + type + ' already registered.');\n        }\n\n        this[type + 's'][name] = format;\n\n        return format;\n    };\n\n\n    numeral.validate = function(val, culture) {\n        var _decimalSep,\n            _thousandSep,\n            _currSymbol,\n            _valArray,\n            _abbrObj,\n            _thousandRegEx,\n            localeData,\n            temp;\n\n        //coerce val to string\n        if (typeof val !== 'string') {\n            val += '';\n\n            if (console.warn) {\n                console.warn('Numeral.js: Value is not string. It has been co-erced to: ', val);\n            }\n        }\n\n        //trim whitespaces from either sides\n        val = val.trim();\n\n        //if val is just digits return true\n        if (!!val.match(/^\\d+$/)) {\n            return true;\n        }\n\n        //if val is empty return false\n        if (val === '') {\n            return false;\n        }\n\n        //get the decimal and thousands separator from numeral.localeData\n        try {\n            //check if the culture is understood by numeral. if not, default it to current locale\n            localeData = numeral.localeData(culture);\n        } catch (e) {\n            localeData = numeral.localeData(numeral.locale());\n        }\n\n        //setup the delimiters and currency symbol based on culture/locale\n        _currSymbol = localeData.currency.symbol;\n        _abbrObj = localeData.abbreviations;\n        _decimalSep = localeData.delimiters.decimal;\n        if (localeData.delimiters.thousands === '.') {\n            _thousandSep = '\\\\.';\n        } else {\n            _thousandSep = localeData.delimiters.thousands;\n        }\n\n        // validating currency symbol\n        temp = val.match(/^[^\\d]+/);\n        if (temp !== null) {\n            val = val.substr(1);\n            if (temp[0] !== _currSymbol) {\n                return false;\n            }\n        }\n\n        //validating abbreviation symbol\n        temp = val.match(/[^\\d]+$/);\n        if (temp !== null) {\n            val = val.slice(0, -1);\n            if (temp[0] !== _abbrObj.thousand && temp[0] !== _abbrObj.million && temp[0] !== _abbrObj.billion && temp[0] !== _abbrObj.trillion) {\n                return false;\n            }\n        }\n\n        _thousandRegEx = new RegExp(_thousandSep + '{2}');\n\n        if (!val.match(/[^\\d.,]/g)) {\n            _valArray = val.split(_decimalSep);\n            if (_valArray.length > 2) {\n                return false;\n            } else {\n                if (_valArray.length < 2) {\n                    return ( !! _valArray[0].match(/^\\d+.*\\d$/) && !_valArray[0].match(_thousandRegEx));\n                } else {\n                    if (_valArray[0].length === 1) {\n                        return ( !! _valArray[0].match(/^\\d+$/) && !_valArray[0].match(_thousandRegEx) && !! _valArray[1].match(/^\\d+$/));\n                    } else {\n                        return ( !! _valArray[0].match(/^\\d+.*\\d$/) && !_valArray[0].match(_thousandRegEx) && !! _valArray[1].match(/^\\d+$/));\n                    }\n                }\n            }\n        }\n\n        return false;\n    };\n\n\n    /************************************\n        Numeral Prototype\n    ************************************/\n\n    numeral.fn = Numeral.prototype = {\n        clone: function() {\n            return numeral(this);\n        },\n        format: function(inputString, roundingFunction) {\n            var value = this._value,\n                format = inputString || options.defaultFormat,\n                kind,\n                output,\n                formatFunction;\n\n            // make sure we have a roundingFunction\n            roundingFunction = roundingFunction || Math.round;\n\n            // format based on value\n            if (value === 0 && options.zeroFormat !== null) {\n                output = options.zeroFormat;\n            } else if (value === null && options.nullFormat !== null) {\n                output = options.nullFormat;\n            } else {\n                for (kind in formats) {\n                    if (format.match(formats[kind].regexps.format)) {\n                        formatFunction = formats[kind].format;\n\n                        break;\n                    }\n                }\n\n                formatFunction = formatFunction || numeral._.numberToFormat;\n\n                output = formatFunction(value, format, roundingFunction);\n            }\n\n            return output;\n        },\n        value: function() {\n            return this._value;\n        },\n        input: function() {\n            return this._input;\n        },\n        set: function(value) {\n            this._value = Number(value);\n\n            return this;\n        },\n        add: function(value) {\n            var corrFactor = _.correctionFactor.call(null, this._value, value);\n\n            function cback(accum, curr, currI, O) {\n                return accum + Math.round(corrFactor * curr);\n            }\n\n            this._value = _.reduce([this._value, value], cback, 0) / corrFactor;\n\n            return this;\n        },\n        subtract: function(value) {\n            var corrFactor = _.correctionFactor.call(null, this._value, value);\n\n            function cback(accum, curr, currI, O) {\n                return accum - Math.round(corrFactor * curr);\n            }\n\n            this._value = _.reduce([value], cback, Math.round(this._value * corrFactor)) / corrFactor;\n\n            return this;\n        },\n        multiply: function(value) {\n            function cback(accum, curr, currI, O) {\n                var corrFactor = _.correctionFactor(accum, curr);\n                return Math.round(accum * corrFactor) * Math.round(curr * corrFactor) / Math.round(corrFactor * corrFactor);\n            }\n\n            this._value = _.reduce([this._value, value], cback, 1);\n\n            return this;\n        },\n        divide: function(value) {\n            function cback(accum, curr, currI, O) {\n                var corrFactor = _.correctionFactor(accum, curr);\n                return Math.round(accum * corrFactor) / Math.round(curr * corrFactor);\n            }\n\n            this._value = _.reduce([this._value, value], cback);\n\n            return this;\n        },\n        difference: function(value) {\n            return Math.abs(numeral(this._value).subtract(value).value());\n        }\n    };\n\n    /************************************\n        Default Locale && Format\n    ************************************/\n\n    numeral.register('locale', 'en', {\n        delimiters: {\n            thousands: ',',\n            decimal: '.'\n        },\n        abbreviations: {\n            thousand: 'k',\n            million: 'm',\n            billion: 'b',\n            trillion: 't'\n        },\n        ordinal: function(number) {\n            var b = number % 10;\n            return (~~(number % 100 / 10) === 1) ? 'th' :\n                (b === 1) ? 'st' :\n                (b === 2) ? 'nd' :\n                (b === 3) ? 'rd' : 'th';\n        },\n        currency: {\n            symbol: '$'\n        }\n    });\n\n    \n\n(function() {\n        numeral.register('format', 'bps', {\n            regexps: {\n                format: /(BPS)/,\n                unformat: /(BPS)/\n            },\n            format: function(value, format, roundingFunction) {\n                var space = numeral._.includes(format, ' BPS') ? ' ' : '',\n                    output;\n\n                value = value * 10000;\n\n                // check for space before BPS\n                format = format.replace(/\\s?BPS/, '');\n\n                output = numeral._.numberToFormat(value, format, roundingFunction);\n\n                if (numeral._.includes(output, ')')) {\n                    output = output.split('');\n\n                    output.splice(-1, 0, space + 'BPS');\n\n                    output = output.join('');\n                } else {\n                    output = output + space + 'BPS';\n                }\n\n                return output;\n            },\n            unformat: function(string) {\n                return +(numeral._.stringToNumber(string) * 0.0001).toFixed(15);\n            }\n        });\n})();\n\n\n(function() {\n        var decimal = {\n            base: 1000,\n            suffixes: ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']\n        },\n        binary = {\n            base: 1024,\n            suffixes: ['B', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB']\n        };\n\n    var allSuffixes =  decimal.suffixes.concat(binary.suffixes.filter(function (item) {\n            return decimal.suffixes.indexOf(item) < 0;\n        }));\n        var unformatRegex = allSuffixes.join('|');\n        // Allow support for BPS (http://www.investopedia.com/terms/b/basispoint.asp)\n        unformatRegex = '(' + unformatRegex.replace('B', 'B(?!PS)') + ')';\n\n    numeral.register('format', 'bytes', {\n        regexps: {\n            format: /([0\\s]i?b)/,\n            unformat: new RegExp(unformatRegex)\n        },\n        format: function(value, format, roundingFunction) {\n            var output,\n                bytes = numeral._.includes(format, 'ib') ? binary : decimal,\n                suffix = numeral._.includes(format, ' b') || numeral._.includes(format, ' ib') ? ' ' : '',\n                power,\n                min,\n                max;\n\n            // check for space before\n            format = format.replace(/\\s?i?b/, '');\n\n            for (power = 0; power <= bytes.suffixes.length; power++) {\n                min = Math.pow(bytes.base, power);\n                max = Math.pow(bytes.base, power + 1);\n\n                if (value === null || value === 0 || value >= min && value < max) {\n                    suffix += bytes.suffixes[power];\n\n                    if (min > 0) {\n                        value = value / min;\n                    }\n\n                    break;\n                }\n            }\n\n            output = numeral._.numberToFormat(value, format, roundingFunction);\n\n            return output + suffix;\n        },\n        unformat: function(string) {\n            var value = numeral._.stringToNumber(string),\n                power,\n                bytesMultiplier;\n\n            if (value) {\n                for (power = decimal.suffixes.length - 1; power >= 0; power--) {\n                    if (numeral._.includes(string, decimal.suffixes[power])) {\n                        bytesMultiplier = Math.pow(decimal.base, power);\n\n                        break;\n                    }\n\n                    if (numeral._.includes(string, binary.suffixes[power])) {\n                        bytesMultiplier = Math.pow(binary.base, power);\n\n                        break;\n                    }\n                }\n\n                value *= (bytesMultiplier || 1);\n            }\n\n            return value;\n        }\n    });\n})();\n\n\n(function() {\n        numeral.register('format', 'currency', {\n        regexps: {\n            format: /(\\$)/\n        },\n        format: function(value, format, roundingFunction) {\n            var locale = numeral.locales[numeral.options.currentLocale],\n                symbols = {\n                    before: format.match(/^([\\+|\\-|\\(|\\s|\\$]*)/)[0],\n                    after: format.match(/([\\+|\\-|\\)|\\s|\\$]*)$/)[0]\n                },\n                output,\n                symbol,\n                i;\n\n            // strip format of spaces and $\n            format = format.replace(/\\s?\\$\\s?/, '');\n\n            // format the number\n            output = numeral._.numberToFormat(value, format, roundingFunction);\n\n            // update the before and after based on value\n            if (value >= 0) {\n                symbols.before = symbols.before.replace(/[\\-\\(]/, '');\n                symbols.after = symbols.after.replace(/[\\-\\)]/, '');\n            } else if (value < 0 && (!numeral._.includes(symbols.before, '-') && !numeral._.includes(symbols.before, '('))) {\n                symbols.before = '-' + symbols.before;\n            }\n\n            // loop through each before symbol\n            for (i = 0; i < symbols.before.length; i++) {\n                symbol = symbols.before[i];\n\n                switch (symbol) {\n                    case '$':\n                        output = numeral._.insert(output, locale.currency.symbol, i);\n                        break;\n                    case ' ':\n                        output = numeral._.insert(output, ' ', i + locale.currency.symbol.length - 1);\n                        break;\n                }\n            }\n\n            // loop through each after symbol\n            for (i = symbols.after.length - 1; i >= 0; i--) {\n                symbol = symbols.after[i];\n\n                switch (symbol) {\n                    case '$':\n                        output = i === symbols.after.length - 1 ? output + locale.currency.symbol : numeral._.insert(output, locale.currency.symbol, -(symbols.after.length - (1 + i)));\n                        break;\n                    case ' ':\n                        output = i === symbols.after.length - 1 ? output + ' ' : numeral._.insert(output, ' ', -(symbols.after.length - (1 + i) + locale.currency.symbol.length - 1));\n                        break;\n                }\n            }\n\n\n            return output;\n        }\n    });\n})();\n\n\n(function() {\n        numeral.register('format', 'exponential', {\n        regexps: {\n            format: /(e\\+|e-)/,\n            unformat: /(e\\+|e-)/\n        },\n        format: function(value, format, roundingFunction) {\n            var output,\n                exponential = typeof value === 'number' && !numeral._.isNaN(value) ? value.toExponential() : '0e+0',\n                parts = exponential.split('e');\n\n            format = format.replace(/e[\\+|\\-]{1}0/, '');\n\n            output = numeral._.numberToFormat(Number(parts[0]), format, roundingFunction);\n\n            return output + 'e' + parts[1];\n        },\n        unformat: function(string) {\n            var parts = numeral._.includes(string, 'e+') ? string.split('e+') : string.split('e-'),\n                value = Number(parts[0]),\n                power = Number(parts[1]);\n\n            power = numeral._.includes(string, 'e-') ? power *= -1 : power;\n\n            function cback(accum, curr, currI, O) {\n                var corrFactor = numeral._.correctionFactor(accum, curr),\n                    num = (accum * corrFactor) * (curr * corrFactor) / (corrFactor * corrFactor);\n                return num;\n            }\n\n            return numeral._.reduce([value, Math.pow(10, power)], cback, 1);\n        }\n    });\n})();\n\n\n(function() {\n        numeral.register('format', 'ordinal', {\n        regexps: {\n            format: /(o)/\n        },\n        format: function(value, format, roundingFunction) {\n            var locale = numeral.locales[numeral.options.currentLocale],\n                output,\n                ordinal = numeral._.includes(format, ' o') ? ' ' : '';\n\n            // check for space before\n            format = format.replace(/\\s?o/, '');\n\n            ordinal += locale.ordinal(value);\n\n            output = numeral._.numberToFormat(value, format, roundingFunction);\n\n            return output + ordinal;\n        }\n    });\n})();\n\n\n(function() {\n        numeral.register('format', 'percentage', {\n        regexps: {\n            format: /(%)/,\n            unformat: /(%)/\n        },\n        format: function(value, format, roundingFunction) {\n            var space = numeral._.includes(format, ' %') ? ' ' : '',\n                output;\n\n            if (numeral.options.scalePercentBy100) {\n                value = value * 100;\n            }\n\n            // check for space before %\n            format = format.replace(/\\s?\\%/, '');\n\n            output = numeral._.numberToFormat(value, format, roundingFunction);\n\n            if (numeral._.includes(output, ')')) {\n                output = output.split('');\n\n                output.splice(-1, 0, space + '%');\n\n                output = output.join('');\n            } else {\n                output = output + space + '%';\n            }\n\n            return output;\n        },\n        unformat: function(string) {\n            var number = numeral._.stringToNumber(string);\n            if (numeral.options.scalePercentBy100) {\n                return number * 0.01;\n            }\n            return number;\n        }\n    });\n})();\n\n\n(function() {\n        numeral.register('format', 'time', {\n        regexps: {\n            format: /(:)/,\n            unformat: /(:)/\n        },\n        format: function(value, format, roundingFunction) {\n            var hours = Math.floor(value / 60 / 60),\n                minutes = Math.floor((value - (hours * 60 * 60)) / 60),\n                seconds = Math.round(value - (hours * 60 * 60) - (minutes * 60));\n\n            return hours + ':' + (minutes < 10 ? '0' + minutes : minutes) + ':' + (seconds < 10 ? '0' + seconds : seconds);\n        },\n        unformat: function(string) {\n            var timeArray = string.split(':'),\n                seconds = 0;\n\n            // turn hours and minutes into seconds and add them all up\n            if (timeArray.length === 3) {\n                // hours\n                seconds = seconds + (Number(timeArray[0]) * 60 * 60);\n                // minutes\n                seconds = seconds + (Number(timeArray[1]) * 60);\n                // seconds\n                seconds = seconds + Number(timeArray[2]);\n            } else if (timeArray.length === 2) {\n                // minutes\n                seconds = seconds + (Number(timeArray[0]) * 60);\n                // seconds\n                seconds = seconds + Number(timeArray[1]);\n            }\n            return Number(seconds);\n        }\n    });\n})();\n\nreturn numeral;\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbnVtZXJhbC9udW1lcmFsLmpzPzY2MTIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLElBQTBDO0FBQ2xELFFBQVEsb0NBQU8sT0FBTztBQUFBO0FBQUE7QUFBQTtBQUFBLG9HQUFDO0FBQ3ZCLEtBQUssTUFBTSxFQUlOO0FBQ0wsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVEQUF1RCxPQUFPO0FBQzlEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlEQUF5RCxFQUFFO0FBQzNEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxvREFBb0QseURBQXlEO0FBQzdHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscURBQXFELEVBQUU7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7Ozs7QUFJTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwyQkFBMkIsZ0NBQWdDO0FBQzNEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseURBQXlELFlBQVk7QUFDckU7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QiwyQkFBMkI7QUFDbEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDLEVBQUU7O0FBRWhEOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFRDtBQUNBLENBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbnVtZXJhbC9udW1lcmFsLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohIEBwcmVzZXJ2ZVxuICogbnVtZXJhbC5qc1xuICogdmVyc2lvbiA6IDIuMC42XG4gKiBhdXRob3IgOiBBZGFtIERyYXBlclxuICogbGljZW5zZSA6IE1JVFxuICogaHR0cDovL2FkYW13ZHJhcGVyLmdpdGh1Yi5jb20vTnVtZXJhbC1qcy9cbiAqL1xuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKGZhY3RvcnkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZ2xvYmFsLm51bWVyYWwgPSBmYWN0b3J5KCk7XG4gICAgfVxufSh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICBWYXJpYWJsZXNcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICB2YXIgbnVtZXJhbCxcbiAgICAgICAgXyxcbiAgICAgICAgVkVSU0lPTiA9ICcyLjAuNicsXG4gICAgICAgIGZvcm1hdHMgPSB7fSxcbiAgICAgICAgbG9jYWxlcyA9IHt9LFxuICAgICAgICBkZWZhdWx0cyA9IHtcbiAgICAgICAgICAgIGN1cnJlbnRMb2NhbGU6ICdlbicsXG4gICAgICAgICAgICB6ZXJvRm9ybWF0OiBudWxsLFxuICAgICAgICAgICAgbnVsbEZvcm1hdDogbnVsbCxcbiAgICAgICAgICAgIGRlZmF1bHRGb3JtYXQ6ICcwLDAnLFxuICAgICAgICAgICAgc2NhbGVQZXJjZW50QnkxMDA6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGN1cnJlbnRMb2NhbGU6IGRlZmF1bHRzLmN1cnJlbnRMb2NhbGUsXG4gICAgICAgICAgICB6ZXJvRm9ybWF0OiBkZWZhdWx0cy56ZXJvRm9ybWF0LFxuICAgICAgICAgICAgbnVsbEZvcm1hdDogZGVmYXVsdHMubnVsbEZvcm1hdCxcbiAgICAgICAgICAgIGRlZmF1bHRGb3JtYXQ6IGRlZmF1bHRzLmRlZmF1bHRGb3JtYXQsXG4gICAgICAgICAgICBzY2FsZVBlcmNlbnRCeTEwMDogZGVmYXVsdHMuc2NhbGVQZXJjZW50QnkxMDBcbiAgICAgICAgfTtcblxuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICBDb25zdHJ1Y3RvcnNcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAvLyBOdW1lcmFsIHByb3RvdHlwZSBvYmplY3RcbiAgICBmdW5jdGlvbiBOdW1lcmFsKGlucHV0LCBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5faW5wdXQgPSBpbnB1dDtcblxuICAgICAgICB0aGlzLl92YWx1ZSA9IG51bWJlcjtcbiAgICB9XG5cbiAgICBudW1lcmFsID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIHZhbHVlLFxuICAgICAgICAgICAga2luZCxcbiAgICAgICAgICAgIHVuZm9ybWF0RnVuY3Rpb24sXG4gICAgICAgICAgICByZWdleHA7XG5cbiAgICAgICAgaWYgKG51bWVyYWwuaXNOdW1lcmFsKGlucHV0KSkge1xuICAgICAgICAgICAgdmFsdWUgPSBpbnB1dC52YWx1ZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKGlucHV0ID09PSAwIHx8IHR5cGVvZiBpbnB1dCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHZhbHVlID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dCA9PT0gbnVsbCB8fCBfLmlzTmFOKGlucHV0KSkge1xuICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnplcm9Gb3JtYXQgJiYgaW5wdXQgPT09IG9wdGlvbnMuemVyb0Zvcm1hdCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5udWxsRm9ybWF0ICYmIGlucHV0ID09PSBvcHRpb25zLm51bGxGb3JtYXQgfHwgIWlucHV0LnJlcGxhY2UoL1teMC05XSsvZywgJycpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChraW5kIGluIGZvcm1hdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVnZXhwID0gdHlwZW9mIGZvcm1hdHNba2luZF0ucmVnZXhwcy51bmZvcm1hdCA9PT0gJ2Z1bmN0aW9uJyA/IGZvcm1hdHNba2luZF0ucmVnZXhwcy51bmZvcm1hdCgpIDogZm9ybWF0c1traW5kXS5yZWdleHBzLnVuZm9ybWF0O1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWdleHAgJiYgaW5wdXQubWF0Y2gocmVnZXhwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdW5mb3JtYXRGdW5jdGlvbiA9IGZvcm1hdHNba2luZF0udW5mb3JtYXQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdW5mb3JtYXRGdW5jdGlvbiA9IHVuZm9ybWF0RnVuY3Rpb24gfHwgbnVtZXJhbC5fLnN0cmluZ1RvTnVtYmVyO1xuXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB1bmZvcm1hdEZ1bmN0aW9uKGlucHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlID0gTnVtYmVyKGlucHV0KXx8IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IE51bWVyYWwoaW5wdXQsIHZhbHVlKTtcbiAgICB9O1xuXG4gICAgLy8gdmVyc2lvbiBudW1iZXJcbiAgICBudW1lcmFsLnZlcnNpb24gPSBWRVJTSU9OO1xuXG4gICAgLy8gY29tcGFyZSBudW1lcmFsIG9iamVjdFxuICAgIG51bWVyYWwuaXNOdW1lcmFsID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBOdW1lcmFsO1xuICAgIH07XG5cbiAgICAvLyBoZWxwZXIgZnVuY3Rpb25zXG4gICAgbnVtZXJhbC5fID0gXyA9IHtcbiAgICAgICAgLy8gZm9ybWF0cyBudW1iZXJzIHNlcGFyYXRvcnMsIGRlY2ltYWxzIHBsYWNlcywgc2lnbnMsIGFiYnJldmlhdGlvbnNcbiAgICAgICAgbnVtYmVyVG9Gb3JtYXQ6IGZ1bmN0aW9uKHZhbHVlLCBmb3JtYXQsIHJvdW5kaW5nRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBsb2NhbGUgPSBsb2NhbGVzW251bWVyYWwub3B0aW9ucy5jdXJyZW50TG9jYWxlXSxcbiAgICAgICAgICAgICAgICBuZWdQID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgb3B0RGVjID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgbGVhZGluZ0NvdW50ID0gMCxcbiAgICAgICAgICAgICAgICBhYmJyID0gJycsXG4gICAgICAgICAgICAgICAgdHJpbGxpb24gPSAxMDAwMDAwMDAwMDAwLFxuICAgICAgICAgICAgICAgIGJpbGxpb24gPSAxMDAwMDAwMDAwLFxuICAgICAgICAgICAgICAgIG1pbGxpb24gPSAxMDAwMDAwLFxuICAgICAgICAgICAgICAgIHRob3VzYW5kID0gMTAwMCxcbiAgICAgICAgICAgICAgICBkZWNpbWFsID0gJycsXG4gICAgICAgICAgICAgICAgbmVnID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgYWJickZvcmNlLCAvLyBmb3JjZSBhYmJyZXZpYXRpb25cbiAgICAgICAgICAgICAgICBhYnMsXG4gICAgICAgICAgICAgICAgbWluLFxuICAgICAgICAgICAgICAgIG1heCxcbiAgICAgICAgICAgICAgICBwb3dlcixcbiAgICAgICAgICAgICAgICBpbnQsXG4gICAgICAgICAgICAgICAgcHJlY2lzaW9uLFxuICAgICAgICAgICAgICAgIHNpZ25lZCxcbiAgICAgICAgICAgICAgICB0aG91c2FuZHMsXG4gICAgICAgICAgICAgICAgb3V0cHV0O1xuXG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgd2UgbmV2ZXIgZm9ybWF0IGEgbnVsbCB2YWx1ZVxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSB8fCAwO1xuXG4gICAgICAgICAgICBhYnMgPSBNYXRoLmFicyh2YWx1ZSk7XG5cbiAgICAgICAgICAgIC8vIHNlZSBpZiB3ZSBzaG91bGQgdXNlIHBhcmVudGhlc2VzIGZvciBuZWdhdGl2ZSBudW1iZXIgb3IgaWYgd2Ugc2hvdWxkIHByZWZpeCB3aXRoIGEgc2lnblxuICAgICAgICAgICAgLy8gaWYgYm90aCBhcmUgcHJlc2VudCB3ZSBkZWZhdWx0IHRvIHBhcmVudGhlc2VzXG4gICAgICAgICAgICBpZiAobnVtZXJhbC5fLmluY2x1ZGVzKGZvcm1hdCwgJygnKSkge1xuICAgICAgICAgICAgICAgIG5lZ1AgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKC9bXFwofFxcKV0vZywgJycpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChudW1lcmFsLl8uaW5jbHVkZXMoZm9ybWF0LCAnKycpIHx8IG51bWVyYWwuXy5pbmNsdWRlcyhmb3JtYXQsICctJykpIHtcbiAgICAgICAgICAgICAgICBzaWduZWQgPSBudW1lcmFsLl8uaW5jbHVkZXMoZm9ybWF0LCAnKycpID8gZm9ybWF0LmluZGV4T2YoJysnKSA6IHZhbHVlIDwgMCA/IGZvcm1hdC5pbmRleE9mKCctJykgOiAtMTtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgvW1xcK3xcXC1dL2csICcnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc2VlIGlmIGFiYnJldmlhdGlvbiBpcyB3YW50ZWRcbiAgICAgICAgICAgIGlmIChudW1lcmFsLl8uaW5jbHVkZXMoZm9ybWF0LCAnYScpKSB7XG4gICAgICAgICAgICAgICAgYWJickZvcmNlID0gZm9ybWF0Lm1hdGNoKC9hKGt8bXxifHQpPy8pO1xuXG4gICAgICAgICAgICAgICAgYWJickZvcmNlID0gYWJickZvcmNlID8gYWJickZvcmNlWzFdIDogZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3Igc3BhY2UgYmVmb3JlIGFiYnJldmlhdGlvblxuICAgICAgICAgICAgICAgIGlmIChudW1lcmFsLl8uaW5jbHVkZXMoZm9ybWF0LCAnIGEnKSkge1xuICAgICAgICAgICAgICAgICAgICBhYmJyID0gJyAnO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKG5ldyBSZWdFeHAoYWJiciArICdhW2ttYnRdPycpLCAnJyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoYWJzID49IHRyaWxsaW9uICYmICFhYmJyRm9yY2UgfHwgYWJickZvcmNlID09PSAndCcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdHJpbGxpb25cbiAgICAgICAgICAgICAgICAgICAgYWJiciArPSBsb2NhbGUuYWJicmV2aWF0aW9ucy50cmlsbGlvbjtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSAvIHRyaWxsaW9uO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYWJzIDwgdHJpbGxpb24gJiYgYWJzID49IGJpbGxpb24gJiYgIWFiYnJGb3JjZSB8fCBhYmJyRm9yY2UgPT09ICdiJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBiaWxsaW9uXG4gICAgICAgICAgICAgICAgICAgIGFiYnIgKz0gbG9jYWxlLmFiYnJldmlhdGlvbnMuYmlsbGlvbjtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSAvIGJpbGxpb247XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhYnMgPCBiaWxsaW9uICYmIGFicyA+PSBtaWxsaW9uICYmICFhYmJyRm9yY2UgfHwgYWJickZvcmNlID09PSAnbScpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbWlsbGlvblxuICAgICAgICAgICAgICAgICAgICBhYmJyICs9IGxvY2FsZS5hYmJyZXZpYXRpb25zLm1pbGxpb247XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgLyBtaWxsaW9uO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYWJzIDwgbWlsbGlvbiAmJiBhYnMgPj0gdGhvdXNhbmQgJiYgIWFiYnJGb3JjZSB8fCBhYmJyRm9yY2UgPT09ICdrJykge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aG91c2FuZFxuICAgICAgICAgICAgICAgICAgICBhYmJyICs9IGxvY2FsZS5hYmJyZXZpYXRpb25zLnRob3VzYW5kO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlIC8gdGhvdXNhbmQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjaGVjayBmb3Igb3B0aW9uYWwgZGVjaW1hbHNcbiAgICAgICAgICAgIGlmIChudW1lcmFsLl8uaW5jbHVkZXMoZm9ybWF0LCAnWy5dJykpIHtcbiAgICAgICAgICAgICAgICBvcHREZWMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKCdbLl0nLCAnLicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBicmVhayBudW1iZXIgYW5kIGZvcm1hdFxuICAgICAgICAgICAgaW50ID0gdmFsdWUudG9TdHJpbmcoKS5zcGxpdCgnLicpWzBdO1xuICAgICAgICAgICAgcHJlY2lzaW9uID0gZm9ybWF0LnNwbGl0KCcuJylbMV07XG4gICAgICAgICAgICB0aG91c2FuZHMgPSBmb3JtYXQuaW5kZXhPZignLCcpO1xuICAgICAgICAgICAgbGVhZGluZ0NvdW50ID0gKGZvcm1hdC5zcGxpdCgnLicpWzBdLnNwbGl0KCcsJylbMF0ubWF0Y2goLzAvZykgfHwgW10pLmxlbmd0aDtcblxuICAgICAgICAgICAgaWYgKHByZWNpc2lvbikge1xuICAgICAgICAgICAgICAgIGlmIChudW1lcmFsLl8uaW5jbHVkZXMocHJlY2lzaW9uLCAnWycpKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZWNpc2lvbiA9IHByZWNpc2lvbi5yZXBsYWNlKCddJywgJycpO1xuICAgICAgICAgICAgICAgICAgICBwcmVjaXNpb24gPSBwcmVjaXNpb24uc3BsaXQoJ1snKTtcbiAgICAgICAgICAgICAgICAgICAgZGVjaW1hbCA9IG51bWVyYWwuXy50b0ZpeGVkKHZhbHVlLCAocHJlY2lzaW9uWzBdLmxlbmd0aCArIHByZWNpc2lvblsxXS5sZW5ndGgpLCByb3VuZGluZ0Z1bmN0aW9uLCBwcmVjaXNpb25bMV0ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWNpbWFsID0gbnVtZXJhbC5fLnRvRml4ZWQodmFsdWUsIHByZWNpc2lvbi5sZW5ndGgsIHJvdW5kaW5nRnVuY3Rpb24pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGludCA9IGRlY2ltYWwuc3BsaXQoJy4nKVswXTtcblxuICAgICAgICAgICAgICAgIGlmIChudW1lcmFsLl8uaW5jbHVkZXMoZGVjaW1hbCwgJy4nKSkge1xuICAgICAgICAgICAgICAgICAgICBkZWNpbWFsID0gbG9jYWxlLmRlbGltaXRlcnMuZGVjaW1hbCArIGRlY2ltYWwuc3BsaXQoJy4nKVsxXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWNpbWFsID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG9wdERlYyAmJiBOdW1iZXIoZGVjaW1hbC5zbGljZSgxKSkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZGVjaW1hbCA9ICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaW50ID0gbnVtZXJhbC5fLnRvRml4ZWQodmFsdWUsIDAsIHJvdW5kaW5nRnVuY3Rpb24pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjaGVjayBhYmJyZXZpYXRpb24gYWdhaW4gYWZ0ZXIgcm91bmRpbmdcbiAgICAgICAgICAgIGlmIChhYmJyICYmICFhYmJyRm9yY2UgJiYgTnVtYmVyKGludCkgPj0gMTAwMCAmJiBhYmJyICE9PSBsb2NhbGUuYWJicmV2aWF0aW9ucy50cmlsbGlvbikge1xuICAgICAgICAgICAgICAgIGludCA9IFN0cmluZyhOdW1iZXIoaW50KSAvIDEwMDApO1xuXG4gICAgICAgICAgICAgICAgc3dpdGNoIChhYmJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgbG9jYWxlLmFiYnJldmlhdGlvbnMudGhvdXNhbmQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBhYmJyID0gbG9jYWxlLmFiYnJldmlhdGlvbnMubWlsbGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIGxvY2FsZS5hYmJyZXZpYXRpb25zLm1pbGxpb246XG4gICAgICAgICAgICAgICAgICAgICAgICBhYmJyID0gbG9jYWxlLmFiYnJldmlhdGlvbnMuYmlsbGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIGxvY2FsZS5hYmJyZXZpYXRpb25zLmJpbGxpb246XG4gICAgICAgICAgICAgICAgICAgICAgICBhYmJyID0gbG9jYWxlLmFiYnJldmlhdGlvbnMudHJpbGxpb247XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgLy8gZm9ybWF0IG51bWJlclxuICAgICAgICAgICAgaWYgKG51bWVyYWwuXy5pbmNsdWRlcyhpbnQsICctJykpIHtcbiAgICAgICAgICAgICAgICBpbnQgPSBpbnQuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgbmVnID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGludC5sZW5ndGggPCBsZWFkaW5nQ291bnQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gbGVhZGluZ0NvdW50IC0gaW50Lmxlbmd0aDsgaSA+IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICBpbnQgPSAnMCcgKyBpbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhvdXNhbmRzID4gLTEpIHtcbiAgICAgICAgICAgICAgICBpbnQgPSBpbnQudG9TdHJpbmcoKS5yZXBsYWNlKC8oXFxkKSg/PShcXGR7M30pKyg/IVxcZCkpL2csICckMScgKyBsb2NhbGUuZGVsaW1pdGVycy50aG91c2FuZHMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZm9ybWF0LmluZGV4T2YoJy4nKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGludCA9ICcnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvdXRwdXQgPSBpbnQgKyBkZWNpbWFsICsgKGFiYnIgPyBhYmJyIDogJycpO1xuXG4gICAgICAgICAgICBpZiAobmVnUCkge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IChuZWdQICYmIG5lZyA/ICcoJyA6ICcnKSArIG91dHB1dCArIChuZWdQICYmIG5lZyA/ICcpJyA6ICcnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHNpZ25lZCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IHNpZ25lZCA9PT0gMCA/IChuZWcgPyAnLScgOiAnKycpICsgb3V0cHV0IDogb3V0cHV0ICsgKG5lZyA/ICctJyA6ICcrJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChuZWcpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gJy0nICsgb3V0cHV0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gdW5mb3JtYXRzIG51bWJlcnMgc2VwYXJhdG9ycywgZGVjaW1hbHMgcGxhY2VzLCBzaWducywgYWJicmV2aWF0aW9uc1xuICAgICAgICBzdHJpbmdUb051bWJlcjogZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgICAgICB2YXIgbG9jYWxlID0gbG9jYWxlc1tvcHRpb25zLmN1cnJlbnRMb2NhbGVdLFxuICAgICAgICAgICAgICAgIHN0cmluZ09yaWdpbmFsID0gc3RyaW5nLFxuICAgICAgICAgICAgICAgIGFiYnJldmlhdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgIHRob3VzYW5kOiAzLFxuICAgICAgICAgICAgICAgICAgICBtaWxsaW9uOiA2LFxuICAgICAgICAgICAgICAgICAgICBiaWxsaW9uOiA5LFxuICAgICAgICAgICAgICAgICAgICB0cmlsbGlvbjogMTJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGFiYnJldmlhdGlvbixcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgIHJlZ2V4cDtcblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuemVyb0Zvcm1hdCAmJiBzdHJpbmcgPT09IG9wdGlvbnMuemVyb0Zvcm1hdCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5udWxsRm9ybWF0ICYmIHN0cmluZyA9PT0gb3B0aW9ucy5udWxsRm9ybWF0IHx8ICFzdHJpbmcucmVwbGFjZSgvW14wLTldKy9nLCAnJykubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IDE7XG5cbiAgICAgICAgICAgICAgICBpZiAobG9jYWxlLmRlbGltaXRlcnMuZGVjaW1hbCAhPT0gJy4nKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKC9cXC4vZywgJycpLnJlcGxhY2UobG9jYWxlLmRlbGltaXRlcnMuZGVjaW1hbCwgJy4nKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKGFiYnJldmlhdGlvbiBpbiBhYmJyZXZpYXRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZ2V4cCA9IG5ldyBSZWdFeHAoJ1teYS16QS1aXScgKyBsb2NhbGUuYWJicmV2aWF0aW9uc1thYmJyZXZpYXRpb25dICsgJyg/OlxcXFwpfChcXFxcJyArIGxvY2FsZS5jdXJyZW5jeS5zeW1ib2wgKyAnKT8oPzpcXFxcKSk/KT8kJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0cmluZ09yaWdpbmFsLm1hdGNoKHJlZ2V4cCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICo9IE1hdGgucG93KDEwLCBhYmJyZXZpYXRpb25zW2FiYnJldmlhdGlvbl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3IgbmVnYXRpdmUgbnVtYmVyXG4gICAgICAgICAgICAgICAgdmFsdWUgKj0gKHN0cmluZy5zcGxpdCgnLScpLmxlbmd0aCArIE1hdGgubWluKHN0cmluZy5zcGxpdCgnKCcpLmxlbmd0aCAtIDEsIHN0cmluZy5zcGxpdCgnKScpLmxlbmd0aCAtIDEpKSAlIDIgPyAxIDogLTE7XG5cbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgbm9uIG51bWJlcnNcbiAgICAgICAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZSgvW14wLTlcXC5dKy9nLCAnJyk7XG5cbiAgICAgICAgICAgICAgICB2YWx1ZSAqPSBOdW1iZXIoc3RyaW5nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBpc05hTjogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGlzTmFOKHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgaW5jbHVkZXM6IGZ1bmN0aW9uKHN0cmluZywgc2VhcmNoKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5nLmluZGV4T2Yoc2VhcmNoKSAhPT0gLTE7XG4gICAgICAgIH0sXG4gICAgICAgIGluc2VydDogZnVuY3Rpb24oc3RyaW5nLCBzdWJTdHJpbmcsIHN0YXJ0KSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5nLnNsaWNlKDAsIHN0YXJ0KSArIHN1YlN0cmluZyArIHN0cmluZy5zbGljZShzdGFydCk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlZHVjZTogZnVuY3Rpb24oYXJyYXksIGNhbGxiYWNrIC8qLCBpbml0aWFsVmFsdWUqLykge1xuICAgICAgICAgICAgaWYgKHRoaXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheS5wcm90b3R5cGUucmVkdWNlIGNhbGxlZCBvbiBudWxsIG9yIHVuZGVmaW5lZCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihjYWxsYmFjayArICcgaXMgbm90IGEgZnVuY3Rpb24nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHQgPSBPYmplY3QoYXJyYXkpLFxuICAgICAgICAgICAgICAgIGxlbiA9IHQubGVuZ3RoID4+PiAwLFxuICAgICAgICAgICAgICAgIGsgPSAwLFxuICAgICAgICAgICAgICAgIHZhbHVlO1xuXG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gYXJndW1lbnRzWzJdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoayA8IGxlbiAmJiAhKGsgaW4gdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaysrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChrID49IGxlbikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWR1Y2Ugb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0W2srK107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKDsgayA8IGxlbjsgaysrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGsgaW4gdCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGNhbGxiYWNrKHZhbHVlLCB0W2tdLCBrLCB0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21wdXRlcyB0aGUgbXVsdGlwbGllciBuZWNlc3NhcnkgdG8gbWFrZSB4ID49IDEsXG4gICAgICAgICAqIGVmZmVjdGl2ZWx5IGVsaW1pbmF0aW5nIG1pc2NhbGN1bGF0aW9ucyBjYXVzZWQgYnlcbiAgICAgICAgICogZmluaXRlIHByZWNpc2lvbi5cbiAgICAgICAgICovXG4gICAgICAgIG11bHRpcGxpZXI6IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICB2YXIgcGFydHMgPSB4LnRvU3RyaW5nKCkuc3BsaXQoJy4nKTtcblxuICAgICAgICAgICAgcmV0dXJuIHBhcnRzLmxlbmd0aCA8IDIgPyAxIDogTWF0aC5wb3coMTAsIHBhcnRzWzFdLmxlbmd0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHaXZlbiBhIHZhcmlhYmxlIG51bWJlciBvZiBhcmd1bWVudHMsIHJldHVybnMgdGhlIG1heGltdW1cbiAgICAgICAgICogbXVsdGlwbGllciB0aGF0IG11c3QgYmUgdXNlZCB0byBub3JtYWxpemUgYW4gb3BlcmF0aW9uIGludm9sdmluZ1xuICAgICAgICAgKiBhbGwgb2YgdGhlbS5cbiAgICAgICAgICovXG4gICAgICAgIGNvcnJlY3Rpb25GYWN0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgcmV0dXJuIGFyZ3MucmVkdWNlKGZ1bmN0aW9uKGFjY3VtLCBuZXh0KSB7XG4gICAgICAgICAgICAgICAgdmFyIG1uID0gXy5tdWx0aXBsaWVyKG5leHQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2N1bSA+IG1uID8gYWNjdW0gOiBtbjtcbiAgICAgICAgICAgIH0sIDEpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogSW1wbGVtZW50YXRpb24gb2YgdG9GaXhlZCgpIHRoYXQgdHJlYXRzIGZsb2F0cyBtb3JlIGxpa2UgZGVjaW1hbHNcbiAgICAgICAgICpcbiAgICAgICAgICogRml4ZXMgYmluYXJ5IHJvdW5kaW5nIGlzc3VlcyAoZWcuICgwLjYxNSkudG9GaXhlZCgyKSA9PT0gJzAuNjEnKSB0aGF0IHByZXNlbnRcbiAgICAgICAgICogcHJvYmxlbXMgZm9yIGFjY291bnRpbmctIGFuZCBmaW5hbmNlLXJlbGF0ZWQgc29mdHdhcmUuXG4gICAgICAgICAqL1xuICAgICAgICB0b0ZpeGVkOiBmdW5jdGlvbih2YWx1ZSwgbWF4RGVjaW1hbHMsIHJvdW5kaW5nRnVuY3Rpb24sIG9wdGlvbmFscykge1xuICAgICAgICAgICAgdmFyIHNwbGl0VmFsdWUgPSB2YWx1ZS50b1N0cmluZygpLnNwbGl0KCcuJyksXG4gICAgICAgICAgICAgICAgbWluRGVjaW1hbHMgPSBtYXhEZWNpbWFscyAtIChvcHRpb25hbHMgfHwgMCksXG4gICAgICAgICAgICAgICAgYm91bmRlZFByZWNpc2lvbixcbiAgICAgICAgICAgICAgICBvcHRpb25hbHNSZWdFeHAsXG4gICAgICAgICAgICAgICAgcG93ZXIsXG4gICAgICAgICAgICAgICAgb3V0cHV0O1xuXG4gICAgICAgICAgICAvLyBVc2UgdGhlIHNtYWxsZXN0IHByZWNpc2lvbiB2YWx1ZSBwb3NzaWJsZSB0byBhdm9pZCBlcnJvcnMgZnJvbSBmbG9hdGluZyBwb2ludCByZXByZXNlbnRhdGlvblxuICAgICAgICAgICAgaWYgKHNwbGl0VmFsdWUubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgIGJvdW5kZWRQcmVjaXNpb24gPSBNYXRoLm1pbihNYXRoLm1heChzcGxpdFZhbHVlWzFdLmxlbmd0aCwgbWluRGVjaW1hbHMpLCBtYXhEZWNpbWFscyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBib3VuZGVkUHJlY2lzaW9uID0gbWluRGVjaW1hbHM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBvd2VyID0gTWF0aC5wb3coMTAsIGJvdW5kZWRQcmVjaXNpb24pO1xuXG4gICAgICAgICAgICAvLyBNdWx0aXBseSB1cCBieSBwcmVjaXNpb24sIHJvdW5kIGFjY3VyYXRlbHksIHRoZW4gZGl2aWRlIGFuZCB1c2UgbmF0aXZlIHRvRml4ZWQoKTpcbiAgICAgICAgICAgIG91dHB1dCA9IChyb3VuZGluZ0Z1bmN0aW9uKHZhbHVlICsgJ2UrJyArIGJvdW5kZWRQcmVjaXNpb24pIC8gcG93ZXIpLnRvRml4ZWQoYm91bmRlZFByZWNpc2lvbik7XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25hbHMgPiBtYXhEZWNpbWFscyAtIGJvdW5kZWRQcmVjaXNpb24pIHtcbiAgICAgICAgICAgICAgICBvcHRpb25hbHNSZWdFeHAgPSBuZXcgUmVnRXhwKCdcXFxcLj8wezEsJyArIChvcHRpb25hbHMgLSAobWF4RGVjaW1hbHMgLSBib3VuZGVkUHJlY2lzaW9uKSkgKyAnfSQnKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQucmVwbGFjZShvcHRpb25hbHNSZWdFeHAsICcnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBhdmFsaWFibGUgb3B0aW9uc1xuICAgIG51bWVyYWwub3B0aW9ucyA9IG9wdGlvbnM7XG5cbiAgICAvLyBhdmFsaWFibGUgZm9ybWF0c1xuICAgIG51bWVyYWwuZm9ybWF0cyA9IGZvcm1hdHM7XG5cbiAgICAvLyBhdmFsaWFibGUgZm9ybWF0c1xuICAgIG51bWVyYWwubG9jYWxlcyA9IGxvY2FsZXM7XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIHNldHMgdGhlIGN1cnJlbnQgbG9jYWxlLiAgSWZcbiAgICAvLyBubyBhcmd1bWVudHMgYXJlIHBhc3NlZCBpbiwgaXQgd2lsbCBzaW1wbHkgcmV0dXJuIHRoZSBjdXJyZW50IGdsb2JhbFxuICAgIC8vIGxvY2FsZSBrZXkuXG4gICAgbnVtZXJhbC5sb2NhbGUgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgb3B0aW9ucy5jdXJyZW50TG9jYWxlID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3B0aW9ucy5jdXJyZW50TG9jYWxlO1xuICAgIH07XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIHByb3ZpZGVzIGFjY2VzcyB0byB0aGUgbG9hZGVkIGxvY2FsZSBkYXRhLiAgSWZcbiAgICAvLyBubyBhcmd1bWVudHMgYXJlIHBhc3NlZCBpbiwgaXQgd2lsbCBzaW1wbHkgcmV0dXJuIHRoZSBjdXJyZW50XG4gICAgLy8gZ2xvYmFsIGxvY2FsZSBvYmplY3QuXG4gICAgbnVtZXJhbC5sb2NhbGVEYXRhID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlc1tvcHRpb25zLmN1cnJlbnRMb2NhbGVdO1xuICAgICAgICB9XG5cbiAgICAgICAga2V5ID0ga2V5LnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgaWYgKCFsb2NhbGVzW2tleV0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBsb2NhbGUgOiAnICsga2V5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsb2NhbGVzW2tleV07XG4gICAgfTtcblxuICAgIG51bWVyYWwucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yICh2YXIgcHJvcGVydHkgaW4gZGVmYXVsdHMpIHtcbiAgICAgICAgICAgIG9wdGlvbnNbcHJvcGVydHldID0gZGVmYXVsdHNbcHJvcGVydHldO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIG51bWVyYWwuemVyb0Zvcm1hdCA9IGZ1bmN0aW9uKGZvcm1hdCkge1xuICAgICAgICBvcHRpb25zLnplcm9Gb3JtYXQgPSB0eXBlb2YoZm9ybWF0KSA9PT0gJ3N0cmluZycgPyBmb3JtYXQgOiBudWxsO1xuICAgIH07XG5cbiAgICBudW1lcmFsLm51bGxGb3JtYXQgPSBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIG9wdGlvbnMubnVsbEZvcm1hdCA9IHR5cGVvZihmb3JtYXQpID09PSAnc3RyaW5nJyA/IGZvcm1hdCA6IG51bGw7XG4gICAgfTtcblxuICAgIG51bWVyYWwuZGVmYXVsdEZvcm1hdCA9IGZ1bmN0aW9uKGZvcm1hdCkge1xuICAgICAgICBvcHRpb25zLmRlZmF1bHRGb3JtYXQgPSB0eXBlb2YoZm9ybWF0KSA9PT0gJ3N0cmluZycgPyBmb3JtYXQgOiAnMC4wJztcbiAgICB9O1xuXG4gICAgbnVtZXJhbC5yZWdpc3RlciA9IGZ1bmN0aW9uKHR5cGUsIG5hbWUsIGZvcm1hdCkge1xuICAgICAgICBuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgIGlmICh0aGlzW3R5cGUgKyAncyddW25hbWVdKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKG5hbWUgKyAnICcgKyB0eXBlICsgJyBhbHJlYWR5IHJlZ2lzdGVyZWQuJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzW3R5cGUgKyAncyddW25hbWVdID0gZm9ybWF0O1xuXG4gICAgICAgIHJldHVybiBmb3JtYXQ7XG4gICAgfTtcblxuXG4gICAgbnVtZXJhbC52YWxpZGF0ZSA9IGZ1bmN0aW9uKHZhbCwgY3VsdHVyZSkge1xuICAgICAgICB2YXIgX2RlY2ltYWxTZXAsXG4gICAgICAgICAgICBfdGhvdXNhbmRTZXAsXG4gICAgICAgICAgICBfY3VyclN5bWJvbCxcbiAgICAgICAgICAgIF92YWxBcnJheSxcbiAgICAgICAgICAgIF9hYmJyT2JqLFxuICAgICAgICAgICAgX3Rob3VzYW5kUmVnRXgsXG4gICAgICAgICAgICBsb2NhbGVEYXRhLFxuICAgICAgICAgICAgdGVtcDtcblxuICAgICAgICAvL2NvZXJjZSB2YWwgdG8gc3RyaW5nXG4gICAgICAgIGlmICh0eXBlb2YgdmFsICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFsICs9ICcnO1xuXG4gICAgICAgICAgICBpZiAoY29uc29sZS53YXJuKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdOdW1lcmFsLmpzOiBWYWx1ZSBpcyBub3Qgc3RyaW5nLiBJdCBoYXMgYmVlbiBjby1lcmNlZCB0bzogJywgdmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vdHJpbSB3aGl0ZXNwYWNlcyBmcm9tIGVpdGhlciBzaWRlc1xuICAgICAgICB2YWwgPSB2YWwudHJpbSgpO1xuXG4gICAgICAgIC8vaWYgdmFsIGlzIGp1c3QgZGlnaXRzIHJldHVybiB0cnVlXG4gICAgICAgIGlmICghIXZhbC5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9pZiB2YWwgaXMgZW1wdHkgcmV0dXJuIGZhbHNlXG4gICAgICAgIGlmICh2YWwgPT09ICcnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvL2dldCB0aGUgZGVjaW1hbCBhbmQgdGhvdXNhbmRzIHNlcGFyYXRvciBmcm9tIG51bWVyYWwubG9jYWxlRGF0YVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy9jaGVjayBpZiB0aGUgY3VsdHVyZSBpcyB1bmRlcnN0b29kIGJ5IG51bWVyYWwuIGlmIG5vdCwgZGVmYXVsdCBpdCB0byBjdXJyZW50IGxvY2FsZVxuICAgICAgICAgICAgbG9jYWxlRGF0YSA9IG51bWVyYWwubG9jYWxlRGF0YShjdWx0dXJlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbG9jYWxlRGF0YSA9IG51bWVyYWwubG9jYWxlRGF0YShudW1lcmFsLmxvY2FsZSgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vc2V0dXAgdGhlIGRlbGltaXRlcnMgYW5kIGN1cnJlbmN5IHN5bWJvbCBiYXNlZCBvbiBjdWx0dXJlL2xvY2FsZVxuICAgICAgICBfY3VyclN5bWJvbCA9IGxvY2FsZURhdGEuY3VycmVuY3kuc3ltYm9sO1xuICAgICAgICBfYWJick9iaiA9IGxvY2FsZURhdGEuYWJicmV2aWF0aW9ucztcbiAgICAgICAgX2RlY2ltYWxTZXAgPSBsb2NhbGVEYXRhLmRlbGltaXRlcnMuZGVjaW1hbDtcbiAgICAgICAgaWYgKGxvY2FsZURhdGEuZGVsaW1pdGVycy50aG91c2FuZHMgPT09ICcuJykge1xuICAgICAgICAgICAgX3Rob3VzYW5kU2VwID0gJ1xcXFwuJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF90aG91c2FuZFNlcCA9IGxvY2FsZURhdGEuZGVsaW1pdGVycy50aG91c2FuZHM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZGF0aW5nIGN1cnJlbmN5IHN5bWJvbFxuICAgICAgICB0ZW1wID0gdmFsLm1hdGNoKC9eW15cXGRdKy8pO1xuICAgICAgICBpZiAodGVtcCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFsID0gdmFsLnN1YnN0cigxKTtcbiAgICAgICAgICAgIGlmICh0ZW1wWzBdICE9PSBfY3VyclN5bWJvbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vdmFsaWRhdGluZyBhYmJyZXZpYXRpb24gc3ltYm9sXG4gICAgICAgIHRlbXAgPSB2YWwubWF0Y2goL1teXFxkXSskLyk7XG4gICAgICAgIGlmICh0ZW1wICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YWwgPSB2YWwuc2xpY2UoMCwgLTEpO1xuICAgICAgICAgICAgaWYgKHRlbXBbMF0gIT09IF9hYmJyT2JqLnRob3VzYW5kICYmIHRlbXBbMF0gIT09IF9hYmJyT2JqLm1pbGxpb24gJiYgdGVtcFswXSAhPT0gX2FiYnJPYmouYmlsbGlvbiAmJiB0ZW1wWzBdICE9PSBfYWJick9iai50cmlsbGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIF90aG91c2FuZFJlZ0V4ID0gbmV3IFJlZ0V4cChfdGhvdXNhbmRTZXAgKyAnezJ9Jyk7XG5cbiAgICAgICAgaWYgKCF2YWwubWF0Y2goL1teXFxkLixdL2cpKSB7XG4gICAgICAgICAgICBfdmFsQXJyYXkgPSB2YWwuc3BsaXQoX2RlY2ltYWxTZXApO1xuICAgICAgICAgICAgaWYgKF92YWxBcnJheS5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoX3ZhbEFycmF5Lmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICggISEgX3ZhbEFycmF5WzBdLm1hdGNoKC9eXFxkKy4qXFxkJC8pICYmICFfdmFsQXJyYXlbMF0ubWF0Y2goX3Rob3VzYW5kUmVnRXgpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3ZhbEFycmF5WzBdLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICggISEgX3ZhbEFycmF5WzBdLm1hdGNoKC9eXFxkKyQvKSAmJiAhX3ZhbEFycmF5WzBdLm1hdGNoKF90aG91c2FuZFJlZ0V4KSAmJiAhISBfdmFsQXJyYXlbMV0ubWF0Y2goL15cXGQrJC8pKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoICEhIF92YWxBcnJheVswXS5tYXRjaCgvXlxcZCsuKlxcZCQvKSAmJiAhX3ZhbEFycmF5WzBdLm1hdGNoKF90aG91c2FuZFJlZ0V4KSAmJiAhISBfdmFsQXJyYXlbMV0ubWF0Y2goL15cXGQrJC8pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgIE51bWVyYWwgUHJvdG90eXBlXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgbnVtZXJhbC5mbiA9IE51bWVyYWwucHJvdG90eXBlID0ge1xuICAgICAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtZXJhbCh0aGlzKTtcbiAgICAgICAgfSxcbiAgICAgICAgZm9ybWF0OiBmdW5jdGlvbihpbnB1dFN0cmluZywgcm91bmRpbmdGdW5jdGlvbikge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fdmFsdWUsXG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gaW5wdXRTdHJpbmcgfHwgb3B0aW9ucy5kZWZhdWx0Rm9ybWF0LFxuICAgICAgICAgICAgICAgIGtpbmQsXG4gICAgICAgICAgICAgICAgb3V0cHV0LFxuICAgICAgICAgICAgICAgIGZvcm1hdEZ1bmN0aW9uO1xuXG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgd2UgaGF2ZSBhIHJvdW5kaW5nRnVuY3Rpb25cbiAgICAgICAgICAgIHJvdW5kaW5nRnVuY3Rpb24gPSByb3VuZGluZ0Z1bmN0aW9uIHx8IE1hdGgucm91bmQ7XG5cbiAgICAgICAgICAgIC8vIGZvcm1hdCBiYXNlZCBvbiB2YWx1ZVxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSAwICYmIG9wdGlvbnMuemVyb0Zvcm1hdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IG9wdGlvbnMuemVyb0Zvcm1hdDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IG51bGwgJiYgb3B0aW9ucy5udWxsRm9ybWF0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gb3B0aW9ucy5udWxsRm9ybWF0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGtpbmQgaW4gZm9ybWF0cykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm9ybWF0Lm1hdGNoKGZvcm1hdHNba2luZF0ucmVnZXhwcy5mb3JtYXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXRGdW5jdGlvbiA9IGZvcm1hdHNba2luZF0uZm9ybWF0O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvcm1hdEZ1bmN0aW9uID0gZm9ybWF0RnVuY3Rpb24gfHwgbnVtZXJhbC5fLm51bWJlclRvRm9ybWF0O1xuXG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gZm9ybWF0RnVuY3Rpb24odmFsdWUsIGZvcm1hdCwgcm91bmRpbmdGdW5jdGlvbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH0sXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgaW5wdXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lucHV0O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IE51bWJlcih2YWx1ZSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBhZGQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgY29yckZhY3RvciA9IF8uY29ycmVjdGlvbkZhY3Rvci5jYWxsKG51bGwsIHRoaXMuX3ZhbHVlLCB2YWx1ZSk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNiYWNrKGFjY3VtLCBjdXJyLCBjdXJySSwgTykge1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2N1bSArIE1hdGgucm91bmQoY29yckZhY3RvciAqIGN1cnIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IF8ucmVkdWNlKFt0aGlzLl92YWx1ZSwgdmFsdWVdLCBjYmFjaywgMCkgLyBjb3JyRmFjdG9yO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgc3VidHJhY3Q6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgY29yckZhY3RvciA9IF8uY29ycmVjdGlvbkZhY3Rvci5jYWxsKG51bGwsIHRoaXMuX3ZhbHVlLCB2YWx1ZSk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNiYWNrKGFjY3VtLCBjdXJyLCBjdXJySSwgTykge1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2N1bSAtIE1hdGgucm91bmQoY29yckZhY3RvciAqIGN1cnIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IF8ucmVkdWNlKFt2YWx1ZV0sIGNiYWNrLCBNYXRoLnJvdW5kKHRoaXMuX3ZhbHVlICogY29yckZhY3RvcikpIC8gY29yckZhY3RvcjtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIG11bHRpcGx5OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgZnVuY3Rpb24gY2JhY2soYWNjdW0sIGN1cnIsIGN1cnJJLCBPKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvcnJGYWN0b3IgPSBfLmNvcnJlY3Rpb25GYWN0b3IoYWNjdW0sIGN1cnIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKGFjY3VtICogY29yckZhY3RvcikgKiBNYXRoLnJvdW5kKGN1cnIgKiBjb3JyRmFjdG9yKSAvIE1hdGgucm91bmQoY29yckZhY3RvciAqIGNvcnJGYWN0b3IpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IF8ucmVkdWNlKFt0aGlzLl92YWx1ZSwgdmFsdWVdLCBjYmFjaywgMSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBkaXZpZGU6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBjYmFjayhhY2N1bSwgY3VyciwgY3VyckksIE8pIHtcbiAgICAgICAgICAgICAgICB2YXIgY29yckZhY3RvciA9IF8uY29ycmVjdGlvbkZhY3RvcihhY2N1bSwgY3Vycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoYWNjdW0gKiBjb3JyRmFjdG9yKSAvIE1hdGgucm91bmQoY3VyciAqIGNvcnJGYWN0b3IpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IF8ucmVkdWNlKFt0aGlzLl92YWx1ZSwgdmFsdWVdLCBjYmFjayk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBkaWZmZXJlbmNlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguYWJzKG51bWVyYWwodGhpcy5fdmFsdWUpLnN1YnRyYWN0KHZhbHVlKS52YWx1ZSgpKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgIERlZmF1bHQgTG9jYWxlICYmIEZvcm1hdFxuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgIG51bWVyYWwucmVnaXN0ZXIoJ2xvY2FsZScsICdlbicsIHtcbiAgICAgICAgZGVsaW1pdGVyczoge1xuICAgICAgICAgICAgdGhvdXNhbmRzOiAnLCcsXG4gICAgICAgICAgICBkZWNpbWFsOiAnLidcbiAgICAgICAgfSxcbiAgICAgICAgYWJicmV2aWF0aW9uczoge1xuICAgICAgICAgICAgdGhvdXNhbmQ6ICdrJyxcbiAgICAgICAgICAgIG1pbGxpb246ICdtJyxcbiAgICAgICAgICAgIGJpbGxpb246ICdiJyxcbiAgICAgICAgICAgIHRyaWxsaW9uOiAndCdcbiAgICAgICAgfSxcbiAgICAgICAgb3JkaW5hbDogZnVuY3Rpb24obnVtYmVyKSB7XG4gICAgICAgICAgICB2YXIgYiA9IG51bWJlciAlIDEwO1xuICAgICAgICAgICAgcmV0dXJuICh+fihudW1iZXIgJSAxMDAgLyAxMCkgPT09IDEpID8gJ3RoJyA6XG4gICAgICAgICAgICAgICAgKGIgPT09IDEpID8gJ3N0JyA6XG4gICAgICAgICAgICAgICAgKGIgPT09IDIpID8gJ25kJyA6XG4gICAgICAgICAgICAgICAgKGIgPT09IDMpID8gJ3JkJyA6ICd0aCc7XG4gICAgICAgIH0sXG4gICAgICAgIGN1cnJlbmN5OiB7XG4gICAgICAgICAgICBzeW1ib2w6ICckJ1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBcblxuKGZ1bmN0aW9uKCkge1xuICAgICAgICBudW1lcmFsLnJlZ2lzdGVyKCdmb3JtYXQnLCAnYnBzJywge1xuICAgICAgICAgICAgcmVnZXhwczoge1xuICAgICAgICAgICAgICAgIGZvcm1hdDogLyhCUFMpLyxcbiAgICAgICAgICAgICAgICB1bmZvcm1hdDogLyhCUFMpL1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZvcm1hdDogZnVuY3Rpb24odmFsdWUsIGZvcm1hdCwgcm91bmRpbmdGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgIHZhciBzcGFjZSA9IG51bWVyYWwuXy5pbmNsdWRlcyhmb3JtYXQsICcgQlBTJykgPyAnICcgOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0O1xuXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSAqIDEwMDAwO1xuXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIHNwYWNlIGJlZm9yZSBCUFNcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgvXFxzP0JQUy8sICcnKTtcblxuICAgICAgICAgICAgICAgIG91dHB1dCA9IG51bWVyYWwuXy5udW1iZXJUb0Zvcm1hdCh2YWx1ZSwgZm9ybWF0LCByb3VuZGluZ0Z1bmN0aW9uKTtcblxuICAgICAgICAgICAgICAgIGlmIChudW1lcmFsLl8uaW5jbHVkZXMob3V0cHV0LCAnKScpKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dC5zcGxpdCgnJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNwbGljZSgtMSwgMCwgc3BhY2UgKyAnQlBTJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0LmpvaW4oJycpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dCArIHNwYWNlICsgJ0JQUyc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1bmZvcm1hdDogZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICsobnVtZXJhbC5fLnN0cmluZ1RvTnVtYmVyKHN0cmluZykgKiAwLjAwMDEpLnRvRml4ZWQoMTUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbn0pKCk7XG5cblxuKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGVjaW1hbCA9IHtcbiAgICAgICAgICAgIGJhc2U6IDEwMDAsXG4gICAgICAgICAgICBzdWZmaXhlczogWydCJywgJ0tCJywgJ01CJywgJ0dCJywgJ1RCJywgJ1BCJywgJ0VCJywgJ1pCJywgJ1lCJ11cbiAgICAgICAgfSxcbiAgICAgICAgYmluYXJ5ID0ge1xuICAgICAgICAgICAgYmFzZTogMTAyNCxcbiAgICAgICAgICAgIHN1ZmZpeGVzOiBbJ0InLCAnS2lCJywgJ01pQicsICdHaUInLCAnVGlCJywgJ1BpQicsICdFaUInLCAnWmlCJywgJ1lpQiddXG4gICAgICAgIH07XG5cbiAgICB2YXIgYWxsU3VmZml4ZXMgPSAgZGVjaW1hbC5zdWZmaXhlcy5jb25jYXQoYmluYXJ5LnN1ZmZpeGVzLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGRlY2ltYWwuc3VmZml4ZXMuaW5kZXhPZihpdGVtKSA8IDA7XG4gICAgICAgIH0pKTtcbiAgICAgICAgdmFyIHVuZm9ybWF0UmVnZXggPSBhbGxTdWZmaXhlcy5qb2luKCd8Jyk7XG4gICAgICAgIC8vIEFsbG93IHN1cHBvcnQgZm9yIEJQUyAoaHR0cDovL3d3dy5pbnZlc3RvcGVkaWEuY29tL3Rlcm1zL2IvYmFzaXNwb2ludC5hc3ApXG4gICAgICAgIHVuZm9ybWF0UmVnZXggPSAnKCcgKyB1bmZvcm1hdFJlZ2V4LnJlcGxhY2UoJ0InLCAnQig/IVBTKScpICsgJyknO1xuXG4gICAgbnVtZXJhbC5yZWdpc3RlcignZm9ybWF0JywgJ2J5dGVzJywge1xuICAgICAgICByZWdleHBzOiB7XG4gICAgICAgICAgICBmb3JtYXQ6IC8oWzBcXHNdaT9iKS8sXG4gICAgICAgICAgICB1bmZvcm1hdDogbmV3IFJlZ0V4cCh1bmZvcm1hdFJlZ2V4KVxuICAgICAgICB9LFxuICAgICAgICBmb3JtYXQ6IGZ1bmN0aW9uKHZhbHVlLCBmb3JtYXQsIHJvdW5kaW5nRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBvdXRwdXQsXG4gICAgICAgICAgICAgICAgYnl0ZXMgPSBudW1lcmFsLl8uaW5jbHVkZXMoZm9ybWF0LCAnaWInKSA/IGJpbmFyeSA6IGRlY2ltYWwsXG4gICAgICAgICAgICAgICAgc3VmZml4ID0gbnVtZXJhbC5fLmluY2x1ZGVzKGZvcm1hdCwgJyBiJykgfHwgbnVtZXJhbC5fLmluY2x1ZGVzKGZvcm1hdCwgJyBpYicpID8gJyAnIDogJycsXG4gICAgICAgICAgICAgICAgcG93ZXIsXG4gICAgICAgICAgICAgICAgbWluLFxuICAgICAgICAgICAgICAgIG1heDtcblxuICAgICAgICAgICAgLy8gY2hlY2sgZm9yIHNwYWNlIGJlZm9yZVxuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoL1xccz9pP2IvLCAnJyk7XG5cbiAgICAgICAgICAgIGZvciAocG93ZXIgPSAwOyBwb3dlciA8PSBieXRlcy5zdWZmaXhlcy5sZW5ndGg7IHBvd2VyKyspIHtcbiAgICAgICAgICAgICAgICBtaW4gPSBNYXRoLnBvdyhieXRlcy5iYXNlLCBwb3dlcik7XG4gICAgICAgICAgICAgICAgbWF4ID0gTWF0aC5wb3coYnl0ZXMuYmFzZSwgcG93ZXIgKyAxKTtcblxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gMCB8fCB2YWx1ZSA+PSBtaW4gJiYgdmFsdWUgPCBtYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VmZml4ICs9IGJ5dGVzLnN1ZmZpeGVzW3Bvd2VyXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAobWluID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSAvIG1pbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb3V0cHV0ID0gbnVtZXJhbC5fLm51bWJlclRvRm9ybWF0KHZhbHVlLCBmb3JtYXQsIHJvdW5kaW5nRnVuY3Rpb24pO1xuXG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0ICsgc3VmZml4O1xuICAgICAgICB9LFxuICAgICAgICB1bmZvcm1hdDogZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBudW1lcmFsLl8uc3RyaW5nVG9OdW1iZXIoc3RyaW5nKSxcbiAgICAgICAgICAgICAgICBwb3dlcixcbiAgICAgICAgICAgICAgICBieXRlc011bHRpcGxpZXI7XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGZvciAocG93ZXIgPSBkZWNpbWFsLnN1ZmZpeGVzLmxlbmd0aCAtIDE7IHBvd2VyID49IDA7IHBvd2VyLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG51bWVyYWwuXy5pbmNsdWRlcyhzdHJpbmcsIGRlY2ltYWwuc3VmZml4ZXNbcG93ZXJdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZXNNdWx0aXBsaWVyID0gTWF0aC5wb3coZGVjaW1hbC5iYXNlLCBwb3dlcik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG51bWVyYWwuXy5pbmNsdWRlcyhzdHJpbmcsIGJpbmFyeS5zdWZmaXhlc1twb3dlcl0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBieXRlc011bHRpcGxpZXIgPSBNYXRoLnBvdyhiaW5hcnkuYmFzZSwgcG93ZXIpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhbHVlICo9IChieXRlc011bHRpcGxpZXIgfHwgMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xufSkoKTtcblxuXG4oZnVuY3Rpb24oKSB7XG4gICAgICAgIG51bWVyYWwucmVnaXN0ZXIoJ2Zvcm1hdCcsICdjdXJyZW5jeScsIHtcbiAgICAgICAgcmVnZXhwczoge1xuICAgICAgICAgICAgZm9ybWF0OiAvKFxcJCkvXG4gICAgICAgIH0sXG4gICAgICAgIGZvcm1hdDogZnVuY3Rpb24odmFsdWUsIGZvcm1hdCwgcm91bmRpbmdGdW5jdGlvbikge1xuICAgICAgICAgICAgdmFyIGxvY2FsZSA9IG51bWVyYWwubG9jYWxlc1tudW1lcmFsLm9wdGlvbnMuY3VycmVudExvY2FsZV0sXG4gICAgICAgICAgICAgICAgc3ltYm9scyA9IHtcbiAgICAgICAgICAgICAgICAgICAgYmVmb3JlOiBmb3JtYXQubWF0Y2goL14oW1xcK3xcXC18XFwofFxcc3xcXCRdKikvKVswXSxcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXI6IGZvcm1hdC5tYXRjaCgvKFtcXCt8XFwtfFxcKXxcXHN8XFwkXSopJC8pWzBdXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvdXRwdXQsXG4gICAgICAgICAgICAgICAgc3ltYm9sLFxuICAgICAgICAgICAgICAgIGk7XG5cbiAgICAgICAgICAgIC8vIHN0cmlwIGZvcm1hdCBvZiBzcGFjZXMgYW5kICRcbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKC9cXHM/XFwkXFxzPy8sICcnKTtcblxuICAgICAgICAgICAgLy8gZm9ybWF0IHRoZSBudW1iZXJcbiAgICAgICAgICAgIG91dHB1dCA9IG51bWVyYWwuXy5udW1iZXJUb0Zvcm1hdCh2YWx1ZSwgZm9ybWF0LCByb3VuZGluZ0Z1bmN0aW9uKTtcblxuICAgICAgICAgICAgLy8gdXBkYXRlIHRoZSBiZWZvcmUgYW5kIGFmdGVyIGJhc2VkIG9uIHZhbHVlXG4gICAgICAgICAgICBpZiAodmFsdWUgPj0gMCkge1xuICAgICAgICAgICAgICAgIHN5bWJvbHMuYmVmb3JlID0gc3ltYm9scy5iZWZvcmUucmVwbGFjZSgvW1xcLVxcKF0vLCAnJyk7XG4gICAgICAgICAgICAgICAgc3ltYm9scy5hZnRlciA9IHN5bWJvbHMuYWZ0ZXIucmVwbGFjZSgvW1xcLVxcKV0vLCAnJyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlIDwgMCAmJiAoIW51bWVyYWwuXy5pbmNsdWRlcyhzeW1ib2xzLmJlZm9yZSwgJy0nKSAmJiAhbnVtZXJhbC5fLmluY2x1ZGVzKHN5bWJvbHMuYmVmb3JlLCAnKCcpKSkge1xuICAgICAgICAgICAgICAgIHN5bWJvbHMuYmVmb3JlID0gJy0nICsgc3ltYm9scy5iZWZvcmU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGxvb3AgdGhyb3VnaCBlYWNoIGJlZm9yZSBzeW1ib2xcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzeW1ib2xzLmJlZm9yZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHN5bWJvbCA9IHN5bWJvbHMuYmVmb3JlW2ldO1xuXG4gICAgICAgICAgICAgICAgc3dpdGNoIChzeW1ib2wpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnJCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSBudW1lcmFsLl8uaW5zZXJ0KG91dHB1dCwgbG9jYWxlLmN1cnJlbmN5LnN5bWJvbCwgaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnICc6XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSBudW1lcmFsLl8uaW5zZXJ0KG91dHB1dCwgJyAnLCBpICsgbG9jYWxlLmN1cnJlbmN5LnN5bWJvbC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbG9vcCB0aHJvdWdoIGVhY2ggYWZ0ZXIgc3ltYm9sXG4gICAgICAgICAgICBmb3IgKGkgPSBzeW1ib2xzLmFmdGVyLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgc3ltYm9sID0gc3ltYm9scy5hZnRlcltpXTtcblxuICAgICAgICAgICAgICAgIHN3aXRjaCAoc3ltYm9sKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJyQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gaSA9PT0gc3ltYm9scy5hZnRlci5sZW5ndGggLSAxID8gb3V0cHV0ICsgbG9jYWxlLmN1cnJlbmN5LnN5bWJvbCA6IG51bWVyYWwuXy5pbnNlcnQob3V0cHV0LCBsb2NhbGUuY3VycmVuY3kuc3ltYm9sLCAtKHN5bWJvbHMuYWZ0ZXIubGVuZ3RoIC0gKDEgKyBpKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJyAnOlxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gaSA9PT0gc3ltYm9scy5hZnRlci5sZW5ndGggLSAxID8gb3V0cHV0ICsgJyAnIDogbnVtZXJhbC5fLmluc2VydChvdXRwdXQsICcgJywgLShzeW1ib2xzLmFmdGVyLmxlbmd0aCAtICgxICsgaSkgKyBsb2NhbGUuY3VycmVuY3kuc3ltYm9sLmxlbmd0aCAtIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9XG4gICAgfSk7XG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcbiAgICAgICAgbnVtZXJhbC5yZWdpc3RlcignZm9ybWF0JywgJ2V4cG9uZW50aWFsJywge1xuICAgICAgICByZWdleHBzOiB7XG4gICAgICAgICAgICBmb3JtYXQ6IC8oZVxcK3xlLSkvLFxuICAgICAgICAgICAgdW5mb3JtYXQ6IC8oZVxcK3xlLSkvXG4gICAgICAgIH0sXG4gICAgICAgIGZvcm1hdDogZnVuY3Rpb24odmFsdWUsIGZvcm1hdCwgcm91bmRpbmdGdW5jdGlvbikge1xuICAgICAgICAgICAgdmFyIG91dHB1dCxcbiAgICAgICAgICAgICAgICBleHBvbmVudGlhbCA9IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgIW51bWVyYWwuXy5pc05hTih2YWx1ZSkgPyB2YWx1ZS50b0V4cG9uZW50aWFsKCkgOiAnMGUrMCcsXG4gICAgICAgICAgICAgICAgcGFydHMgPSBleHBvbmVudGlhbC5zcGxpdCgnZScpO1xuXG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgvZVtcXCt8XFwtXXsxfTAvLCAnJyk7XG5cbiAgICAgICAgICAgIG91dHB1dCA9IG51bWVyYWwuXy5udW1iZXJUb0Zvcm1hdChOdW1iZXIocGFydHNbMF0pLCBmb3JtYXQsIHJvdW5kaW5nRnVuY3Rpb24pO1xuXG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0ICsgJ2UnICsgcGFydHNbMV07XG4gICAgICAgIH0sXG4gICAgICAgIHVuZm9ybWF0OiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgICAgIHZhciBwYXJ0cyA9IG51bWVyYWwuXy5pbmNsdWRlcyhzdHJpbmcsICdlKycpID8gc3RyaW5nLnNwbGl0KCdlKycpIDogc3RyaW5nLnNwbGl0KCdlLScpLFxuICAgICAgICAgICAgICAgIHZhbHVlID0gTnVtYmVyKHBhcnRzWzBdKSxcbiAgICAgICAgICAgICAgICBwb3dlciA9IE51bWJlcihwYXJ0c1sxXSk7XG5cbiAgICAgICAgICAgIHBvd2VyID0gbnVtZXJhbC5fLmluY2x1ZGVzKHN0cmluZywgJ2UtJykgPyBwb3dlciAqPSAtMSA6IHBvd2VyO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBjYmFjayhhY2N1bSwgY3VyciwgY3VyckksIE8pIHtcbiAgICAgICAgICAgICAgICB2YXIgY29yckZhY3RvciA9IG51bWVyYWwuXy5jb3JyZWN0aW9uRmFjdG9yKGFjY3VtLCBjdXJyKSxcbiAgICAgICAgICAgICAgICAgICAgbnVtID0gKGFjY3VtICogY29yckZhY3RvcikgKiAoY3VyciAqIGNvcnJGYWN0b3IpIC8gKGNvcnJGYWN0b3IgKiBjb3JyRmFjdG9yKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbnVtZXJhbC5fLnJlZHVjZShbdmFsdWUsIE1hdGgucG93KDEwLCBwb3dlcildLCBjYmFjaywgMSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn0pKCk7XG5cblxuKGZ1bmN0aW9uKCkge1xuICAgICAgICBudW1lcmFsLnJlZ2lzdGVyKCdmb3JtYXQnLCAnb3JkaW5hbCcsIHtcbiAgICAgICAgcmVnZXhwczoge1xuICAgICAgICAgICAgZm9ybWF0OiAvKG8pL1xuICAgICAgICB9LFxuICAgICAgICBmb3JtYXQ6IGZ1bmN0aW9uKHZhbHVlLCBmb3JtYXQsIHJvdW5kaW5nRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBsb2NhbGUgPSBudW1lcmFsLmxvY2FsZXNbbnVtZXJhbC5vcHRpb25zLmN1cnJlbnRMb2NhbGVdLFxuICAgICAgICAgICAgICAgIG91dHB1dCxcbiAgICAgICAgICAgICAgICBvcmRpbmFsID0gbnVtZXJhbC5fLmluY2x1ZGVzKGZvcm1hdCwgJyBvJykgPyAnICcgOiAnJztcblxuICAgICAgICAgICAgLy8gY2hlY2sgZm9yIHNwYWNlIGJlZm9yZVxuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoL1xccz9vLywgJycpO1xuXG4gICAgICAgICAgICBvcmRpbmFsICs9IGxvY2FsZS5vcmRpbmFsKHZhbHVlKTtcblxuICAgICAgICAgICAgb3V0cHV0ID0gbnVtZXJhbC5fLm51bWJlclRvRm9ybWF0KHZhbHVlLCBmb3JtYXQsIHJvdW5kaW5nRnVuY3Rpb24pO1xuXG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0ICsgb3JkaW5hbDtcbiAgICAgICAgfVxuICAgIH0pO1xufSkoKTtcblxuXG4oZnVuY3Rpb24oKSB7XG4gICAgICAgIG51bWVyYWwucmVnaXN0ZXIoJ2Zvcm1hdCcsICdwZXJjZW50YWdlJywge1xuICAgICAgICByZWdleHBzOiB7XG4gICAgICAgICAgICBmb3JtYXQ6IC8oJSkvLFxuICAgICAgICAgICAgdW5mb3JtYXQ6IC8oJSkvXG4gICAgICAgIH0sXG4gICAgICAgIGZvcm1hdDogZnVuY3Rpb24odmFsdWUsIGZvcm1hdCwgcm91bmRpbmdGdW5jdGlvbikge1xuICAgICAgICAgICAgdmFyIHNwYWNlID0gbnVtZXJhbC5fLmluY2x1ZGVzKGZvcm1hdCwgJyAlJykgPyAnICcgOiAnJyxcbiAgICAgICAgICAgICAgICBvdXRwdXQ7XG5cbiAgICAgICAgICAgIGlmIChudW1lcmFsLm9wdGlvbnMuc2NhbGVQZXJjZW50QnkxMDApIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlICogMTAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjaGVjayBmb3Igc3BhY2UgYmVmb3JlICVcbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKC9cXHM/XFwlLywgJycpO1xuXG4gICAgICAgICAgICBvdXRwdXQgPSBudW1lcmFsLl8ubnVtYmVyVG9Gb3JtYXQodmFsdWUsIGZvcm1hdCwgcm91bmRpbmdGdW5jdGlvbik7XG5cbiAgICAgICAgICAgIGlmIChudW1lcmFsLl8uaW5jbHVkZXMob3V0cHV0LCAnKScpKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0LnNwbGl0KCcnKTtcblxuICAgICAgICAgICAgICAgIG91dHB1dC5zcGxpY2UoLTEsIDAsIHNwYWNlICsgJyUnKTtcblxuICAgICAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dC5qb2luKCcnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0ICsgc3BhY2UgKyAnJSc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH0sXG4gICAgICAgIHVuZm9ybWF0OiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgICAgIHZhciBudW1iZXIgPSBudW1lcmFsLl8uc3RyaW5nVG9OdW1iZXIoc3RyaW5nKTtcbiAgICAgICAgICAgIGlmIChudW1lcmFsLm9wdGlvbnMuc2NhbGVQZXJjZW50QnkxMDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyICogMC4wMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudW1iZXI7XG4gICAgICAgIH1cbiAgICB9KTtcbn0pKCk7XG5cblxuKGZ1bmN0aW9uKCkge1xuICAgICAgICBudW1lcmFsLnJlZ2lzdGVyKCdmb3JtYXQnLCAndGltZScsIHtcbiAgICAgICAgcmVnZXhwczoge1xuICAgICAgICAgICAgZm9ybWF0OiAvKDopLyxcbiAgICAgICAgICAgIHVuZm9ybWF0OiAvKDopL1xuICAgICAgICB9LFxuICAgICAgICBmb3JtYXQ6IGZ1bmN0aW9uKHZhbHVlLCBmb3JtYXQsIHJvdW5kaW5nRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBob3VycyA9IE1hdGguZmxvb3IodmFsdWUgLyA2MCAvIDYwKSxcbiAgICAgICAgICAgICAgICBtaW51dGVzID0gTWF0aC5mbG9vcigodmFsdWUgLSAoaG91cnMgKiA2MCAqIDYwKSkgLyA2MCksXG4gICAgICAgICAgICAgICAgc2Vjb25kcyA9IE1hdGgucm91bmQodmFsdWUgLSAoaG91cnMgKiA2MCAqIDYwKSAtIChtaW51dGVzICogNjApKTtcblxuICAgICAgICAgICAgcmV0dXJuIGhvdXJzICsgJzonICsgKG1pbnV0ZXMgPCAxMCA/ICcwJyArIG1pbnV0ZXMgOiBtaW51dGVzKSArICc6JyArIChzZWNvbmRzIDwgMTAgPyAnMCcgKyBzZWNvbmRzIDogc2Vjb25kcyk7XG4gICAgICAgIH0sXG4gICAgICAgIHVuZm9ybWF0OiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgICAgIHZhciB0aW1lQXJyYXkgPSBzdHJpbmcuc3BsaXQoJzonKSxcbiAgICAgICAgICAgICAgICBzZWNvbmRzID0gMDtcblxuICAgICAgICAgICAgLy8gdHVybiBob3VycyBhbmQgbWludXRlcyBpbnRvIHNlY29uZHMgYW5kIGFkZCB0aGVtIGFsbCB1cFxuICAgICAgICAgICAgaWYgKHRpbWVBcnJheS5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgICAgICAvLyBob3Vyc1xuICAgICAgICAgICAgICAgIHNlY29uZHMgPSBzZWNvbmRzICsgKE51bWJlcih0aW1lQXJyYXlbMF0pICogNjAgKiA2MCk7XG4gICAgICAgICAgICAgICAgLy8gbWludXRlc1xuICAgICAgICAgICAgICAgIHNlY29uZHMgPSBzZWNvbmRzICsgKE51bWJlcih0aW1lQXJyYXlbMV0pICogNjApO1xuICAgICAgICAgICAgICAgIC8vIHNlY29uZHNcbiAgICAgICAgICAgICAgICBzZWNvbmRzID0gc2Vjb25kcyArIE51bWJlcih0aW1lQXJyYXlbMl0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aW1lQXJyYXkubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgLy8gbWludXRlc1xuICAgICAgICAgICAgICAgIHNlY29uZHMgPSBzZWNvbmRzICsgKE51bWJlcih0aW1lQXJyYXlbMF0pICogNjApO1xuICAgICAgICAgICAgICAgIC8vIHNlY29uZHNcbiAgICAgICAgICAgICAgICBzZWNvbmRzID0gc2Vjb25kcyArIE51bWJlcih0aW1lQXJyYXlbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIE51bWJlcihzZWNvbmRzKTtcbiAgICAgICAgfVxuICAgIH0pO1xufSkoKTtcblxucmV0dXJuIG51bWVyYWw7XG59KSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/numeral/numeral.js\n");

/***/ }),

/***/ "./node_modules/vue-country-flag/dist/country-flag.esm.js":
/*!****************************************************************!*\
  !*** ./node_modules/vue-country-flag/dist/country-flag.esm.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(global) {!function(A,o){void 0===o&&(o={});var f=o.insertAt;if(A&&\"undefined\"!=typeof document){var g=document.head||document.getElementsByTagName(\"head\")[0],n=document.createElement(\"style\");n.type=\"text/css\",\"top\"===f&&g.firstChild?g.insertBefore(n,g.firstChild):g.appendChild(n),n.styleSheet?n.styleSheet.cssText=A:n.appendChild(document.createTextNode(A))}}('.flag{width:60px;height:40px;display:inline-block;background:url(\"data:image/png;base64,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\")}.f-and,.f-andorra{background-position:0 -41px}.f-ae,.f-are{background-position:0 -82px}.f-af,.f-afg{background-position:0 -123px}.f-ag,.f-atg{background-position:0 -164px}.f-ai,.f-aia{background-position:0 -205px}.f-al,.f-alb{background-position:0 -246px}.f-am,.f-arm{background-position:0 -287px}.f-an,.f-ant{background-position:0 -328px}.f-ago,.f-ao{background-position:0 -369px}.f-aq,.f-ata{background-position:0 -410px}.f-ar,.f-arg{background-position:0 -451px}.f-as,.f-asm{background-position:0 -492px}.f-at,.f-aut{background-position:0 -533px}.f-au,.f-aus{background-position:0 -574px}.f-abw,.f-aw{background-position:0 -615px}.f-ala,.f-ax{background-position:0 -656px}.f-az,.f-aze{background-position:0 -697px}.f-ba,.f-bih{background-position:0 -738px}.f-bb,.f-brb{background-position:0 -779px}.f-bd,.f-bgd{background-position:0 -820px}.f-be,.f-bel{background-position:0 -861px}.f-bf,.f-bfa{background-position:0 -902px}.f-bg,.f-bgr{background-position:0 -943px}.f-bh,.f-bhr{background-position:0 -984px}.f-bdi,.f-bi{background-position:0 -1025px}.f-ben,.f-bj{background-position:0 -1066px}.f-bl,.f-blm{background-position:0 -1107px}.f-bm,.f-bmu{background-position:0 -1148px}.f-bn,.f-brn{background-position:0 -1189px}.f-bo,.f-bol{background-position:0 -1230px}.f-bes,.f-bq{background-position:0 -1271px}.f-br,.f-bra{background-position:0 -1312px}.f-bhs,.f-bs{background-position:0 -1353px}.f-bt,.f-btn{background-position:0 -1394px}.f-bv,.f-bvt{background-position:0 -1435px}.f-bw,.f-bwa{background-position:0 -1476px}.f-blr,.f-by{background-position:0 -1517px}.f-blz,.f-bz{background-position:0 -1558px}.f-ca,.f-can{background-position:0 -1599px}.f-cc,.f-cck{background-position:0 -1640px}.f-cd,.f-cod{background-position:0 -1681px}.f-caf,.f-cf{background-position:0 -1722px}.f-cg,.f-cog{background-position:0 -1763px}.f-ch,.f-che{background-position:0 -1804px}.f-ci,.f-civ{background-position:0 -1845px}.f-ck,.f-cok{background-position:0 -1886px}.f-chl,.f-cl{background-position:0 -1927px}.f-cm,.f-cmr{background-position:0 -1968px}.f-chn,.f-cn{background-position:0 -2009px}.f-co,.f-col{background-position:0 -2050px}.f-cr,.f-cri{background-position:0 -2091px}.f-cu,.f-cub{background-position:0 -2132px}.f-cpv,.f-cv{background-position:0 -2173px}.f-cuw,.f-cw{background-position:0 -2214px}.f-cx,.f-cxr{background-position:0 -2255px}.f-cy,.f-cyp{background-position:0 -2296px}.f-cz,.f-cze{background-position:0 -2337px}.f-de,.f-deu{background-position:0 -2378px}.f-dj,.f-dji{background-position:0 -2419px}.f-dk,.f-dnk{background-position:0 -2460px}.f-dm,.f-dma{background-position:0 -2501px}.f-do,.f-dom{background-position:0 -2542px}.f-dz,.f-dza{background-position:0 -2583px}.f-ec,.f-ecu{background-position:0 -2624px}.f-ee,.f-est{background-position:0 -2665px}.f-eg,.f-egy{background-position:0 -2706px}.f-eh,.f-esh{background-position:0 -2747px}.f-er,.f-eri{background-position:0 -2788px}.f-es-ca{background-position:0 -2829px}.f-es,.f-esp{background-position:0 -2870px}.f-et,.f-eth{background-position:0 -2911px}.f-eu{background-position:0 -2952px}.f-fi,.f-fin{background-position:0 -2993px}.f-fj,.f-fji{background-position:0 -3034px}.f-fk,.f-flk{background-position:0 -3075px}.f-fm,.f-fsm{background-position:0 -3116px}.f-fo,.f-fro{background-position:0 -3157px}.f-fr,.f-fra{background-position:0 -3198px}.f-ga,.f-gab{background-position:0 -3239px}.f-gb-eng{background-position:0 -3280px}.f-gb-nir{background-position:0 -3321px}.f-gb-sct{background-position:0 -3362px}.f-gb-wls{background-position:0 -3403px}.f-gb,.f-gbr{background-position:0 -3444px}.f-gd,.f-grd{background-position:0 -3485px}.f-ge,.f-geo{background-position:0 -3526px}.f-gf,.f-guf{background-position:0 -3567px}.f-gg,.f-ggy{background-position:0 -3608px}.f-gh,.f-gha{background-position:0 -3649px}.f-gi,.f-gib{background-position:0 -3690px}.f-gl,.f-grl{background-position:0 -3731px}.f-gm,.f-gmb{background-position:0 -3772px}.f-gin,.f-gn{background-position:0 -3813px}.f-glp,.f-gp{background-position:0 -3854px}.f-gnq,.f-gq{background-position:0 -3895px}.f-gr,.f-grc{background-position:0 -3936px}.f-gs,.f-sgs{background-position:0 -3977px}.f-gt,.f-gtm{background-position:0 -4018px}.f-gu,.f-gum{background-position:0 -4059px}.f-gnb,.f-gw{background-position:0 -4100px}.f-guy,.f-gy{background-position:0 -4141px}.f-hk,.f-hkg{background-position:0 -4182px}.f-hm,.f-hmd{background-position:0 -4223px}.f-hn,.f-hnd{background-position:0 -4264px}.f-hr,.f-hrv{background-position:0 -4305px}.f-ht,.f-hti{background-position:0 -4346px}.f-hu,.f-hun{background-position:0 -4387px}.f-id,.f-idn{background-position:0 -4428px}.f-ie,.f-irl{background-position:0 -4469px}.f-il,.f-isr{background-position:0 -4510px}.f-im,.f-imn{background-position:0 -4551px}.f-in,.f-ind{background-position:0 -4592px}.f-io,.f-iot{background-position:0 -4633px}.f-iq,.f-irq{background-position:0 -4674px}.f-ir,.f-irn{background-position:0 -4715px}.f-is,.f-isl{background-position:0 -4756px}.f-it,.f-ita{background-position:0 -4797px}.f-je,.f-jey{background-position:0 -4838px}.f-jam,.f-jm{background-position:0 -4879px}.f-jo,.f-jor{background-position:0 -4920px}.f-jp,.f-jpn{background-position:0 -4961px}.f-ke,.f-ken{background-position:0 -5002px}.f-kg,.f-kgz{background-position:0 -5043px}.f-kh,.f-khm{background-position:0 -5084px}.f-ki,.f-kir{background-position:0 -5125px}.f-com,.f-km{background-position:0 -5166px}.f-kn,.f-kna{background-position:0 -5207px}.f-kp,.f-prk{background-position:0 -5248px}.f-kor,.f-kr{background-position:0 -5289px}.f-kw,.f-kwt{background-position:0 -5330px}.f-cym,.f-ky{background-position:0 -5371px}.f-kaz,.f-kz{background-position:0 -5412px}.f-la,.f-lao{background-position:0 -5453px}.f-lb,.f-lbn{background-position:0 -5494px}.f-lc,.f-lca{background-position:0 -5535px}.f-li,.f-lie{background-position:0 -5576px}.f-lk,.f-lka{background-position:0 -5617px}.f-lbr,.f-lr{background-position:0 -5658px}.f-ls,.f-lso{background-position:0 -5699px}.f-lt,.f-ltu{background-position:0 -5740px}.f-lu,.f-lux{background-position:0 -5781px}.f-lv,.f-lva{background-position:0 -5822px}.f-lby,.f-ly{background-position:0 -5863px}.f-ma,.f-mar{background-position:0 -5904px}.f-mc,.f-mco{background-position:0 -5945px}.f-md,.f-mda{background-position:0 -5986px}.f-me,.f-mne{background-position:0 -6027px}.f-maf,.f-mf{background-position:0 -6068px}.f-mdg,.f-mg{background-position:0 -6109px}.f-mh,.f-mhl{background-position:0 -6150px}.f-mk,.f-mkd{background-position:0 -6191px}.f-ml,.f-mli{background-position:0 -6232px}.f-mm,.f-mmr{background-position:0 -6273px}.f-mn,.f-mng{background-position:0 -6314px}.f-mac,.f-mo{background-position:0 -6355px}.f-mnp,.f-mp{background-position:0 -6396px}.f-mq,.f-mtq{background-position:0 -6437px}.f-mr,.f-mrt{background-position:0 -6478px}.f-ms,.f-msr{background-position:0 -6519px}.f-mlt,.f-mt{background-position:0 -6560px}.f-mu,.f-mus{background-position:0 -6601px}.f-mdv,.f-mv{background-position:0 -6642px}.f-mw,.f-mwi{background-position:0 -6683px}.f-mex,.f-mx{background-position:0 -6724px}.f-my,.f-mys{background-position:0 -6765px}.f-moz,.f-mz{background-position:0 -6806px}.f-na,.f-nam{background-position:0 -6847px}.f-nc,.f-ncl{background-position:0 -6888px}.f-ne,.f-ner{background-position:0 -6929px}.f-nf,.f-nfk{background-position:0 -6970px}.f-ng,.f-nga{background-position:0 -7011px}.f-ni,.f-nic{background-position:0 -7052px}.f-nl,.f-nld{background-position:0 -7093px}.f-no,.f-nor{background-position:0 -7134px}.f-np,.f-npl{background-position:0 -7175px}.f-nr,.f-nru{background-position:0 -7216px}.f-niu,.f-nu{background-position:0 -7257px}.f-nz,.f-nzl{background-position:0 -7298px}.f-om,.f-omn{background-position:0 -7339px}.f-pa,.f-pan{background-position:0 -7380px}.f-pe,.f-per{background-position:0 -7421px}.f-pf,.f-pyf{background-position:0 -7462px}.f-pg,.f-png{background-position:0 -7503px}.f-ph,.f-phl{background-position:0 -7544px}.f-pak,.f-pk{background-position:0 -7585px}.f-pl,.f-pol{background-position:0 -7626px}.f-pm,.f-spm{background-position:0 -7667px}.f-pcn,.f-pn{background-position:0 -7708px}.f-pr,.f-pri{background-position:0 -7749px}.f-ps,.f-pse{background-position:0 -7790px}.f-prt,.f-pt{background-position:0 -7831px}.f-plw,.f-pw{background-position:0 -7872px}.f-pry,.f-py{background-position:0 -7913px}.f-qa,.f-qat{background-position:0 -7954px}.f-re,.f-reu{background-position:0 -7995px}.f-ro,.f-rou{background-position:0 -8036px}.f-rs,.f-srb{background-position:0 -8077px}.f-ru,.f-rus{background-position:0 -8118px}.f-rw,.f-rwa{background-position:0 -8159px}.f-sa,.f-sau{background-position:0 -8200px}.f-sb,.f-slb{background-position:0 -8241px}.f-sc,.f-syc{background-position:0 -8282px}.f-sd,.f-sdn{background-position:0 -8323px}.f-se,.f-swe{background-position:0 -8364px}.f-sg,.f-sgp{background-position:0 -8405px}.f-sh,.f-shn{background-position:0 -8446px}.f-si,.f-svn{background-position:0 -8487px}.f-sj,.f-sjm{background-position:0 -8528px}.f-sk,.f-svk{background-position:0 -8569px}.f-sl,.f-sle{background-position:0 -8610px}.f-sm,.f-smr{background-position:0 -8651px}.f-sen,.f-sn{background-position:0 -8692px}.f-so,.f-som{background-position:0 -8733px}.f-sr,.f-sur{background-position:0 -8774px}.f-ss,.f-ssd{background-position:0 -8815px}.f-st,.f-stp{background-position:0 -8856px}.f-slv,.f-sv{background-position:0 -8897px}.f-sx,.f-sxm{background-position:0 -8938px}.f-sy,.f-syr{background-position:0 -8979px}.f-swz,.f-sz{background-position:0 -9020px}.f-tc,.f-tca{background-position:0 -9061px}.f-tcd,.f-td{background-position:0 -9102px}.f-atf,.f-tf{background-position:0 -9143px}.f-tg,.f-tgo{background-position:0 -9184px}.f-th,.f-tha{background-position:0 -9225px}.f-tj,.f-tjk{background-position:0 -9266px}.f-tk,.f-tkl{background-position:0 -9307px}.f-tl,.f-tls{background-position:0 -9348px}.f-tkm,.f-tm{background-position:0 -9389px}.f-tn,.f-tun{background-position:0 -9430px}.f-to,.f-ton{background-position:0 -9471px}.f-tr,.f-tur{background-position:0 -9512px}.f-tt,.f-tto{background-position:0 -9553px}.f-tuv,.f-tv{background-position:0 -9594px}.f-tw,.f-twn{background-position:0 -9635px}.f-tz,.f-tza{background-position:0 -9676px}.f-ua,.f-ukr{background-position:0 -9717px}.f-ug,.f-uga{background-position:0 -9758px}.f-um,.f-umi{background-position:0 -9799px}.f-un{background-position:0 -9840px}.f-us,.f-usa{background-position:0 -9881px}.f-ury,.f-uy{background-position:0 -9922px}.f-uz,.f-uzb{background-position:0 -9963px}.f-va,.f-vat{background-position:0 -10004px}.f-vc,.f-vct{background-position:0 -10045px}.f-ve,.f-ven{background-position:0 -10086px}.f-vg,.f-vgb{background-position:0 -10127px}.f-vi,.f-vir{background-position:0 -10168px}.f-vn,.f-vnm{background-position:0 -10209px}.f-vu,.f-vut{background-position:0 -10250px}.f-wf,.f-wlf{background-position:0 -10291px}.f-ws,.f-wsm{background-position:0 -10332px}.f-xk{background-position:0 -10373px}.f-ye,.f-yem{background-position:0 -10414px}.f-myt,.f-yt{background-position:0 -10455px}.f-za,.f-zaf{background-position:0 -10496px}.f-zm,.f-zmb{background-position:0 -10537px}.f-zw,.f-zwe{background-position:0 -10578px}.f-su,.f-sun{background-position:0 -10619px}');var A={name:\"CountryFlag\",props:{country:{type:String,required:!0},rounded:{type:Boolean,default:!1},size:{type:String,validator:function(A){return\"small\"===A||\"normal\"===A||\"big\"===A},default:\"normal\"}},computed:{flagIconClass:function(){var A;return(A={})[\"flag \"+this.flagIconCountry]=!0,A.rounded=this.rounded,A[this.flagMargin]=!0,A},flagIconCountry:function(){var A=this.country.toLowerCase();return\"f-\"+(A=\"ad\"===A?\"andorra\":A)},flagMargin:function(){switch(this.size){case\"small\":return\"small-flag\";case\"normal\":return\"normal-flag\";case\"big\":return\"big-flag\";default:return\"normal-flag\"}}}};var o,f=\"undefined\"!=typeof navigator&&/msie [6-9]\\\\b/.test(navigator.userAgent.toLowerCase());var g={};var n=function(A,o,f,g,n,r,s,a,i,d){\"boolean\"!=typeof s&&(i=a,a=s,s=!1);var t,u=\"function\"==typeof f?f.options:f;if(A&&A.render&&(u.render=A.render,u.staticRenderFns=A.staticRenderFns,u._compiled=!0,n&&(u.functional=!0)),g&&(u._scopeId=g),r?(t=function(A){(A=A||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||\"undefined\"==typeof __VUE_SSR_CONTEXT__||(A=__VUE_SSR_CONTEXT__),o&&o.call(this,i(A)),A&&A._registeredComponents&&A._registeredComponents.add(r)},u._ssrRegister=t):o&&(t=s?function(A){o.call(this,d(A,this.$root.$options.shadowRoot))}:function(A){o.call(this,a(A))}),t)if(u.functional){var w=u.render;u.render=function(A,o){return t.call(o),w(A,o)}}else{var b=u.beforeCreate;u.beforeCreate=b?[].concat(b,t):[t]}return f}({render:function(){var A=this.$createElement,o=this._self._c||A;return this.country?o(\"span\",{class:this.flagIconClass}):this._e()},staticRenderFns:[]},function(A){A&&A(\"data-v-0ba80393_0\",{source:\".small-flag[data-v-0ba80393]{margin:-15px -22.5px;transform:scale(.25);-ms-transform:scale(.25);-webkit-transform:scale(.25);-moz-transform:scale(.25)}.normal-flag[data-v-0ba80393]{margin:-10px -15px;transform:scale(.5);-ms-transform:scale(.5);-webkit-transform:scale(.5);-moz-transform:scale(.5)}.big-flag[data-v-0ba80393]{margin:0}.small-flag.rounded[data-v-0ba80393]{-moz-border-radius:15px;border-radius:15px}.normal-flag.rounded[data-v-0ba80393]{-moz-border-radius:10px;border-radius:10px}.big-flag.rounded[data-v-0ba80393]{-moz-border-radius:8px;border-radius:8px}\",map:void 0,media:void 0})},A,\"data-v-0ba80393\",!1,void 0,!1,function(A){return function(A,n){return function(A,n){var r=f?n.media||\"default\":A,s=g[r]||(g[r]={ids:new Set,styles:[]});if(!s.ids.has(A)){s.ids.add(A);var a=n.source;if(n.map&&(a+=\"\\n/*# sourceURL=\"+n.map.sources[0]+\" */\",a+=\"\\n/*# sourceMappingURL=data:application/json;base64,\"+btoa(unescape(encodeURIComponent(JSON.stringify(n.map))))+\" */\"),s.element||(s.element=document.createElement(\"style\"),s.element.type=\"text/css\",n.media&&s.element.setAttribute(\"media\",n.media),void 0===o&&(o=document.head||document.getElementsByTagName(\"head\")[0]),o.appendChild(s.element)),\"styleSheet\"in s.element)s.styles.push(a),s.element.styleSheet.cssText=s.styles.filter(Boolean).join(\"\\n\");else{var i=s.ids.size-1,d=document.createTextNode(a),t=s.element.childNodes;t[i]&&s.element.removeChild(t[i]),t.length?s.element.insertBefore(d,t[i]):s.element.appendChild(d)}}}(A,n)}},void 0,void 0);function r(A){r.installed||(r.installed=!0,A.component(\"CountryFlag\",n))}var s={install:r},a=null;\"undefined\"!=typeof window?a=window.Vue:\"undefined\"!=typeof global&&(a=global.Vue),a&&a.use(s),n.install=r;/* harmony default export */ __webpack_exports__[\"default\"] = (n);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLWNvdW50cnktZmxhZy9kaXN0L2NvdW50cnktZmxhZy5lc20uanM/ZWVhMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBLDZEQUFlLGlCQUFpQixFQUFFLGlCQUFpQixvQ0FBb0MsZ0dBQWdHLHlLQUF5SyxRQUFRLFdBQVcsWUFBWSxxQkFBcUIsK0JBQStCLHN1a1RBQXN1a1Qsa0JBQWtCLDRCQUE0QixhQUFhLDRCQUE0QixhQUFhLDZCQUE2QixhQUFhLDZCQUE2QixhQUFhLDZCQUE2QixhQUFhLDZCQUE2QixhQUFhLDZCQUE2QixhQUFhLDZCQUE2QixhQUFhLDZCQUE2QixhQUFhLDZCQUE2QixhQUFhLDZCQUE2QixhQUFhLDZCQUE2QixhQUFhLDZCQUE2QixhQUFhLDZCQUE2QixhQUFhLDZCQUE2QixhQUFhLDZCQUE2QixhQUFhLDZCQUE2QixhQUFhLDZCQUE2QixhQUFhLDZCQUE2QixhQUFhLDZCQUE2QixhQUFhLDZCQUE2QixhQUFhLDZCQUE2QixhQUFhLDZCQUE2QixhQUFhLDZCQUE2QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixTQUFTLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixNQUFNLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixVQUFVLDhCQUE4QixVQUFVLDhCQUE4QixVQUFVLDhCQUE4QixVQUFVLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixNQUFNLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLDhCQUE4QixhQUFhLCtCQUErQixhQUFhLCtCQUErQixhQUFhLCtCQUErQixhQUFhLCtCQUErQixhQUFhLCtCQUErQixhQUFhLCtCQUErQixhQUFhLCtCQUErQixhQUFhLCtCQUErQixhQUFhLCtCQUErQixNQUFNLCtCQUErQixhQUFhLCtCQUErQixhQUFhLCtCQUErQixhQUFhLCtCQUErQixhQUFhLCtCQUErQixhQUFhLCtCQUErQixhQUFhLCtCQUErQixHQUFHLE9BQU8sMEJBQTBCLFNBQVMsd0JBQXdCLFVBQVUsd0JBQXdCLE9BQU8sa0NBQWtDLDJDQUEyQyxtQkFBbUIsV0FBVyx5QkFBeUIsTUFBTSxXQUFXLGtGQUFrRiw0QkFBNEIsaUNBQWlDLG9DQUFvQyx1QkFBdUIsa0JBQWtCLCtCQUErQixpQ0FBaUMsMkJBQTJCLGdDQUFnQywrRkFBK0YsU0FBUyxvQ0FBb0Msb0NBQW9DLHlDQUF5QywrSUFBK0ksNlBBQTZQLHVDQUF1QyxpREFBaUQsYUFBYSxrQkFBa0IscUJBQXFCLGVBQWUsdUJBQXVCLHlCQUF5QixLQUFLLHFCQUFxQixvQ0FBb0MsU0FBUyxFQUFFLGtCQUFrQiw2Q0FBNkMsOEJBQThCLHlCQUF5QixZQUFZLG9CQUFvQixhQUFhLDBCQUEwQixxQ0FBcUMscUJBQXFCLHFCQUFxQix5QkFBeUIsNkJBQTZCLDBCQUEwQiw4QkFBOEIsbUJBQW1CLG9CQUFvQix3QkFBd0IsNEJBQTRCLHlCQUF5QiwyQkFBMkIsU0FBUyxxQ0FBcUMsd0JBQXdCLG1CQUFtQixzQ0FBc0Msd0JBQXdCLG1CQUFtQixtQ0FBbUMsdUJBQXVCLGtCQUFrQiwwQkFBMEIsRUFBRSw4Q0FBOEMscUJBQXFCLHFCQUFxQiw0Q0FBNEMsc0JBQXNCLEVBQUUsa0JBQWtCLGFBQWEsZUFBZSx5R0FBeUcsd1pBQXdaLEtBQUssdUVBQXVFLHFHQUFxRyxPQUFPLGdCQUFnQixjQUFjLDJEQUEyRCxPQUFPLFVBQVUsUUFBUSwyR0FBMEgsZ0VBQUMsRUFBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy92dWUtY291bnRyeS1mbGFnL2Rpc3QvY291bnRyeS1mbGFnLmVzbS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIiFmdW5jdGlvbihBLG8pe3ZvaWQgMD09PW8mJihvPXt9KTt2YXIgZj1vLmluc2VydEF0O2lmKEEmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudCl7dmFyIGc9ZG9jdW1lbnQuaGVhZHx8ZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdLG49ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO24udHlwZT1cInRleHQvY3NzXCIsXCJ0b3BcIj09PWYmJmcuZmlyc3RDaGlsZD9nLmluc2VydEJlZm9yZShuLGcuZmlyc3RDaGlsZCk6Zy5hcHBlbmRDaGlsZChuKSxuLnN0eWxlU2hlZXQ/bi5zdHlsZVNoZWV0LmNzc1RleHQ9QTpuLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKEEpKX19KCcuZmxhZ3t3aWR0aDo2MHB4O2hlaWdodDo0MHB4O2Rpc3BsYXk6aW5saW5lLWJsb2NrO2JhY2tncm91bmQ6dXJsKFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFEd0FBQ21rQ0FZQUFBQ1I3REVUQUFBQmhHbERRMUJKUTBNZ2NISnZabWxzWlFBQUtKRjlrVDFJdzBBY3hWOVR4UThxRGhZVWNjaFFuU3hJRlhIVUtoU2hRcWdWV25Vd3VmUUxtalFrS1M2T2dtdkJ3WS9GcW9PTHM2NE9yb0lnK0FIaTVPaWs2Q0lsL2k4cHRJang0TGdmNys0OTd0NEJRcjNNTkt0akF0QjAyMHdsNG1JbXV5cDJ2U0tFUWZRZ0JsRm1sakVuU1VuNGpxOTdCUGg2RitWWi91ZitISDFxem1KQVFDU2VaWVpwRTI4UVQyL2FCdWQ5NGpBcnlpcnhPZkc0U1Jja2Z1UzY0dkViNTRMTEFzOE1tK25VUEhHWVdDeTBzZExHckdocXhGUEVFVlhUS1YvSWVLeHkzdUtzbGF1c2VVLyt3bEJPWDFubU9zMFJKTENJSlVnUW9hQ0tFc3F3RWFWVko4VkNpdmJqUHY1aDF5K1JTeUZYQ1l3Y0M2aEFnK3o2d2YvZ2Q3ZFdmakxtSllYaVFPZUw0M3lNQWwyN1FLUG1PTi9IanRNNEFZTFB3SlhlOGxmcXdNd242YldXRmprQytyZUJpK3VXcHV3Qmx6dkEwSk1obTdJckJXa0srVHp3ZmtiZmxBVUdib0hlTmErMzVqNU9INEEwZFpXOEFRNE9nYkVDWmEvN3ZMdTd2YmQvenpUNyt3R2xGM0s3Z1MrVkNBQUFBQVppUzBkRUFBQUFBQUFBK1VPN2Z3QUFBQWx3U0ZsekFBQUxFd0FBQ3hNQkFKcWNHQUFBQUFkMFNVMUZCK1FNRndvRU5BRnd4WFFBQUNBQVNVUkJWSGphN0oxM2VCVFYyc0IvTTl0MzB5c0pJZFJRQXdrdGRLa3FDa2hUQkNzb2doOEtsbXYzWWtPdjVlcTk2aFVzS0ZpeEFCYkFCaXBWbE41N1QwaXZtMnd2TTk4Zkd3TUxDU1FoQ1VtYzkzbjJTV1ozNXN6ODVpM25uUGVjT1FPS0tLS0lJb29vb29naWlpaWlpQ0tLS0tLSUlvb29vb2dpaWlpaWlDS0tLS0tJSW9vb29vZ2lpaWlpaUNLS0tGS0RJcHk5Y2Uyd3gyMC83RTB5WEVxQjh4NzVnTHZIcnFxUmk4dGZFazM2QzYwdnRaaWx5VVVici85clEveTdhVmdCVm9BVllBVllBVmFBRldBRnVNNUVYWmNuYzdrQ09IZ3FpU1lSYVhoZEtuTE4wYlJydGhPZHdZSFhLeUFLTW9MWWtJRmxnWXljanBTWUl3aVBPSXpicVNVN3N6K25UOXJ4ZWdTTXdTYkNUYWZRNmlXeU05c1RFcDVPWE16Umhna3N5M0R3MEZCeUxMM3hPdTNrNUVmVHZNVUJKSmNWalZxTFJnMWVsd3V2SE1UaFErMXdlQkxJTWFkUWxQOG5pWW5yR3g2d0lFQndlQWJaWmkrR3pFSlVoWkIxTUpsUWJ6cmVRQTJtQkNkYXV4WEx2aGpDQkRPMm1Hek1SVEVFaDZZMVhKTU9OaHhHSjU1RXZ6V2RnRUkzTFQ3NGpQd1BicUlvczRUd2pnVUlKNjA0VDJpUVBRS21SQXQybTVud2tKTU5NMHFmU08vUCtvMy9SMTUrREFCeHMzdWpqUTBsZkV4UDdLa0JDSUxQQ29TL091VXlPR3dKYk56MmZ4dzZtTnl3Z0wxZU9IbWlNMTZQRTdVZXhLQVFuTWRLQUJITFZnK2FrUER6ZlI0QlNRYTN4MGhXUVEvc3RnWmswcUlJUVVINVNFSnpIQ1YyZEpFQ3RxTm1iQys4Z3JkSUFMMEJTUklRWkFGSkZwQmxBV1FaVVMwZ0NpcDA2a3kwT3JBMUZHQkJnRGJOZjJEZHVsc0lqQXJHRyszQktXYUJtSXIzdEJ0VlVCaUZRWWs0MjdvSVNuRUJNdWJpV0VTTkZvKzlpS1RrVmFoVURTeG9CUWRiU0VwYXgvNzl3d2hyZHB3Z2pxTUs4RktjYThLcEt5QTR4RTdoY3ZBY0VERWt1UWtiNVNJekxZN1dMZGRnQ0hRMXZDaWRsUmxKVGtFQ3NsWkFsamtuWGVpTEhxcXJ2VVJjYjhaVEltSUdSSlZNb2FVWmhVV1poSVlVTlN6ZzNKejI1R1MzUWg5Z1FENlBGcEJBV2lXU3VUY01RMmNYakJHUlZUclNUM2ZBcU00bk5HUmJ3d0lPamJLU2xxL0hWVnhDQnUzUmhSZWpkbGp3NkF4NFZWcGNraGY5T0M4QjF6bHdXZ0pJeSttQTNlckFFR1FnSU5qYThFeGFrZ1QwZWdtWFNrMmVJNDdjVTdHb0RVYjA4U0llU1VMWUw0R2d3ZTF5NG5LNFFaQXdoV2hRYXpRNEhLYUdCeHdidlplY3ZQYVVXT1B3cXJ5SWVuQllIVGk4S3B4MkI0SWdvTktxOExoQmI5S2kxbXVRM1I1MHdpbGF0dGpYOElEVmFpZkpIVDhudjZBWlZsc29EcGNKUjJnSWhYbWRDSTdTSXdvaWRydUhrSUJkbUl4bWRIb2JnYVpDb3FMU1VLdmxodG1XVm1za29xTlBBYWNBY0RqMHJNNXVoelBQaHNwa1FQWTRTRXI2RldPZ3UzRW1BUFI2QnltZEZtRzJoS1BWeXdoeVFaM0Mxamt3UUhoVUZ1RlJXVXBPU3dGV2dCVmdCVmdCVm9BVllBVllrWVl1ZnJtWE5YR20wd05QVzV0ZWFxRkxFNEs1L3JvVzlZVndLYS91VWlhbUtjQUtzQUtzQUN2QUNyQUNyQUFyd0Fyd0pZcGZJcjU3WkdzSHAzZGZjcUhYeENVVkhIMzhzOFAxQVREZlpzN3M5V3BpK2NBQlFhSDZtamlKTVN3eXJIVjRYTy82QU53NlBDNWQ4V0VGV0FGV2dCVmdCVmdCVm9BVllBVzR0anNQT1dscGpxZ2FLRFIxMzc2Q1pXKzlWUzg2RHdhREliUENIOWZBYWRuM0JNNGxmWmFBVFAzNUxGRjhXQUZXZ0JWZ0JWZ0JWb0FWWUFWWUFWYUFGYW15blB0UTRCSmcvS1VXdWhpSXVNUXk4a1M0NGUwYUlEeE1PcThScC9pd0Fxd0FLOEFLc0FLc0FDdkFDbkNqQkJZMEdvVGFXb3JsSWxKbkQwd0xhalVCeWNtb1EwTVJOUnBzaHcvaktTeEUzN0lsdGtPSDhKYVVOQjVnZFZBUUhwc05RUlR4RkJlakRRM0YwTG8xa3NPQk5pWUd5ZWxFMzZ3WitULzgwUEJOV3RjaUZrM3paZ1QxN0ludDRFRmNHUm1vUWtOQkVMQWZPMGIraWhXb3c4THd5aDYweldNYU5yQ21lMXZFbHRHb21vWmkzcm9aU2ZMaUtTakF1bXNucnF4TVhEazV5QUlVYmR5QXgydEJiQkdCdWx1YmhtblNza2xIUUpOUTNGNFJ3ZTFCY0h2UnRBakhxMWJUZnZtbm9OYXc0OHFScUdVWjZZZ0YzRjdVeGdEME9oMkZKaDNZblExTHc1clFRRnlGTG9LVGUyUGI0bHQ1SmFqL0ZRUzBUTUMyN3hpMkhmc0liSmxBY0w4ckFMQnYzVWRRNXhUY0ZnL2FpT0FHWnRJcUFWV1lnWlpQUEl2VGFrYldhZEMwYVltbzBSSTJxRCt1ckhUY1dSbUVEYjhTUWExRjI3b0ZrazZEMjFwTTg5bHpFQUxVdGFhSzJsa3hUYVVDU1NUenU4OEk2ZElYUmxvSjZwVkM0Yll0eUtjT2svZnFNbVNQaDdBeEk1QkVnV1lQemNTOFpRdEI3WkxJWHZvSmdxaEIxR2dBZDhQUXNPenhva3BvaWVYd1FjeXJmZ1pVbkg3dERSd0g5aUdKV2pwKytUbW1kaDBvM1BBSGp2MzdTWDMxZFpBRXpMK3N4SEpvUDVxRTFzaGVxUUdadEF6Qm5aSnA4OXhyUkUyZmhseG94blVrbGRDVS91amJ0TUFqT0duMnhrdUVkRTBtdEhjLzNNZlN3R3doYXZvMEVsNzRMMEdkdWlCN3ZBMG9Tc3N5eGIrdnhmemJMOGlTQzVVNkVBQnRXQ1NpeWtqUkwydlFSa1NpYTk4ZXRhQUR3Sm1meGJGbi9vRmFvMGRTMVY1dFdXdlZrdTF3QnZvdUNhajBLdVJpQjhIOStxSUppVUJHeGhRYWorQUZUWmdKUVlhZ2xKNTREUm8wSWJGNDNGNmNPdzQzUEdBNVBadkFZZjBJN2p1VW9KNDl5Vnl4bE9OUFBRVnVML3I0ZUZSQlFWaDM3MGJXYTRtZGRUZlJZOFpUdkdrejVvMi9rcE8xc1dGRjZiOGtmOG5QeURZN2g1OTdFSDJITGhqN2RrVmxsVEN2L3gxa21hRGVLVWlSSm5MWHJTSnQvbitKNmpPWWdoL1dOZHpPZzlkcUpXLzVyMFJlZncyNjJIamk3MzhVVjA0MkhuTVI3dXhzUE9ZUzlDMWJrTGZ5ZTV3eHNlUisrVDI0dmJVS1hPdWRCOW5oSXUvVDczQ241K01wS01CMitCQzJ2WHR4NStXaGF4cUxvQkx4cEdhUi8rbXlXb2V0MC81d3ptZUx5RisySEcxa0pQYmp4MzFST3lvS3I5V0sxMnF0cTh1bzJ4WFR2Q1VsMk0vcTZMdHljcFNjbGdLc0FDdkFDckFDckFBcndBcXdJZzFWL0NhbW1Vd211YkVCV3ExV29VSmdmTS81TkdxbFhqWWY3cE44ZWM0cjFuWmZNVGdRK25mei82NVZNN2o3UnYvdlFvUGcyaXZxR1BqaFdqaUJ1UVQrK3hpRW5UVmNOTHcvREQxbmxZK0Yvd0tIczQ2Qjd3WUcxOEpKTERaWThNS1o3V3NHUU5Ob2FOL0t0LzNBN1RCNkNCdzhVYlBuVGJuWURxa2c3d1M1eVNVODNOZ2pFYmxQc3Y5M2MyY2p5L3VSWjk2TXJOTWlXN2I1dHUrNUNUbWxNN0pyTjdKNXMvOHhMWnI2OXEvdWRZU0J2UGxpUVRnVjVOVFNwME5WMVR5UklDRC8rUVh5ZTg4aWh3WDd2cnZuSmgrZ1l5Znl3M2Y0L3BmM0kvKzZFUG5FS3QvL203NzA3V3ZVSTgrWmhWeXlGYmxMdStwZGd3anlSNlVzbFFKT0JmbmhTOUJ5U21ka2FSOXk3dS9JazhjaUQrMTlCcktpejBjdkl0ODhFam50TjkvMi81NnMvdm4vN3l5T0M5WlJaKzhnQWJjQzFYMGgzNElYWU1wWTMvOTdqMEJpd29YM3R6dkFVTHIwVVY0aHRMMEdDb3VyZnQ3dStLYjEvelVwS3I2eTliQUl2QUZVNW9ueGtFQmZsZEtxbWUvMVlRQ1B2ZWFMMEhCeFdEZ0RDL0RFNjJkZ284S2dYN2Z6bzNwNUVnck1QUXUyUExsZzFSc0J2QW5jVktyeGlxU29CTHdTL1BrNUJCamgwRW5ZZnhTT240YXVIYXFtSVk4WHJ1enJxNmZieEVOUUFQeThBVzU1OU9MTnFkZUEyS28wdXlweTh0ZUIvMVRpWW1PajRQTlg0WW9lTlZPdGVMM3c5RnZ3ci9kOHo5cGZTTzRDWnBmei9ia21YU2xnQ2JnWitMMFNGNmxTd1hNejRmRzdmQytMcTY1azVzSk5EOE9helJmZnQxdXAzNm9yQVZ5cHRyUUkvSStMUDVvamlwRGNIb3FLNFZUR3BXbjN1OTlBa2tDcnVValR0ZFJ2Szlzc3JwU0cvNUxmVlRwdU5zVDQrWE5vb01TZzdnNkc5SEF3c0p1RHNLQ2FIUkN6T1VVMjd0S3hlcnVlMVZ2MXBHYXAvUzUrdmlPSHF6d1Z2eUd4V2laOXRyelc5VG5lU0o1ZEwvcDlkK3gvZzJjMjNYL0JmUzRaMkN1b21EVDhWLzVzTXZDeXdpYmxiZUdiNy91aGx0eFZBcTV5ZjFnbGUvbmYycHNJZCtSZU50Z2dWeEh6MXR4NFVkZ2FTK0pGMnpKNGZkMnRDSmNoUVNJZzg4cnZVMmxXVXIydVZiVXpIZ1BUZjJiRzdwZnFIUGkyQS9PNDl1VFNtc24zcEZZeHArVVZWRXk0WmcxYm92dlhDV3hpL25hK1c5RUhqVlQ1ZDV2RzEyUk9TeVY3ZVd2dEpFS2QrYlVPRytBdTV1M1ZFNm9FVzZNbS9aZkVXRS96MzNXMzFhby9DOGk4L1BzMG1wY2N1K1N5YWlSdk4rVDBEN3lZOVNyTEJ6eGNLOEJETjcvSHFCTmYxdEROdXdRZjlyOTFhcUxYclVQYnAwK053cnAzN1NLN1Z5OWtaL1V5ZlBHMWxwZjJlTWliT0JHcG9LREdpcFJMU3NpYk1LSGFzTFhpdzM1Uk96V1Znc21UYTRoV3B1RHV1L0VjcnRtSnBqVSs4bUJmdnB5Uy8vem5rc3V4ZnZBQnRrV0xhaUVBMXBRUG4xMm9Sa1BVK3ZWb2UvV3FudC91MlVOMlNncXl3M0hKMXhKZkYyTkxzdHROL3NTSlNFVlZmdys0YkxHUVAyRkNqY0RXaVVtWHhiQ1RKeW1ZTXFYS3h4WGVjdy91Z3dkcnJVNnYxZEZEKzdmZlV2TG1tNVgzMnc4L3hQcnh4N1hjK2FnRkgvWTdnVlpMMU8rL28rMXg0Y3llZS85K3NudjJSTGJaYXZUODhYVTlQaXk3WE9UZmVDT1MyVnp4UGphYnoyOXJHTGJPVGJyTW40OGZwM0RxMUlyOWR1Wk0zUHYyMWNXbDFOME1BTnVTSlZqbXpUdi8rMDgveGJwZ1FSMG1FR3JaaC8xT3B0TVI5Y2NmYUx0MjlmbnR3WU5rOStpQlhJc3o0dU12NXh3UDJlbjArV3BKQ2JMZDd2dS9EcWYvMTFqM3NFcitmUFFvQlhmZEpZbUJnYko3ejU3THMvTEIzMG44N1B2WE8yZTdlejk0cTlyWU1ZSDByQ0p1dm44QjZ6WWZQZStnaGYrK2pkRUJMZzVObkZuMlhjaFZBMmozNVZzRUpUNkF4ZWJmbldzVkg4RVhMMHdnYU43N0ZQNjRocVlQVHlOKy90NjZZbHdxbjNpNy9GZDVxbkp5aFgxRGJpWm40V0thUmdmejI2SUgrT2U5MTZDNmhJY2ZyNyttSzcvUHVRN1YzUTloMmJLTDlsKy9ROXpqTXk2Ymh2MUkwaVpOY29TTnU1b1REejdQa1NrUEk1ZFllTzdCVWZ6MDBVeWFSQVpWcVdDOVRzUGNaeWZ3UmpzTnA4Wk5ROSs4S1lucnZpSjRVRy9TTWd2ckIvRFVweGViditrNmtGWnpuNk5vNVhyMkRMZ0J5OWJkRE8zYmpwMC9QTW13ZnUwclZXaENpeWcyZmpDZElTdVdrUHIwZjRtWk5ZWDIzNzZIdGtra3kzL2RROWNSLzZvZndDNjNWMzdreGErNTQ5ZDA0cjViZ0dnMHNQK2F5V1M4dm9Db1VCTS9menlUT2YrNER2RUNBNzgzWE51TjlVOWRpenoxUGl4Yjk5QnV5VHlhelo2SlZ4RDR4L05MR0RQdEhRcUtySmNOdU54cTZmdlZlK2wxNERTTFhudUIyQysrSk8zWk55aGV2NW5XYjcvQWsvY01KeWUvQkxidUtMZkE1K05sVGw0L25ZQWVYV2l6NEJXMHNkR2NTaTlnNHN6MzJiVHo1R1dQMG43QUExTGFhS01qQXN1MjMvcmlEeWFNR011d2lhUEkrZWhyMHA1L2l5YlRKeEhWcVMwVmRlM3RCNDdTYXQ3emhJOGZqcUJTc1huWFNkNytkQjNOWWtKcEZoTmF0dCtTSDNkY2Z1Q0hwbDBaTUdwbzUzSjNET3BYdVlrYnJlWSs1N2Vka3RTQ2xLUVc1L3RTcXhtWEh6am85Ym5hTGJmdHJOU0JrczN1dDEyMGNqMWJtbGJodlhDNmJwY2ZXSEM3endPcGlsVHBXRjA5aU5KL0IvbDd2NXltK0w1N1hOZGMwZDVRbVFPTGZsN0gwVHNmOVF0cWJiLzhYK1hQM1BtaHl3Lzg3dy9YV0Q1ZXNjMFBlRURQQktaTjZvOU9wOGFkbFV2bTNFOW85dFFzVkNhanY2bVlES2hNUmp4RnhXUy8vUm4ySXljSXYvNWFkb1hHOE1IaWpUaWRudnFuNGZXYmo3cis2ajhaRFZyZWVIb0NkMDdvQzBEK2toODRjZjhjRE8xYlVWSmtxYmpBa0NCaUg1bE94bXZ6T1h6ckE4UU03c1Bqajg3aXBxZVhzdnRnZXYzMDRZNEpNV3o2OWxIdW5OQVh5ZTdneEgzUGN2U3V4NG04ZlR3SFp0M0g5MzhjcWJEQSs1NzlDcGRYb3VrajArbTQvSDFzKzQvZ3VPVWVmbmx3RU5NbTlVZW81SHpFVnMzOEk3NVdJekZoZUFudFcvbC9IeFRnb1dOcmEvVTBMSWdDazhmMzVxM25KbUxRYTdBZlBzNlJ5US9qeXNpbTFVZXY4c3lXZk41NTRDTVd2SEpyaGRYS3dzVi9zSGJURWI2YWV4ZHQrM2FuODRiRkhML25LWTVOdUlkL1BqaVZJZitkelBUWlgyQXV1WEFWdHZMRHJvaGlCRG41V1dqVU9wcEd4eElXUGhTdjE4enBqUFZrWk9jUVlOVFFvbGtYbHYrNmhzbVBaRllkK01WSFJnYzlNdjBxQVBJK1g4YUpmN3lBc1dNYmdqNS9oK0gvV3M2T2ZXbVZLblQzd1hSNmpIcVJlYzlQNHBZeEtiUmQ5QVpaNzMxTzZsUC9JYkhyRnJiTWY1UzJFOSs2WUJrR1F4d3hUY2JSb25ucEZ4dG5nU2NRZFhRZldyZThpZFl0eityMHVOWld6NlE3dElsUlN6WTd4MmJNNXRpTTJVUk51WUY5OTg0aVpmcUNTc1ArSlJhYms5di84UkZUSC8wVXU5TkRrK2szMFdubEo3anpDakRmT0wxcXlaakMvYkQzTGZqdFpsaDlHL3d3SEhMK0xQdlo2WktxQjZ3K2xTYnVIWHdUaFQrc3B1V0hyL0tTMEpSSi8vaVlZa3YxUnZKa1dXYkI0bzJrakg2Si9VY3lNU1YxSUhITkY0UmNmZkVuc2lUcHJJenhxZTlBcFlVYjlrTGlMQmp3SHVqUHpOVjNPS1hxK2ZDSTUxZXNnSmp4aURId3dEY1ZIalRsNGRJQnI5QitaNzdjSWtFRkhZSjlSekpKdkhwT2xXNld3MmtEU3lvVTdBVk5JTVFPQmtlZTc4ZHZlMExyU2REN1ZSRFZGQlNWWEZxVXJnOWlzUmFDTmdqMnZnNGhIYURyUDMxL1l3WkNzMnRoN3h1dzZXR1FKVEp6QzZxbjRmb2tlWVhGb0EwQlV6TndGVUpRQW1Tc0JsY3g5SHdlY2plRE5SMnBjQitIVDdnQVE4TUczcm5meXRBQlFJZnA4RzF2bjdabEwvUjVIZHdXMEFiRGtFOXh1YkxZZThUVThFMzYyMVZaeUxJTDlCRVFmdzEwdkJ0R3JZUHdKUGp6SVJpeUNFUXQyYm43S2Jhb0c3NUpiOW1qSXk5L0xaRVJWOEx3Ny8xLzdQTWFCUHF5S04rdFdsdWxjdXN0c01zdDhLOFBsN0p4V0R4V1dZLy93S1lXT0VFZmR2UDlPN21sMncwY0dHRCtBcGxidWk3ajNaRHo1M0FHWUNGcDJUS3k4cXFXT3FuWENRQ2JROFhLWnc3UTEzUCtFNURYblp6SFY1OXBxMXhtdmM5NG5FelhrLy9VUnd6eHJBUkFnNXNKR2YvajZ5ZVA0NVdxL2lTWW1nWWdoNDlvTWQvN0ZWTW1MQ1kvUTJMcGNoMlNWRDFkTlFoZ2dPeDhMUi9Xd0F1bmxLeWxBcXdBSzhBS3NBS3NBQ3RTWitMWEdEMGQzM0lKeU9NYkdlTFN1TlFUMXlzK3JBQXJ3QXF3QXF3QS8xWGRlVHprZVN0ZXdTWFg2eVhOVXpkVEltbzA0L0d2b2tJRzZ3MzAwZXV4eWhMYm5FNjJPNTBzc2xnd2lvSnZUWi93U0RwcGZjbTN2UzRYcy9KejhRSTJTZWFtZ0FDNjZYUjAxK29JRUVVMk9oeXNjZGg1SWlTMGZtbzRSQlNabkp2REtyc05veURTU3UxYk9TaFg4bkxVN2VhdzI4MDZ4NW1SLzNVT080ZmRibzY1M2VSS1BndG9yZFpnRkVWVzJtMU16czBtUkJUcnI0YW5CUVZoRWtYK1dWakFQd3NMTUFvQ1Z4dU1yR29TeTBhbmcrY0tDM2pkYk9ZS3ZRRVplTjFjaEU0UWVEbzBqTjQ2UFY5YkxkeVNtNDJ0ZEd6NGlaQXdiZ2tJcUwvQXp4UVdVQ3pKdkIwZXlXbXZoeGw1dVJ4eG0zbS9wSmpmWXBxaUNRM240WUk4WnVUbklnTTJXZWJmWVJIMDFlc1prcG1PczNTVnNMa1JrY1NwMUh4b0tlWm9rWXZuUThQckovQjlRU0c4V1d6bTMrWWlna1VSTlFJZVpCeXl6R21QaDg2bHZudk1mV1lOblVTdGxqU1Bwd3hXQmZ4Z3MyR1d2Q1JvdE13S0NxNi9VWHBoU1RHQmdzQ2tnQUJjc296bnJQR2dlL0p6bVpwMy9xdEtwdWJsY0cvK21ZV012SUJMbHBrVUVFaUFJTEN3cExqK0FrOEpERUlDanJyZGpEUWEwWncxSnl2WDYrVjBPVlZQK2psVmxsb1FHR2swY3N6dFJnSW1Cd2JWWCtBVk5pdEZrc1FSdDVzZjdEYmNjdFVmWmZUSU1qL2FiQnh4dXltU0pGYllyUFUzYUkweW1tamhjaEd1VXZGTVlmWFg4eWlRSko0SkRTWFBLNVg1ZmIwRVhtcTE4clhOZ2lURFl5R2hITXgzVVN4VjdmMkZnYUxJaktBZ0hzelBSeFJnbk5IRTNUVVl1R29VZUp6SlJBZXRoZzRhTGErWWl3Z1Z4U29EaDRvaVA5dHRMSXFLNW9EYlJVZE5QZGJ3TnpZckd4ME9MSkxFRFFFQi9PNndNOHhncEVEeXN0M3BSRlVhaGM4TkloS1FyTlVScmhJNTRuYlRYYXZuLy9KeUNSQUYrdWtOVEt2QndGV2p3T05OSm5ycGRCZ0VrYnZ5Y25nL0lvcTNTOHhNRGd4aGxjM0dHb2VkVStkRTZqaTFta0Y2QTFjYWpDeTFXWGd2SW9vWmVibk1qNHpFTHN2RXFkVDFWOFBySFE0K0xTbmhvTnZGSjFIUnZGOVNUQytkdnJUUm9lTWpTMGxaWStTdlJrWnE2VytudlI1NjZmUjhVRkxNNitFUmpNM09vb05HeTYwQmdZd3htZW9uOEZDOUFTMEMzWFU2b2xVcWtzTjE3SEU1bVZkY3pFODJHOE1OUm1hSGh0RXY0elFBYTJPYk1xZXdrTWNLOGhodU5ERWpLSWliQXdJUmdkOWltckxONmVBS3ZhRkdOVnlqOVhDdTVHV0Z6VXBxcWRrNlpabWxWaXNyYkZhQ1JaRi9oMGR3d0hWbWliY0RMamYvRGc4bldGVHh2YzNLVXF1MXJJbVo2bkd6d21ZangxdXpLNkhXV0Y2NlJKSjRzYWlRZm5vOXY5anRIUE80NmE3Vk1kQmd3QzNMQ0VBTHRZWkpPZGxrZW4wM0pFYWxabEZVTkNjOHZyYTFWaEJZWTdlenplbWt0VWJETUlPQjN4ME9uZ2dKSmJEYTNjUmF5a3NIaWlKUGhvYnlxY1hDQ0tPUmp5T2owUXNDT1Y0dm9hS0taVFliVHhibWw4RUNaSG85UEZtWXp3cWJqVkJSUmJiWGkxNFErRGdxbWhGR0k1OWFTbmp5a21CcjJZZHRrc3o4aUVnQ1NpL3cwWkJRSkVCQ1JpMEVzdFJxWmJmTFJVbHAzUndnaXJUVGFCbG5NdEZabzZXYlRsZTIrdmVWQmlPOWRYcHNza3hBZmZYaFNKV3FEUGJzRTRnSWZHV3hrS3pWMGwyclF5Y0k2QVNCN2xvZFNWb3RYMWtzQ0lKdzNsTG5nYUpJbEVwVmY0UFdoVTd5YkdnWWl5d1diZ3dJSUZRVUNSRkZiZ3dJNEhPTGhXZER3NmlyOVMzcUxFMnJFUVNXUkRjaHorc2x5K3NsMitzbDMrdGxjWFFUdEpleTFQamw5T0hLVkFuOTlJYXlmbkkvdmFIT0UrTjFQakd0clViRGpLQmdoTkwvYWV6QUFQY0hCeU53ZWVTeUFHc3VHNjR5dHFRQUs4QUtzQUtzU1AwVkdaYkl2amY5TktiUEVzV0hGV0FGV0FGV2dCVmdCVmdCVm9BVllBWDQwc1V2aWRlTFRabjVoUC9abUFERHljK0VDbCtoSWk5cGZKMGxXZWt0S2NBS3NBS3NBQ3ZBQ3JBQ3JBQXJ3TFhlZWJoejBBZVpCbzI5VVhVZTdHNUQ1Z2Ryem16N3pUMlFQMk1KME1qV0FHQ3BjRFBLR2dBS3NBS3NBQ3ZBQ3JBQ3JBQXJ3QXF3QXF4STFjU3Z0L1Q5K01rMjU2WS9EWTBKVU5lcnQzM0UwZytOaWc4cndBcXdBcXdBSzhBS3NBS3NBQ3ZBQ25BTmRoN1dmZlpEVHF0Z01iSXhBUjQzUzdsWDNIeHQyUnZsL0FiVHRJbWRYVTI3eERVcWpaN2VmZHFsK0xBQ3JBQXJ3QXF3QXF3QUs4QUtzQUpjQytMWGx0NXpKS3Vnc05qV3RGRzFwYk9MQ3lvRS90ZDdhdzREblJ1WlVnOHJQcXdBSzhBS3NBS3NBQ3ZBQ3JBQ3JBQXJ3SXBjbWlncnBpaytyQUFyd0Fxd0Fxd0FLOEFLY0ExSzdhOFJQeDdRQU1zQmEyTUdmZ2pvQXlRRHdVQTZzTDR4bS9UVzB0c1o3R3VrTXdIb0RjeHNySjBIZGVuZmVHUjVQcktjaHl4bmwvNGQxOWc2RDVxek5Ka0szQVhjZ3UvMWR4WmdaV1B4NFJBZ0JlZ0lUQU1PQUxaUzMvMEptQWg4QmJ3SVpBSXZsZDZFQm12U0FySjhFN0o4dXRSME55TExiYy9aNTEvSWNrN3A3d01idWtuTHdKZEFJWEFjV01NNWc1WEFhL2ltdEs0dk5mY0dINlZibHZwc2YrQm9PYi9uQTF0S2I4aUp5K3pES3lIVVZjMkNCQkZFUFhpUG5nVzZvUHg5dTJkQ3hIV1FGd0xiN3F4ZFFDMVUvSXI1YVBpMTFEQ3IvSmswSHZteCt5dTM3NkwzZkQ2Y2Q3aDY1NnJLcDVTcGZKUE85bmxmdFdUc1NIanNma2pzY1BGOW04YkFuOXZneHFtMWI4TG5NdFdZRDV1TElUZ0lmbG9Najh5Q2lsNldGUmdBdmJyQmxoM3c2N3JMMzloYVVsM1RTV2lObkhFQTJaR0p2T2tYNUJWZklIZExPbisvNmJlWFZrbDV5QlBIMXI1SmMwNjFWR1BBZ0J3VGpmemhYR1M1QURsMUQvTGFGY2l6SDBZMjZIMi9od1FqWng5RVR0MkZuTEhQdDkyZ2dmLzZwSFJEL21NbHNpY1hlZDhmeU1zWElmZm9pcnhpRWJJOUhibExKMlMxdWs1Z3p3TytaQjkrNGdIbzBOYi91ODNib2UvVmNQc01jRHFoWDI5NDgyVlFxK0h3TVFnUGhYUGV1OXd3R2g2UjRYRHJCTmk3QVQ2ZkQyT3U5UVV1QUswR0RoK0Y3MytDL1FlaGJXdm8wQTVPcHZyQTY0dFUyYVFEQTVDTFR5SjdjODRFSTI4dXNyZTBLeWpsSWx2VGtBZjBRWDdyMzhpdWJPUzlHNUZmZWhvNUtMQUJtblI0R093OUFOdDNROXNVK09vN0VBVll2Ukd1R0FsTGxzR2hvMkN6d2IwUHc5QXhQalB2MHhPV2ZBVDMzUTBxVlFPcmxnVGhUTVFkTWdENTlSZVFSMS9qMnpZWmZiK2Z2YjlLNWR2dit5K1JWMzJEL050M3lCM2JOZUFvWFpYUHZYY2g3MWlMZk1Qb3Z3a3dJT3QxRGNpSGEwSWNUaVVScndBcndBcXdBcXdBL3kzRmI5RURYYWZicTcyKzlOUUpnL2xtMVZieUMwdk9tSThvMExWREMvcDJTOEJrMEdGenVOQnExQVFHNkJFRkVYT0pEYmZIaTFhandtWjNzV25YVWJidlA0a2t5V1ZsaEFXYkdIOTFDdk8vV2wxZHhxWE9mUjlkWDI2YTlsTGtpeFYvTU9QbVlid3lmd1VCUmowakJpVVRFeFhDdmlQcHpQOXFOUTZuKzB5YXRsTkxkRG9ORzdlZnlkSnJOV3I2ZEUxZ3hrMVhrcDFuNXFmMXV5aXhPcmpqK2tHODgvbXZ0Wk9YdmhTeDJCems1QmZ6enhsalNNM001K3VmdDJDeE9TcDl2TXZ0WWUzbUE2emRmQUNEVHN1NHEzc1NIeE5PWm01UmxjcXBzNkIxN2NCa3drTUNNT2kxZlBMdGhrdTZTTHZUeGFMbEc5Rm8xSVFGbTdoMllITHRBRThlTzZCSmFKQ3BTZ1dvUkpHSDdoeUJ4ZWJndFFVL3NPelg3WXdlMnUyU0wyejRnQzc4dEg0WC8xbjRJMFVsTmg2NmN3UXFzV3I2Q1EweU1XWHNGVEVWQWk5ZnZTUHY5bkVEdUgzc0FOU1Y2SlViZEZwbTN6dVd4VDl0WXQyV2d3QnMybldVTHUyYm85ZHBLanhPa21Va3VlSnhVcTFHVFhLSDVtemVkUXlBamRzUDgrVVBmL0wwekhFWTlkcEtLZUgyc1FPWU12NEtscS9lbm5mUktOMnFXUlEzWDllUGRWc09zbmJ6Z1FvTG5YM3ZXTjc4NkNjS3pQNnpWWnBHaHpGbVdIZm1mcllLZ0RiTm94azF1QnVod1NhQ0F3M0V4MFlnQUNhRERxZmJ3N0pmdHJOKyt5RU9IRTBINE00YkJ2SGoybDFrNVBnUGhJUUZtN2gvOGpVODk5WTNlTHplY3E5cllFb0hCcVowWU5IeTN6bDZLdnU4S08yblJuVlU4Z1NnWTJHeGxYVmJEdEk2UHBwYlJ2Y25OU09mb2hLYlg4SC91T05hUHZsdUE5bDU1dk5PV21LMTB6dTVEVzFieGpEOGlpNW8xR28rL1c0RHJacEY4YzhaWXlnMFc5Rm9WUFR2MFk1V3phSVkxaStSWVgwVFNlN1FuS0FBSTZGQlJuN1p1TGNjMzNaek5EV2I2VGNPNGZmdC91T3dMWnBHTXV2MjRXUmtGN0p3NmRxemxYREFtN3ZycTBwRjZkLysyTWU2elFlNWRVeC9nZ0lNZkxCNERSYWJneEdEa3ZsejExSFNNdlBMUFM0aU5KQW1rU0ZFaFFjeisvWEZBQXpybThnek04Y2hDTUo1KzJ2VUt0cTJhRUxiRmswNGtaWkRSblloSXdkM1pjWHFIZWZ0bTVhWno3cXRCeGsxcEJ2TGY5dE9nRkhQMUFtREtMRTZlUEdkNzNCN3ZCYzI5L0kwUXBjQW93QUFJQUJKUkVGVWZLNi83VHh3aWlPbnNwZytjUWdKTFpyUW9ta0VYNno0QTROT2U1NXA5ZXpjaW9rait2RHl1OHZSNnpVWURWcXljczI4ODl3ZGRHanRleFk3UGJzUVNaWnBGaFB1ZCt6Mi9TY3g2SFhNdk8xcU1uS0t1T1A2Z2R3NG9qY2xWZ2VaT1lWbE1LZXpDaGc1S0puMnJac3lwSGRIRm42OW50KzNIZlpyc0p3bGZocXVkTmdyS0xMd3l2d1Z0SWlMUksvVDBpdXBEWU42ZFRnUHRudGlTMTU0K3p2c1RoZkxmOXZCeU1IZENBOE5wRmRTbXd1V0w4c3l5MHNqdkY2bjRhRTdyOFh1Y0JFV2JPSzd0eC9rMU5vMzZkZTliVm5EeFdUVTB6SXVrcGZlVys3WHVxdlJlamdxUElpTTdFS2VuL2N0TVpFaFJFVUVFUjBSN0V2WGhnWnlWZi9PdlB2RmI4aXlYQWJ4N2FxdHZQamdCSFRhQzdkeHZsbTFsVEZYOXZBeitWdkg5R2ZsaGoyY3ppb2cwS1FuUGlhQ0orNitqdGpvVUo2Zjl5MnBtZm5FUklWVXJScTltRW1mTFhkY1A1QlB2dDJBeSswaE84L00wL2VPWTlxTlF5Z3dXeGcxcEJ2L2ZuOEZubk44S0NlL21QYXRZK21WMUlhc1hETkxmOTdDNmszNzJYYzBuY3ljUXNLQ0E5QnExZnk0YmhmanIwNDU3NXg5dTdibGxmZFhjQ3cxbS9EUVFGNThkeG43UzZQNXdXTVpUQjU3QlgvdVBIb2h4dXFadENBSTZMU2FzaFpVWWJHVmo3NVpSNmVFT0FiMzZraVB4SllNN2R2cHZLRFVPajZhYnAxYU12N2UxL2w5K3lIR0QwL2h4bXQ3YzhQd0ZNWmRuY0xHSFVlWU1PdE5ydXpYdVZ3elg3bGhENklnb05kcDZkZXRyVitiM09ad29kR295ZzJFbDZ6aHJoMmJVMnl4Y3p3dHAreTdmTE9GamRzUFl6TG9tRHp1Q25vbHRhWlhsOVljUHBsRldMQ0pVVU82TWZXR1FhUm01SlBVb1RtRFVqb1NIUkZjRnJRU21qY2hMTmlFV2lWeVBDMFhqOGRMZkt3dmtPMDVuTWJjejFiUnZWTUxiaHM3Z0IvVzdtTGlpTjU4OHQwR3pHZFZrVnF0bW9nd242dFZSc09WN2p6MFNtckRoMS83RDlsbjVoUlJZblV3Y25EWHNyb3dPaUtZd0FBOTIvZWRZdmdWWFZpLzVTRDNUeDZPMitQbDVmZVc4ODhaWS96SytQamJEVHgwNXdnMGFoVnZmUFFUZXIyR245ZnZvWFY4Rk0vTUhJOG8rclRYb1hVc0M1ZXU1VlM2WDhPSmpkc1BNKzNHSVd6WmZheG1nNVpSci9VenB6TVZmZ1NiZHgvamc4VnJjTGs5R0hSYWhnOUk0cjdicithSjE3NUVxMUhqY252UXFGWDA2WnJBK3EwSHk0NzlZOGNSZWlTMlJLTlc0ZkY2Q1REcWVlSzFyNWgxMjFYY2VHM3ZNbGlBa1lPN3NuYkx3ZlBPNzNUNXlxN3hLQzNMNVgvZkxDYUNXWE0rWnZQdVkyZzFad3ltMEd6bHRqRUR1R1pnRWkvTSs0NmYxdTFtYUo5T3JOMThFSzhrSVVreXYvNnhqeXY3ZGVhWGpYdDU4WjFsRE8zYmljbmpCcEJmYUNtM2NSSVhIY2FmaTU5bFFJLzJoQVdiTG5wdGx3Ujg5dDArTjdBQTZIWCtqZnBmLzlqSE5RT1RhTkUwa21mdkc0L1JvT1dwTjViUVBiRWxuNi80Z3k5LytKTnVuVnJ3M0Z0Zm85V29tWDNQV0ZvMGplU2FnY25sTml2L09sZHloK1lzZS9kQjdJNHoxaVpUZVdJL0grNmUyREpBcFNyL0hyU0lpeVFscWZWNTMwZUdCWktTMUpwbXNXRmx2UnVBWFFkUDBhRlZiTm0yWHF2aG1pdVMrR3o1UnI1WnRiWHNSdDAwcWk4cVVmUTdkdStSMDM3YmY0blpZbWZ6cm1QbzlScEdEdTdLcVV5ZlA4ZkhSSlI3YlFCZXJ4U3djVjgxTkZ5ZS81NnQ0ZGJOb3M5SmxsMjhxcENxWW90bmlkWHVMSU85cEJUUHRyMG5MQlh0MkR1cFRibDNmY1NnWk5JeTgrbVQzSVlta1dkYVBRZU9aOUNtUlpNeVg5dXc5UkMvYk56TGlFSEppSUtBTE10Y016Q0psUnYyTUtSUFJ3YjBhRitteGNTRXVISTF0dXkzN2FRa3RjYmw5dEE4Sm9MRlAyMHFiWndrbEh0dGYyV2ZxdVhERlZYdWtpUlRhTFp5K0dRV1V4NTdGNnZkTnhRNHBIZEhmbHEzaTlTTWZPYk0vUWFyM2NrenM4YXpkYzl4Sm8zc3c0M1g5bWI3dnBNOFBYTWNEcWViT1hPLzRWUjZIait1M2NXd3Zva1hqQ05hamRxdjAxSVphNnB5UFZ4Ulk2YW8ySVlzeTF3MTVTVzZkV3lCdytIQ1pOQVJGaExBcDh0K3gySno4TmowNjlDb1ZmejZ4ejRHOWVxQVNoU1JaWm1oZlRxeGNzTWVydXJmbVVHOU92TFIxK3RZOHZObVJnNCtQNGZsOW5nSkRpeDdQd1haK2NWbldrOHFzZWFqdE52dExUZHRzMkwxRGtZTjl1V3dkaHc0aFNBS0xQbDVNLy83WkNYUFAzQUROcnNMalZxRjIrTmw0L2JEWmFZTDBLZHJBbHYySE1mdDhhSlJxN0RZbk15NTczcm1mcmFLcjM3Y1ZCWWYvanJQdFFPVDhVb1NkejR4dnl6RnE5T3FjYnJjTmEvaFAzY2VwVyszdHZ6Mnh6Ni83NCtsWm5OOWFhTS9xWDA4aTMvY1RPL2tObVhmT1oxdS92dmhqd1FZOWR3NnB2OTU1ZDQrZGdBZmZyMk9FcXVESG9rdDZkbWxOVDI3dEdidmtkTTg5OVkzakJqY2xSNkpMVGx5TW91eFYvWkFsdVd5L0JsQTMyNXQyVlRKVmxhVk5MeDkvMG02ZFd4UjdtK25zd3Q0L29FYmlJOE41N3RmdDlFME90UlBpNE43ZFdUeGo1djRZOGNSdjFTUjJXSm4vZFpEZkwxeUMvMjd0ZVdLbm1lMG41Z1F4MVAzamlVanU1RFpyeSttU1drMzlKZU5leWsrcTR5VXpxM1pzdnQ0eld0WWxtVmNiZzlHdlJhYncxVm1UcFBIRFN3TFhpczM3TUhoZE5OODRIMWNQenlGSjJlTW9YbHNCRCt2MzgzU3QrN25WRVllLy90a0pVVm1LMjZQbDhRanB4bldONUhSdzdyejVzYy9ueGVaQlVGZytCVmQyTDd2QkZhN2t3VkwxdkxvdnorbnhPcnJzWmtNT2x4dWo1L3AxMmgvK0dSNkh1T3U2c25PQTZsY043UWJZNFoxNThzZi9tVE5wZ1BzT3BUS3ZiZGN4WVp0aDVCbG1YMUhUdlAyb2w5WXMyay9McmVYMXo3NG5oZmUvbzUxV3c2aTFhZ1ozS3M5c1ZHaGZQdkxWcTY1SW9uTTNDSThIcWxNazMvSmZ4Yit5TFFiQnpNd3BRTzdEcDZpYll0WXdrSk1IRDZaeGUxakIvRDFxaTFZckk2YTd3OERaT2VaaVdzU3pqT3p4cEdaYStaZjd5d2pNNmVvTEFXMGNzTWVwazRZN0tlaHEvcDNZZkdQbTloek9LMU1FMjZ2bHk5LzNNd05zOTdrdlM5K1E1Smtycjg2aGE5LzN1S25yWSsvV2MvQW51MkpEQXRpN21lcm1QMzZVbDU2YnhrWjJZVThQWE1jeldMQ3k4NWY0ejRjRm16aWtidEdrcDVkUUluRlVXNTNiTnUrRTJ6ZmU0TEhwbzFDci9NMS8zNVlzK09DSnBmUW9nbWlLQ0FJQXFPR2R1TzdYN2ZqZEhsNGVmNXkycmVLSlNXcE5RNm5tKy9YN0NTM3dGY1ZiZDE3QW5PeGpkVE1mQjY5YTVSZlIrS1NmVml0VW5ITDZINkVCQmw1ZTlFdlpmM2YvajNhc1dIcm9YS0QyOG1NUEI2ZE5ncXRSczJULy9ucWd1VS9NK3ZNNkd5UHhKWjh1Mm9yMi9lZFlPYXRWeEVaRnNTMmZTZDQ2NU5WZnJWRG42NEpIRTNOWnZsdjJ3azA2Wmw2dzJETUZoc2ZmN09od2dSOXBZQUg5KzVJLys3dCtQUzdEWnc0bmV0WEp6NDhkUVJwbWZubmRjai9NdStjL0dLc2RpZVAzRFdTSXlleldMRjZSN2s1NDAwN2p4SVRHWUlzeVh6N3kxYmltb1FoU1JJck4remhtMVZiK1dIdFRyLzBhMXlUTUs3bzBaNlg1eTh2VGZvNytPK0hQOUl5THBJbi9tODBHN1lkT3EvcXJOUlF5eTJqKzdOdXl3SFdiS3A0cU9YcG1lTjQ0K09mejB1VHhrU0ZNR1pZRDk1ZTlFdVoyVjQ3TUptUUlDT2lLQkFTYU1UcmxUbVdtbzFhcmNMajhmTDc5c1BzUDVxT0pNbE1HWDhGMzYvWmVkNVFTMmlRaWZzbUQyZk9XOS9nbGFRS2gxb0c5ZXJBcDkvOXpySFU4NGRhL0lCais5M3o3VzFqQm93dU1GdjRiTm5HaTVxSFFhZmw4YnV2NDRNbGEvdzAvY1RkMS9HZmhUOVcyTU5LU1dxTldxWHlHeEEvZHpEdG9UdXY1Vi92TFBQVDdGMDNEdWJsZDVlWFZZc1hjc09icnV0TFJFZ0FIMyt6ZmxuNjczTkhsMXN0M1hUNzlIdS8rdkhQK0Q5M0hxMVUxODNqOWJKdXkwR21UaGlFS0lxa1p1VFRJN0VsTm9lN0xKVmFualJ0RW9Zb2loVU8xWGdsaVVDVGdkQVFFK25aaGZUdDFwWVJnNUo1K2QwVk9OMFhuMG92eVRLN0RxWnk4SGdtbzRkMHo5KzZidG1DQzVwMGRmcVpJd1lsMDdGTlV3eDZIWFBtZm5QQnlId3hEZjlWcGMyK1p5eFdtNE5ESnpMTEhXZXFwUGlaZEkzTkFQaCt6VTd5Q2kzSXNzeXRZL3BYYWh6M1FnbkRXMGIzUTVJazhvc3Nsd0piL2FibHhTVEFxQ2M2UElnNWM3OGhLTURBNkdIZGlZa01ZZWZCVkg3ZmRnaW42OEttcU5PcTZaMmNRTGVPTGNqS003UHNsMjJZTFhZZW5qcUNBS08reHVaNTFQcTBwZTZKcmVoWE9tM0o3bkNoVnFzd0dYVUlDRmhzRGp3ZUwxcU5HcnZUelI4N2o3QjF6L0ZhbmJiMHR4TS9EVCswNVBnU0VNWTNMa1I1NmF2WHQ2cjVvTlZRUkFGV2dCVmdCVmdCVm9BVllBVllBVmFBYTZNL1BLcHpXTnRRazZaUkFSWmEzVzFmclFpNGFaZ3VySFdFdnZiTzduSGg4YnJ3Rk9laDB1cVJWVHEwZWhPb05CVVBRRitpSE10emhOVkt4dU9pckRZTHRyd2pPUElPZ2RxTFpDdEVFNUtBemhTTlByd05hbU5BM1p0MDdYUkhaVHgySzlhMGRiaUswNUJrR1ZkK0dyTEhodXlWa2F5WmVPeVpCTVFOcUJQbzJnZjJ1ckhuSGNGcHljWnJ5Y1NTZllTU3ZGT29KQWx0MERHQ20zY0Z5WVZOZjRTZ3Bvays4MjdJd0M2SEZaYzFHNi9MaGpsMU82SnRCNjJiK2diRnNyTUNzZWNFSXBwaWNSWWN3Uk9kZ0xxV2dXdTlXaEs4VHR6bUl6aUxqdUF3NXhFWlhreDJCdVJrUUZoWUNlYmNWTnptTkdUUmphYzRyK0didE5mbFFEU0ZvN0prZ1NBaWFpQThFZ1FaUkEySXNvVHN0U0haQ2xGcDliVU9YT3NhVmdkRkludFVxQVBpTVlVM0p6c3pDQm53eXBDVEU0Z3hPQnhOWUV1MG9XMlJWYnFHcjJHMVNvTXhQQUZIOWhZQ1loSXd1NHRKeTg0SFFZVXhNcDZncUFUVStrQzB4aWkwaHNZUXBkVmE5T0VKU1BZc0pGbExjTnNJOUVWSFVXbE1xQUxpVUt0RXRBRlI2Q01TUUZRM0FtQkFZd29rb1BrZ3hKeERlQnk1aUNJSXhqQmtqd3A5UkFLRzhMYW9EYWE2dUpTNmEybXBkQVlDbXliaXNsc0liSktFeDJsSEV4eUZTcVdwOWJxM1F1RDBBbWVCelNuVjhxczhkYVdmUU1nRmNKZCthcTN6VVBHclBKZnZLVGdNUWlON2xhZXN2TXBUQVZhQUZXQUZXQUZXZ0JWZ0JWZ0JWb0FWcWJxY003NHhUVzVvQUNHQ215UjFBVW5xQXBMVlJjU3JMSDVRUTR0T0NKY2xBVkJYZ0FEcTRDQkNldmNncEg5dm1IbFh3OUp3VlFGRCsvY21vRXRIaE5LMXQ0UnpIb3RWTnpiQWk0bTZNUUs2WEM3VWFqVmlPZnVvTHpkZ2M5WDVENlZYRlZDU0pOeHVOeVZGaFJ4Yy9RMzdmdjZLNUhGMzBXdlVUWFVQWEJ1QUFGbW5VeW5LeWNDU2VaSlRtMVp4YXY5dTdCa0hjVmt0aUNKb2JyNi9ia3k2dGdCbFNXTDcycFdFaGtkdzRPY3ZPUDdqQXJMeml3aFF5OWc4NFBTQ1VRMHFBU1JqR0syNjlxMGQ0Tm9DQkxEYjdaUVVGWkM2WXdQSGZsdkMwYlhMMGNoT1ZFQ1JCelFDdUx5Z0ZjSG1BVW4yVlRzUlhhNGdPQ3lpWm9CckUvQXZNZWZuc1AyYkJhU3QvNWJpb3p0UWUxMFVlOERsOXIzSXlsVmFuM3BrVUF2Z2xuMndIaGt3aFhIOVk2OVd1RWlEdWo0QW5pMTVHYWw4T1hVQTZvSlUxQ0pJSGlqd2dGUHlRVW40NXIrb2dVSW5oT3A4SFFLZENwd2VHSHpINHpScDNycnkxVkpkQTU0ckdRZDNRMzRxZGdsc0xwOEdCY0FnUXFZVFFrVlFsWnB1cUE2SzNhQVJ3U09CT3FZdHcyNjl0L0wxOElMQVArb2M4R3h4dTF5YzJyc1psK1NEQ0ZHQjFRT1M1QnRQRHROQmdST0N0RDYvZFhuQjRRVlJyU1h4dXNtTWUrUWxkSHA5NVlIL2dxMHJRRDlZaDQydkhya0oyNWJ2a0dXZm1XcEYzemliQlIrWURJVHJJTjhGUnRIWHVZM3Zrc0tJaDE2bFU4cUFza2FIMCtuRTdYWVRGaFoyNGQ3U3FmL05sK3NLMEEvVzdlYjdPZFBKLzJVaGNxbHZGcm9nMWdpRzBzZEJYYVZhdHJoOVdpOXdRWmdlWWx0MUlLSk5Fc2JXWFlucU5naWowWVFvaWppZFRrSkNRbWpac21YRmJlbjRlNmR5T1VTajBXQm8waEp0aTY1RXBGeERsNTdYc0dyZWJJcVBiTVRpZEJHaDgybWJVcTJIYUNIR0FBNEpzbzRkSVAzSUFRenRqM05WdDhHNDNXNEVRVUFVUmJLenMrdGZXL292dVhyR2JETEczSW5GWWlFa09KajRmcVBJODlod0h0bU0zZU9MemthVmI3RXdWV2tnQzliNC9oYTZ3QlFjaVY2dlJ5eGQ5c2JqOGVBdDUvbm5lZ0ZjVkZSRWJtNHVScU9SMXExOVZVcFlYRXZFSHNNb3pEdUN5MXhJc1JzY2FsK2dFZ1NmbHRXY2FXem9JNXB3L1BoeDlIbzlXcTJXd01CQWREcGQvUVBPeThzakp5Y0hzOWxNbXpadFVKVXU4eHpYdkJXRlIzZmp0TmtSQmRDb1FCUWhSUFJwV3l2NmdwaGJHMGp5cEh2UkJ3VVQyNklGQm9NQlVSUnh1VnpveTRuWWZnNHR5M0tkSmdBa1NXTC92ajI0M0Y0aUlpS0lpNHNqS3l1TGtwSVNEQVlEanBKQ2pBWUQ2ejU0bWR6ZDYzQm1IRVduQXBNYTNKS3ZaZVhWR0dnNS9nRkdQL0JDV1FCME9CeFlyVmFpbzZNUnoxbmI3ckptTGRNUC9RS24zOE9vZGVGMUZuSHMyREdDZzROcDE2NGQ4Zkh4dE8yVVJGeXJ0a3ljTTUrRWNUT1E4VFUwM0tYMXROa0ZWbTBvSG1NSWJyZTdMQUFHQmdiU3BFbVRjcHVYbHhYWWFVM0hVM3dBeDdHM2tXeXBKQ1FrWURLZFA1dEhGRVVHM3pnZFZVUXp0S0xQbkQwU0lJUG9jZENzYVJ3YVRlVW14dFM1RDh1eWpOUHBSSklrQXBvTW9NaHNJYkh2Rkp6MkVrcUtpd2dNS245eFhVbVdrVDBTT3RIWENERzd3UlRSQkZQWFlTUU9HVjNwODljNXNDUjUyYmJxRmVKVTZ3amlPRWtHbVpNYjl1RHlhakhubjZicm1JVVlUS0hsYWxrd21QQ2d3V0Yyb3hZaHZOc1FrcStiak5Gb3JQVDU2OXlrVlNvMVBhNTZCRGw2SW9FQmVqUnFnVWozU3FLa256QzZ0bkpvMjJMeWNrNVRrSi9ML3QvZndlWHlyZGxodFZpSWlqWno2MzB4QkxhS0piVHZlQWJkK1RpSmZRZFhQeEZmMTAzTFk5c1hJZVQvVElscE9DSHBqNUZlRklRcUxBVVRwN0JhN1hTSnpTQkxjeDNhMk5Ha0hkMUd2UE4vdUlsQTZQdzVCcjJlaU5qNGk2NDhmRzZhMW0vajE1Q1djbDEzSHR4dU55V0ZxWno4OHorRWQ1cEdkTk4ydUZ3dWptMTRqaWJhZlJUYVEwZy90b1oyY1JwTzViZ1IxYUZFcGJ4TVdGd3ZUQUZCNWRhMWxRYitJREJSYnE2eTFtZ2V1REpCN1BTdStSdzlzSW5BQUIwaEFVWk1zWU93cTFwaHN4YmhQUG9tbHN5MUlBdm90U3FjcHA0WURRYjBVaXF5S2d3aE1KSGdwcjB3UnZZZ1BESzJhc0F3VFE0UjNIUlJGNUNzTGlSSlhVQnQzd0MzMjgycDFYZGh6ZmdGaDFNaXBZT2VuV21oZU1RSTFLS0w0b0xUT08wV0pBbHNIaU90MjNZRlRUQjJyeEczMjRYWGxvSFZuRTVFU0FqdFIzMUJjR2hVMVlETHk0RFU5ZzF3T2EwYytQRU9iSmtiNk5aT3krb2o3UWhyMmdOWlZHR3ptSEU0TlJoTlJvS2lPMkF0UEVsa1RDdFVraDI4RnR3T013NWJJY0hOcnFKVjV5dXJydUhLNUxocTR3WTRISGJ5VHUvQ21iYVk3S00vRVIxVVRKQlJ4YkVNTiszaTlXdzk1Q1krQ2tSVEd3NFd0S2ZubGJOb0V0Zis0bEg1VW9Gcit3Yklza3h4c1JscjBTbGNwejVCWjE3T3didzJSQm16c1pWa0V4NFdTcDZVaEJRNmpONURiNjk3NE5xOEFVNm5BMHZoYVNSWmhVNm5JWFgzWjhqT1REejZSRHIxdVEydFZudjVnV3Z6QnJoY0xyUmFMVTZuczl5K2JyMEF2aHhCc0Y0QjEvVU5xSGZBdFgwRDZqMXdUZCtBQmdkOHFUZWcrY3k3R2pad1ZXL0F1ZE9XL25iaVIxOTgyejFwN3UwNzR4b1RvS1piOHVtZ2orYzJxeURGSXdsNHBVYW1VNm4rcEdrdmh5akFDckFDckFBcndBcXdBcXdBSzhCMTBubHcvYnAyamV4d0RXeFVnSHJ0V3UzUWdZUEs3VHhvaGx5UjF3aVZtcWY0c0FLc0FDdkFDckFDckFBcndBcXdBbHdMNHRlV2RxLzVQVngydVJwWDcwaXJEYThRMkxId3N3VDNscDJOQ2xqVE16bEI4V0VGV0FGV2dCVmdCVmdCVm9BVllBVllBVmFrNnIybnN6ZCt2ZldmN3Q2UDNhWTJka3dnUGIySW0yNTZuM1hyanB4MzBJY2ZUbVowRXplSEpzNHMreTdrcWdHMCsvSXRBZ05uWWJFNC9mWnYxU3FDTDkrZlJORDc3MVA0NHhxYVBqeU5aay9zcWl2R3BmQmUrYS95Vk9YbkNmdUczRXpPd3NVMGpRMW05ZXAvOE05L1hvdEtWWDNMdi83NmJteGNNQmJWcklld2JObEYrNi9mSWU3eEdmWERoOVBHVG5TRWpidWFFdzgrejVFcER5T1hXSmd6WnpRLy8zd2ZUWm9FVmFsZ3ZWN0R2TGR1NU0wQk9rNWRQdzE5ODZZa3J2dUs0RUc5U1VzcnJCL0FkOTd6cGZtYlZnTm9OZmM1aWxhdVo4K0FHN0JzM2MzUW9lM1p0ZXNwaGczclVLbENFeEtpK09Pbi8yUEl1cTlKZmZxL3hNeWFRdnR2MzBQYkpKTGx5M2VUbkR5bmZnQzdYRjc1NFllWE1tVlJHbkhmTEVBMEd0aC96V1F5WGw5QVZJU0psU3Z2NC9ublIxL3dBY2NiYnVqT2huZEhJZi9mL1ZpMjdxSGRrbmswbXowVEx3SVBQcmlZMGFQblVWQmd2V3pBNVQ0Ly9QMzNlMGpaZFpyUFAzeWUyRysvSXUzWk55aGV2NW5XYjcvQWswOWVTMDVPQ2V3by83M2VMM1FUT0huRGRBSjZkS0hOZ2xmUXhrWno2bFErTjk0NG4wMmJUbHoyS08wSFBHQkFHMjEwOUJsZmZXditSaVpNR00yd2lhUEkrZWhyMHA1L2l5YlRKeEhWcVMxRkZSUm9QM0NVVnZPZUozejhjQVNWaXMyYlR6SnYzaHFhTlF1bFdiTXpEMEl2V2JMOThnTS8vUERWQWFOR2RTbDN4NkIrUFNwVllLdTV6L2x0cDZTMElDVmw4dm4xb1REOThnTUh2VDFQdStYdXltVXRKWnZkYjd0bzVYcTJOTzFkaFZNblhYNWd3ZTArRDZRcWNpbkhLbTNwQ2lRdUxwVFFVR1BOYUxpK3k5U3AvZW5TSlE2NzNjWGV2Umw4OHNtZmx3WmNQR09HNjVxck9oZ3FjMkRSeitzNGV1ZWpma0d0N1pmL3EveVpBeDZvK3NXcVJXYk85SzNxTUhIaS9Fdlg4Q3YvL2MzeTBhS3RCditxS29IcDB3ZWcwMmx3WitXU09mY1RtajAxQzVYSjM2eEVrd0dWeVlpbnFKanN0ei9EZnVRRTRkZGZ5eTVERTk3L1lDTk81Nlc5Y1NjeU1oQ3RWbzNENGNicDlCQVJFVUJJaUpHaUlsdjFnZGV2UDFvMmttWTBhbm56elluY2VXYy9BUEtYL01DSisrZGdhTitLa2tKTHhRV0dCQkg3eUhReVhwdlA0VnNmSUdad0g1NTRjQmFUL204eHUzZWZyalp3Ym00SkN4ZHV4T24wRUJDZzQ1MTMxdUd0eGhNNDVRYXRqaDFqMkx6NWNlNjhzeCtTM2NHSis1N2w2RjJQRTNuN2VBN2NPWXZ2ZnoxY1lZR3pabjJCeXlQUjlKSHBkRnorUHJiOVIzQk11WWRmWHgzQ3RHa0RMcnJ1eG9YRVluSHk3cnZyZU8yMVZVaFM5UjZpRS8wYkF3SlRwdlJsNjlZbjZkUXBGdnZoNCt3ZGVqUDUzNjJpMVlldjhuSmhMQk51WG9qTDVhMnd3SVVMTjVLUzhpS0hEMmNUMkxjN25UY3NKcUJiSjQ3ZGVBK3pteFh4eFdkM0VCeHNxTmJGbnIzNlZYVlh3dklEZnVtbHNVRUxGdHlPd2FBaDcvTmw3QjAwQ1pWUlQ5QW5iM1AxczV0NCsrMjFsVHJSN3QybjZkNzlCVDc5ZEJQcXNCRGFMbnFENWk4K1FzYi9QaVR4bzdscy9YRmFyVVh5aTNWai9ZQTdkSWhSU3pZN3gyYk01dGlNMlVSTnVZRjlVMmJTYytUNzdOaVJWbVh6dSsyMmhkeDU1OGZZSFI2YVRMK0pUaXMvd1oxWGdQbW1tbTlXYWpRcVJvN3N3dU9QWDhPUUllM3AxNi8xeFlIVmFXbmkzc0UzVWZqRGFsb3VmSlVYODJPWWVPdUhGQmM3cW0yQ0N4YjhUcytlLzJMLy9reE1TUjFJWFBNRklWZGZVZUV4MWMydXVOMWUrdlZyemF4WlEvamxsL3ZKejdkZVBLY0YwNVlBNHk5SG95SW9TSTlPcCtIYWF4Tlp1blE3ZHJ1N1NsRzRiZHRvNXN5NWpna1RlcENWVmN5OGVXdDQ1WldmY1RvOWZqbXRldFBTR2pxMEF5Ky9QQTZUU1V1ZlBxMjQrKzdQcW5UODRjUFp2UHp5ejJ6ZGVvcVltR0RtelBtKy9qWXQ5WG9OQXdhMElTSEJ0NDVPcDA2eHRHd1p3WWtUVlp1dnZtOWZCdHUzcDZMVHFldDNXOXJoY1BPUGZ5eWhZOGNZUWtOTlRKdzRuL1Qwb2lxWDQzUjYvUDdXNjg2RExNdmNkOStYWkdhYU1aa3EvNWJhcUtoQVg4cnBjbmNQQXdLcS9tcmRRNGV5S1M1MmtKbHBydFQrbzBjbjhjTVBNeGs3dHV2bEIzNzIyZXZRYW12WGdMS3pTOURyTldSbkY5YzlzTUdnOFdzRVRKN2NoeUZEMnZsOXA5R29haFI0NTg0MEVoT2ZaZnYyMUxwUEFFeWFsTUxJa1oxWnVIQWpicmVYc0RBVDQ4ZDNJejI5aU1tVCt4SVRFOHd0dDN4UTQ4SHU3TCtWa1JwcmVBaUN3QysvM00rUUllMlJKQmxSRk1yK1dxMU9PbmQrcnNyVlRBMUp4WU5wbHhwbHAwNzlCTGZieTEvcjMvNzE5Nm1ubGwwdTJOcno0YTVkbS9ISkozZVU2NmVQUFRhY0tWUDZjczVDd0EwWCtJWWJ1dlB4eDNmUW9VT1RjbjgzbVhUTW5qMkNWMSs5M2krNFhRNnBrYUMxZVBFMkZpL2VCc0E5OXd6aXJiY21sZjIyZXZVaGhnejVUODFkc0ZyRTY1VnJKZ0ZRRTlLcVZTUjJ1NXVSSTk5aSsvWlVXcldLcUxHeUl5SUNHRFNvSGQyNnhSTVJFVkEvZ09QaVFoZ3paaDdmZjcrSHE2OStnK0ppeHdVYjgxV1JxVlA3OC9ISFUxaTJiQVlUSnZTb0g4RFBQZmM5SzFmdUJ5QXZ6OEx3NFc5aU5Hb3Z1ZHpJeUVDNmRZc25KaWFZMk5nUVVsSmFFQkppdkR3K2ZHNFg3V3pKeUNpcWtYSnpjMHVZTk9sOVdyUUl4KzMyTW5ueWg1Y3ZhTlZsdjNuVXFMbm9kR3JVYWhHUFIycmN3RmFyRTZ2VmlTSlZhUUtmdmRIdDNXMUxCT1R4alFsdzIvUWV5Z0ppMVJLTlNpUklLLzU5Z0JNQ1Zkd3Nadjk5Z050a0g2ZkpvUjFvVldMakJ4WUZhSnQva3ZBTnZ4SnFVRGQrNEZDOW11aGRtekVlTzBoclcxN2pCMjRpdTRqWXV3VlBiaTZkODA0MGZ1QXVCU2Z3NXVRZ3UxekVIdCtMU2F0cU1NRHF5dm1zUUtoQlRaelhTbkx1Y1RwdFdJRzMySmNManZ4K01YZTM2OHl1Z0ZnT0JzWlM0UFJnYzBzTkQxZ2xDSFFJMGRBNjZ4anRzbzhTdldNam9mdDM0TTNKUWJLZG1UbWp5amhOMjBlbTBpa3lFbGQ4U3pLN0R5QzlSVWNPTm1uREFWVVErVFozd3dEV3FBVDZPREpwbW5lTTBNMXJDVHEwRzA5ZW5oOXNtVWdTbnJ3OHRJSkF0RnFEb05WaUNBNGdMMEJQUGtMREFIWjRKT1o3d3RFMEcweEl3cFhFdTR0SnpEOUJmT29ob243Nkd1MlJBNzdHdU1GQTdvUXBaTFpMWWw5WUN3NEh4bERvOEdEelNHQnJnRDdzbG1SeWJXNXlNYkF0cUNQNjVFU210T3BBMTBmdlFIYTVLTGh1SXU4TS96L1NpNTNJZ0d5cDM0c21WRGxLT3p3U080S2FvWTZNQkNBN3NRZHB4VTVLWDJIV09LTDB1WEpTRjRxbGJTSW1sNHY5b2ZHTnZ4NHVjSGpJNnRvWEtTNit3UUZYUzhNdXI4U0p1SFlFOWgxQ2dVdHEvTUFBQjZKYUVhc1hzVjVnR21LajZoNmU4R3BaRnRpcXdmV0hxNjFoczhPRG1ZWW5TazVMQVZhQUZlQ0dHNlVIeEc4STA2a2RqUXB3MnpuYmZwM1ZiUm5kVG5lTDJkNjBNUUVMZ2oram40WkxuSUd1SEd0VUl6UGluSXBOK3NHVi85a3VJTGRzWE1BOS90NUJ5OCsrMTV3WWVMeEQ1SUZHcGVIb2dKeUtmVGhRVjZLTk11WDhmYXFsajNmZGZ2akxmVGMyYlZ5SWoxWU12RDYxZjRHQTNLZzFyRFF0RldBRldBRldwTUcwdEJqL1diWHFwSU4zUDBTNzhFd0FpamVFY09xcE5uNi9OLzNIU2NKRytLWkc1TnNEaVBqUHUzVkh1UFJtWldLYUFxd0FLOEFLc0FLc0FDdkFDckFDckFBcndGVVh2eVRlNlZuM1ZxdVFhRlBsVjFrSTFWdXJmWjdxU056U0N3QTNEYXo5WlpEL243M3pqbytpMmg3NGQyYTJKcHZlQ3lFRVFndGRSQVVWUk1BQ0NqWjRkc1dIZ3RoN2ZlcXo5NFkvc2Jlbno2ZWdJQ3FJaUtCVUthRWlhVHRGQUFBZ0FFbEVRVlRYVUpPUTNzdldtZnY3WTJsTEVraEkzVGpuODFsbE45TytjODQ5NTl4ejc4eVZKZEVpNTlGTnVqWU5seTZJYVBRQjdkdHJQdUphdmRXR2JHNnRlbmVSenplZmFzQ0cwSUh0cmdyZnAzUzFYdkhRZ2R1eitOaDN5YXZoalc3RDl1MEJGSDdqK3o2UHNERUYyUHBYdEFwZzJMM0ZkWThQaDU1VDNIaVRNV29VZnVQN1cwQzNxaVk1dG03U2pZM0QrOHBPN2lVajhVRWxHT1g2elp2V2hFUm1lVVFMSWhiV0Radzg3YzJUT3VUUkl3OG5raEpINEVtZjUrVGthajBzNmNBNnNBNnNBK3ZBT3JBT3JBUHJ3RHF3RHF6TENjV24vSEhtTzk5Vkxla3lLS0E5QVE3WnRkcSs5Tlp4QVhvYjFvRjFZQjFZQjlhQmRXQWRXQWZXZ1hYZ3hvblAyTkw0TlQ5VzNQVG5uKzJxODFCcExhdGNXaGR3MzZ5dHpsNlpUWDlTS1RRRTY2MFRNUTBkZ2h3YmhhaW93cjF1STQ3M1BzT3pjVXV6QW05SkZLNDZOZHdjWWp6emRBS2Zmd3c1SWh6UHFuU3FubnNOZGZOMkFKU2VYVEZmZmhIT21UK0NFQzF2MGszdUlCTGpzYjM1TEpMVml2Mzl6N0MvNGZ1QWx2YkhjcEFrbE40OVVEZHNRYkphRWZibVhhVzZXWjFXNEZNUElsbXRlRmFsWTMvei9UcTNFL21GS0xIUldPK2VESktFSEJQbGZ4cVdFK0l3bm5FcUFQYVB2NnpiWklYQU9tVWlTcyt1S0owNlloalFCL3NiNzZIbEZmaVhocFdVNU1QL1B0Um1hOTJ1V3hja2l4bERXbmVrQUN1R2JsMVFPaVlpaFllMjN6Z3NSTXZOZUd3MllIWDMzaU5hVE90VzkzYmJNOERwd3JONUc2TGFqbWZiVHRSOVdZamlVdjhDMXJKemNDOWZCWUIxNHRWUTE4clNrb1Q5M1krcHV2MGhuTi85U1BuNG0xQjM3dkpQTDEzMXhJc0l1eDNEcWYyeDNubHpuZEJTZENScWJqNzIxNmVERU0zbXNKb2RXTXM2UU9XZGo2QVZGV085K1hxQ1A1MkdjZGdRNUtnSTVLZ0lqRU1IWTc1c0RPcEc3NXVNbXpzR3QwaW01VjZ5a3JLTHJqNllXZzRtNk0zbnZLbGwrZ1ljNzMrT2MvR3kxdXM4N0lwV2l5dXRVak84YkxZRVpyenEvUndyWFpzWE1EOUlLcTRUK1BOaFlydEE5R3RQdlNVQk8vaVBYZ0RRZ1hWZ0hWZ0gxb0YxWUIxWUI5YUJkV0JkR2lqSGxDRGVtd0ZjZHQxMVhmbnNzMkVBL1BUVGZzYU1tWGZFSkE0dWQ5OHpKWWZmcDc5S2RQanhueWtVUXFybHQ5cDZOZlhjcnRiajFmenRtc2NuOHUyQ1U0QmJUdno4OE5peEhYbnl5VFdNSFBrVFBYcUVFaGpvN1VXR2hwcTQvbnB2QjNiTDdqaUdUNzZIL09LZzQ5OVJTZFQ0eUhMTmp5SnJOVDRHcGViSGFGQnJmRXhHVDQyUEltdjFiOE5QUDcyV3A1NWF3NElGMlp4MjJpekN3c3dIYjBReTQ4Y2ZXYjFqOCs1NGhrKytoNEtTSUw4eDZWcExQT3ZXSFhsdTN1M1d1UGZlUG9TRm1Ubjc3RGc2ZHc1bSt2U3pFRUx3NFlmYldMTUdoaysraDRYVFh5TXFyS0xOQTUvUVM1ZVZ1WGozM1Mya3BZWFJvMGNvSnBQTVAvN1JtUVVMc2xtenh2c2c0NlpkL3FQcGVvV2wvZnNyZWZmZEkrTzRTNWZtTW5QbUhoOUh0bWxYUE9kT3VadkNVcHYvQXdOY2Nra3l6enl6bGhFamZxSmJ0MUNDZ295SEhkbDExNlVDc0RFamdlR1Q3Mm5UMFBVR2Z2NzVkVHorK0dwKys4M3J5RUpEajNaa25ROXYxOWFoNjEyWFhydjJ5SVBISG8vR3JiZjJQT3pJVWxLQ21EWnRDRUxBWjUvdFlQVnFPSGZLM2Z6Mjd1dEVobGI2ZjJwNXJDTXpteFd1dVNhVlAvL01ZZlZxN3pESmhwMkpuRHZsYm9yS0F0dEhMbDJiSS92bW05MCtqbXpEemtTR1Q3Nm5UVUUzcXZNd2Jsd3lUejlkMDVGRlJWbTQ2cW91UjJtNjdVQTNDdmk1NTlMNTE3OXFPckpMTCszRUZWY2N5Y2pXNzBoa3hKUzdLUzRQOUIrbmRhS01URlUxYnJzdGpaQVFFOE9IeDlPaGc0MTMzejBUSWVEOTk3ZXliaDJjTy9sdWZwditPdUhCVmY3Zkh5NHRkVEY5K2hiNjlvMGdOVFVFaTBWaHdvVE8vUHByMXVFYnMyNUhCODZkM0xxYWJ0SUN3SjQ5Rlh6d3dkYkQzLy84TTVmdnY5L3I0OGpXN2VqUXF1YmQ1QldQaXkvdXlMLyt0WnJ6enZ1WlhyM0NEbmN0UTBKTVhIdXROeU5MMzk2QmtiZmVSVWw1Z0g4RFN4STg4Y1Fhbm41NkxmUG5aM0g2NlVlNmxtUEdKUEdQZnh6SnlOWnVTMkxFclhlM09IU1R6Z0FRQXRhdlArTEluRTZOTysvc1RXaW9pYUZENCtqYU5aUTMzaGlNRUlJdnY4eGc5V29ZY2V2ZExQaS8xd2tMcnZaUGt6NWF5c3RkZlBqaE5nWU1pS1JYcjNCTUpwbUpFN3V4ZW5YQjRZeHM3YllrUms1dE9mTnU5cXJsM3IwVnZQWFdwc1BmbHkzTDQ4c3ZNdzUvVnhTSk5Wczd0aGgwaTVScEw3bWtFODgvdjQ3enp2dVpidDFDQ0E0MkFSQWRiZVhxcTcyTzdCQjBhVVdBL3dPLzlOSTZIbm5rTCtiUHorTFVVNzhuUE54OE9EVTl1a2JXRXRDR2xnQStWQW82MUxXODdiWTBRa05ObkgxMkhCMDdCaDJ1a1gzd3dUWldyNFZSVSs5ay9qdHZFaHBVN1o4YVBqWWptelp0TXoxN2hwR2FHb0xKSkROK2ZBcS8vSkoxdU0rOWFrc3lvNmJlU1ZtbDFmK0JEem15RHovY2R2ajdraVc1ekpybG01R3QycExNeUZ2dmFuTG9WaHRiT2pvalMwc0x3MmJ6ZGkyRGcwMWNjMDNxVVpwdVd1aFdBVDQySXhzMGFCYWhvYWJER2RtVlZ4N0p5UDdhM0xUUWh0WUFQallqYzdzMTdyNjdOMEZCUm9ZTmk2ZDc5eU1aMlZkZlpmRFhLamp2dGp1Wi84NGJCQWM2L05Pa2o4M0lQdnBvRzZlZEZrMmZQdDZNN0thYnVyRjJiU0dyVm5renNwV2JPakZxNmwyVVYxbjhIL2hRMS9MMTF6Y2UvcjU0Y1E1ZmZMSFRKeU5yQ3VnMk5TQit5U1hKdlB6eWVzYU1tVWV2WHVHSGEyVGg0ZWJEam16bHBrNmNkOXVkSnczZHBvQmZmWFVERHp5d2twOSsycytnUWQ4VEVXRTU3TkdQN2xxdTJKakMrYmZmU1VXMXhUK2NWbDF5cUwwQ3VGd3FkOTNWbStCZ0k4T0hKOUNsU3pEdnZITW1RZ2crLzN3bnkvL3lPckpmcHIxSlVJRERQelY4YkViMjBVZmJPUFhVS0hyMENNVm9sTG51dWxTV0xjdmpyNys4QzhvdTM1RENlYmMxVE5OdGVsTExybDNsVEp1MitmRDNQLzdJNGF1dk1ud3lzdVViVWpqL3RqdnFEZDNtWi9HTUc1Zk1zOCttYytHRmMwbExPK0xJSWlNdGg5djFzZzJkdWVEMitrRzNhV0JKOGhiN0gzdHNGWFBuWmpKbzBKR3U1YkhUTDVhdTkwSlhWcHY5eDJuVmxwRWQzYlU4MXBFbEo5dDQrKzBoQ0NINDVKTWRMRTJIODIrL2szbHZ2K20vSmwyYkl4czBLSm9lUFVLeFdnMWNlMjBxZi82WlMzcDY0UkZOMzNISFNZV3NkaW0rTTdxNlBUa0RJUzVyN0VHejNwaEZRbGpqbmpMTExyR1NlTmU0cG5BRU05bis1T1YrYWRKK1hRRFFnWFZnSFZnSDFvRjFZQjFZQjI0UnljaHlVMUNxL24yQTM1bFJ3bnZmbDdZdjRQd1N0ZGFuVXV4T3dYOStxZUQ5V1dXNDNEVTNVRFh2dm40SHZIbTNrOFNMZDNQL3RBS3FIVWZBSHBoV1FHR3BTbWEraHljL1BETGNVbEd0Y2RjYkJTUmN0SXRkMlc3L0F6N25sQUJPNzJYaGxTOUxtUGhzTGc2WFlNOEJOM2Fud0dpUXNKb2w4b3BWc2dzOFZOazFybmt5bHpmL1Y4SjVwd1Z5UmkrTGY3YmhGMjZOUkpaaHl4NFhGcE5FcDNnakh6NFNnOGtvRVJRZzg5R2pNU1JFR1Fpd3lHemU3Y1NnU0R4elM2VC9PcTNVRGliR0RMR3hjWmZUeDB5UGZZN3MwTi9IbjJ1alE0ekJmNEVCN2h6dmZSSFlMeXVxZk9vc1I3K0hhTzV5NzkvdW5CRG0vMkZwNklBQXdvSVVGcTJ0dStUeit4bzdDVkVHVHUxaDhYOWdSWVlScHdhd2VZL1Q1L2VqTmJ4NWo1UHpUZ3VzODVWYmZwZDRuTjNmeXM1TU54NVZITldHdmY4dHI5TEl5dmR3Vmo5clMxeEt5eFRpNHlNTnVEMkNxLzZWUzI2eGh5cUhSclZEWStpVVRNS0RGUUFTb2d6dEJ6ZzJ3Z3YxN2NJS0lrT1Z3Nzl2MnUyaXVOeWJWY1dFSyswSHVHOFhNK21mZHlRbDNraHdvRXp3aUF4c1Zwa0RjMUlvcmRUWWxlVWl0WU9wL1FBSFdtWDZwWnA5NHZBaC94UnFrem1sZThzTmkrajk0WmFTbGdoQnJXYlN4OG85VjRaaE5VdC9IK0FuYm9yNCs1bTBEcXdENjhBNnNBNnNBK3ZBT3JBdTdVMThNL2dwWTJjZ05YNWlXcHNTSWMzazNkbjZ4RFFkV0FmV2dmMVRtbmVCS1FFSkxrR3NVeVBLTGFoUUlOY2trMjJScVpiYkNiQUVEQzFSdVN6ZnplZ2lEOUd1bXRNYVhCTDhIbTdneDBnRDMwUWJxVkw4RkhoUXVjclR1NTBNT2NFTUhaT0E4NG84bkZmazRkRTlMcDVQTnZKWm5BbVB2d3ltU2NCOSsxMzh0cmI2aExESFNxeEw0ODBkVG1adHFDYk1JOW8rc0NMZy9XMTJudHp0cERFS0dsYWlzbWhOTlIyY29tMERQN0hieVpXNW5pYTVtTTUyalc4MlZoT29pcllKUEs3QXpUMlpyaWE5b042Vkd1L3NjTFk5WUlzR0wyUzRtdVdpTHM5ek03aE1iVnZBdDJTN1NYUnF6YWFKWjNjMXppYzBPZkQxT2E1bWRTNm5scXQwcjlMYUJuQ1hhbzJ1MVJyTkxSY1Z1dHNHOE5CU0R5MGh3NXBoa3VsSkFTYzZXMlpoeG9SbU9NOUpBY2UxRUhDc3E0MEEvKzM2d3prdE5IcWZhNUxhQm5CV0N3Rm5tOXNJOEtLd2xwa3BzU2hNYVJ2QXU2d3lPd0thdi9uUGlUUzJIYWYxV1Z6enpweGJGYXl3TFZCdU84RHZKUmpKTWplZmxoL3RiS1k1Z3Q5Slg3RkRob2U2TkkrV1o4UVlXUmJTUElXdVJxbG9WcFNSMTVwNFV1aEdtOHpVcm0zNHFaYW5Vc3o4TjdacHZQWXVxOHo0M2dITldzVnNOTEFxd2MzZHJUeVIwcmcydHloTVllZ3BBV1EyYzR4dkVxOGpnRmVUVEF3ZkVNRFMwSWFwSjlja2MwYzNDK1A2QkZCcWFQNkVwa2t6aUZYQkN1ZjNDMkJvaWNxbCtXN0dIS2NRdnpEY3dJOFJDdC9FbWxwMEZLTEpVeVp4MER3WGhTbmNKU0RlcFJIckVrUzdCT1dLUks1Skl0c3NZVmZhNFd4YVRZSXNzMHlXMmM5N1MzKzc3cUVPckFQcndMcTBsaHdiREdjQWpaNlk1dGxpeTFVVVloc1Z6L09NdVZYak84WTJIbEhNRE1wZHIwOU0wNEYxWUIxWUI5YUJkV0FkV0FmV2dYVmdIVmdIMW9GMVlCMVlCOWFCZFdBZFdBZldnWFZnSFZnSDFvRjFZQjFZQjlhQmRXQWRXQWZXZ1hWZ0hWaVhGaEtmaVdtNzRUL0ExZTJNY1dZSzZCUFRkR0FkV0FmV2dYWGd1a1NKOTM3K05zQzJTeUh3a3I4UmNPRGxZTHU4ZFlCYmZKMEhRektZVHpuNDc0N2cyZGZPTlh5MFptMlgvUTFNT3ZEeTJ2L2RMb0ZOUGNDVWR0VDMzbURzMW82QkEyc3g0WlkyNjVZRGxtbzM0Y0RMZ1JaOGxOalEyTnNsMWZPV21mcUNzWFBOMzQycFlPb0RyZzNIOU5DUHVnbEhyODBrTkVCckpXREpBS0VQUStnOWpiT1ZoQ1gxMkVpRDB0ZWc5SGtRcmxZeWFlR0NrcWZnd0Fod1p6U2ZHYnAzZWM5UjhsVGpZSnVzRFR0WFFmWVFLSCszNldITHAwUDJZTzg1bXNpVkhKSHJIbWJmOXE0a05lYUFBNlBoc1lFUUc5QzRDOHV2aHFkWHc2cjh4aDJuejJiMmYvQUtIV3R2d3dwb2pkVDVYNFZ3MVc5d2R4KzRxT1BKSGVQbmZmRHFCcWh3Tjk0R2hkd0N1WFNsRzU1ZUE0c1B3Q01ESUx5ZWIza29jY0p6YTJGeGpwL0c0VDl5WUhsdS9iZGZrdHU4c00wT2JGSmdXRUw5dHo4bjNydVAzd0lQam9IQUJqUWFteEZPai9aajRGR0p0Zjl1VjhGWngxdFlSM1h3VStBQUJjNktxL243dWlLNGFnRmMvUnRzS3E3NTk3Tmp3YXI0SWZCWjhXQSs2c0pkS3J5NUVTYi9BZGxWc0w4Uy9ya1kzdGtFbnFOeVk0dWg5aHZWNW9HUE5zMXRwWERkNy9EbFR0Q09ldHVVSnVDekhYRDk3NUJSZHVUM2tSMzhERGpZQkdkRWU0RSszQVlURjhIdThycTMzMWtHTnl5Q1Q3ZDc5eGtjQTBGR1B3SWVGZ2RaVlRCeE1ieS94ZGRrNnhLWEN2KzNHU1l0aHR4cUdCYnZSOEJsTHJoMklXd3BidmkrRzR2aG10OE9wcFZ0cmdCUWh6UTJXN0tyc09pQXY1ZDQyb2pvd0Rxd0R0eU9nRFVRN1Eyd1BUSTFTSHlLZUVLSUpubGpXaHVUbVpJazZSUFRkR0FkV0FmV2dYVmdIVmdIMW9GMVlCMjRrZUpUeER0dDVtczVSWTdLRmUwSk1NSml5NmtUK0svOGZYSEE2ZTBKZUZkNVViYmVoblZnSFZnSDFvRjFZQjFZQjlhQmRlRG03anowemluTUtRMHd0NnZPUTJpMU0yZGpYY0JmZnpNdlRoTHRxL01nSkxMVDlEYXNBK3ZBT3JBT3JBUHJ3RHF3RHF3RDY4QzZORlFhTkRITm5WOUk0Y2RmVWZqSjEzZ0tpdndDMERaNFVIYlhuLzZUZUZJbWJZeU9KTzZoTytpMVlSRWQzM2tCYTUrZWY0ODJMSmxOaEY5NUNkMFhmVS9xVDE4U2V2RjVTSXJpRjhDTmZ1YkJkc1pBYkdjTXhKVjFnTUlQdjZUdzgyOVFTOHYvSGw1YWlMK0JoaXVYcmFMZ3ZTOG8rM2tCUWxYYko3Qnd1aWlaK1NQNTczK0JmY01XdjNKYURRSjI1eFY0dzlLbi8vT2JzTlM0Tml4SnZxOU5hZS9BZWh6VzQ3QWVoL1U0ck1kaFBRN3JjVmlQdzNvYzF1T3dIb2YxT0t6SFlUME82M0ZZajhONkhOYmpzQjZIOVRpc3gyRTlEdXR4V0kvRGVoelc0N0FlaC9VNDNIN2k4TjlieEt1dkNoRVVKSVRYLy9qL3gyWVRKL0N5UW9nREI0UzQrbXIvaDczcUtpR3lzK3NCZkVnV0x4YWlkMi8vQSszVlM0aEZpdzVqMUI5WUNDSGNiaUhlZkZPSWtKQzJEeG9jTE1UcnIzdXYrU2hwR1BBaHljMFY0dnJyaFpDa3RnbDc3YlZDNU9UVWV1a25CM3hJbGk0Vm9sKy90Z1BhdDY4UWYvNTUzRXR1SExBUVFuZzhRa3liSmtSb2FPdUJob1lLOGZiYjNtczVnUndYZUs5enI2aTM1T2NMY2ROTkxXdm1raVRFalRjS2taZFg3OHM4THJCMXZWWDhPK2Zmd3FFNTZnKytZb1VRcDV4eTRvczFtNFVZTVVLSVcyOFY0cGxudko5YmIvWCtaaktkZVA4QkE0Ull2cnplbDJWWDdlS3BuS2RPMEoxSlI1Q082THlsczVoVE5xZiswS29xeFBUcFFvU0gxN3pRTGwyRStPd3pJY3JMNjk2L3ZOeTdUWmN1TmZjUEN4UGkvLzdQZTQ1NnlweXlPU0psYzRvZ25mb0JIL3FNMlRWRzdITHVxajk0WWFFUU45OHNoQ3dMWVRBSThkSkxOY0xFY2NYdDl1NWpNSGlQTVdtU0VBVUY5ZDU5bDNPWEdMTnJqQTlEamVKRkRlQmp4Q0piZUNENkFSNktmZ2lyYksxZmpwcWVEaTRYbkhaYXJYL09xODRFVFNQR1ZzY0tWQ3RYZ3RFSUF3YlU2M1IyemM0TCtTL3dVdjVMT0RTSDd4LzcrektlRVBpUUpKdVNlVDNoZGNhRmpEdnBYTDFhcTJLL2N3L2J2bjRPTkkzdTF6NUJrckVqQWRMSnJ6YzJxMndXZDJmZnpWN1gzdG8zT0ZuZ1EzSis4UG04bGZBV3FlYlVCbC9jK3FJL3liL21RczVlV0FuQUgrY0VFdjNGVC9TTkd0cmdZKzEwN3VTTzdEdVlWejd2K0JzZUE5emdFcys4OG5uMDJ0YUxSM0llb1ZxcmJ0QyszY0pQeGRRMURiTUxURzR3cGFiUlBmTDBCbHBKTlkva1BFS3ZiYjFPRE50VU5TMlhjUEY4M3ZOMDM5cWRHYVV6NnIzZmxzSmxGRVVaeWV3YnpmNyswUlRHbU5oVXNMVGUrODhvblVIM3JkMTVQdTk1WENlNUFHS0RUYm8yR1JFMGdtbUowK2htUHY1U3N4b2FEdUZneVpMWGtTV0ZNNGJjamxXeUlwL2d2bTkzYk9mMjdOdjV0ZUxYaGw5Y1k5dnc4ZHIyM0pTNXpWS1l1R0QzQlNkbHZrM1NodXVTRkZOS3MxVmlPcGs2dGIyNmRMeXgrZGE1Yjhwak4vdmp0QnYyekdWYjdva2QwLzZxbmF6WTlFVWRwZFdtV3pTb3lZNTB3TzI3WHRET2d0WHMzdnd6a1YvK1JFV3dsUVZqUjVIYWR4d2RRM3dINFBKY09XeFo4Z251MWN0SlhyaVRueDdaVGNlVXMwaExQQWZwWVBNNzREblE5b0IzdTNiN0hqZ3dHTnZyNzlIL3h3TUlDZjdJeThMNDhYVTE5ak1ick5nWHpHSGt5eXN3ZXFDaTlHWEU3Q093QUx1ZHU5dVdTUSszRGVmMStOZDlnUlVUc21KRUVuZy9BUUVZRlZQTk95NFprTTFXNUlQeFFUSWFzWmhzUHR1OEV2OEt3MjNEbXdUWWQ0eHpNazgyWk9kRVl5SWZKbjNJaS9FdkVtbUk5UGxiVnRFbXNxTTFYS3FkL1lNN1VqSm1LRUZ4WFFpM3hQcHNWK1F1SU0rK242eU9KZ1FTTys2L0hITm9OUEdoUjJKNnBDR1M2OE92SjgyU3h2S3E1WlJyRFJpZGZJK25HaDJIVFpLSmU2THY0YkdZeHdpVUE0Kzc3WnF0MzJJTmlxQm40dkUxdEtka0k1bTdsbkQyd0NuSDNhNUtxK0tadkdkNExmKzErbVZialUwOFJnV040cTNFdDA2WVZUVzNiSGR1NTQ2c081aGZNYjk1RW84a1V4SXpPODNrbDg2L3REb3NRRGR6TjM3cC9Bc3pPODBreVpUVWRFN0xMSmw1TE9ZeHRuYmZ5cVVobDlidnFPdld3WXBHdkZydnI3OWc3ZHA2YlhwcHlLVnM3YjZWUjJNZXhTeVpHM2lpWTBvOEYrNjZVT3gwN0R6NUVzL3p6d3ZoY2pXdXhGTllXTy9kZHpwMmlndDJYWERjRWsrdHdKMDJkeEt6UzJjM3ZJZ1hFVkd6Q05lNWMvMktlSjkvWG5zUkx6eGNpSGZmYlZBUmIzYnBiTkZwYzZjVEExdldXOFFUT1U4SXUycHYrakt0eWVRdHlVNlpJc1RUVDNzL1U2WjRmek9ibTZWTSswVE9FOGNIYmxDRk1qOWZpSWtUVzZjUW41L2ZOSVg0QmcyMWhJWDUvMUNMUHBqMnR4c3U5WGlFZU9NTi94a1FmKzIxUmd5SS8yMm1QQnc0NEowUTR1K1RXcTY4c2g2VFdsNTU1ZTgxYmVudklENWRwLzdUYVBLbFBPL3R5aDlYSjNKMnF4RUtaa3BwNkV0NTZzQTZzQTZzQSt2QU9yQU9yQVByd0Rxd0Rxd0Q2OEE2c0E2c0E3Y2ZNVFQzQ1lvK3NMSm50Ym1WTVV0MWs5YUJkV0FkV0FmV2dYVmdIVmdIMW9GMVlCMVlCOWFCZFdBZFdBZld4Vy9GWjJMYTBHcyt5VnI4MTk2RXhoNDBjL0U5Sk1ZR04rb1lJaWVQcWdIbk54cFFPV05BZHNEM0h5ZnFiVmdIMW9GMVlCMVlCOWFCZFdBZFdBZldnWFZnSFZnSDFvRjFZQjFZQjlhQmRXQWRXQWZXZ1hWZ0hWZ0gxb0YxWUIxWUI5YUJkV0FkV0FmV2dYVmdYVnBHZkNhbXJiejZIbmZLOEZNTkVkZGNTbWFobmVlbi84SEhNOWJpY3RkY1p2ZU54eTVnN0tKdktQM1J1NXhJMUtabEpKNzVTcTBuR1Rvb21hZUhSUkwzNDNjZ1NjVGVmeXNaNDI1c0dVREJ6SDVGbTJ0L1k5cjZwRjcycWkwNzJEcjRZZ0xtL3N3N2o0NWk1NEs3bUh6bHFaaU1EVjh5ZStpZ1pQNTRZQ0FmVnY1QjNFL2ZFL3ZBVkxyTStvU1ZVa1RiYU1QdmZmVlgrZURsVnBaY2R5ZFYyekxZTm1Uc1NZSDdnUDQ4aTlnSGJ6c01ldmFWSHpIaStrOWJEYmpHQTlNSDhpdTQ1ZTNseEVjSDhjUjFkM0xlOWpYa0R4bEw5T1RyZU9mUnkzaDQ4dGs4UC8wUEZGayt2dW4rTEJQNzRHM1lCZy9rdDJXN2VlcktqL2h6OWI2MjFZYWZlL2pMNG9CdW5jS08vaTNRYXVMVVdBdXgyOUl4eDBZUmN1RUlKSU5YeTN0dnZQdHdHKzVYc0FuN3hxMVVMbHVOdFU4UGJHY01KRE9uakpYcnNzak9yN2xNd2REN0pyVktHL1lCWG5ISHM2Nlk4Z0pqZlE5MkNCWWdkTXpJQmwzSTBmdTJKTENQU1NzN2Q4cWxxMWFkMUlGYkNrQlBQQnJqdEhJbjN1TG8vOG1iTlpibU1Kc01CQVdhTVJ0bDNIa0ZvQWtNTVZIcysrZTlQbTM0a0hnS2kvSFluZGl0TnV3cWlGcmVUVi9RYTNEckF6OTUzMmVsYTR4UmdVZDczU2R1UDRkelRrdW1jdWtxTWwvNlB6QW9aRjh3bG9MRXpndzgrbVlWVlBMdDNFMU1takFReGVtaWNOcEhWUHkrRE9XcThieFZHTUlIMzIzd1NXRFMyNUpKRHgyVXpNSXZibVRSZjI3a1ZFOEJHV052SlBlMTk4aSs2RkltbWdjejdLWFZOVHl2cW1uYzhmVFBkQjcrT3ROLzIwdmt2eCtpeS9jZkU1Q1R4ZFJmM21manBDU21UdWgvVWdsTXN3SDNINVJxT2d6cXptZm54VGVROS9yN0hMajRzc09nSjRxbEIvSXJhb0xQK29TQTNHeHVuZmNlbTI1S1pPcjRmc2M5aGdhb2lIcC90Sk0xNmV0dVB0ZlczNTNQem91ZlJEWVp5Umw3T1kvOWxzK2ZMemJjY3g4Q2YrRzlQM25vbHJPWTlPK0hpTG16aUx5M1B1VFdCZDl5dkhWMFBHT0dFM3BtelhWUE5ZOEwyVkJ6emFhaWViOWpYVlMvcFZKODR2QlBZKy9ZYVBJNGVxbldBQXFyVlhMU3Q5ZTVZMVRQRkdKQ3pSZ2NkZ0RLdzZMWi9kdGZkVzV2aTRrZ2ZtQVBrQ1FNZGp2eDgyYlh1cDBBVEE5UEplMmVJOHNRQ1NIWSs5SkxaTDd3SE1uUHZVRFNGTjhsaXRZOS9BeDgrSFhENDNEQ2t0KzJDNGxlQURGQTJ2RnUxZnBzbjYrUndIRVhBc3pLaHF3Tko5WHVuQVVGVkwzeEJ1N1Njc28rL1JUUGRkZGhDQXhzdjNIWVUxUkVWVVVGVVlDNmVUUHVvcUwybVhnNE1qTnhIRGlBcDZ3TWg2TUtGZGp0ZEtDWnpWVHUySUd6c0xEeHZhVzJKSXUyWmxDMjhqdE1jUkpWTTI4bTBIR0F5c0JVZnBueE5PNUNPeW5uM3NLcFowYTJIMkFwMmtwV3Z6NTBGanZaNmpxTHJHb2JKbHNDZEJUSThaVWt4MXJhbDRiN0c2cVIzVCtnbGJrNUs3U1FoZXA1ZEpTRGNRUkZrcEwvQlYzRjVlMm5EVmZ2M2sxV3YxR1lTa29KQ2JmaEtzZ2pZUGwveWZuNEFZYUpIQ0lXTDJWWDMrRzQ3ZmIyQVp3N2F4Yk9LWDFJR1R5QmdPQWtjakpWU2pQV0lXc2ErN2FrRTN2clczZ3U2VVhCN05udHc2VERMaGxIVlVZd0l2QmNFdnVHTXFhekM3ZmpRY2JkOXdvaGdUWktTN1lSL3M4SENFd1pDT3N6L0JkWUFsYTdkOURiTkJBbGJRRGJNbVlScUNqMDZUdUp5YzkvUkhtbG5WVi92VUdKNUdDMW93enpqdFdreVpXaytyT0dLL2Z0WmRLTXEwblo0MmI4Tndjb0daeEUrUjB3c01kWWxtNmVpZW1SVjNEbVZiSDJ5aGh5SXhVNlozVDNiNU0rZldZR08rOU9ZME5RQmt2T0hjVDZ6dG1ZVnI5SzhvNFpiS3ZLSkd4RVBFbVpCcHdtTnhlWGQ2WFh3dTMrRGF4b2d1dGYzY20yWVVsOGQ1YWJZZ2RJR01pdnpFWm9FdVhCVlFTZjBwVTc1bnJvdEhyN01ldVIrcW5Ua29BZWkvYnp3Q0pCY1ZJc1c4K0tJek1PVWpJMXVpL0tJU1J2UDRZR29mcEI0Z0ZnUkNKbWZ6a3hYNWFqK2NSUjZhU081MWRWUzdtTkhJTy8yMDNUZ1hWZ0hWZ0gxb0YxWUIxWUI5YWxyazdKWVhIc2paMGhFSmUxTDBCcHBpVTVWMS9LMDNzM0RIR205ZzdzMHg4MlJMd3pRRExFb0ZiUFE2dWVoK1pjRFEwYWJ2WXpZSytXVXpBRTN3ckJ0eUxVQWpUN2ZOVHF1V2lPUDBDNDJoK3dEN3dTaFdLN0dzVjJOWWdxVlB2dmFOVnpVZTBMUUN0cmY4Qys5SUVvQVdOUUFzWmdGRzQwNTNLdjVxdm5JZFNjZGdqc0EyOUV0cHlOYkRrYndwOURjMjN3YXI1NkhzSzlyUjBDSHhQcFpGTmZaRk5mREtFUElUeDdqbko2cTJwMWVtb1YyRmNhc0EzMytIOXFLUms2WVFpZWdpbDJOdWJFRFJnalhrTzJqZ1RwcURXWFhCTDViMXV4cnpmNG80YVA1L1FpVVd4WG9kaXVPc3JwelVNdCs1V0lpWGFNQ1ZyN0FxN042VlV1TUZIeW5ZeHc1eU9xM0lSZHN3ZmhPZEE2d00rOStLa3RMSEl0NDhhTkl5RWhvVmxPV0xWbVBjNDkrMEdTUUVrZ05tRW1tbXZqUWFjM0YrSGUybktkaDR0R24xazk1NmNsVmttU0dEaHdJR1BIam1YY3VIR2twYVUxK2tSYXRaMnllUXRSaTB1eDlFakZ2bVVIa2lJakdReUVYRGdDUTJRNEFNS3o5NkRUbTF1bjAydE01NkZXNEdOM1NrMU5QUXgveGhsbklNdjE5SFZDSUZ4dWlyK1pUZTZMMDNBZnlBVkFDUXhFcUI0MGg5UDdQY2hHMU5TSmhGOTFDVXBnSUVwWWlIZDN0UkROL3V2QlRHOHhDR2ZMQUI4dE1URXhYSFRSUll3Yk40NFJJMFpnTnRlOTRsM3VpOU1vL3ZwN0pFVkJxNnpDVTFLS2NOY01SYWJrRGtpSzl5YUdYVEdXMkFlbTFuTHpxZzg3UGMwK0gxSFBUSy9Sd0VlTHpXYmp3dlBPNStKeFl4bHowVVdFaElRY1k4Y2FGWXVXVWZqcDF6ZzJiMGU0UFVobUk2NTlXUWlQaXJWUFR6ejVoU2pCUVZqU3VoRStZU3kyb1djZzEzWVROUTJoYWtoR0ErQkJjNnp3YXQ0Kzk3aE83MWhnamdYR083K3ozcC9UalFIaURtdVVHRzRKRlNOSGpoVHZ2UE9PeU1yS0VrTFRSTm5jMzRRUVFxZ09oM0JrN0JHNXI3OG5QQ1ZsWWpCTVRmOEFBQ0FBU1VSQlZQZTFVOFdPQzY4U3FzTWg4dC83WE5oMzdCS2F5eTJFRUtMb1B6T0UwRFJ4dEpUKytLdkkvdGVMb256aG42STJVWjBiaEx2a0plRTRjSTZ3NzQzeCtUajJ4czVvMHNRalEzVVJKU3QwbHhRMi92WTdVNmRPcFVPSERselJkeURmZi9FbFc3WnNRVGFiTVhkT0p1YXVtMUZDZzdIMjdFWmd2MTdJSmhOUk4xK0xKVFhsb09aQUxTdW5ldTJSU2FpdS9kblkwemZneml2QTByTmI3ZG1UcVRlRzBQc3h4eTNFbkxBU1E5aFR5SmJUYThWck5IQ2g1aUZlTm1KRDVpMWJBbUdTZ2hDQ21JejlmUFR0LzBoTFM2TmJ0MjQ4OE1BRExGdTJERTNURUM0WG5wSlNiMmc2OW9LQ2d5ajVmaTRBbm9JaWRsODFHYld5Q3ZmK0F4aGpvdXFSNlhYRUVId0xwcGhabUJNM29vVCtxKzc1TG84L05Db3JLakpVTk5Tc1V4V3orQ1VrUmZ3VmxpcmV0aVVJUUR3ZkdDZk9Nd1hWMkRZMk5sYk03bkc2V05YelRPRndPR3FZWitHblg0dU15eVlLSVlUWWRmbE5ZbDFNbXRqVTQweFJ2V21iT0JsUjdjdXk2dFR3bzVNM3JOajdsNWtGMzRSeHg2UlFPblVNcUplV2Q2cE8zckVYWWtRaVhQWSswMkNWSkhvYmFzNkZ6TTNONWFjOU8vbHE3M2FpbzZJWVAzNDhYMzMxRldWbFhxOWJuYjRKNFhZRDRDNHNScmpjeEQxMk45YTBiczNUZVpCbEdETEl4SXVQbXRteU9JaFY4eUw0MXowMit2VTYvZ05yZXpWdk5VUTU2UGdMTlpYempVR0h2eDh0UTR5QjlGT3NsRmRVOE8yMzMzTDExVmNURlJYRmhTTkhVcmhpRHU2QWc0RkM5VDRGWSs3U3FlVjZTNzI2RzNqNGprQ1cveGpPenVXUnZQcGtFTU1HbXpBY2s0VWZlakxwMERNcm0xUUhNWEVLazZ6aE5VN1lTVEhSVVRINlRFcHh1OTEwV3IyVzRQaHlwaStmd2FCQmc4alB5VDI0azlSeXdFZExZcHpDclRjRU1QZXJNRExYUlBIeDZ5R011OEJNWUlDRVczaWZMbkVmUlAvRFZZbjVGRGUzOXd2bFhLUHQ4REVpWkFOdUlhZ1NHa25LRWFzWlpRcGlhcmN3VkFtK3phdGcxYXBWWk9mbm9RR1hUNWpnNC9SYXZSRHZjQXBXZkFCWnZ5bnMzNmZ5YkhFK0d2QndmQ1EzOWczQnZrSG1HMWNwYnhRV01jb1V4T25HQUJDd3p1UGdaMWM1RXdQQ3VUNG1sS0RUUEh6MFl4WFBWZVNqSUhGUFFDUnVJTjFkeldKM0ZRQ3hzYkdITTcxenp6MzN1SmtlZ09aWW5xMVlCeWMyS1RCQXhlOEc3QnNOU0FaQlJvOXFmbGhpSjNPZXpEOVRRK21ScXVEY0oxT2VyckRTWG8xVENKREFoTXlRTGlhQ3V3bk1LU3FyUDRQYjhuTElWdDJFU1FyL01JZGhrbUNqeDhGQ2QyV05jd1lGQlhIKytlY3pidHc0Um84ZVhUUFRhMDdnWTZWNmpVTG1MVGEwcmg1SzdDb0p3UXFtUkEzVktlSGFvYUJXU3BpN3FLaVZNcUlDMWxjNEtDd1VuQjBReUZWRis5bWlPaHAwUHFQUnlMQmh3eGczYmh4ang0NDkzTDF0RWVEeW4weVUvMnpBbmF0Z1NsSnhGMGtFRHZKUXNkbUFjNlVCSlVpZ0JBczhic2pyNE9DM3BTN0dKQVRTNFd4QitjOG0xbFU2bU9zcTUydG42Y20xVXdsTzZkK1JjUmVmeTdpTEJ1enJkY3B0eWMwR3JEa2djNm9OKzFxdnZ6WWxhVmo3cXBUTk1TSUhDR3lEUEJpU05KeFZFdGxiTkFLMm13Zy9ROE9kSnlHWndiSFp1MSs2eDg3dGxkbFVpY1k1cVROUE0yVXZXZWxLYkxZU2oxWW1FWE9QSGJWQ292QTlNL1oxQm1TcndEcFFCVlhncVpSUXR5aW9kb2tZREpBRWNpQ1VhUnFXelVhV1MxVzhYMTZNQ1lrUVNXazBjTFBYdEF3eEFrT01OMkVJUE0xRDFVb0R4amdOUTVTZ2ZMNFI1M1lab1VrWVZRa2xRaU9nbjRxMW40Y1lEVHk1RHJwMjB1aSsxc29QOHgzTW1hL0IzbVlzOGJURjhlRXRPenpNbWUva2gvbE8wamU2RWFLTm1YUlRTOCt1Qm5wMk5mRGdiWUZrNTZqTStkWEpqNzg2K1dPNUMvZEoxUEg5YWtBOElVNWg4blVCL1BoRkdKbnAwWHo2WmdpWGpyWmdDNVJhcncyM2xJUUVTVXdZYTJIQ1dBdE9sK0QzcFM3bXpQZHFQNzlRODk4MjNPQW9vY0ZmNlc1K21POWt6bndIc2RHS1R4dHU5NU5hY3ZLME9TbW5GVnpzbDIzNFpDUStSbkg1cmRQU3BiR0pSL3BWY2RXbTlVWnJld0owOVhYYiszK1ZFL0MzTldrZFdBZldnWFZnSFZnSDFvRjFZQjFZQjI0aThTbngyTTl6VktaY1dOYXVPZytiVlhNbFg5VUI3T3JxZGdYSFZUZmJ5WjJxelA1S0k2a2gzZ2xtT1ZVR1Frd2FBY2JtbTJUcXlwRmRkV3E0dVkzcDV5VzlRT3BDNUlCMUNLMkNKU3ZUQ0k4dTV0eSttd0JQeTV0MGM0bkFURkdSd3Y0OE04WFp5ekdXajJKdmNSRTVPV3V3SmlYU1BTcUkrSGc3RW81bXY1Wm1kbG9TbWhTRFd4cUEyUzR4Y2tNVjNVYW1zSExMTWlMQ05wRjRRU3JYWGpZQ215Y1F0endBVFlwdDlrdHFWZzFyaEZHNUo0aUMzek5nZXhCQlZ5V3dyR1FJQmFjSHNFdW8yTW8xTHM1YVNOSDdIcVR1T3drL0o1aWc1REJrVWVTZkdwWXBwbkpUTG1LZmdhQi9sUE4wWVJTeFlqZVB6M21WKzM5OGd3N2FkcDdhSFV2UUZlWEkxUXBWVy9LYkZiWkY0ckRCSXlNN1pFU014bm9HWXlqN2c1RTlVN2lpUnpKZHF4ZXdUaDRNQ1NxZS9Rb0dUZkovcHlWS1pUUTNDRm1qMU9YazN3VngyQlFUa2doamNxNko2RmduUXZJKzlDWUtaSDkzV2lBRVNDcUlVb1ZMK1oyQWlQTTV2VU5mK2dmbVlRZzdsMHY0SGExVThXNGo4SDhOQi9aeFVMVXJnT3E1Z1V4Ty9ZT2RTa2RXdXZzaWdudHhsbXM5VTlURjJPY0dRcEIzVzc4SERocmdvRHkzQ2srSnpQN01JSzZvK29VbitueUdrR0Rycm1qMkdvTklpcWpDbWxwQlVQOTJBSXdFa2NNclVkMFNzWVp5RktPR2M3TVpKRWlidWd1UFcwYjFTQmlNb2tXNk1qN0Fhd29EaXd2dHhvUm1QMnZ3d2Y5bk5uOC9aVitWcVJncWF3ZStkM21ISFFoNnQ2ditvTVFPeU5NTEFEcXdEcXdENjhBNnNBNnNBK3ZBT3JBT3JFdURlNnRINUtmTGJxaDJybHpScnNhV3pLZWRiaDg5ODFOOVlwb09yQVByd0Rxd0Rxd0Q2OEE2c0E2c0F6ZGw1K0dQTDMvT1R3bVJvOW9UNE80eXJlRHNxeStNUHZUZFoyekoxS3UzSzZGUFlydlNhTmFHTEpmZWhuVmdIVmdIMW9GMVlCMVlCOWFCZGVCbUVKOWNldVBPM09LUzh1cUU5Z1NZbFZkZVhDZndjKzh2MmdIdGJHSWE3TkRic0E2c0ErdkFPckFPckFQcndEcXdEcXdENjlKZzhSbGJTdmxrMUF4RSszcnJJWkkwYy9lTjgvV2xQSFhnNXBRSXM1dFFvK2Z2QVR3dUlZOGZ6MXpEajJldTRZTFl3aFlIYnJIM2VNUmJuVHpWTTRNaGtTV0hmM3UxN3paR3g0WHo3eTFkeUhlYTJvZUdKZURxcEJ4K0dMeldCL2FRREk4dVpzNlphN2dpTWMvL2dUc0ZWdk9mMHpid2FJOWRCQmpVT3JjTE1xZzhsYmFUVDA3ZFJBZXJ3LytBRlZsd2Mwb20zdzllUi8vUThucnZkMXA0S2JQUFhNdkU1R3dVU2ZoSEcrNFJYTVV6YVR2b0VWemw4N3NRRXZ0eVkxbTFyUnQ1SldHVVZ0b0lDNm9nTnF5WU05SzJFQi9sZFdBV1dlTytibnM0TDdhQXh6ZDFaVWRsUU5zRU5za2F0M2JPNUtia0xCVDVpSFkwSVRIL3IxUDU0TWZSN00ySnEzUC9uc243dU9YaUh4alNleE9TSk9nZFVzbU13ZWw4c0xzRDAzY2w0aFp5MndIdUYxck9NNzB5U0FuMGZUVlZVVmt3RDc1M0MrazdVazk0akMxN08zTG5XN2R6WnArTlBEUHBRNEtzZGd5U1lFcm4vWXlLS2VTeHphbXNMdzFxM1RZY29LZzgybU1YL3htMHNRYnMvdndZcm5ubTBYckJIaTFMTnZUbSttY2ZwckRzeUVJem5XM1ZmRGxvQTQ5MDMwMkFvcllPOE9DSUVtWVBTZWZxcEJ6a1l4eE1wZDNLM1cvZlNuNUoyRWtkZTE5dUxQZTlNd1dYNTRnQnlwTGdtbzRIbUQwa3ZkYncxbXpBSVFZUHovWGF5WWNETjVOUVJ3aDVhOFpseDIydjlaR051MVA0OU9jTGF2eWVZSFh3d1NtYmViNzNUa0lNbnVadHd5TmlpdmhYand3aXplNDZ0OGtwUFpzK0YweWc2MGdIc3F4UjRhb20yQjFQWmFXZ0tFZGk3MjQzRzdZWFVsWng0aFhudjVnL2tpdUdMU0lzdUtMRzM4Ykc1M0ZtUkRIUGJPM01MM21SOVErWlIzOEpHOWQ1UE5DenRtVC91ZDQ3dWIzTGZnSU14MzkvWFViUkM1aENJcEdRaURER1VDWnlDUTgzWUFtekU1eFF3ZWhoeWR3eXZoKzJybnRKam9vaE44Zk5nTFJ3U3NxZHVOeSt4M1o3RE1TRWxkQXJaVS90UHNTZ2NYNXNJZDJDcWxoZEVrSzFxdFRXSDk1YU1udlhOL1hXOE5qNFBCN3N2cWZldlp1bi95K0R2TkpxSEU0VnlQUzJHN21JOEJBTHFjbWhaSGV2b0d1WEE1eVIwb2Q1OGp3ZUdOcVRzc3dRU3NwY2JNbW91YjdTd3ZUKy9HUEV3aE5hM3FDSVVsN2Uzb21aV2JFblo5SnhGaWRQcGUza3pNajZML0xrOGhqWWx4ZkQyQkZ4L0xHcWdKSXk3OXNOTlUxUVdHS25zTVRPOG5UdnRyWUFJOE1HOTZkb2NEWGhIVXE0NlM0ck8zWjVtUFdGUmw3aEVZKy9LN3QrNC9QQkJwV24weklZSFZmSXZ6WjNJYXZhVWorbkpRRlhKZVh3dzVEMEJzRUNGSlo2UThuc0JWbUhZWTlZbHUrMmxkVnVmbHlReVN0UEY3TnNqcG5jM1JaU1VnSzQvbDRQdzg4OG9xWFNTaHR1dGY2dTV2VHdVbVlQVHVlR2p0azFva2V0d0VaWkk5Yml4Q0kzUE41SngzbmgyVCt2NklMQlVETW9hRUl3WjBFMkw3KzJoLys4NXlDR3pneTRLSStKa3lJd0dSVWtTU0RSc0x6YUtHdllqQ29LOVFCMmFUS3Y3VWhtL01wK2JDbTNOYXlTRWVLN0NMTEJJQisrQ1I5K200SEhjOFFwVFpyUUJmbmdIdys5T0d6anBuTHVmM1FicFZ1UzZOcGI0cmJIWlhxbHloZ2FrR3hzTExOeCtiTCtUTXRJcWpVZHJUTU9ieTBQWk1LS3ZyeXlJeG1IVnI5d2JUSjRTSTdMQWVDQ29mRWt4bHFSOElVQzZOczlsSSsrM1VXdnJxRTFyRUxUQkI5K3RvOWZaeXAwaWVySW8xTUcxZXZjRGszbTVlMmR1R3BsMytOMk9JNUxvZ3FKai9ja01uYkpBRllXaDlicnhFUDdidUR1Rzd1emNIa3VXYmwyVXBKc0JGcDkyK0NHN2FYRVJscll1S09rMXRmQ2RVc0padDM2VXI3OG9KS2l2TzlPZU02L2lrTVp1MlFBbit4TlFCVlM0ek90VEx1RkcxZjE0ckZOWFNqekhOK0JqRDF6S1c5K3RnV25TOFBqMFRBYVpLcnNubU82aWhBZmJVVlJhajk5UWJFVGkwVmgzZGE5ZEk5NXRjNXpWWGdVbnRpY3lvMnJlcEZwdHpSOWF2bGRkaXdYTFRubHVKbE54OWhjTGpscnlaR3dzdC83OHE0UlErSjhuTmErQTFWNFBCcGh3U1pNUm9Yb0NBdTJBQU9weVVFa3hRV1FrMi9uMnZQbUV4cFVXZXQ1RnVhSGM5R1NVL2cySzZaQkxxM0J1WFNoMDhqZDY3cHpXM3JQT2d0dmQxdytrODRKM3Jic2Nuc2RUc2ErQ2grblZWRHNEVnRsbFc0OEhvM2lNaGV5TEpGZjVHRDl0aEw2ZHRuQkRSZk1xM0hzRXBlUis5WjNPKzc1bTZXM3REQS9uREZMQnZDL3pOZ2FkOWhtdGZQNmJkT0lqenp5RnRLOVdaVzFoakJORTF4K1FSSVdzNHpGckdBMktYU09QOEFyVTk3RnFQZzJoVGtIb3Jsd3lTbjhuSHZ5VHhvMXFqOWM2VEh3MUpZdVhQZFhiL1pVK1hyR2hLZ0N2bmowV1U3cHRyM1dmY05DanF3cU8zdEJKdFhWS21VVkxnYWtydWJqaDEvd01lVmNoNW5KYTlKNGNHTlh5dHlOcTFuVXEvTndJc2x4V0ppUkZZTWtRYi9RaXNQckkxdk1Mc1lNWGtIbnhBUHN6WW1qdUNMNDhENTJ4NUhZcXFxQ3RFNTdlT3k2ejdqKy9COHhIZXoyQ2VCL21iSGN2cTRIR1pXQkoxa25ibURub2Q1NXRDYno1czZPek11SjR0KzlkdEE3cFBMZytRUWpUbG5EaUZQV3NEOC9obFZidXBGZjZpM2lSUVNYRXh0ZXdtazl0eEFUN2pNSGxMM1ZWaDdmMUlVMUpTRnR1MnE1dlRLQXExYjI1ZHFrQTl5ZXVoL3JVVmxTVW5RZVNkSEhMN2lybXNRbit4SjRKeU1KcDliMFZlUm1xVXVyUXVMVGZRbU1YZGFmcFlYMUwvTnNyUWhrd3NxK3ZMWWp1VmxnbXczNGtHUlZXNWkwSm8ySE5uYWw5RGpPNWxCekdMK2k0Zmw3bXdJK0pEOGNpR1pNSGVFa3ZUU1lTNWIxNDczZEhWRGJ3L3VsRDBueHdZUmh6b0ZvbnVpWlFiREJ3K3M3ay9scWZ4eUNscE1XWDd0MGNVRVlGeTN0VDVCQkpkZGhidW5UdDg1aXJWVWVBMVdlMWxrblZwL2pvVXM3RTU4NDBQT0dtN1pYOU9qWktXVDB4ZHB4SzNKK0pKdlN1bGpxZEZwVnhjVmhtUS9lYTh5ZThRM0dCeDlEU3VuODkyakQycXFWT0NlTXcvUG1xMUJkM1g2QnRhTlRBRlhGODlsSE9DOGJqYnBnZnNzc3d0RGlHcTZGU2VUbDRYN2dMbHkzM1l6WXYrL3ZFNWEwNVV0eFhuRXhubmZlQkllanZXajRCRXQ1dWQxNFBub1A1K1VYb1MzKy9lK1RlSWdEMmJqdW5vcnJ6bHNSMlZuK0ROd3d4NlQ5dVFqblpSZmhlZi8vd09YMFAyQWhhSGkyNFhMaW1UNE41eFZqMFpZdCtmdmswaUp6UDY3YmJzWjkzNTJJM0J6L0FKWm9mTWxCWGZncnprdEg0L25rQTNDNzJ6YXcxVmpTTkJNYkhRNDhiNytPYzhJbGFLdFd0aWxnbjF3Nm5tTFhEbWl5MXkyTHZidHgzWElqcDR4SjVwSkhCaElTRTlEaWdMY2ZEemhTbERlTERhNzVjUy9iZjkvTFV3L0E3VGVCMGRoNndDMVdBS2lzZ251ZmdBRWo0TThWYmFYejBBTDlnMDNiNE95eGNQM3RrRmZneDJHcG9mTDVOOUJ0TUV6N0NGUzF0WUNGYU5FeVIxazUzUDRJbkhvZXJGalRPcGxXcTBqNlJqampRcmp6c2VhL2hqWlR0Und6RXU2K2hXWXZwUmxPdnV2UU5KSVlEMjgvQjJQUHAwWHFocTJtWVVXQmU2ZkExaVV3N2dKYXJFaHFhSTAyZlBvcE1QMWw2SnZXeXFtbGFPWkFIQm9DTHo0Ty83d2E1RmF5clJZYjBicjJDbmpsU1lpT3BGWEZCN2dDcTlMa1RpbkZ5dTNQZHFiZjRGRFdBYlI0L1c5SjNjRDdSYVFGOWpUTmVVd21EUCtjVE9GMUUzbkNaSUtpMXRKcHo3cUJQWnJTSkVtZWZNWVFqQTg5anRRaHFjMFZBSHlBWFo1QUp4QjRzZ2VUSXFNdzNQOHd5b2p6YUt1RGNVM2p0Q1FKWmNKVkdHKzlBMnhCdEdVeDBNaEFMUGRJdy9Eb0U4ZzllK0VQY3ZJYURnekVlTnRkS0ZmOEEyUUZmeEZmWUsyZWFlR29DekRjK3lCU1ZEVCtKc2QwSG81ZnBwVVNPbUI4NUhIa004N0VYNlYrSm0wd1lMaHhFb2FKazhCc3daL2xoRTVMUHZVMGpBOC9qcFNjUW51UU9qVXNoWVZqdVBkQmxBdkcwRjRtdU5TaTRZTk82Ykx4R0c2L0J5azRtUFltUHNEQlhidmFpMis2SlV6dTB3OWQyb240TkU2eE9mbHJZRUs3b1N2UVlJbHJ1L1JZYnZjV0x3QzB1S1M3WUpZRDRwV1FWcWw0dEppNGdSL3NzTnJkakwybHRtVENYOWtoVjIzbTdtR3J1eUZ4eElSZExkRWZiaUpSVlFsSmtwSHIrVGkraDJqY29pUFc3LzZvMDRUYkpMRGJMYU1aTzZBaXFEWU1SekltRWVwOEc0WGp2NExHcVk3RU91MER5SzMvRzF0YUhkaWpXWEZhaGxJdHVpS1pJd2kwUmVFczMwNlY3VTRNc2d0ajZYUWszQ2hTaFUrRzY5blRBN2swQUNuWGd5cEFxV2YyMjNxRGFiSVZSOGk5T01NZVJqWkZFaEovQVlvb3dpMUNrTVBPUncwNEM2ZDFOUGJFZVhpNnJNRFI0UmVLdElzUkxna3h3NDRhT2hVUkVJWmo2bHRvWGZyV2UxeXMxVFRza1JKd2xhekVJRmVnQmd6SFhaV0pJZUl5akpZb2hCQzRYQzQwVFVOU2pEZ2NMZ29MWmN3aDkyRmxLdElsUmJpUU1kb3IwYkl6Y1BVZWlpTW9tc0NOaTVCVmQ5c0Rkc3VwZU9SRVBBR25RdkF3M0I0Tmc5R0NPU0FHcDlPSnFxcG9tb2FtYVpqTlpveEdJNXFtRVJFUjRlM2N4Q1REN3pNeGJGeUVzdm9YcE9vamovQzJPUTBMSWFPcURvenVKY2p5RmlyTi9aQ3MzZkFJUVhWMU5RYURBVW1Ta0NRSms4bUVwbWtZRFFvSnEyZmh5WWhCT2VWY05FM0YrdFhUbUVyemFrbVEyMWdibGlRTmk1U0pRWEhqa2J1aFdEdGhOQnF4MmJ3UFdickt0eUM1ZG1PeFdEQVl2UHFvMkxJYVRWVlJsbjZQYzhIWHVKeHVQQjI2VWRYbkhOeHhuWnFoeE5NTW9rbmhxT0dUTUZ1Q2tCVURxcXFpcWlxdTZreU1GaFdSdFFKbFp4VlNZRGltdU00NCtvOUNUVXJEWEY2SWE4R1hTTW05VUdJNzRTbkl4TFZySFlFYi8yaTd3RUtBUXd2Q2JEWlJXcGhPWUxpMy82MG9DaVpiVDl3YjV5UG4yVEVzL0ErRzRseVFKS1FySDhNKzhIejRjZ1lXb2NJRkV6RXMraCttcFROeFcwTVE5YlRzVmdHV0pEQWFyWGp5WGlQUU5nNlBNeDVMWUx5M2pja0pPUHRNUUt5ZVIzVktmMnhGYzcyRHlSbHJNVlZYb05qTE1kM3hKcDZRS0twamtwRXkxbUxNcS84QVlMUDNoelVOWE1iK1dOUjFnRUFJR1UwT1J4SGVGM2Q2UERMMmhGa0lZOGZEM3RoVldRNG1DNG9zSTI5WmpySnhDYXJiamRTeEsxcEtQOFMrTFlqQkYrTmF2Umh6Z0lXZ0Y2NnNXN3ZKU3E3MFZrRmNpMmxZbUZKeFd5N0FJUzVCMFE1Z1VBOUEwTG1ZQys1QmxsWGN4c0VZSzV3NEs3ZWhkVXBEMHpRVWF5Q3F4NDBrRzlEU0JpTjZEVUdXWmR4dXR6ZFV4WGJFV1pLUGRjQVF4TklmR2pTcjNkQmNiZFFqSmVJMkQ2WmFPUk5MeUVBVTJZYW1hZGlkZVNoYVB2YUFCekRuemNYNDNTWmNqbnRSN3A2T0VBS2owWWpUNlVRcXprRmU5enZ1MUZOUU9uVEQ3YWpHTk84alRPa0xxVGp2QnN6SmFmRFRlOWdXL2JmMXZiUmRPUU1pcCtEeVdBZ002WVdtYVFoTlExRVVsSUI0WkRrUlExQi9QS1pSZU1hc1J6VUZZS29xUlloRVBCNlBOOE1xenNQODlRdHd3ek1JV1NidzBZc3dTdDZ4b0xBUDdxKzNrMm9SWUl1MmtYSkhHZWFJZ1FjMUxuQlZaV0EwS0JndDhRZ0N2Tm9NajBZTFBSZWpMQ09FQUNGUVZSVkprdEFPN01iZ2RpQisvUVRWYUVZeHlLQnF0VHVmMWdhdXRrekFHSkRzdlhoUEFlNktEVmpJUnBRcE9DcFMwR0s2UUhVRlJvOFRKVDRGajJKRVVSU0VFQmdNQmx3dUY0RnJ2QzhlTXU3ZFRGTk9yMjVTWUk4SDFNQlJpTEIvb01wUm9LcG9GZXNJcW5nZXc5b0RNTnNPTG5DSFJLRU5Ib3M3S2dtUHBxRmFndkFBNXZpT0NDRVFHNWRpMnJpNFdaeG9rd0pyeGhRUUx0elZCY2lCa1NpS2dsYTFCOE9NL1ZSWDlNVmczb3ZKVllpeHJBRG1mb2daRUpLRUk3NHJybEhYbzhZa2d0dEowT2VQSVIwMXppVWtDV2RrRWdZMERBV1pqZXVWTmlXd1Nld0dyUUp6UU9qaHhGOWVsbzFIbklQN290dW9ObG5Rakw2amo1SVFlUHFlQzExUDlhYVdsZVdvY1oxUXJVRUlRSldOVk4zd0xNNS9QbytxR0JvOUg3UkpFdyszY1JCVkFUZWlCQS9HNjRNRTdvMUxDUTBNd0JVV2o2ZTZFalVqbmRDUEh6eXNRZFVhaEx0ekg3U2dLTlIrdzlIT0dPUDEwcEtFY1ZjNkNnSzU5NW1vMlJsVTVtWVIvdjQ5S01VTmVDNnF1UklQSWFCU0hvVEJtb0txYWtqbHhTamgwZEM1RDY2UWNOdzVlekYyN0laSTZJeDc2ekpNeTJaNTgyZDdCY3FtcGQ2RHJKaU5aK1pydUh1Zmc2dm42Ymhpa3JCMTc0KzZaek5xVVQ0Qm1odEg2a0FDVjg1cHVUYnNrTktRakZFb251MG9hZzZhRklacTZvVmRHWVJzSFlwSGlrUXVMY0JUVlk0VUdvbGFuSWUwOFU4TVBid21DNkNwbmpydm1pRi9MNGJmUHNINjJ5ZFU5QjJKOC80UE1GU1dZanRqRkU2bkU1ZkxDUzBKYkZLMzRKSFRjRWk5VUcyVE1BUjBRVmo2WUsrc3hpeFVEUG1aV042N0I3Y0tucWUvUjhuZGkyM2FiYmk2RHNBVGswSkFjVGJHTGN2ckY4OTNyc2FqdWhFSHU0OU9weFBaYkQzcHBPUGtOR3c4QTgzWUJjMXlLcEx0Ykp3ZUQ3SXFzQmdVek9WRm1KNitBc2xSaWV1Wm4vR1VseURDRTVBRGc3RHNYSXRsNTlvR25jdFlYWUw3M2hGb0k2NUJWV1FzQXBUL1BvZlVVbUZKMWN4Z0RNTVFNZ3k3M0FlRHB3eVRTOENCUFpoc1FTaFBUVUNwTE1ZVEVvUGg2eGRRVXdmaHVlQUdLa2JjZ1BYSDZjaWF1OEZoSWFCd0grTHJaK0hyeG1WWURRTFdoQmxINEQvd2lBamtnSjVZUWdjamIvOEd4MCtMUUFOalFBakd4VjhqdWIzUEVCdks4akNrLzRxbm9oZ3g1aVpNMXp5TWZmUS9rYllzSi9ETnlRMis2S2FjY0ZGUFlBWEpVNHdsYmlLU1dvejI3a2hNdjI3R2hQZmhydG9xaHZZZVo4QmpYMlBNMjRjbklnN25yMTloY1ZYaURnakRWRjFDYThrSkxjd2pnbkdhaHlOYkVwQTMzb1RoL2xFWWZ0MTg1QUJTYlRjSWhNR0VZOE5TVEIyN1lTOHZ4OUtsTDRiZi9vdmlyR3JWa1k0VGFsZ1c1UVM0ZmtKYTZUcWNDNTl3SHdsTW01ZGd1UGxGVkZYRkdoR0Y5TnVuV0txS1czdGs1OFFhbGxXUVpsYkR0L1dEUFh3bk5SWHgwL3NJMVlPV25ZRmw0WDlwQzNKOERSZG84R1UxNUdrbmRYRHp2STlSRjN5SjJlT2tyY3owcWh0NHJidmVKbnc4VVR4dDYrMFBOWUhkZUVIWHRMM245NXNlZUo4YXpQZjJrelpoWGRxZytQaVNyZDI3bjFUL091V1hYekFsSlRGMytYNHV2T2ZubXI1djdnMUVobHJJZitrbGlqLzVwRVVCZTJ6YkpqVmJ4Y01mUkFmV2dYVmdIVmdIMW9IYks3QS92UHBTMTdBT3JBUHJ3RHB3V3hhZmlrZkVQLzk1VWdkUmd1cjMzSC9BYWFjaEtTMzhOUGw5OTlWZEFCQ2ljWkgwNTJYN0dYMXYzUVdBMWhCSjhuMDAxa2ZEQzFZMTdzVzY2M1lVMXZyNzR2UURoTmhNYmNLa2ZjdkZwNzhyMmwyalhURkZML0hvd0Rwd094S2ZCbTEzZWhybHRPWXUzOCtsRC8xUzQvZXMyZGNTMFVwaHlXbzIxQjJXTEtiR0pRVW1RKzBHWXpZcGpUNTJzMlJhRmIvODBuQVRNWm13blhOT3ZiYlZLaXZ4NU9lM0hlRHN1KzVxK0FFaUl1aXlwSDd2aHE5YXV2U2t6cUU3TFIxWUIyNFpZS0ZyV0FmV2dYVmdIVmdIMW9GMVlGM3FLQUN3U3N3QUxtdG5qRE01VmJwY2I4TTZzQTZzQSt2QU9yQU9yQVByd0Rxd0R0dzQ4UmxxZWJVRFhUdWEyaGZnUGhkZDc2MEwrSlJBd29mYTJoZnc0a3JDNjlUd3IxOS9ZZjA5YTFlN0F2WWtkcTU3OGRuQkYxNVVqWGNBb2QxOERqTHBYbG9IMW9GMVlCMVlCMjd6cWVVNWwxeGhIM25xQUd0N0F2UWtkcll2Ky9uSTY2aDhDdkdMS2tUV1VCc0o3U3kxekI0V0pDWFdxdUUxVlJRWHV0c1g4RDRYeFhXYTlMMlo3QUI2dDdObXUwUDMwanF3RHF3RDY4QTZzQTZzQSt2QU9yQU9yRXVEeGFjL25ETnIxb0hJYzg2SjIzTC8vWFQ3OTc4cFhiMmFtTkdqMmZuY2MwU05HSUVwTXBKVmwxMUcrYnAxZmdONDhUR012aWF0cWhUOCtpdlZlL2FROGVLTHhJd2VqWDNmUGtxV0wyZmI0NCtqdWQzdHF3MUxCZ043M242YlFULzhnS2V5a3NKRmk5ajl4aHQwZitZWjRpKy9uTHc1YzlvWDhJSHZ2dzlNdWZOT2lwY3RvK3RqajdIL2d3OEEwSnhPWXNlTm8zclBIalNYcS8wQWh3NFk0Q3hac1lLdzAwK25lT2xTZ252MXdsbFFnRFU1R1VkdUxzTGpRVFlhMnc5d2NKOCtMazlGQmJrLy9FRFdGMStRUEhVcTBhTkdzZitERDlqMnlDTjB2dmRldjE5UDNBZTQ2TTgvTFNuMzNzdSs2ZE5KbWpTSndvVUxpVGpuSE1yWHJ5Zmk3TE54RmhTMEw1TzJKaWQ3ZGp6NUpEMWZmcG15VmF2d2xKZXpmdUpFa2laTndwcWNUTTYzM3lLYi9IdE9oRS9WTXUvNzd3TlZ1NTJ5dFdzcFc3ZU93b1VMTVlTR1VyUm9FU1VyVjZJRUJMUXZEY2RmY1VWbFFGSVNRYjE3RXpwd0lKM3V1QU5KbG9rY05veE9VNmNTMktXTDMydllCN2d5SThPWWN2LzlyQmsvbnFDME5KVEFRUHArK0NFWkw3MUUrYnAxeEY5eFJmdlNjTVJaWnpreVhuZ0JSM1kyMjU5NGdvaGh3OGlmTzVlQ0JRdkllUGxsRENFaGZxOWhuemNSM05LdjMwUEZpeFlGeGsrWWdLdW9DRTlwS2JuZmZVZk1tREhJSmhPVjI3YmhPSEFBVjE2ZTN3RCtGNTZxMjZRM2J6WkpCZ09Tb2hBOWFoVDVjK2NpbTgzRWpoMkxKTXM0c3JPOXkyYTFGNU9PR1R1MjJoQVNRdjc4K1VRTUhZb2hJSURZU3k0aDk3dnZjQlVXa3ZDUGZ5QzFwMHpMWUxOcG5lKzdqN0JCZzRnWU5neExZaUtSdzRiUjRjWWJDZTdUaHc0MzNOQyttNHRsa0FBQUlBQkpSRUZVT2c5Rml4Wlp3b2NNSWZYaGh5bGF2QmpONDJIclF3OFJNbUFBM1o5NWh2SjE2OUNjenZZRFhMNTVzeWxuNWt5TVlXRmt2UEFDSFcrK21mQ3p6aUx6azA4d3g4U3c3ZkhIL1Q2WDlzbTBFcSsrdW5MMzY2OEhPYkt5aUwza0Vzd3hNWFM0NlNiU3I3b0sxVzRuYlBCZzdGbFo3VWZEN29vS09mV1JSOGlaTll2STRjTXArTzAzaWhZdnB1UGt5UnlZTVlPT2t5WWhEaTREMWk2QVpWVUZXVVkyR0VEVGtJUkFraVJra3dsTFhKeC92RzIzSVNhdGhJWnFPNTk1aHBpTExxSncwU0lpUjQ3RUZCSEJtdkhqaVI0OW12MmZmTkx5cjJsc1RnMW4vKzkvdGs2MzNVYkhTWlBJblRVTFoxNGVtWjk4UXR6bGw1TThlVExGUzVhMHIxemExcTJiTy9iU1MvR1VsOVBsb1lmSW16MmI4dlhyU2JycEpsd0ZCWFI3NmltL04yc2Y0TWhodyt3bFM1ZXk4OWxuaVRqN2JHU2prUzRQUGtoWmVqcmJIbitja1A3OWtjM205dE9HUFpXVjhyN3AwM0ZrWmxLMGVER2xxMWRqNmRDQnN2WHJLVXRQSi9Qeno5dVgwOHI4Ylk3UlUxNU8xQVVYVUx4a0NhcmRUdTczMzlQNWdRZW96c2pnd1AvK3g3YWhobzA3ZTFEaU40VC9QUTZ3T0t1bkVLczJJMVNWL0huemlCazltdnhmZmlGMzlteUVFRmdURTBrZm10MTdaNWtmcWZSNHdPYkJmVjIyVmJtVUxGdUdKVGFXamxPbVlJcU1aUDJrU1NnQkFmUjY4MDFFeHRYdHgybFYvN0xVMG5IU0pLcDM3eVord2dTSy8vaUQ2QXN2Skdic1dEcmZmeitlaWdxcytlMG9MSm02cDdnMzNYRUhwM3p6RGVXYk51R3BxdnAvOXM0N1BJcXFhK0MvMmI3cGxUUklDS0VFUXUvU1JNQ0dJcUNJZ2cwYnFOaXdvTDc2MlgzMXRXTEJpbGhRTElCaXBhaDBLYUVIQ0lSQUVranZiYlBaT3ZQOXNiUUZBbW1iN0M1em5pZFBrdDJaTy9PYmM4Njk1NTU3NTE1U1pzd2dmdVpNQXZ2MElYL1JJbXJiZUZHYXR2cnIzM3lEWTJLb09YaVFpcTFiS1Y2NUVrMUlDS1dyVjFPeGZUdEt2UjZmTGhaUWU0bUdmYWRlYVJTTlJ2eTdkeWVnWjAvaVpzekFiaklSTm1ZTXNYZmRoYjVkTzR3UlhwU210UjA2cXVyODBrdnNtamFONElzdVFoTVNRdTh2ditUSUo1OWdPbktFbUp0dThpNGY5cmw4cU9udzY2L1Q2ZW1uT2ZMSko0U09IRW5wNnRVRTlPcEZ5YnAxYUVKRHZjdUh6VnYzYXZ6OC9JaWNNQUZFa1NNZmYweFZTZ3JkM25tSHlLdXY1dkJiYnlGYzRVV3h0R25kZG0zd2tDR1ViZHhJOExCaFZPM2VqU1k4bk5yTVRMUXhNUWdxRmRveUwwclQrazBiWDVPL2FCRWhRNGFRL3QvLzB1N09PeDBKQVoyT2dsOSt3U2N1RGxPWTJudE1HcnRJMUhYWHNmWGFhL0h2MnBXd1N5N0JOeUdCUGZmZmoyaXgwT085OStEQVF1L1JzQ0FJaEkwZWpTNDZtb1RISDZkbytYTDBzYkVFRHhyazZBdDdlTGJqZ2hTbkpQT09vQzZMRVNUdldqRk5FcGIwclVpN2NGZE1jMDRBYVAxMG5qNnljS2FHSlYyZHdDKzBIZFo3aDEra1YvSDJOUlQwcG5CN0hjMlNpMFNuVVRHcWJ4dzlPb1FUSGVwSGRKaGpzWkM4RWdONXBRYjJaQlN6YXNjUlRCWmJ5NXAwczlhR0FsdytvQVBUeC9YbThnSHgrT2djQVV1RnNZTEZleFl6dWVka0F2UUJKNDZ2TVZsWnVUV1RUMy9ieFlxdEdTN0xCcnNFdUcvblNGNi9aeVNqKzdiSEx0cDViZlZycEJha011ZVNWNmt3bENFYXFubHM4UU84TVB3WlZGb3RIK3liUjVBNm1Ga1h6MkxpOE03OHN5T0wyUit2WWNmQkF0Y0dIczJoMVZuWEQyRHJ4N2V4cHVoem5sL3hQSlZGQlV6MEgwWWJxNTdVbkYxWVRMV1UxVmJSUHF3OVZyT0o4cElDK3RhMlkxZjZKaXFLOHZsbXh6ZEVSdGV3OWVQYmVIalNnR2F2UTVzTldLTlc4dm5zc2J3OWN6UzFWaU8zRGJnTmxkSENYNm5MMkNVZHdSQXNNR0xBT0xUUm9TUW05T0tHQVZNUUl2ellRemFyRkh0NTlzb1hLYzQ5UW1jeGdoZi9lUkdGUXVDZCswY3o3L0d4YU5SSzl6SnBRWUNQSDdtY25rbFd4bjAxam02Qm5SbW5HMHh5Mlc2bVgvWXdpSFk2UnNYeDlmWjNlZjNmUnhrZWZTV3JSQTMvbHZ6RmxCNFA4ZmFWYjZOVUtKbGZNSjhWcVgvUVg5T0ZvN21IV0YrNGhUdkdPcktrZDczeFo3UDRkYk1BUHp4cEFMZGYyWk1pUXhFTHJ2cWNHVXZ1SkhIcWsveW9IMGRGYlFtVHZ1dUhBaFUzZFozSnpQQ25xTkthOEZQcGlReElvTGd3aTVHZnQrWFMrSnY0djlGdk1LWG5GSlFvU0V0ZXo3ZXBYek91NnpqdUdOdVRQUm5GekZtOHRmV0IrM2FPWk1iMTdaajJ3elNHeHd5bU4vRjA3enlRVUw4dzB0TFMySis1bDN1Ni9JZE13MkYybDI4bUxxd3IvUXNTK2R0bkRmNEg5eE5RYTZUU3Q1RHZqRzhSVzl1Wkt3WmN3NjZxWFh5Wi9TVnQxZUZJdFdZT0dnN3kxbjJqV0x2N0tEdlRtelpIek1rNW9xSUhQNUt2OFF0b2lDbC84L1E0cktwQ0p2YWN5TngvM3VLK2NVOXdTY0lvQkVFZytaTVgyTEhoZHlxcEpjSVd4aThsaXpDWXFrank2VUVuZFdmRU5yNTBTcS9pb3RSS0xrbVl4dko1SzZncUxHVHE5VE80THVrNmVyWHJTMjdLTHVZZStwb3VJWjBaMUtVakMxYnViUkJnbE1WUW5aKy81ZTFtMGZEbEF6b3dxbThjRU1mQlBja0VCSVNpVkRuYVc1dk5Sb1NsaEhGaEJuUjk3aVNrZlVjUzEzU210ckNZa3YxSG1CTy9rSUthUE5TUkdzWWtEdUpHVlRBSnRncWlBM3hPZEZXMzVHL2xoNnh2a1d3aWNTRnhkSTdRY2xuL2VGWnN6V3dkazU0K3JqZnprK2Z6YjhaNnJvMitsTStuZm8ybElwZmRTMzhoYTgweUJneTM0cU1WMFBwbVVlblRsZ1VCUDVCTkJqMTFpWXhaM3gyeCt4aENSaVJ3b0hnWHlYK21VM3MwbDhNcmYyR2RyNG11bDkvTTVCNlRHZDkxUEZsN3RuTTRkejhCZ1dGTUg5ZTdkWUIxR2hXWEQ0am4wNjEvOG1EOHpieDQ4SDB1S2IrU1pjOC9RM3lreUpBeDFmaDEwS0p1MDU3SzlGLzVPSDgxNmZuN21CaC9HMlRrazVtWVFVcjRHbXAyL01yU3lkdDU5NUYrUlBqN1VwR1Z4Zm9mLzJiVm9yKzRhT1JRZ3E2NWhHTFJpajNUd0diemZwNForU0k2amFyUllXaWoyK0ZSZmVQdzBhbDVZTWdEMUZTV015NXBBb2FTRWdiZS9nRGgrU3V4RmxSUmZhQ1lxaTFINEVnNk04SW44TjNJeGR3eGREYUJ1UUpqUTY3bDgzRi9NNnZkaTZTdDNVaU4xVXBSdFpGcXM0V3lvanhLaTBvWU1HMDZYZHYxWmxuZVB5eE8rNGtiZXR5QXIwNTl6STFhV01NOU9vUmpzVmw0OUtlSGFhc05aWGFmRnptK2EyYlZwSGN3K1lXeDY2Y1gwYWtWQlB0M3BXaDdNcDFHak1kb05ETHNzWWRSNXorRUx1TTNra1F6aFZWK3RCOTdKV0pOSHFJQUV4NzRIOVhsRllURUpRTHcyTkRIc0IwdHdtd1JFVVdSN3ZIaC9MbjVjTXNDUjRmNjhYdnE3M1FONzBSQmFTNS9wdi9KVloydkFpQmd4STBJMWRVazN2RXBOa3N0dnNGUkJCUm1rZlhMMi9nTXVJdklUZ2tJd1JQSjJKbEtWTkpvZ2hQMjBQM3F1ekZXRnFIVytSRVNIb1d2cisrSmEzMjcrMXZpYmVGc3k5ekxqWXFiaVE1dC9OS01qVGJwNkRBL0xrKzhuSEd4VnpBbWZqU2RRanM1ZmE5V3EvRU5EQ2MwcWdPaUtPSGZ0alBhTGhPeGxXWGlHNkFsZ09Va1hqSU9ZL0YrMUxaVUJJV1NrTWoyQkFTSG96d3RXVGhyNkN6U2FnOGptZTBNYURlQW1IQy8xcW1sZlRXK0xNaFlRWkdwaUhzVCs1K1NaSkFRUlJHbFVubmk1dk1PSE1CcXNqTG91aWxrN0Z4SGdES0FBUHNlVktVL2tMb3ZnSzYzU0toVUtrUlI1UFJOY2d1ckM3bXJ5eTFZQkRzS1JkUEMvMGFmblZkaXdHcTM4a1A2VC9UeFQrTDF0YStmbGxseEFCei9XKy9ueDlDYmJzSW1xRG5ZWmpSN0FwNUFaVmxINTRHQmRMNG9Ca0VRRUVVUmhVS0JLSXBPWmIyNjdsV0tLdk41ZWV0YjJFUWJ1Y1dHVmdBdU5hQVVsRHd3WUNhSlFRazhOZklwVHM5eDIrME9qZmo1K2VIYnBnMEdvNG1sQjR4VTVSeWxwTVNYUDJ6dlVTTkdJK3FpOFBmM1I2bFVub0ErVlI0ZjhUaWZIZnlXU044SVZBb1ZlYVd0QUx3bm94aUZRc0cxQTI3Z3AzMC84Mi8ydnlkTThiaFpIcjl4VVJUSkt6ZXc1SWdTUDJwb0h3enRBeXdZTXlyNVJmeUFjdVZGV0N3V3ArTlBsQ1dKQktvRHVDdnlXbDZiOENZQWV6T0xXOTZIViswNGd0RmtaZFhoRmVSUWhqRjlNeWFyaWV1N1gwOTViU20rU24rMjUyNmlhMFJQS2czbHZMWHJZVG9GZjh6UlEzc0o4TmM2WnVXR3hXQ3BNSEhRc0oxcFVRUHd3UmVOb0VXdFVKK29BeGJzWG9DK1ZrRzNzSGdxVFpXbzhHSFZqaU10RDJ5eTJGaXhOWk9PQ1hGYzIrOEdRa3NrSXVKNlVsVmJ3ZTIvWE02VDdlL212ZUpYQ05ndDBLMGltcXJhL1d5dHZJY3NleVJTcFFySnJzWldvaVF1WUJmbS9BMWsvdkVONVYxTVJQajNaSnpQSkhxTnVwSzRrQVQ2UmZmanJkOWU1Qk94aE05ajU3TmpiMEdUa24xT0NaUysvUjdLMmVFWFdlOFYwNjRZMklGbHIwOEc0TS9OaTFpZS9UY0RPdzlqZi9FYXhQMDcwU1QwUWUyanA5S2F5NDRqMnltekZoQWx4VE91UXhabEpnVi81YmVqU3NnajBqZUtvQUFOb2lpUm1aYUdQbFBIajI4ZklyVXdqUmh6QUVXMUpjVEZkNk50Y0Z1dWVQeUhCc1hTZlEwRnVUdTJ2OXUyV1pxbEZWc3orR2RIRnFQN3R1ZkQvVi94UXNlWi9GdCtnRmZHZkk3NVlqTTJpNDNNekV3cUt5c1pHYStoWXljL0ZtUTh6NTZxV0NSQjRJRmhrK2tYZUFXcDZibG9NYUJTcWVoeGIzZFFpWVQ0aG5QUGhudDVzZE9EREJ4NENXcWxtciszWjdGeVcyYVRtcVVtQVVzU3pQNTREVnMvdm8zcmUxeFBSSHdTUTNaWkVTVVJyVnFMb2JxVzMzYm9hT3RYUmZzMlpxcUtCTzZJZlpXd3NEQ1VTaVU1T1Rua0hNMml1aVNYSERHU2NsczRBd2JvTVdGeXRQTkdnWGZ5dm1IMDdnSnU3RDJGMlIrdmJuS2FwOGtaangwSEMzanNvMVc4UGZNMmg5WjlWakRuczJ1cFVGbjRaZHB2M0hzTjJPM0JWRlpXc2lzMWc3MTdVekdiakVSSFJ4TVoxWTZ5YWp2OSsvY25NREFRbFVyRlQ0ZCtvcmF5bXI2V0dPYmVQSjhjUXo3ZElyc3g2NE4vbXB6dGFMYWMxcHpGVytuUklaemJyK3pKMW9MdFBEZitOY29QWlpDeGZ5ZGJ4WU9VMTVaemVmZ0VxclQ5U0JyWWo1NGRIRXRuYmttcm9WYXZSS2Uzc1BEUVFpNk91NWlzby91SkVjTFlHVlpJSDU5QXV2a0ZNLy9QRk41ZHNyVTViclY1MHJTU0JQZTh2WUw1ZjZidzdDWFBJaW9FQmc0ZHk0cnNOYVR0M1VZQzBZU0dhcmwwa0pITjFRc29zWlNnMXFqWmEvNmU2Tmc5R0pWbFpPYW1JUndxWkdyaWpSeFZWeEdzQzBHaFVERC96eFR1ZldkRnM0MUVOQ21uZGFyWVJZbmZOcVpqdDJtWWNuRi9CRUhBTE5qNTdlZ0tKclM5bk5LTVF6eTM3aVdTVlBGUVkyYlJydSt4bGh2b28rbEE3cEZEL0pEeEs5WmdIV1A3VG1CVXAxRWt0dW5LckxuLzhQUzh0ZGp0amFkdDFwelcyVFE5Wi9GVzF1NCt5aHYzWHNMb3ZzTVpHai8wUkFSVmtmNHVYUko2MHRFdm5sV0ZtNmhRVnFHT0RtZlVnQkVNSEhFVkZwc0Z0VkxOUHp1eWVQeWoxYzNpczgzYURwOHZvM2xaLzNqSFlOckFEdmpxMUJqTUJrdzJFMkcrWVlpaXlLYXNUUXhxUHdpVlFrV055Y3FLNUF3Ky9XMFhLN2RsTnBzSk4yczdmRDV0cjlpYXlZcXRtU2VHUzd2SE80WkxZOEpMQU1ndDF2THJYeHZZbStrRnc2V25oNkYvYmo3YzZMU015NENmeTltd0MwSHdxc1Y0a2FSZDQrc0NibWMybUJBa3ZBdFlNRFY3T3l5TEc0c0FzS2Q3N05VS2lRWXZsaVdvTlpsZGQ2Ykh0K1FONysvVEtWT3lXaHA4VFZGZ1hJKzlSMytYVnoyVWdXVmdHVmdHbG9FdmRPRENOMTlHYXFWRlFWc2MySHc0bmRLdlA2ZGl5WGRlREh4S2I3N2trL2RCRkNuNTdFT2tZeXRHU0MyNGNrU0w5SWRMUHZzQVFhdkRkOEJnS3BjN0lsaHJZVDZsWDMyR09pcUd5dDkvSnZianI3d0hXQjBWUSs1VHM4NzR2T2hkeDVoeTREWFhlWmRKNnhLN25mTjdmVkpQTHdBV1JhcVcvUXFBSnI3ak9WZGEweVU1TmdBeTd0eUdhS2oySE9EcVZTc3AvMkVCdFh0MlVmYmRWK1E4L2dBVnZ5eDJ2S1NaMEttT08xQ2lTK3lHNmVCK2p0NDdqZUtQMzhWV1Zrck5wdldVLy9pdGUvdXdRcThuLzZWbm5EN0xmKzRKMUcwaTBIWHBodWxBNmhubmFCTTZZaTh0NGVpTVd4RU4xWlIrK1JtbFh6cVdlUTY1YVpwN0Evc09Hb0l5TUFoN1pjWEpGc2xtSS92aEdTZ0RBczk2anEyd2dLemJiOEJXWEhUR2R6NzlCN3U1RHl1VWFEc2xudW5PTlRWWTgvUE9lb3E5cWhKclh1NVp2OU8yajNkdjRMSnZ2OFNVdXFjWjIrOFBFWTAxN2d2czA2Y2ZDbjN6N0NJb3FOWDRYalFNaFkrdit3THJ1dlVnZnVGU05PMDdOS2tjWlhBSWNaOTlTOURFeWU3ZkRxdGoyaEgvN2MvNDlPbmZxUE8xSFR2VDRmdGY4ZWsveUhNQ0QyVmdFSEh6RmhKdzZaVU5Pczl2K0VqaXYva1pkVXc3ejR1MEJLMld0bTk5aUtaZC9TZHpSejcxQWdvLzErN2E3dExPZzJTMUlOWTQ1a1VxQXdKUng3UkZFOU1PNDQ2dCtBd2NnalUvQjJ0ZUxyYVNZcEFrbDRlVkxnY1dhMnVKL2V4Yk5ESHRuRFIzZU1LbHRIM3pnNU1QeG1MQldwQ0hRcWYzYkdCbFVEREtvT0N6UEFnamtzV0NjR3cxY2tHalFSUGIzanRUUEE1VHR6WjdRT0VCd01ZTENmaGtaZGJTb21xTmkzYjQvamZVMFcwdkhPQ21ocDRlWjlLdEtUS3dEQ3dEeThBeXNDeHVKTTRMdnp6UFl1QTZMMk5jd3ZOTWtuMVlCcGFCWldBWldBWjJRNmwzQXNCWEJZUERJVUlQQmJXd3VSaU1OaThFVmdqd1VGZDR1Uy80bkhKMGpRMW1iNE9QMDBCMDhYc2hDc0V4MWF0L0dHd3ZiZHIxRk9lNzBOSlI4UFpBWjlpWGRzT0tYSmc3R0g2NCtQUnd6VFhoNENkRDRLZEw0TllFRi9yd2ZZa3c3dGk0MXRwQ3VIRU5yQytFRjNmRHBtTUxMVXhxRDNkMGNpMXd1QTVpZktDdEw3VFJnMHJoQW1DZEV2N2J6L0gzMWhLWW53NnI4bUhLV29kSmJTaUVSNCs5MHZ0NmYxQzdVTTBGdGZEcUhoaTV6SEVmTnRFRlB0dy9EUHhWVUdLQzUzWkNhZ1ZvbEpCZjZ3RGVVUXJiU3lCS0Q0OTFoMTZoc0szRWRkQWJDbDFjYVlVZTI5MGd5d0R2RElJTy9vNkxQclFaQnRyZ1R6dE02UURYeERxT0M2bkhiZ2crS3JpNkhmUThOdHlVVWc2L1p6ZTl0dmRSMWI4TXhibk02TGltdXdRNFREYTVHTWEyaFV0VjhNZG9DRkJENTJPdlZ4ZldudnRDd3lNZ1pieWprbnVvcStPOGp2NE82K2diMmpoUXJRS214RHNxMWVFUlRkVHc5aklvTWtHYlUxWm5udEVGZkVSWXRSUDZoRGwrQUhKcVlFL0Z1V0hYWHVtb2JUY1Z3MDFySWRQZ1hBdkgrRUN1OGVUditrZ2JIVHpkQzVLQ0lMTWEvaTA2ZjVOVnA0WnRJanl3eGZteklBMWtwWUR2YVlQME03ZlVmU0VmRlh3eHpBRlZaSUpyL25HR0JaQndRTjRRRDk5ZERFLzNyRjlObkZzTDh3N0NyMGZoZy8zMWE1L1BXZXlQbVREM3dNbi9SUnZzV1ExK3B3ejV2clhQY2NHNjVPcDJrT0R2K1B2dGZZNUs4S3ltcG9ERVFJYzFYQm9ENGZYWWkwNlVISUhQZFd2QUxEYlJwSS9ML1p2aDd6eVlNd2ppZk9HYVdTQW9JS1BhWVFGL25tY3IwNTZuUEp3dDUxZ2t5U1k2dEdRVllYK0ZveldvajVqc3pWUkxueXBMajhJdlJ4MFZUWnRqc2ZTaEtvY3BOcWVVbWVHL0tlZU8zQVRneG5oSEZMZ3dvK0gzVU8vT2d3U2tWVGwrR2lJcHAreWZOeWdjMWhTY0cwYmkzQkFTRU9ONzhsaTM2eDcrbmcySGowM09lU1FKd25SMUg2dXM1OTI4dFJmZTNOdTQrM0U1c05FR3QyOXdhS09ORG40ZERmRitaMm8yeHRmaHYvVzF0c2E2VTRzTWlLOHZoSXVYT1pxbmk4SWRBY2p5WE5oWkJtb0YvSmJ0Q0ZYZEtnSFFITkE5bGpxYXFWNGhqcy9TcXh3bVg5dUNlemkzNkpTSFdqc3N5bkw4TkxaZjNOU1d3U055V2lvRmhHb2RmZThJM1FVQWJCUGhxK0d3Y0FTTWo3c0FnQ1AxanQ2WXdlYUlySnFTOFZCNUFuQkJMZnh2RHp5OXd3SHNrb3lIdThuQnF1WXBSeDU1a0lGbFlCbFlCcGFCWldCWldreE9tNWdtTFVieTNJbHBlcFdKeHhMZjU1SEV1ZWlVWnFyL1ZaSytMc1l3ZEVHeXY4ZUZsdWVUcTZOWDhFYWZaMm52ZHhScm5rRE9PeHFxLzFXaUhHQldOaW1XMWlvdEJLaXFLRGFIdVFWb3ZOOFIzdXJ6REZkRy80MW9nZUxQMVpRdFVDRmFtcW56Y0hINHY4VDY1akR2OEMxdVo3NUZjOVJZY29YbTdTMWQzWFk1c1Q2dEMxeVgrVFo3OTFBaGlGd2R2WkpRYlNuK2FnUFZWaiszTnQ4bUEvY04zazJVM2pGMGNHbmthbjdLSHRjNjVydEJTZEc3NXpmZkpnT1BhN3ZpNU44eHkxc0UrRlR6dGVRSzVNeXB2L25XRzFpcnRQQjY3MmVaM3JIdUpaOXVqUHVKRytOK2N2cnN0OXdybUo0OGh3cExvRnVZci85UU8wZHZpcTdpcjkzbkJqYmJOVHkwL1RVMmxReGs3b0RIOEZHZWUrelNMaXA1SnVWcDNqMTRENUlrdExyNXFxTWxJaDYyNGovTVRsYVJ6bFp2ay83K3lMWHNMdS9PZDBQdnBFdkFvYk1lazE4YnljMGJQMkZqeWNCV04xK0ZCa0p1c1JGNml4V0ZCdjdNdTVRWDlqMnhCMzZ1dncvdnIrck1zTCtXcytQS2kybm40N3lFVEsxTng2QVZmelU1Q0drdTgyM3pzQlZOakVTV0laYkhrbC9pajl6TFFLQ213WldXUm1raFJwOS9Wdk9MMUJjMUdyaTV6ZGRrMS9MSzN2dDU4OEFEbU96YXh0ZlNWMGI5alVKd0pJTkx6U0VZYkw3RStXWTd6REJtQlhzcXVybUYrVDYyOHlVeURYRk43dytQaTFrT3dPYVNBUXhhOFRlRFYvN0Y3M21YTzc2TFh0NWc4LzFwK0Mwc0dqNk5XTTFSaXVlcHlieEoxeUJZLzZGMjRyODFFWDZubGFPV1dDWnQrSXJyMW45OVh0aDZhVml2TWpFbWNnM3ZwYzNnbVpTbnNZcU9wZDRtYi9pQ1dWMCs1TVVlcjlMV0o0OGNZM1NEemJkd2pocHJYdjNOVnhNajBlWmhLLzVENjJlK2pRTHVHN3lidTVMZlkybjJWVTZmUzVMQTJ3ZG1rbHphajM0aHU4NEozRnJtMnlqZ2pTVUR6OW0yYmlnZWpGREh6Z0ZuMUw3ejFKUjkwMHkxYjNOR1dxZHJzcUhIdUl2NU5rdjNzQ1ZxMzlCYnJJVGNZbXV5K2JvVTJCM04xeVhBN215K3pRNTh1dmxtdjZQQnNORjl6TGZaZ0p2TGZDTm1XVkZIdTg1OG13enNDdk45M1lYbTJ5UmdUelRmUmdFN21hKzVrZVk3ekU3RXd5MXZ2ZzBDOWdienJUZXd0NWp2ZVlGN0J1L3pmVDdwTmE4eDMvTUN2OVhyLzNvTWE3T3AwZVliTWN1SzN4RDNNZC96QWl2eVRLcnMxNzNIZk04TDdQdEZYb0JocTlKcnpMZlpJaTFQTWQ4bUF5dTB4OHozWnM4dzN5WUJlNkw1TmdyWWs4MjNRY0RlWUw3MUJ2WVc4ejB2c0QxU2EyLzNwc1ZyekZjV3puaVJVenJyaW1rcWxXT0kxV1pyWEVhb2trQ1VuUDl0TEQ5Y3NrRHZFaEFtTmFoWkdqVnFGUUFyVnpiT2ozMnBxUmV3MjdURE45NzRQWUlnTlJyWTdXdHB0ZHBLOSs1NzBXZ3NhTFZtcnIzMkp4UUtrYSsrdWcyTFJZUFZxbWIzN2w1WUxCcFA1NWNXTzViNWthVGJiNTh2R1kxNlNaSncrcW10MVVtMzN6NWZPbjVjZlg1c0tPdDFZRVBLYk1EUDRub0JneVQxNkpFaTVlWkduNEF0TEd3ajllNjlzOEVYZFNmZ2N3Nkk3OXVYaEZKcGR6TDF2WHU3ZTdRTm54TzRYNy90NkhRbXBrNWR5S1JKaXhGRkJVT0gvdXQ5bGRaeENRcXFvRmV2M1J3NTRvaWZOMjRjUXMrZUtkNFRlSVNGU2Q4b0ZGelozQmZKSzFLRjFLY2RqbWdqbFRYM3RVV1JaU1Vsd3MxbjFYQnhNVG9neENWMlZJKzRvN0RRQmRjR25TRFUwNGU5VVdSZ0dWZ0dsb0ZsWUJuWVhVTkxpMml4cUJYcXF1YStpQUFCOWVxY0lqWDd0YTJpMVZJbnNQWnpyWVo2M2x4RHhDWkJmWWJvRko4cEFseWdWSTNzd3pLd0RDd0R5OEF5c0F6c2hwR1dVc0J1bHpDNzREcjFIVzl0OW1zckJleDFacGNraWNXbmp6UTB5NCt5bmxsenlTVS9pMlVmbG9GbFlCbFlCcGFCWldBWldKYVdFT2VKYWNsSTduUnp6MFhEOHpGTkJCU2NHZDNXcEpzRDFtTjgyRld3Ymduc1NsaTNBMjUyMk9mZEdOZ2xzQys0S1hCTHdib0ZjRXZDdGpwd1M4TzJLbkJyd0xZYWNHdkJ0Z3B3YThLMk9IQnJ3N1lvc0R2QXRoaXd1OEMyQ0xBN3dib2MyTjFnWFFyc2pyQXVBM1pYV0pjQXV6TnNzd083TzJ5ekFuc0NiTE1CZXdwc3N3QjdFbXlUZ1QwTnRrbkFuZ2piYUdCUGhXMFVzQ2ZETmhqWTAyRWJCT3dOc1BVRzloYlllZ0Y3RSt4NWdiME45cHpBM2doN3BpUWprWXowWEU0elQvQjh6alhMTjlSdjVZanpBSHNUN0htQnZRMzJ2TURlQnR0eXdHNEMyekxBYmdSNy9rcnJBaENuU1Z2N2ttTFB1bUthaDh1U3BIMUhKN2tzVGV2dUlnUEx3REt3RE94UjBtSWJMZ2ROdUI1MWROdXpmbWZOeTZGaTZTSnZBNTZFVC8vQlovM091RzF6aXdITFBpd0R5OEF5c0F3c0EzdGI0QkUwNFhxQ0prdzY1ekc2THQzTytWMzdMMzg0NS9rVlN4YzNTMXZkTE1EcTZMWjFCaFgxTWpQL2dQT2VYNU84V1RacEdWZ0dsb0hsWnFsUllzM0x3Ymh0ODNtYkpZWC8yZGY0RTZ1ck1LV2xudmNhYmdOY3NYVFJlZHZJOWwvK1VHZlRZMHBMSld2YURiSkp5OEF5c0F3c0E4dkFjdURoSXFsWXVyak9MbDV6QlJWdUJyeElObWtaV0FhV2dXVmdHVmdXWjNHYW1DWjlTdk5NVEx0YkxBT2hTWnRGaVlqRnloM0s4R1pnWEVJLzVJbHBNckFNTEFQTHdES3dEQ3dEeThBeXNBd3NBOHZBTXJBTUxBUEx3REt3REN3RHk4QXlzQXdzQTh2QU1yQU1MQVBMd0RLd0RDd0R5OEF5c0F3c0E4dlNRdUkwTWUyZlc1NnhEbjd5VnBWUHQwN2s1bFl3ZGVvODFxMUxQK09rTDcrY3h2aElLMmszUG5EaXM2RExodFBsaHcvdzkzOFFnOEY1ZC9zT0hjTDRZZDRVQXViTm8zelpHbUllbjA2Ny8reHVLY1lsOE9uWko2WXBTMHVFZmFOdW91aUxSY1JFQjdKNjlhTTg4OHhZbE1yR1cvNmtTWDNaT0g4aXlnY2Z3N0IxTjRrL2ZVemJwKzV6RHgvT25uaWpLZVRheThsODVHWFNiMzhjcWRyQVN5K05aOFdLaDRpTURHaFF3VHFkbWc4L3VJSDNobXM1TW1rNnVyZ1l1cS83a2NDUmc4bk9MbmNQNER0bi9sRDVjNGZoZEpqN0loVXIxN05uK1BVWXRxVXdlblFpdTNjL3k1Z3hYZXRWYUtkT2JkaTAvRjVHcmZ1Sm84KzlROVNEdDVPNDlGTTBrZUg4OWxzS3ZYdS81QjdBRm90ZGV2enhKZHkrTUp1MlA4OUg0YU1uOWNwcDVNMlpUNXN3WDFhdWZJaVhYeDZQSUFoMUZuajk5ZjNZOE1rNHBIc2Z4ckJ0RDEwV2YwaTcvM3NBT3dLUFBMS0k4ZU0vcEt5c3B0V0F6L3BXeXg5LzdHSGc3aHkrKy9KbG9wZitTUFlMNzFLMVBwbUVqMTdoNmFmSFVsUlVEVHQzbnJYQVYvb0taRjAvQTcvK1BlazQvM1UwMFJFY09WTEtEVGQ4eHBZdG1hMWVTenNCRHgvZVVSTVJjZEpYUC9oc0k1TW5qMmZNamVNbyt1b25zbC8rZ01nWlUyaVQxSm1LT2dxczNYK0lEaCsrVE9oMVZ5QW9sU1FuWi9IaGgydG8xeTZZZHUyQ1R4eTNlUEdPMWdkKy9QSEwvY2FONjNuV0F3T0c5cTlYZ1IzbXZ1ajAvOENCN1JrNGNOcVo3YUV3by9XQkF6NzZVTFAxbmwzMU9sRTAxanI5WDdGeVBWdGpHcko0U2EvV0J4YXMxak5BR2lKTk9WZU9wV1ZnRjVoMDFYMzNXYTY4ckt1K1BpZFdyRmpIb1R1ZmNLclVPdi93ZnYydjdEZXI5WUZmZjJlVjRhdUYyL1RPVFZVblpzd1lqbGFyeGxwUVRQN2NCYlI3OWtHVXZqN09wdUtyUitucmc2Mmlpc0tQdnFVMlBaUFFTV1Baclk5azN1Y2JNWnV0N3FmaDllc1BXWTcvN2VPajRiMzNidVRPTzRjQ1VMcjRUeklmZmdsOVlnZXF5dzExRnhnVVFQVHNHZVM5OVJrSGI1bEYxQ1VYOFo5SEhtVEt2WXRJU1duYWU4S2pSaVdTbkp6cDFCc1RCQUZKa3BybXc5MjZSWkdjL0JSMzNqa1VzZFpFNWtPYXc2bm5BQUFnQUVsRVFWUXZjT2p1cHdpLzdUcjIzL2tnZi94enNNNENIM3p3ZXl3MmtaalpNK2oyMnp5TXFlbVlicC9KUDIrT1l2cjA0ZWNNUzArWFcyOGRqRnF0SkNJaWdIdnVHY0ViYjF6SHZIbTNNbkprWnpwM2ppQXlNb0FiYit6ZitFcExFQVJ1djMwSTI3WTlUVkpTTkxVSE05ZzcraVpLZi9tTERsKyt5Zi9LbzVsODB4ZFlMUFk2Qy96aWk0ME1IUGdxQnc4VzRqK2tIejAyTE1LdmJ4S0hiNWpKLzdXcjRQdHY3eUF3OE56VmhDQUlEQm1Td1BQUGorUFFvWmRSS2hVc1hicUwzcjNiRVI4ZnhycDE2U1FraEpPZC9UOXV2bmt3blR0SE5BNzR0ZGNtQnN5ZmZ4dDZ2WnFTNzM1bDc4Z3BLSDEwQkN6NGlNdGYyTUpISDYydGwvbWtwT1RRcjk4cmZQUE5GbFFoUVhSZStDNXhyODRtNy8wdjZmN1ZYTFl0bTM3VzgrTGp3MUFxRlF3ZjNoRzdYY1JzdGxGY1hFMVltQjkrZmpyNjkzK0Z0OTc2QzBseTlNaFNVL1BJejYvRVpMS2U2TDRxRkVMOWZiaHIxeWlWYUt3bDg3SC9VdkxkcjBUZWR3dGJ1ZzNqN3F2blVWVmxhcERwR0F4bWJyMzFDMWF2VHVPREQ2WVFPV01xL29QN2NPak8yZFJPblFHY3VVWmVVbEkwLy80N213VUxOdlBFRXoveG4vOHM1ZWVmZDZKU0tiRFpSQUIyN3N3RzRQMzNWL1A1NS8vU3QyOHNPVG5sYk52Mk5QdjI1VEY5K2dKcWE2MzEwN0FxTzF1eDk1S3BsUCs1bXZndjN1VFYwaWh1dk9YTEJzTWVGMG1TbUQvL1h3WU0rQytwcWZuNDl1cEs5elhmRTNUNWlET2Z2RXJCWlpkMXc5OWZSOWV1VVNRbFJmUHp6NDRlMlhIWTA4dXVxVEd6WlVzbXI3MTJMVDE3eHBDWUdNbjVEUEEwL1U5dnRWMEFJaUlDS0NxcTV1NjdoN0Z3WWZJWmViSHp5YWVmM3N4Nzc2M0NhTFNRa1ZGU3Y1eFdhNGhTcWFCSGp4aGVlR0VjWGJ0R01tL2VoZ2JEQWp6MjJHTDI3czFqNU1ndWRPc1c1YjZocGQwdU1tSkVKMmJNR01HUFAwNC81ODJlUzZxcnpUenl5QmplZi85Ry92cnI0VHJUVVNyY1FBb0txbmovL2RYVTFKalp1emV2MGZYRmdnVmJ1UG5td2VUbFZmRDMzL3ZkRjNqNThuMHNXYklEZjM5ZGs4c2FQUGcxd3NMODZvekEzS0szTkd2V2FJWU1TYUJUcHpaTjYvb3BCTWFPN2M3amoxL212ajU4elRXOXVPT09vYXhaOHlnNU9VM0xWeGNWVmZQcXF4T1pQbjA0MDZaZGROWUJCS1h6di8wbW56VWljS0drcHhmUnMyZGJEaDRzb3FURVFIcDZVYVBMR2ppd1BRcUZBa0VRZVAzMWxWUlYxUUxzaCswL3VvMFBpNkxFZSsrdFl0ZXU3Qk85TktQUjB1QnkxR29sVzdjZUlUazVpMTY5MnBLWFYrRytHWS9kdTNONDdiVnIrZUNES1EzcUNKd3EvdjQ2NXN5WnpJTVBqdUx3NFdMM1QvRWtKSVF6YytaSXBrOGZqcSt2dGtIbmFyVXE3cmxuQkE4K09JckprL3RUVTFPM2hiUzZEd05FUmdaUVhHd2dLaXFRdSs5ZVFFMk5HVDgvSFJhTHJkNWg2YVpOR1F3ZTNJRWxTM1pTWGw1RGFlbUo0UnduSDNhYldCb2dMaTZVa0JBZit2ZHZUMzUrSmIvL25uTE80NU9Tb3VuV0xZckJnenN3ZS9ZU09uWU1KeTJ0OFBURG5HSnBGVzRrUjQ2VUVoOGZ5cWVmM2t4dWJnVzMzR0ttdk56SXZuMTVxRlFLVENZYmd1Q28yR0pqUXlncE1mRG1tNU9JakF3Z0k2T1lEejljNjNscFdvVkN3UmRmYkdUNThuMnNYcDNHMEtFSkpDYy94YXhaWTVBa2lWZGZuY2k2ZFk4emVIQUhEQVl6eTVidDVmZmY5L0RaWnh2cWxaeFF1UnZ3bWpWcHJGcDFnSmlZSUxwMGllQ0tLNUxvM2oyR0RSc09JUWdDWnJPTlBuM2FjY1VWU2F4Zm44NDk5M3lMU3FWQXBWSTJQR3ZwRGlLS0RpM2w1anJhMFh2dlhjaW9VVjM0OWRjVTFHb2xDeFpzSmlVbGg5VFUvQk5CaXMwbW5qVko0QkhBcDB0ZVhnWGZmTFBseElOSVR5OGlQYjNvdkxrcmp3VStEbHJmenoydTBwS2xtY1haRVFZdlhJelFmSUhIKzQvMjMzei9kWjBHdHlyZ2FVTWQ4dml3REN3RFg0REFFeTl1ZStFQUo4WUY4Si9ia2k0YzRQSEQyOUkvTVlUWUNCK1BCRDV2YUJrWnFpTThTSWRTSWFCVUNrd2ExYzRSMUYvYmlTV3JzMDhjdC85SUZUVzFOczhIRmtWNCs4RStqQmtRNmZUNWs3ZDA0OGxidW1HelN6eit3VTYycDVWNWgwa1hsWnU0WXRZYVh2aDg3eGxqci9tbHRWeHkvei9NK1NFTlNmSWlIN2FMRXM5L3ZvZVZ5ZmxPbnovNzJSNDI3QzcyemtwTHIxVXl2SmRqN0NjOXV4cUFLd1pINFdsU2IrQkwra1pnc2RrWi84UTZ1azM5ZzljV3BITFp3RWgwR3FWSEFkYzdBUkFacXFQdnRCVms1amttcFQzMTBXN1c3U3FpWjhjZ2tsTkx2UTk0L3U4WlozeTJiRk8rSEV2THdES3dETnlpNHBUdjJaY1UyNnFEYWE2UXBIMUg1WnlXREN3RHk4QXlzQXdzQTh2QU1yQU1MQVBMd0RLd0RDd0R5OEF5c0N3ZUxjNFQwLzV6eTJJUW1wekUyL3J4bGdLbEpFVTJwUXhOaEwwZzhZZnF5R1pnWEtMcVZTUnY1U2tEeThBeXNBd3NBOHZBTXJBTUxBUEx3REt3RE94K3dKb29FVTJFZE9FQWgxeGxKdVFxODRVREhERFVTc0N3MWxrRnNVWGVMdFcyRlFtL3dZUm9WQ0RaUVJmdmVOYzNhcm9KRktEMEVTbitYb2M1VCtFZHdPWWNCWWJ0S3RvK1dZdENkOUozdzZlYUVFMENPYS81dEFoc2k1cDB4Um9OQjZZRVlLOCttVVlUcXdYU3B2cFRzVWJ0blQ0c1dVSHBKNEhrZ0JaOEpVU3owS0krM0tMQUlWZFlzVlVLcE4vclMvbzkvdGlyQllLdnRMUW9jSXUrRWkvYUpRNU1EVUEwT3JSNllFb0F3WmRadlJlNDlHZm5OWFpFbzBEcFVvMGNXc3JBTXJBTUxBUEx3REt3REN3RHk4QXlzQXdzQTh2QXNyaFluQkpLR2QyQ0ZpTjUxOXVsQ0N6cGtGb2hUMHhyM29lcUFsV1lpSzZiRFlXZjVQM0FrZzNDbnpBUzlZWUJkYlRvNGNBQytBNC9kNlpSNFNzaEtCMmExYlMzSStqY1I4c056bHBxNHV3RVRUVlJzNzd1MFFMUktKRDNpRDkrSXkwWTFtZzhXOE8rdzZ4b1l1Mm9ZKzNuc0duSEw4UGFrN0Q2ZmpZVWVnbDFsT2hCd0lJREdNNXYxcWVDSTREL3BXYmlGbGVpanJPN3IwbXIyOWtKdmJzV1JhQjB3cHlGWTVZY1BOV0V6OENUME9hOUtzcSsxaUdkWmF4SUhTa2lITHVTdHFNZDR4YjF5WWZoVHNEV2JDWEZiL3NTOXFBUm4wRm5hbFRiMFk1a2cvS3Y5VlF1MVVJZHlyUG1LeWllNDROMnVZM2FiV3IzTm1sN2hVRGhTNzZVekRuN29uOTVEL2xUdWFSdTJCTVZtVUdnZHJ2YVF5b3RDY3dIejF3M3kxcWd3SkxsV2V0cDFidlNPbDVaMmZJVjFLeFhJMWtkdnFtSnRkZTd3dk1iYldsMVlGVjliOVozbUpXcVA3U1V6ZGNobVFUVXNYYkNIelhpTzl5SzVkdHphMWtWS1JMMm9CRjlMeHZxU0pHSzczUklkamNHVmdaSWxINm1wM2JIeWNPdFI1WGtQK0tQejlEek4wKzJBZ1ZpaGNPWWFyZXJXZzIyM2ladHJ4U2NZRSs0dGgxcTF0V3ZJcXBlcVNIcnVrREVHc0V6ZkxoQjhZbEdRdEJLNkh2YVVQZzZHdHphWFNva2s0RGxxTkw3Z0NXYlFQUmJCaUpmTmFCTnNMdFZyOXMxR2xaTENIcUhaZ1ZmQ1VIbHdiMmwra3JPM1FINERyWmkzS1RHbmNRbHdNZmo2WnFON2dYck1wUDJpa2hMQnBhQlpXQVpXQWFXZ1dWZ0dWZ0dsb0ZsWUJsWUJwYUJaV0FaV0JaM0ZhZGhBQ21mWnQzSzB5MUVZb2tRaFR3eFRRYVdnV1ZnR1ZnR2xvRmxZQmxZQnBhQlpXQVpXQWFXZ1dWZ0dkaDd4R2xpMnNqYlp3NWV1eTNCcXdBdjduOTRNTXlWVFZvR2xvRmxZQmxZQnBhQlplQ1dGNmZSdzBWdHVodDdGZVhvdlFsd2Q1dTJ0ZGNYN2ZXUlRWb0dsb0ZsWUJsWUJwYUJaV0JaV2pTMGhOK2FaU3RQOXhKcENZeVRKNmJKd0RLd0RPeVo0alRVTW5kdWo4U0VCQit2QWp4ODJKZzRjMllkd0VsSmZrRVhYeHpxVmNCcjE1WUd5VDRzQTh2QU1yQjNORXVCYjh3S3lyeHpvMWNCQmlZT0Nhb1RXRkZlckxBZVB1eGRKaHpSU1NIN3NBd3NBOHZBTXJBTUxBUEx3REt3RE93Q2NScDUyUGp4eXNLZWNmWTIzZ1NZY2tSWk5PU2V5eUxPMm5td0pQYTErbnBaVHN1eXR0UXErN0FNTEFQTHdCNHJUclgwblhlbTdCSUVJY2FiQUNWSjJsVW44T0hETmFZekpnVjRQckpKOW1FWldBYVdnV1h4eU83aHgrMXVTUHNqNnFyT3YwZVBRL0tXNW1scGtGQ25TY2ZVNXZoK21Yd3JTemRjUTdlcTFBdkhoNGVWckdmdDZtRzh2dnN4UWl4bEYwYWxwWkJFN3N5Y3g5YS8rbkpYeHFlb0pOdUZVVXNIV1N2NFg4cHMxcXdlenZEaWRSZE9zOVMxYWo5TC83MkdyN2ZjVEp6eHlJWFREbCtWL3p1Yi9oN0lNNmt2NFd1cnVUQUNENjFvWnRiQnQwait1eC9YWi8rSWdPUXh3RTV0Vk9iRlZ4c0QxdjdlNEhjUGxSZGRoSDdPZXlqNzkzZS9EcjlTcUxzZEZob1phOWczYmNJd2VDQ211KzVBS0NwQXFjQnRmbHdYUzBzUzVpKytvTEp6WjB4dnZBRVdpL2Y0OERtNXE2c3h6cDVOWmZmdVdILy9IYVFMWUE5eEFIdDZPdFhqeGxFOWRpejJBd2M4SDFnSURLelhjZGJseTZuczBRUGpJNDhnVlZSNExyQnU5bXlFNE9ENkhXeXpZWHJuSFNvNmQ4YjgyV2RndDNzZXNHYlNKRFJYWDkwdy95NHVwbWI2ZENvSERNQzJZVVByTkZPbi9wT2FXbEUrQ003YkRpc1RFMUYyN296NjJtc3hMMWpRY1AvZXVaT3E0Y1A1TmZZNlh1MzlFbmsrTWEwRGJCZnJWNldxeDQ5My9MN2lDZ1EvUHlTRG9WRVh2K2JvRWk3TC9ZTTVuV2J4ZnFlSE1DbDFibURTR2cwK2MrWVFkT2dRUVljUEU1U1ppZjdaWngwVmwwNUhVRVlHUVRrNUJPWGtFSmlhaW1ySWtJYlZCWFlUVHg1NGxjMy9ER0I4N2xLWGg2bm5CN1pZTUQ3eUNPYlBQMGZSdmoySzl1MFJmRTYrK1NLRWg2T0lpVUVxTDhjd1lRSzJqWTJiZnR6T21NMzhyZFA0WmNQVmRLL2MyOHFWbGloUysrcXJWSThlalZoUWNPWXorZlpicWdZUHhuN3dZSk52eU45YWpaL04wTXJBeDl2VU5XdXdiOTE2eHVmbUw3NUFxbWxhVjdGRUc4NURmZDVuek1qVmJBNGQ3QjdBZ284UHFqRmpIRW92TER3Uk5oNnZ4Qm9qTmtIRjNJNzNNMkRNZHI2SnV3VzdvR3hsSHo2MVNoODlHa0d2eC9MTEwxUjI3VXIxWlpjaEZoV2htVENoVVYydGxaR1hNM1QwSnA3dC9qSlY2b0NXN3c5bkRMK3FKbkQ5SDNXK2krYzdkeTcydzRjeHZmUE9DZTBxb3FMd1hiZ1E0eU9QWU4rNXMzNFg3ZFFGNGZXM0VTNjcwdVdBUWI0S29jNTJXS0U4dDVwcTMzNGI4YlIzSXNUOGZLckhqRUVSYy83Z1FRZ0lRUC9jYytqdXZ4ODBtdGFQdE01YldkZjFBb2pkam5qMDZEbElCYlIzM1lYKzVaZFJ0R25kZVc4cWwxOWcyREI4M24wWFZkKys3cEh5Y1ZsdDJLNGRQbSs4Z1dieTVNYm5qandCV05EcDBEM3hoS1A3Nk9OKzd5STNLN0JtOG1SODNuZ0RSV3dzN2lyTkFxenMzUnZmZDk5Rk5XSUU3aTVPd1B2M1YxUU1yRWQvK0xpVWEwTjVwOCt6TE81MEMvYlBsZkI1bFdjQjIreVNXTjl3OExNTzAza2o4UWtxMVlGUURYakk2RU9EVGZxZmlERTgzZjIvcFB0M3hoT2wzc0FaZmdrODNmMi8vQlY1bVVkUGh6Z3ZzRUhseHh1SlQvQnBoeGxZRkJvOFhlb0VsaEJZR0hjVEwzVjdsbUt0OTd3R2NWYmc1SkJCUE5Yek5YWUY5Y0hieEFtNFVCZFpPNzMvUEg1cWU1MzNURnU2ME1WSmpmcW9SMmRKRW05N0dlTVdVOEZiZ3h1VjR2RUdrWUZsWUJsWUJwYUJaV0FaV0FhV2diMEdXS1VVTHl6Z0J5YnVkcjhFUUhPSVhtUERhbGRnc3p1ZWFXSzdjdTY5Sm9WYkxqMUF4K2hLUGwrV3hJNzA4QlBIYTFSMkxEYWw1MnA0VEw5c0x1cDJjajdJZ2V4Z2poYjVvOWZZcURHcG5HQTd4VlF3Zm1pR1oycFlvN0x6ekUxYm1UbzZEWnRkNEl2bFNieTVxQzkyVWNCb1VqSGt3Y21NNkpucjZJd0xNT09xUFV3ZG5VYXduNWxlSFVwNDVkc0IxRnBjTjZqcGtnU0FyODdLa1lWZllMWXFpWjF5QjNaUk9HY2x0bmZlTjhSRlZKTnd5elR5U24xZG1nQndlcFRqTHUvZTc5ZmxUWjhqRlJkUnpXVlBUTVJIYTZWdHVJRWpoZjUxSGh2b2ErRi9QL1RuY0Y0ZzdkcFVOenR3UW54WS9MNkNPa3c2TUZBZjNKVEMvZlJXRExWcVVvK0UxUHVjMGlvZFh5enY1dlNadjQrRmFtUHo1TUIxT3JWUG5TWmRXRno5dkNSS3p6VWF1T29WYXZ3ZlJoS2FwaVhmNm5lbzlia1JVUm5WZEo4VmhPMFJiZnpQL3ZhSkpFbi9rUm9qMWlKSnlyeFZrbmFGUzlMK2daSlUva3VqaXBGczVaS1VkWmNrN1k2UXBIMDlKYWwwb2RRTXN2bGN6Vkxqa3RHcWNBaTlIYkNCcGkwRVhkTTRkU2lESUh3bVNEWlFoVURJRk5jMlMrYmQyNFB0aHVyRzNhdHlCNkk0SDBYdGJ1ejVxeHJkeEN1VWU1REVUMURVcG1IL2R5WFFSRjlXcXZ6ckJLNWU5a3RpOWErTG0rRTUvdEJNK3ZpbTZYRkJRdWRZOSs4dHVYQ1V4M2ttWG1DUVVkT3hTK01MQzZuQlhxbEhzamZ0T2ZyMnlLYjJZQlNpdWVrUmx5b3kybFRubDVJa1BkT29ldEJlSzBubUxFbktmc3hSczVxekpFa1NHMWRMNXp3cFNmdTZTZEtoaVpKVTlwM0xhK2xHZGtFMFVQNGpGSDhBMlE5QmJVcmo3RklaQklIandKd0J0Z0lJbXVTdW5RZUY0MFlybDRGa2hvQW16SksxbDBQSFA2RW0yZEU4Q1NyWEFiLzh4b3J1cTlhbk42cWdzSUJLeXFvbm9OZVlnWGVvTVRkdVIxQkJrSkFrQWZBRjVqVVpNQ1lxTUw1TzROeUNLdjlOVzdPYVVIejVLVGNPU1hHbDdNMnEzeXFLM2R2WC85aUdTRkxYS0IrWE4wdHhFZFZjMGp1Yko2ZHNJeTZpR2orOTFlbEJuQ3JoUWJYRVIxWXg5OEhWeEVWVUUrSnY4cnlNUjBTd2tVOW5yZUs2NFllNGY4SnVyTGFUbDdscDlJRXpVa0ZmUDdHQ2dZbUZ6SDFnTlVxbGF5ZTRPWm4wN3IxNSs0Q3hUUzAwK1VBRSs0K0dzQ2N6bEdYSmNaaXRTaExibFhQMVJaazhPbWtIMFdFMS9MMDlsaDNwNFJ3dDhtZnJ3VWd5Q3dKSnl3bW11S0o1ZHdNdUtLektxeE40eCs2Y25PYVkycXhXaWR6OTltZ0t5MzJJQ1hXOGc1U1dFOHhOUGdjSThqUFRJYktTWFlmRFRoei96dUxlWkJmNzB5Njh1dGsxV2xwV1UrNXlrN2JhRkJTVStTQkprRlBpZHl5b2dVcWpsaW12WEVsZXFTL2lLV21mN0dKL3A5OGVtYVk5bTd5enVBOTJVZUMzVGZHdEZxYTNhT2ZoZURMdlhFazlyd0tXcGRWN25rblBMd2JKdTdieTNQZUNjRUdidEF4OE5nbncweElhNUhQaEFJOFozSUhMaGlSNEJmQTVBNCtSQTlvVEZLRGo5b2w5VUtzVTFKcXRtQzEyVmlkbllqTGJ2QTg0cDdDSzkvOHpsdTZkSEs4QWJONmR3NGZmYi9WWTJQT2E5S0dqWlh6MXk4bjFxRmNuWjFGVVZ1TzlKZzB3dUZkYmJubnlKd3kxRnBJNmhyTjJXOVpwS1JrQlNaSzhCL2llRjMrbnBOeDRBdTUwdWY2eWJpeGFtZW94ME9ldHBZL0RPcnA0WjBMTm5ES1FMdTFEdmNPSHp5ZUJmanFHOW0zSGxjTTdlUyt3ajA3TnQvKzdEdE9PWnlqZThEaEtoWUkzSDdzTTA0NW5XUGJ4elZ3eHJDTUtoZUM1UG55NkdFMVdibjd5SjlLeVJ2REN6RXNjVDAwaGNQWE1oZnk5S2NNN1RWcVNKTGFrNURwOUZoM3U3OTArZk9Yd2p1UVZWVE4xOWhLKy9uVzN4L2h4bzNOYWhhVTFkSi93SWVWVnRYejM1eDY2SllSN04vQ3JuNjEzK2ovMWNMSGNINWFCWldBWldBYVdnV1hnaG9sVGxQL2JiMzJQRE9wV0VPdE5nRzBTOHVwZUlrNnZzU2tEZlMyeVNjdkFNckRuaUpNUDMvakNGZHZCdS9ZOWhQL1ZEVnhTNldQRmczYmxrRTFhQnBhQlpXQVpXQWFXZ1dYeG5QNndkc2dISzRNdlhuMnBLcmpjYXdETmVURzV4WE1XdEQyclNadnpvNm9LRjErUDhXQ1hDOGVISlp1YXNsV2pLVjgxQ3NtbThuNWdCN1ZBVFZwWGlwWk13bFllZkFFQUh4TnJXU2lGaTYvSG1KWjQ0VFJMSjB4ODlXaXZNUEY2dDhNMUJ4Szl3c1FidGptTkc1bTR2cEh2TnpVNDBuSVhFMStRWktHbm4rUjZZQ2NUWDN3OTFsWXk4WitMVlB6WXc4U0lJTEZsZ0FHczVTRVVMWm5jS2lhK3ZGU0pCSHlSWkthYnI5UXl3QUNTVmRVcUpsNXFoUmN6MVdnRStERFJYRytmYnJiZWtxdE52SU5lWkVhTWpaNStFZ3JCQWZkZGdZcS95NVFrNkNWNitMb0lXS2tVV3NYRU0yc1ZSR2drL3VodFl2dEFNNC9HMnRBSWNOVHMrRDVXNXdMZ3BFNEJ6SDJoTjFlUGlteHhFNWR3bVBBajZXcVV3TU94VnY3c1kyTFVzVXFydmI1K2xWZUQ3aWlwY3dBenBzWVRFNmxuNWZvaUxGYnhuQ1p1S1d4RHlPWExVUi9yYm9ackpLWkYyVTQwSnlrR2dTL3pWUlJiNmo4M2MxR2h3NHlmamJjeXFjM0pQVkFIQk5RUDJIa1J1dUFiSmdQZDZqcDRYM29WaGhvYlAveWVRMmFPOGJ5Rml5WTl4clN1cUh4cnVMUlRJVC8wc0hCeHNFaDd2VVI3dmNTZ1FKSEpFWFpTYXhRY01kVWYyaVFLckNoVm9rQmdjS0FEdEoxT0lzRkhZbXlvU0psTklNZDg3RDNINm9CcTQrYVV0eHZ0dzIvTlMyZkR0dElHMWVMYUhZTjVMMEhDNzdTYWRGdVZnckU3dGR3YVpTTmMwL0FnWW5XNXM3N0doOWxKOUxWVGJoVmNXMHNMQW5UcDRGL25QbEwzWGJvVHJkckdmN01jNWx0ckYxaFdvdVMyZlZweXpBS2lCTGRGTmZ6Rmtja1JqclVGREhhQmJ3dVVURXpSY3NWT0hXbEdvWGw4dUM1NTZQYU9QSGxQRjU1OUo1VlB2OHM4NC92KzhZVlUyK0dIQWpYemM5V2N1dnR3ckU2aW8xNUMyNEJIcnhMZ25yWTJSZ1dMUEpHdTRhZGlKYVo2Qmx4MVhpWWgxcmZlMnBVazBHb1UyTzFTblZwZVZhYms0VmdiVjRiWlQ1aXZueEsrNjI2bW8wLzk3bGF0Y1Bqb1I0a1c3SkxFaU8wNkZoYldIN1pPRFYvVU40UWxIdzdtdTkreWVmU1ZQZWYyVVFtK1dKVEYvQit6a0tTejc1RytMVE9DWjNwbE9qVXhzdzVxMkZXdE9ORitwaGlFRTFBakFpWENOU0toYXNleElXb0pxK2lvckRaV0tyaDdmK1BYMkRvcnNGYWpSS1VTQ1BCVG85VW9NRnZPZklUK3ZpbzBHZ1dsNVJhcURPZjJ2N2wvOWVHK01ic0k4WE9zMFNFQUNrRmkwTEdtcE55czVLdDh4NjFZUllGL3lnVkFnUkx3VTBHMVhVS1VtdWUxZ3JNQ3I5bGNUUGZMLzBZUU9DdXNRaUh3NHF4dWhBUnB1UE9KN2RqczU2NWhDeXA4bVRyM2FoYk8vUDBFOUMyUmRoUUNsQmwwVEoxN05RY3RKb0tHcjBWUW5YeDRkcURTZHZ3UjRUcGdnS0pTYzkzdHF5ang1WklqQ0FMbmhUMHVLMUxhay9URTdkdzNaaGY5NHd0UG1QcUhmL2Vtb01KUlg1d2VxTGhDbkI5ZC9KTEZRS3UrSVM2b2JRUVBYNE5QbDdSbUtlK2NpWGgzRUVjc1BzWmwzVTIzSFV4elZYZXpRY0QrdmlwR0RBd2pORmpUSXJ0em51eHVkbWtkNE5ob0g5WjhONExsWHc1dHNiZlBtdHZFRzFTQ3dXamp6elVGSERoY2pWNnJ4R0MwdGFpSld3cmJFSExaY3RRaDVTMERmQ1RYeU1RWm14RUV6dGtYZHFtSi96UzVTYlY0Z3lzdHEwMXNGZGptTW5HUG5mSndvaFl2Qzc0d2dFODE4Wm9EaVJjRzhIRVRMMTlkLzZTaDE4emlxYStKZTlXMHBmcVl1TmZOMHpxZmlYdmZySlhUQWhXL1hydXJ1SkJGY001UFNhM2VIM2FCTEJFRVlaTFgrdkFGMHl6SndES3dET3c1WXNyZGdmSElSdThITHR2OEVWbWZqcVo2Lys5b1FodTNLS0hiUjFxV3NreU1tZXVvMkxHQTJweXRKRHk0SFUxb3gwYVg1OWJBeHF4L3lmbitacXpsV2ZqRUQ2ZlQ0K21vL05vMHFVeTNBeFl0TlJnT3JxUTgrVE1NYWN2UVJuUWpkdHF2K0NkZVRYUGtobDBLblB2amJRVDF1dzJWZnhRS3RROUszekFVR3VkeFo3dXhGR3RsRGlXclg2UG04Q3JzcGtva20yTmN5Ni9MRmNUZStqT0NTdGRzOStSU1lIdE5LVm1mamo0WnVDdFVLSDFDamxVNEF0YktiS3lWT1djTUttc2prdkJOdUlUUVlRODFLNnpyZ1d2TG5QdXFvZzJib1FpYm9hanUzb3hDU2V4dFM1dFVNYm04V1pKRU81YlN3MVR0L1FtYm9mQ0VxZGJtYkc5d1dVcDlpTXRnbTAzRFJjdWVwR1RkbXc0TnFYUUVkTDhXNDVHTlNIWkxvNnlpYXM5aUFucE1jaDhOVzh1ektGM3ZtT3RWYzNnMXBmKytkMUxiTmhPVnV4WmlMYzlxdExYa0xiNExVOTR1OTBrQVNLS2R3Ky8yeGxhVmg5MVk1aHBOYVB4SW1KV0NKcVRKV3lRNEpRQWFaZEtDUW9sZndpZ256VFpGUW9mUElyai9IZGhxaXFqYXM0U3dpMmVEb0VDMEdOekhoM1Z0K3pmYlRRVDJub28yc2p0YXdEZGhsSHYybGdKN1R5WGtvdnVhZEhHbExwQ2cvdFBRUmZkcHNVaXUwUm9XRkVvQ2UwK2hQUGt6Skx1MXdhQWhReDhncU4rMFJ2ZDZXcVZaOG1rL2pBNzNKMU8rOVhPcVVuNDhlMEFoQ0FUMHVCNTkyMzdZamVYNGRyZ1luL1pEVVdoYlo2WFRaa3ZUMm12THFkcXpHTWxteGlkK09OYUtiTEsvbmtqRTJOY0pIVDZyTmZzalRyVTBwd00zWkVOQmk4VXNMZjluaVNTS29pU0taKzV6V0xEc0thbHl6NUpHYjFpNFpmdGFxYWdrdjZuN0hpNXVOcE5XcWRRc1grVW9UNi8zWWNSRlZ6aDlIM0hGZnh0VjdvSDBGTEx6TXZoMjBZZDg5czd2N2hOTEM0TEE5ZGZjZ1ZxdElhRjlJdHQyclcveURhWHNTOFpINzB1QWZ6QTNYWDhmYXJYR2ZZQUJBZ05Dc0ZoTS9MTHNXekt5MHRoL3NQRWhZVWxaSWJ2MmJ1SEhwZk93V2EzNCt3YTZYK2NoS2JFdlFZRWg1Qlljb1VQN1JJeTFOYVRzUzZhb0pKL1JJNjQ1NjBMNnAwdnlqblhvZFQ2VVY1WXd1UDhsYk42Mm1nRC9JSHAwNis5K3dBRFJrYkVrZHV5Rm9hWUtxOVhDZ2ZUZGhJWkVjUER3WGdSQndOOHZrS2lJZGs3bmxGVVVVMUphaUY3bnk3NjBIZGh0TmdJQ2d0SHJmR2diSFUvWHpyM2N0M3NvQ0FxR0Rob0RRRUZoRHFscE93a0tDT0ZRUmlxVjFlVnMyYjZHVzI5NGdINjloZ0tRbFozTzYrODl3Y2loWTdIWmJTUjI3TW0veVg5enliQ3JTSWp2NmhudDhOa2s0MGdhQnc3dUpxOHdtNEY5UnlDSkVtYUxpZERnY0Radld3MkN3RVVEUnRFaHpxWExhRGkxd3k0Zkg1WWtpYXJxQ21xTTFjeGI4Q2IrL2tHTUdYRU43V003NGVmcmp5QzRmQ3lnWllGUGxWcVRFYVZTaVVKUW9GS3BXeVhTYXRHOHRGN1grcHRVeWFPSE1yQU1MQVBMNGpGeS81dEw5Mi9aZDFUeU1sbGNwMGxuNXBmNWo1MzFPYzk4c2dLVDJYcGgrTEFvU1h5NFpDUEQ3LzJJNU5Uc0M2ZlNPcHhUaWpkcSs1eTF0RGRxdTE3TmtqZHB1OTd0c0xkb3U4R0JoNmRydTFHUmxpZHJ1MG1ocFNkcXU4bXh0S2RwdTlrNkQ1Nmk3V2J0TFhtQ3RsM1NQWFJuYmJ1c1AreXUyblo1QXNEZHROMGlHUTkzMG5hTHBuamNRZHN0bnROcWJXMjNXaEt2dGJUdE5OUmkzTGdaL0NKYlVOMGlaUjk5U3RyLzNZMVdzcnZtR3FldHc5VnE3enkwTTFmeXpKRjE5S2dwYk5IcnRqaXdRcEtZWEx5UEdYbGJYYWRWZHdGdUxhMjJPSEJyYTdWRmdkMUJxeTBDN0U1YWRUbXd1Mm5WWmNEdXFsV1hBTHV6VnBzVjJCTzAybXpBbnFMVkpnTjdtbGFiQk95SldtMFVzQ2RydGNIQW5xN1ZlZ043aTFickJleE5XajBuc0RkcXRVN2d0dWJxNm52enRucWRWbVU1UlJialdIamZtMzdxbnBoMklZZ01MQVBMd0RLd0RDd0R5OEF5c0F3c0E3dWllL2d6NUFmQlptOENySUQ4aVhVQjk0UW9ZTEEzQWNkQ3J1ekRNckFNTEFQTHdES3dEQ3dEeThBeXNLczdEN29rOHUyVjN0VjVVQWFTejc0NmdLTVhlRi9uQWNpbHIrekRNckFNTEFQTHdES3dEQ3dEeThBeXNBd3NTd1BGNmRYTHBhblpWV25wYmYwUEYzZ1A0S2N6bk5kN2RqTHBLSCtkNnZGeEV0Y1BrbENyTGhBZkZvQXhQZUgvcnBWSWlMaUFLcTJJUUhqOEdvbEpYcVp0eGZrYy9OS2U4SDhUSlRwRVhBREFKN1FkQkxQSFNWem5CZHF1ZHpzc0NIQlpUM2htb2tTSE5oY0E4SEdKRElMWjEwaGNPMUJDcmJ4QUlpMUJnTXQ3d2RQWFNyUnZjd0VBbjJpM2crREpheVN1SGVBNTJtNXlMQzBJY0hsdmVIcWlSTkZETklRQUFDQUFTVVJCVlB2d0M2anpFQlVNVDQ2WG1EaEFRcVc4QUlDUGEvdUszbzZhM0YyMTdaTHVZVlF3UERGZVlrSi85OU8yeS9yRENnR3U3QU5QVDVDSUMvTjA0SnljZWg4YUhRSlBUcEFZN3liYWJqaXcxUW9QUE5CZ2JZODlwdTNZTUU4RFhyTUdmdjBWOHZJYWZHcDBDRHcxUVdKOFB3bFZLeVdYNnRjVktDeUUyYk9ob0FBeU1od2JKSThkQytIaDBMMDd2UElLK1BqVVg5dDlvVmQ3aVMvWENod3RjVWNOUjBUQWE2K0JLTUxodzQ3UFVsS2dRNGNHd1o0cU1TSHcxSGlKY1Myc2JTY05td0wybDhNdy9kbmJtaWg0OFVYNDU1K1RqZTVMTHpVSzlrUzdyWkRJalA2SWI2VVhNWXJHbGdlV0JMdDB6cU4vL1JWNjlZSW5uNFNubjRaZmZvRzc3MjdVaFErYkQzUDdrVHRZYjFqdnlEUW8zYkhTaW8yRlRadmdoaHRneDQ1R2FWZEM0dDJpZCttNXY1Y0R0b1hGS1lXNXBtcDF6c1YrRjhlNDZtS0h6WWU1NDhpZHJET3Nhem5DL2dndEVtbWRMdThWdlVldi9iMWJGcmJSelZJVEpNT2N3ZTFIN21oMTBCYlI4SHRGNzlGemZ5KzNnWFdaaHQxTnF5N1Y4UHRGNzd1ZFZsMmk0UXh6Qm5jY3ZaTzExV3U5UDhWelhLdnVEdHRrRFh1S1ZwdEZ3eDhVZmVBeFdtMlNoalBObWR4eDlFN1dWSy9CRTBYUkdLMTZLbXk5TmV6cFdtMlFodWNXei9WNHJkWkx3MW1XTE80NGNpZXJxMWZqVFhKV0RYOVkvQ0U5VW50Nkhld1pHczYyWk5lTVNoL3RsYUFYckRobEF6WUg5V3p5bHRydG5udUk2SWZ2T09QelBTTW1ZOXlUMWhxTVN3WlhwRXhxOFl5SDEzWVBaV0FaV0FhV2dXVmdHVmdHbG9GbFlCbFlCcGFCWldDUFR3Q1UvZkxYSVgyUExnbE5LVkFWRW9RcTBQK016eTI1aFlnV1M0c0QxdTVKT3h3eS90S09KKzdQNldiRGduVzYrSFl1dWJBbXBuWGVBN0xtRitsa0g1YUJ2VmljZk5oV1VtNHlaVFp0aTF4M3E3UnNKZVdtT29FUDN2Ym9McUJKdFhSZGFkcTBLUSswVnBwMmwrekRNckFNTEFQTHdES3dEQ3dEeThBeXNBd3NBOHZBTXZDRkRuekJpVk5lT3VoTnBPYStRUElJNk9UbitIdnpQcmpvK3BQZjNmUEtYWHowbjg5Ty9QL0kzL2Z5eGU2UG0vWDZGWSsxMHF0NHNnL0x3REt3REN3RHk4QXk4Qm5TWW1zWVNtWUJuLzBxbmd4WEVxWlJvRlpJeEc3ZmpmR0hMOUNPdkJ4bFJMUjNBQXZWQWxYZjZhaGRwYUdOUldCaVd6djdCcGd3NnlUQy85MVAxUXVQd0F1Z0dUU0NxT0ZhendZZWVVU04rVnM5NVdZQm13UytRS2hGUWZad0c2SktZdFFxeCtJZFJrbWljTWRxUm0wRGV4YzlidzJ1eFNaNEdQRFVWQzNQYk5hemRISTFCRXBjL1drQUFEcFJvTk5DTFFvbEtHMk9hRjR2Q1B3eHc0QmdFcGcyTDRDRUtnVXpMNjNCcW5BeHNHOHpyWll5SkZ2TjA1djFaS2x0bU51S0ZQbElwSVJZNkZlbVFRbGNrcVZ6NnJyczhiZGkwSUZHS1hGUWIyTjRqcHBudCtoNWJWaHQwenNQNStvdFNhbE43eTFKUm9IaW1RR0lWWTZpUzlSMnN0dlk2Wk9yT1hHTWlJQ0E1SFR4STRFMmRFYUJDT3ZKcHg3OFRBM2FQdGFtMVNIZFhOeGJxdmxGUzAwMTdBbHpqUGFIV1pYMFBnWFdvaEJZUHZwWkZvWXU1Ui8vUjdFSkRzQzRTcFVUN0ZHdG5lcXZkV0IzNTNaWWhJUC9xUGpqam1wV1RhOWxZNlQ1RERNU0ZSS2h2bjlqMUc0anhXY2NQL3Y5eDZtSUtpVCs2bXRrelV3RHExVldUQWRWcnZQaEpSdWFWcGgvdm9xZTVTcUVLb0dZVUlsK2hab3pqbEhiNEswQ2Y4bzdMZVNPZlpWVWEvcFNLNm5SQ3c3VERVREFHaVJSM2taaVFLbVMxSjhGTWt0dHJzbDRRTk44K05aZ0xmK0wxSk9qdEJNb0tyQUFvWkx6SmFvVjRTeUkyOGZQY2FNWms1M0NFNGZQYkg5MmhGaUlNQ2d4YUNVS0MrQ0dvNFptWTJ4V2s0NVVPY3B1YTFmaUx3bG53RHA4MkFjRlNqSjFXL200V3hWbnE0ZjdsbW1Jc1NqcFVxMDZVYVpiK3JEeTJMMFZDaUkyb0VJNDAyQUNiTm1vN2NYNENTR1kxQkp6NHM5Y0thMVFFQkdCTWtGQ0pRaXU4K0hySHB6UXBNS2lqdVpDV2pxYnh4b1J1OWdaTVNmZ0RDZFJJNUpVOFNIUnh0RVUraTNnaHk0Mm5zcDBQbWI3eGJYVTlMVXgrR00vN01HaFhIZlZxRWJmMDVMM2x0WU52UGpkbjVzRWJObThsZ04zWDRNdFF1U3d2MFJvdEprUk9VNXpPOG4xczJMUXY0Tkp1QVFGVU9JblloVkFmZXpCVkFnUzVqWWloL3drQXFJdFRPZzdrY1hQdjkxNEIzNVBPRWZnSVVsTnFyUWtxNFdpb1IyeEdxclpIbU5tVUs1elowQVVJQzI4bGlJMTNObmZna2toSVNvaCtROS8ydFk2aDNtYm9zMWNsS2NsK0pORmFJZVBhVHl3SUxpdTBoTFVHdlJqSjZHQ0U3QTFwOWkwUW9LdVJYb3V6dFZ6bVZaQkoxK0JhdzVwT0w3MG9CRUo4ZGl4RitWcFVVWkVvUmswM0hVK3ZHRFA1MDB1VUh0Slc0WXRWV0d4V0NsVmlld2NYY3VBdi9XMHNTdWR6R25PSW45eWZVU0N6QUtJRWxWSWJPbGJTMUNoa2k1NUdnSWtnWlJyUjVDWDlvM3JnQjljZVZlekZEcWx2NWJITnVuWWNsY04vMGFJaEIrd0VYSEUyV1ExRXNUWEtFNTQxdUVBR3djbVdOQmJvTzBiS2xMQ0plNHhmWUo5NVNmdTN6MzhQdEZNUW9XQ3NIOVZYSzJId0pLVHNGWUpkclV4b3hRRnVwZG8wQnhUZTJTbGtrN0wxUC9QM25uSFNWVmREL3o3eXRTZDJkNHJDOEl1dlhjUVVCQVVzSXU5RUkzWWEyeEpOSm9ZbzRuUjVHZHZxSWxkc0VWRlJWRkVlcThMdXl6YmU5L3A1YjMzKzJNUkhBV2s3Q3k3eXp1ZkR4OTI1cjI1Yjc1eno3bjNuUFBPdXhkRkFaY0Y3cHppUWdsRGVCaVduSlltd0YvSGVOaG1GcGl5MWtxT1N3NFpKbmZPOWJKOW5pZms2bFpCWU1iS0NDSXJUVnd5eTBtclVRdkhWd3RmRWs4VDRPVkJQdHgvY21EcXY5OFhMb29JWXQ0allpZ1NLSTdZLzc2Y2xNcm5sNDdtK21sT0hDWXRYRjhyL0RrdEpWc2g5aUVud1ZLSmdzOE1GSDBra2Y2bUJka0Fjbm9hMWpOblk1cHlPc1pSRTlpMjlGYVV6ZDBoYXltQW5LWFFNa25ocXFmM3YzM2RGUk41N3ZmLzZOQTByWjZJMTRGMVlCMVlCOWFCZFdCZE9reEM4eC9EWHY0VWpabmh1RkROTjVmdVNJd3hweDBrVTlLMGMzQldtTzRYQ3B2NjVWV2QzYkd1SldDVUJRc1FkV0RERW9OQVhKakNtR3A5ME5LQmRXQWRXQWZXZ1hWZ0hWZ0gxb0YxWUIxWUI5YUJENVVBQ0FiVmp5VkptQjZ1a0xpaDJTVnMyRkhDOG5XN3NVZVp1R1RHSU9KaTR6QWFqQnFhRmdqSFJUV1BaNnNZRVRIaWdBa0FTUklrSUN4VjJnNlhqeGMrMkVLZkxEc1h6aHBQb3FzQ3g4NmRQRnRtNU1hTHhnZ0dXVEtHcFVldDF1QnhVZWxtbDRmTFpxZXhkZU0yVnF4YmdXdlpBdGk1am5PbjljUGw5WFEvR3pZWW15aHFXRXZBbk02RnczdmdHejJUbGNZQkZIdVhJY3IrN2dkYzFWeE12K1J4M0ZuN0VZMXVJekdhRVZHU0tHellUbkZqZm9jQmQxZ1NMekU2Z3pYRmk4Z0tOcEswK211ZXFjdWdWaEpKVEN0bVp1K003Z2VjR3QyTHV1Qk9iUEdwQ0dhRlcxTjJVdTV3VUJsL0t2RzJsT01EckxrY0dtYXJNeXhYOHZrc3ZadEV5WGpwVFhpQ0hsUWx5RW1Da2V5dFd4QUdxSm9pQ0s1d1hOYnBDaHdjZU9mSVBnSmdDOGVGYzlia0YwWk1PNk1YZ09HbkJ6S3k4UG1WRnZPWStkRmgrYUUxM2JYVWdYVmdIVmdIMW9GMVlCMVlCOWFCZFdBZFdBZlc1UmNTV2d6Mm0yRUxRRGl2SXk2c3ZiS3VveGdYQ29LZ2IrV3BBK3ZBT3JBT3JBUHJ3RHB3eDB1SDNGc3lxREM1Q3FaVkNQUnIxa2h5QzJ6N2RCeUd0Q1FzUTNLSm1uVUtrYk9uSUJqa3JnODhwUXJ1MlF5cGJpSEVtOVg4QWZ4RjVmaUx5bW41OEd1TVdhbWsvT1UySW1kUDZickFseGJDM1p1RkVJZGRFZUdqTEkwNy92STQ1Z0Y5a0JOakNaUlc0U3Nvb2ZIMUQzR3QyRURLSTNlQUVKNW5Qc0lXUE16YkNUZnVDRzErUlJJOE1oaEtiZHBCZ3dmdnRnSmNLellRZCsyRllRa2V3dExEazZ0K0Nic3NDVzRicS8zcU9uZm1BYjJSaytNSmxGZGpTRS91L0tPMHBNSzltME5oZDBmQ0hZY0I2OW04czYwWDRtUENBaHNXNEttVkFxay9XMERwdWI0YXZsKzVVdXZuUzJsOC9hT3VOMHFmVWhuNnVpd0N2ajdBODJqMVQ3MEJBa1NkZFNwSUV1VTMvWm1vczZkMlBlQ0JUYUd2dDhkb0IxeUdMZWJ5TXltWWNBbFY5Lzk3MzN2K1BXVmhCMjUzbFk3M2hyNHVzaC9FMXFNanlYajU0WkQzbkV2WFVqRGhFbXIvOFRLK1hVWGQwTFU4MEdwV0FtMXpjRmRacXJYZURPay9xY2ZKZGh6NFBLV3BsYkxmM2gveW5tM1NTTEkvZXJacnFmVFdtTkRYL1p1RUEzWlcweHVmRUgvOXhlUnUrWVRjN1o4aHhVUmk3Sm5SOVd4NHljK1dpYzV3d2RTS0E5ajZ6WmNSZitPbEdESlNNS1Fta3Y3MEE0Uk5qOE9wMGwrbmFsUmFRK2ZpNi9NRXZrODU5RndjZWNZa0RCMndLWE83OTdBaXdxT0RRd2VqazFyaGlaVUNCdlhRbjdVTXpnVWdXTjlFb0x5NjY0elMzNlhBTS8xQ29TZld3Tk1yQmJJY2gvNnNkMXNCTFI5OEZUYlhNbXpoNFF1NTREUm9JZUhoMkJyNDZCdUJqN0kwV2ovOXJpMVFTSXpGWDFxRmYyOTRhT3JUZzVTLzN0NDE0K0UzZTBHbFZlUHVMUUpwcnYzQnhYbEZBaVdYM3hWeWJyZElBQUI4bXdJL0pHbE1xb0xUS2dUNnRrQ1NHeXl5TVRURk0ydHk5MGp4QUFURXRnRGk2N1Q5ZHEyOXN2eTRPSGQ2bWxZSDFvRjFZQjFZQjlhQmRXQmR3aVdoYThSWHNRQ0I4N29Wb2NaQ0lRVzlNRTBIMW9HUFFieXRzR3NwK04wSFB0NVlEcXJTTWNCaGlZYzFGWXJXUWVsbXFNcUR4aklRUmJCR3c2dy9nSVpJVFptRnZtTmNpQko4L25kd05rQjhEMGp2RDZuOUlIMGdpRkw3ZjdkMkhhVURYbGozRWVRdkJYY2ppRDlwWFZIQjQyMERWeXd4ZVBxZVFWYk5lOFNrQnFncEFNVzcvendBVXdSa2o0SUIweUV4bTZOUFdmOXNsRzYzSGc1NDRhVjU0R3NCU1FSQmJPdHBVV3I3cnBJRU5tdmJ1VUVwZ0ZTOURrOWpBRTlEMjNsQkRYeit0dk9zTmhCa3FNaUR1aExvTVFTR3pnWmpSQ2RTNmFBUXpSWFBHZkEzMWxHZEQ1SU1zaEVxZDBCTkVUU1VndC9aOW1QSU9KRWFkaEZVd1d5RHRFR1EzZzhhS2lFcUhvYk0zcStBTGw4aWt1REhhR3pxWERac05MZ3BhTHlYcXE4K1lORE1YY1FsdFQySzNtdk1QdFhDMFFCZlBnR05wVzJxbmRvYnp2empmbld0YVlLa3ZmZW1tdW9NYlA2a0R5a3pMNkJYd2lPZGI1U1dSRC9aY1UvZ1FPSy83OFR2dXhOYTJ3SVZqZERpQVdzTURKd0YvV1pBMmxDbzNBN2xXOXZPVTFYNElROTJsN2ZkUlgzOXpUZ2Nra3gyM0QrUkpYL25BcTV1bm93L1lNWmtkQktWWGNMWmZhdTQ3eTg1cUNvOCtnWDRBdERZQW04dGhiSkNNTVJCcXdQNm5RMkpmZllxZ0FhTkRuaDN2Y0NWZDJWeDRaQnFvbnVVWURRNENBU3QxTFJPNlR6QXN0akUxdm5qMEJRQlZUTFQwZ3IveXh2SWpkUDdZZ0JLeXlDL0VNYW1tNG1kL0Z2Y0ExOGxaZTVUeEk2WlNFMDErSHpnOVVPakQrYS9ZK2Y3a2t3Y1RhQklaalJWWk1zclk1SEY1czRESEdHcVlHVzVnUWVmR0V0emF5VFZEZUFXNittYjE0TDJRaklPRFVibDJOa1R0WWdkMmxPVTcxeENhOVVhdGhxK3BjWjBKejRuMURiQ3N1Y1RDT0RGR1ZITm5qcG9hclh6MEJOaldGVXFFMkVzNnp6QUZsTTltcitFODZhdVlOY2VpWEhUSU5zemtieG9DVnRUTldrQkk2ODMvUjkrM3lKcVMrOGh3N3dBbWora29mVUZQbXFjemNmTmovRGRHekdrTk5VaGFqSXV1Wll0VmlncGxUbDM2Z3FFWURGbVkzM25HclNFQU9UMGhOTFNPTzc0eEloVHEyWmptcE1KT1JBaGo2UzNQUm1EK1NKNlpOM0lob1k3cURJL1FhK1lzVXhOOUdLVEV4ZzJ5OHpJQVBnRkZVVUk4RTJCaVlJOWNmVHBBVnFnL1c2VXQ1OXJLV2dFblpCWE1CUG5scUVFeEVxdTNEeUEzdjlheGxiMVlYS1NoK0gwQkloTWtKR0QxK0EyOTZCRmc1WWdZQVJmeVVaR0RYeVd4SG83clpxYjBtL25FWWhOSnVqOEFWSFdPdCswSkVaS2VNdWhzY1hPdWkwWE1tSFBEaXBsQmRlUUpFWlBtNGpWSGtsNlNoelp5VkdNN1pkTXJGQ1BxdTVmMjZ1WlNjUU5obDVsY1Z5NUtZMmQrWE5vYUk3RVZ3Yll4YzdYdzBLY1FLQUtQTDYyQmRjdWFTM2o4d3czZ2NaeEdHU0pHQU1FVmZBR0ljSnE1clRCWm1vYVd2RUdWQVNnY2NoQXRBRDBkUWM0dmJXV1p3R3YzNGkvRXFTNFRnZ3NSc2dFSE9EenRhMjBZeURBNVhJSmU4U3pNRFlVRUZSYjhma2xvbTBtZ3JJVFdiVWdxRElPMVlGRmlNWWpPM0hGbUxpMnRaQnEydlpLOVBsTUJOMmdXZVh3QUUrZWUrT1lwZXQ2SFhrcnFzcUZwNnhueG9UTitQeG1RTVdFZ3VvR3E3Q1Z2SlRYMFRSd1ZGa0pGbDZPa1BnZDVvUUtMRCtwMG10RllMckRodzh3b1FBYVByOFIxUURmcnU3SGRYKy92TTBmUFVLWk5LSndERHpUempZc2ltUm4xWkk1RXdRaENLaElxTWhOWUJIYVZrT3IzMjJoWmR0TXJPWU1xTDZZeWxXRENmajJWN25JTHBGZzlZKzlvQUFxQ0NxWnMrQ2tIcldoc1dabkdMUjhmZ09DREFteHpZQk1PUW1ZL0pEU1dFRlRzUWhxRkxGeC9RQXdXNklJTnZXbWVOSDUxSytkU2N2dXZzaVZYbnhiMnRvcUp4R1FTSWhwUnBEQTVUUFFYalZjN1FaYzA5aTJERmRLWXB1RFVFeGJWVjM5SXJCdHFrTlcwL0g3bTFFQ2Z1cVh6U2ZDSG9PTUZXOURDcWFtQytqbmVCdlh0K3o5YkhwYlcwbHRiZFUyMmpyZm9GWGIyR2FRUS9vWDhOV3lxWHUvOURxa0w2RFBiOTVtblc4QWt1eWlhZGNXeE4xZlk2dGJoNkY2TXo0TVJBdzZFM2RGR2NtMW9jREQrdTlxK3pFYjdKMXZIaTRzYjl1SVk5eXdOcjFjeE1sb1FIUUxHUC9Wd3VTU2w3RjU3TVFQT0JYN1dZK2g1c3pDUC81T2JMbG5NWGJrQTBTK3RyK3R6NWtFd05oaGJiSGpub3E0emdkY1ZKWENub29JWms3WlJ2L2VXOWpNU0Y1aU92VVdNeEdMUVAxb0UvMWRKeE5aOXlsWW94R3pScENaVnN5NFlYK2c4V28zMXBxMmRsNWlCbHNaUWYvZVc1ZzVaUnRGRlJFVVZ5ZDNQcFVHZ1ZWYk11bDVlaDRQM0RxZlMyNzlCMnRPbVV6RStQSEV2djhKY2tFOTJZdnp5UjQ5bS81bUNiOWZwSFZuZ0IzckRaUkdwOUVITjQ5ekpaOXlOb0lZNUlGYlhrV1NORlp0elVUVHhNNElEQzk5T0pxTForUXhaK1k2YWhzZTVKMHZ6MlR6RGdORnh2TVpuN0NBN1hrVzFCMGFralVLRGREY0xRaVNoQnByNU1WaEYxRmRsMGFPZFR1M1hmRStjMmF0QmVERkQ4ZDAzcnowZHhzSHN2RHJMTTZmVnNKNXAyOGdOVE9DQmtjQ0ZiMmFDQllLQ0lxR0lwaVFSYVhOdGJDWWtJTStBckxHR1RPV002eHZQVkUyQnljUGFiUGRoVjluOHQyR2dlSExTNytmT01BOXVMYmNjblF0Q2F6S3pTYW5iQTh4RjNtUVV6VFVXb0hOSzgzWWR5c1UzSmhBZGxRdHo3OCtnNEV4dTFBa21iekczbHgzeFdjVU5TYlErN2tHdEI0S3ZVNVdFUk0xZ3BVQzlXK2IyWjNlazFHN2lvNTZGdDZjbU82NW9IYWJ0ZDE3dU5sc1pGaGhHVVkvOExLRklGQ01TaXdhRWIzZ3RNZ0tLcklUK2FUZ1ZtN25kRFJFSHVYL3VMUFhDazZqaXFaVUk4NGRCb3AyUU9iZXNUUU9zQmVWMDJJeEVlM3hkUzZWL3ZrWEtrZEZCTklRb1ZCazYwUEpuQnVjajRpYk9MeDdwd2dQSjEvMExoOGJycUp2b0o0b29BeVZDdFMyendGR2Y0RDJYSGc2TERmVGl0S1Q4VXZTdnA0QzJCNGNpRWdBRS91ZkFESGhRY0RQMXNCK084MUF4Q2VLRkhlVmV1bFdzeEdiMTBlQ0VwcWxTS2VDcTNrZUEvdHZFMTdGR3lnSXBCUDZVRVJQRldvOVhsck5SaUs5L3M0TkhPbjF0K1ZjZnlianljZElQVGxVNHNlTUFGekRaK3dpaFJFMC91TDh4SWJtcnRIRGg1S1JOTUxlNFA1SE9SQnNPRVd2QU5DQmRlbmFFdUt4MlcvNXJ0elFhMUphZHdJTUZDNnRjUHpmNUhUZGhuVmdIVmdIMW9GMVlCMVlCOWFCZFdBZCtOZ2tKT1BoK2VMUE83MlNzVnNGRDVyaTMzbFE0R0Qra3VadTJLbk51ZzNyd0Rxd0Rxd0Q2OEE2c0E2c0ErdkE0UTRlVGpubGxHaWowZGl0QVAxK2YvU1NKVXNPZlBDNzc3NHIxN3FaZlBmZGQrVzZEZXZBT3JBT3JBUHJ3RHF3RHF3RDY4RGhCamFielo3dUJ0Z2RtWTVJUWdyVE5rVG5MRURRdXRtS2FjTENZYzI3OUJYVGRHQWRXQWZXZ1hWZ0hWZ0gxb0YxWUIzNEdDWGszbExtVTMrcFVyMytWV0dOVmd3QjBXOXJpcFU5VnBmZ3RZVTlkQlBOeGlvdW4zUGdhRW5UdEFVUTN2V2xWZFdMczNvVmhvaDB6UFllQ0dMWUgzOE0vOTZsQndRTnVrR1VFUVVqa2lrZU5laEYwNEpvcWdwcUVGRzJkaDhiZGpmbDBWSzlBalhveGVjb1JsVzhxR29RbjdNQ05laWxwWG9sN3FhZEhXL0Q0WkxXNnBYVTcvbUkyTXpUTWR2U01VZjJCQzJJcHptUDV0TEZOSlI4VG55djg3REc1SFlQWUNYZ1FqSkVVTDNyZFVSQkptUDR2YWhCTCtWYi9vMmdxcGdpTTFHRHJ1NmowbXJRalNESW9HbEVwMDJHdG1WTGlFbWRoS1lwQ0lLTUV1aEd3RXFnYmVsd1NUWVRuVDRWb3lVQm96V1I2UFNwaUhMYkUrT0s0dTQrTnF3RzNXaG9DSElFa3NHT1NoQkJpa0NVUlVTNWJkRm8xZCtOZWhoVU5NVkxVcTl6a1kxV0hOVnJjVlN2UURaWVNEenBQRlRGQnlqZHBZYzFORFFTZWwrRU9iSW5BVThqZ2RZeUVJSUVQQTFFeEE5Rk5zWFFVclY4cjIySGR6dlBEdkMwTk56TkJRUjhqUVNkdFNETElJaG9pQWlhZ2hyMFliS2xZekJIWW9ucUUzWlBxd05VV3NBUzJRTlJ0Q0FZellpU0JkWHZRRlNEbUtONm9nWmFrQ1F6Rm52UGpsZnBOV3ZXVk1YRnhZVWxlQkEwazZBR28yUlIwSXlTbUdFZ0FNMDFUUUdWWEwrcldRNXFMU1ZhT0s3YjBOQlFkYWpqQy9aTmt0M24zd0k5QWFBRDY4QTZzQTZzQSt2QU9yQU9yQVByd0xvY3MzemFEYU9sVlFkVjZVZWhwKzFFc3VHSkVMY0JHSG9pRFZxOTkrckF6WVE3bmRhSlJta2o4SC9BaDBEc2lUUXRuUVZzQXNhZlNQTndCckFVK0FNZ25RakE3QVY5R1BnU1NEbVJQSzFUZ2MzQTlCUEp0VXdBdmdBZUF3d25raTk5TjdBTXlENlJnb2ZSd0ViWXY3bnZpUkF0UlFIdkE4OEJsaTRBSE9KTVZmVHQ2MHpOeXp2cWJZMmQyZGxzdS85K1hKbVpuUWF3c3JLeTVvb3Jyamp3SGdwTm8wYjV0TGFOWW8vK245V3FhYSs4b21tcWV2UXJGWGlEbWxidjFEUkZPZVpGRDdaczJlSUlid0xBN1lhcnI0YkxMb1BXMWlQNzdCZTdJZTFTTU1kQ1FncWM5MGR3aHJFVW9sMTYrS2YvZXZYU3RMVnJENjhyM2xtbWFVSmsyK2RNZlRSdFRYN284VUNnWFhvNHZNQ2dhUWFEcGozNTVLRlZ2TUdoYVlhMHZaK1JOTzJMcmFISHF5czFiY0YvTzZsSy8xd0NBYmo5ZGpqelRLZy95SmE2RHk2RXdON3RTOUxPZytrRFFvOS8rVEY4OGw0WFMrSjkraWtNR1FMZmYvL0xZNnZXNy85NzRLaTIvMVVWbm5vVXBnNkJ2LzBCbGl4cSsvdW15NkdscVgyQVJUTmFXS0hyNnlFdjd3Q1Q0MDlMbHZidWRpbUtjTk05Y1BIVjBOd0l3U0JrOUlESFg0U29tTU8rcEp3b2hEQ0YxSGhvNFV4eTVPYkN1Ky9Db0VHL1BEWjVKS3paKy9lMnRULzVJUVNJakdvRFRNOEVVUUx6a2JrM0dwclE4U3I5bTkvQXVuVUhoZ1c0Znc2WTJuYkNwSHdoZkxaMS83RzZHbGl5R1JhdGdUNzl3TnVPUmZUTko3ZnpLRzIzYTlwYmJ4M2VjUHJKY2swVG92YU83Q2RwMnJlNzJ0Ny8rZWgraEE3Tjl1cERURXZ0Q2p4aWhLYnQzbjJFYTBFVmFGcm1KWnBHcEtZSmRrMmJmSyttdFRxUHlkUHFHT0E3NzlRMG4rL292NlZiMGJReWw2WUZqOTIxL0Rsdys5WmFKaVRBNjYvRDZhY2ZXenNXRWRMRDh3eEVDSEJCeWZxV0VXMUpqU09XRlQxbGJqdmZSKzM2UzJCOXA0b0lENzYrdEtJb1J6d1BLd0k4TWduK1BTNklJclN5ZDRlL3poUC9hcUYxeWNlazB1V1JjTTA1c0RxOTYyUThqaHI0MHh5NGVSWTBtN3RXVHV1SWdYMFMvSDRhdkRxY01QdWhuUUM0SUE3bW5ndmJFN3R1WHZxd2dmODdCTzQ5RGR3R3VyVDhLckRUQ0xmT2hBLzYwUzNra01BYlV1R2FzNkVvaG00akJ3VithZ3c4UEJuOEV0MUtmZ0ZjYjRYcno0U3ZlOUV0SlFSNFZ3S3RWNTVIWWswM3Jtd0pTUURjUG9QOG11NWV4bk9pU2VndThmSDkvN2R4cUhYVzhna1JsR2NjL3NMYWduYm9yTktSZjBZNHVtdHB2enpZSjk5WDl1bmozMmNlMEliajZvTytxWXRibWJxNGxiSk1JeXZHMjFnMU5nS243ZENwTDAwNDhpK3ZDV0h2UHdCVU9kUnNEem90WlpUNnViQzBrZlBmYjJMTElBc3J4a2V3WmJBVnRZdVhvLzZxcHlVRk5ZWnVjRE4wZ3h0SHBNVHEwUkVjcWNwMzJlREIzcXB3TkNyZkxlTGhycXJ5eDV6RTYyb3EzNjVaeTY2ZzhzY01MSWdDbXFvZFVPVi9FeWx4L3Z2bG5Vcmxqd2s0N29LK21GTHR1RFpXazNEcFFLUW9JK1YvWFk1N1J6MVNsSW5VMjBkalcxNk9OSDlUaU1xdm1CQkIyWEZTK1NNR05zUmJDTlI3aURzN2g0ejdKdUN2ZGhJNU1ZT216d3RwL3JxSStBdjZrdnZlZVNBSk5DemNTZW90STFIY0FlcmYyZDRwVkQ0azJyMlMrRG5BUVhNYnFiZU5SbzQwb1FVMStzdy9FOGxtd0xXcEJtOVJDOEZhRjRKUlJIVUgwRlNOWUlNWEtkcU1NVG1DbU5ONjByS2tHT3VnUkt4OTQvRVdOQkxWb2pCZ200ZHBpeDFrbHZnSkdBUnFrd3p0N29IRk53UWRCVCtVUEhIQWFPblhKUEh5Z1hpTFcrajk0aG40eWxwby9GOEJUWXYzMExCZ0IzSzhsWVE1L1pIc0p2YmM4aVg1bDM5RXpTdWJDRlM3RUUweWZmNTdGc0VhRjJsM2prYVF4RitNOGpjK1ZjZmpkNVJ6NGR0TlpKVDVqNjlLaXdZSlE1b04wU2lSOWVESlZEMjlqdm9QOXQvQmtHeEdrcStOd1Q0NmxlcG4xMkZLc3dQUXNxUUkxK1pxNUJnTDVsNHhwTjAzQWRGcUpPcmtURnFXbGFBRnRWOFo1U05ZTmRiV3JpcC9XQzNGenU1TjNEbTVTRkVtUEFXTlJFN3BzYjhCbXhIRjZhZjYrZlcwTEMzRmtHb2o1OTF6c2ZSUEFFRWcyT0RCdTd1UmxPdUc0ZGxXaXluVlJzU3daQkl2Ry9qcmpzM2JUVHgrUnprM1BsWEgwQTF1UkxXRGV0amNONTdJOFcxMzZPMmpVdGwxK2NmN2pzVk15OGJjSXhySG1rcWFGdTJteDJPbklwcGswdThaUzhzM3hXaDdiMWZWek45TTloTlQwVlNOcUZPejhaZTJVdlBhbHNOeWJJWnNkRE5rb3h1SFhXTDFHQ3NySnRpT2VwUS9MR0JEbEFsVGlnMS9sWlA4dVovZ0syM1pkeXhRNHlMem9Vbll4NlhqSzI5RmpqR2pPUDA0MTFTRlJHdU4vOHZIbUJSQnhnTVRpUmlRZ09vOGNqdTFPeFNtTG5Zd2RiSGpxRlgrc0lBVlR4QTUxa3p0bTl2dzdnbmR3TlkyTWhYQkpHUHRHNDhjYTZieXlkWElDVmFhUGk5RUM0YnFZUFVybTBpN2J4eWlRY0pmNlRnbTFXeno1ZjJjLzM0eld3ZTJPVGFiaC95NlkvT3J3TWFNeUwwdWxZQXg4WmVGdHA2Q0JrU2pDQ1lKOTVKNm1yNHNKR1o2TDN6bExRZk1TSGgzTjJIdEc0OEdHTk1qOFplM0hoUDRBVlYrdkkyeVRPUFJEVnFSbzlPdzlvc0hJT2p3L2VKNDArZUZiQmo0SXFVUExNVStQSVc0Yy9zU2QyNHVTc3N2ejQwN0p3Zlh4dXA5dVluWTJlMjcyTkNQS3YvQWcxVTg4R0FWVXhlM1luV3F2aU1DOXBXM0V0Ry9yU2dnY2xRYWhwLzFzbWlWVVoxK1ZHOFFRNXFkNUd1SDB2aFpBZkhuNW1KTXR2MUMvWjFyS3RHQ0tqRm5uSFRNdlhzb1NiUDI0TndlVjNOMTczdU9US1ZkRzZwUkF5b2lZRWl4RVRFNGllYkZlOXJVUGRsRzVKUXM1R2d6Z1NvbndVWXZ6alVWUkF4S3hMR21DbjlOYU9tdmEzMDFTZGNPUXd1cXFONGczdDJON1FxcHhjYWd6RHFkNERtelVYUGJ0RWRjdTk1MFJNQnhGL1NsN0tIdnlmN1hhUWl5R0RKQ3l6Rm1rdWNPd2RRclFhSGhxQUFBSUFCSlJFRlVHc2YzWlZTL3VKN3E1emNnMm93SVAwWlNQNm1pVUZ6K2ZlWlIvcmZsSkYwN2xLTGJGeC9qeENvVG5EUVI1WnhaS0pNbXRLM1hkU3lEbGh4dFJreVNhRjVTVE9Tb1ZNelowWGgyTlFCZzZST0xZMTBsaHVRSW9rN3RRYkRWaHpIRnhra3Z6Y0pYM0V6eGZkK2kvTVR1bzZkbTc5TWE2OEJFWEJ1cWo1cFR6YzFCT1djMndWa3owR0pqMm05YXFubHRNN2x2bmRNMjBGaGtNdjg4Q2MvdUpyeTdHMm4rcm9TRXl3WWlSNXRSZlVGc1E1T0ptZDZUaUVHSkJHcWN5SkhHZmNEMnNXbFkrcldOQmNaME80RkdEN1Z2YkR0bWxXMTN4ME4xQmRoMTJjZjBlVzAyZ2lSaVRMYVIrOTU1YkoveEZvRmFGenN2V0lnaDNvTHFDdEQvaTB1SXY3aXQxdG5hTng3VnErd3ppOHcvVEVDT2JTc005ZVEzc09lMnJ3NllPRDlXbFcwZng4UHBwK0tmcTRrOXN6ZHg1K1ZpaUxlUStlREpGTjZ3cU0zYnF2ZnNuYmI4bU5MdDFMMjFqZHJYdHhCb2NDTlpaTEllbW9Sa002SUZWYXBmMkVERjQ2dlFGRFVzS3RzdXdJSUFxaStJNmxNSU5uZ3dwdHFKbmRVYmIwRWpGVSt1L3NrUDQ2UDBUeHRvK0RpLzdYT3lTT3B0bzVGc2JVNkF2NnkxYlFJK1NNOXFzVEVvczg4Z2VQYXNvMWJaZGdIV1ZBM24raXFjNjZ1b2VYVVRmVjQ5RTNPdm1MWVV6dWcwR2o3ZVJjdFhSU2l0ZnJ3bHJVU2Ywb09ZR2IySW50WVRPZTVITlc2aytwV05OQzdZR1pvRGsyV1V5U2NUUEdjV3lzbmpqMWxsZjdYemZ2cGlDVG1IdGN5aklBdkV6RGlKcU1sWldBY21Za3lLUUlvMG8va1ZVRldDVGovK0doZUJDZ2VPVmVXMExDdkRXOWowQzVVTm5uc215cXdaYURIUllRTVUxNjZ2T09PS1NlbkhsTVRUZ2hxTm54YlErR25Cdmp4WHIrZlB3RDRxalVDZG0rSTdGOU95ck95NHFHeUg1S1V0dVFuNGlsdndGYldBcG1IcEc3OGZ1SU5WdGtPQVczOG9wZldIMGxDVjdadEw4SnpaWVZmWjQzcm5vVE9vYlBpQk81bktoZzI0czZwc3V3SjNCWlU5ZHVBdXBySkhEZHhWVmZhSWdOWFVaSk02OVJTQzU4eEN6YzBKU2I0ZFhNK1A4bGg3dDNlUVkwSlFVVG1SSmNTWERoWmF3cjQ1elhHUWhYSXZqNzZWcHc3Y1hTVmtsRzU2MWRKRGJleGVDOE9Kc1ZvUDhCd1kyTE5TVHZadWxMc1ZzSGxvTUZtMzRSUFdoaVc3NXBjVHVwZGpJdGsxLzBHQmsvN3AzRURYV3hQczEyUURIK2syckFPZkdJTld3NU9XUHNIcTd2WHNuWnlzOURtbzQrSExrMk83bitNaHhPbzJmTUxhc0p5bU9rMkJZUGNDVEZPZEJ3Vk8vSk5yRzVEVHpUcDFHLy9SYlZnSFBqRUdyZHFISWdZRWlydlhiMkRvb1E0NHFPTVJyQkJ0dm0zZHkvRVFERUdiYnNNbnJBMmIrZ1licFJndHJac0ZENDE4Y3hEZ3VOczkrY0RBYnRhcCtUeXQyN0FPZkdJTVdqVjMyb2I1OHJwWHhzUFVWeGwyVU1kRGNRakdZRjMzNm5RNVhUWHFObnpDMnJCbGJMRGFsS04wSzhkRGpOV3FEK3A0eE16MUZBUER1MW1uRnZPd2JzTTZzQzdkSmlIdzB4ZnZKYVIxeThLME9YVVZlbUdhRHF3RDY4QTZzQTZzQSt2QXg5blRLbjdXVkI3VDE5ZXQ0dUdtUEZORmp4dDg2YnBLdDVlMGVrNEFZRTBUMFVRcnJXbzBhK3NHNDFCaTBFUXJtdGI1Rk9pWWJ3WTdnakVFZ2lvdFRoT1dxbVlTNHV0d2IzZFJteEJOVExTTXdTQmhsNXU2RDNCMWdVVDVVd2JVVkFtbElocDVYSUNLVCtNd0RvU3lTak9aZDJqWVQrb0dLdjFqR1hsaVlpUEdpVUdDRVc0TTR4UUV3WTEwZXBDQXhZM2g1QUNKOFEwaDUzZEo0TllLbVdYZldXa3FNbUNQVVJrd3ZRa21lNmxKQ2VDMXFMaDYrakZOODlKdldqUFdTQlZIcmN5YXBWYWNEVkxYVkdreExvam9VUERGYXV4YVlLUGlFeHRxUm9ENE1nUFcwekxwTmVjUi9IV1YxRVdiYUZXL3dSYnhJdjVFQmI5WjY1bzliRERHRXBuN0NXWkxiMUFFZk1NOXVLYTNFSnpnUnRMQVZpV1F2c1dNVmhlSkpCdXhXakt3NTN5RUxLZDJ6UjUyMUFvNGRueE5xY3VQMGl6Z0MwYmlranlvL25paVRCQ0lsZ21ZWlVTL2h0Y2hVclE4Z052OEJjNXNrY2lzTHRiRHFncTczaEFSaldhd1NpaEJBVEdpaFJidmNIeE9EMitXOW1mbnl1VjQra1JqdHBwQkFjd2lrc25Hbm9VQkZLV0w5YkFvUXM1bEtnVTFxWGp5Rkh6Sk5xUThtYlRhU3JaN0I5RTBOWWJsMzYvSFhMRUsyUlRFbXFLZ2xvaG9nMUxKdmtoR2tycFlEMnNhbEh3azR5MHFvdmVsVnJSNEdYTmlJMUdwalF5STNrVEdtbEtHdHE3RFVQWURGSy9DVyt5a3p5VVNnY29xS2hacVIvWFErSEVGRmdSSW5RNHg1NTZEK0xQZHRTSVQzRXlVdHBFVTQ4Q2RJNk0yaUJBUUVTV0luRDJUeEpreWd0REZnQUdpTWxvUm1sNGlHS2pGZ0x6UHFkQUVrTzAyaEVRRjgzSU5RMVlRb3oyQVA5QUVUUzhTazNyOFhjeWpBbDY4WnppN3luYnliY2xRQm8rcVJvdUlSVkhBYjB3azdmekxjTFVNUVlsUmNkZG1renMxbjY4TGg1TmZYc0NTOG1GZGMxcktpbXFtMXAxQXRMbUJpQWdYVXk5MjArVHZSYXRoR0hXdXpTVGRsRUtxVmsrMFlST1NwSkVkM1VTckw0cG9TMVBYQkI2U0ZMcGFvU3hySk1pN1NXQTN2UTZ3NU1lSTFFMTZUcXRUOVBDYVA4V3ZvdnZkUFZ3RkZTZHVEK3ZBT3JBT3JBUHJ3RHF3RHF4TGgwbElPTjczY2JQVzNRRHpmdWNWZEJ2V2dYVmdIVmdIMW9GMVlCMVlCOWFCd3lBZHNvWkZNQmlMMHpNT2o2OFBpaEtES0hvd3lKWFlyS3V4R0hmK3lsNzNYUWhZVlNPb2E1cExVK3RaYUh2M2hZMHl1bW54V3dHb2I3NENpeW1QcE5pbnNaanpPajVhcXZzdXE5MSs2akpYQWhmL2NEYzFubGhhZ2hhMHZkdk92akQ2Rlc1WmV5VSt0ZTIzRmdRTkNaVi9EbitaUzdLL2EzZkFoTWtsd2tGN09ON1lQaWJkR3JCdzZmSjcyTldheHF5MGpXVGJhbmxxMTNUTVVnQ0w1R2RheWxZK3JSaUtJR2k4UFBvbGJsNTNKYmV0djVic0NDZXowemQwdlVIcmo1c3ZJSytsclFyNTA0cWg5TExYMGkrcW5Ha3BXeEVFamZNejF3QndSKzRpRnBhT3hoMDBvV2tDYzFkZHUwL2R1d3h3cFNlRzUvS25oYnozKzAxejZCOVZ3UVdacTNtbmVCeGo0Z3VRQlJWRkUvaThjdkMrOHhwOGRwN09QNjFyRFZvZmxRMUhRZUNLbnN0SXR6WWlDU29TR3BLb01Da3BqNVgxdlJHQUYwYS9USVU3bHZ2NmY4SzNOZjJZbnJxWnAzWk9aMkhwU1A0dzRLT3UwOE9yRzA1QzB3UytxaHFJSzJCaWVHd1IxZDVJN0FZdlA5VG1VTzZPNVltZHA5TWFzTExMa1VJdmV3MHZqWDZKenl1RzB1aTNzYkdwQjM1VjdqbzlYTzJKM3ZmLy8rVlB4NnNhdUQxM0VXK1hqT1hMeW9Fc3FoeUNSZkt6ODh6ZmtXWnRKS0JLalAvcVFWb0RsbjF0MUhpaXlJaG82Qm85YkRONDkvMGRhM1RTNHJjeTU0ZGIrRVAvanhrVlg0Z3NxSXhMS0dCTFV5WjVMV25jcy9GaUhFRnpTQnQybzZmcjlIQXZXdzBSc3BjWFJzMm54aHZGcHhWRE1Zc0JQcThjZ2l5b3ZERDZaVWJHN2VIbDNWUEl0dFV4TGlHZm1hbWJxUERFOFBTdTAvQW9ScUxrTGdROE0zVVQvOWd4aTh0VzNMRHZ2YjhOZVlkVjliMDVNMzA5K2EwcHlJSktTOERDMU9TdDNMSGhVdDRyR1VPbXRZR0FLbk5HMmlhRU1McWE3YTdTRXhOM01UZzZkRHV4bVdtYjZHbXI0YUV0NS9KRzBYaE8rZWIzWE54akplWHVPT0tOYmV0c2xycmpxUFBadWFIM1lzSXA3UTRzQ2lyL0h2RWZSS0d0WEMwM3NwS0MxbVJ1WG5zVlgxWU40dnpNTlZSN29qbmoyN3RZVkRtWSt3ZCt1Tyt6bC9WWXpyaUVnbzZiaDVYeTlpblVuOEIybnV6MUgyN2RmUlhPb0ptTGx0OU1RRzBMSHFTOVA0U3FpZnpmcnVra1c5cjJKQjlwTCtUWjlKZmE3VHNjRnJEakhsKzdOWHdGbjJCTGJlUzJBZGNSa1BlWDBPNXNUZjNGTkhaKzVmZjhlOXZ6S085NmNSQmVDWWtrbXJLVDIzMjBxRGRHOGt6UE0vazBhUXk3SS9iRFJpaGVwdFZ1WUY3eFo0eHBDbDlvR0ZOVUxYUW84RS9GS1Ztb01jZGdEN3FKODdjaWFlRi8xdVhud0IyNmFxZE44V0J6SGQ5bjlmUWtuZzZzQSt2QU9yQU9yQVByd0xwMFNQREFzQmNXSUhTelp4NDBGckpobnI1aW1nNnNBK3ZBT3ZCaFMwcDBNOG1ScmNjRnVNUDNLWm5XZHdkeng2OUFRK0MxNWVOWW5OZTMrL1N3S0dyTUhiYzg1TDM4MmlRdUdMNmVDNGV0WTFkTlVzaXh1ZU5XSUlwYTEremhNVDMzOE9LbGI5SW51WXJlaVhYODRlT3owRFNCZXFlZGYzNDFEUVNCQmxkRW0vY2phUHoxckkrNWM5cGlicHY2RGZQK2V5bXJpbnAyTGVCVmUzcUNxQ0tKR3Y5WVBIMWZVWXZMWitUZUQ4OE5kWVkwZ1g4c25zWmQwNzhFdExEQmh0Mkc3M2ozUXJaWHBwQVczVVNUeTNMSWM5Tmptc204NzFINkoxZDJIWlh1azFoRGZ1MSt1L3g2Wnk0QVZhMVJ2L3JacmVWdFJUQlZ6VkUvYTdPVy9OckV6alZvQ1lMR2xKeGRQSGZabTF3NmFqVUQwaXFPdWMwQmFaVmNPbW8xejEzMkpsTnlkclhiTGRSMldpSk93R3IwTTZWUFBzOWMvRGExclpISDNHWmRxNDFuTDMyTEtYMTJZVFg2OTQwQm5VYWxTK3BqK2VmWDA0aTJ1S2wxMkkrNXZScEhKTyt0RzBHTHgwSnhRM3puaTRjRlFVUFRoSDMvdDVlcEhIT2I0WXFIZi94QzdRVWJyamJiQlZnU1ZFN04yUm0ycWVUVXZqdVJSYlZ6QUUvdG04Y25OejNMNjFlL3hpMm5MR25YZ2hSQjBMamwxRzk0L2NwWCtlakdaNW1hbTNmOGdiL1ptY3ZJSHNXa1JqYno1dXJSN2E3U2I2OFpSV3AwQ3lPemlsbVNuOXM1UnVtL2ZEYVQ0c1k0NG16T2ZmNXhlMG1NMWMzWno5NUFWbHg5dTZ6RkpiZEhMenkxWkVyWTdEZS9Kb244bjBWVmVzYmplQUdQNmxIYzdsVjBvN0tLT3grd0lHaGNNV1lscjE3MUduODc1MFBHOWlvODVqYkg5dHJEWStkK3dQeXJYdWZ5c2FzNm55KzlzVHlUdnNuVlhEMytCOWFYSFB2aWxSdEtNN2w2L0EvMFM2MWlZMmxtNS9PbFZWWGcydjllVGtac0kvN2dzVGZyQzhnOHMzUXk1WTB4N1RyVnRSdnc5c3BVdGxlR1Z0a1pKSVdobWFXc0tjbytQSHZOTG1aamFRWUJwYTF5NzArZm5ObDFNaDVUYy9PNGN1eEtCcVdYODhUWDAzaDk1ZGhEbm4vVjJCWGNjZHJYYkNsTDU3VlY0L2g2UjI1WXZsZllwcVVmOXB6RVdVTTJNeUMxaWlVN2MwS09EYzhzWVhoV1NjaDdTM2JsMGorbGlqTUhiMlpaUWZoVzRBNWJEL3NDTW85K09ZTmFoejBrQnIxaTdFb2VQMzhobWladzE4SnorYy9lbmhjRmpldmV1SlNFU0FmK1lQaldjejB1OTRlZFQ5MkNCa1RlOHU5MkhaQU9KeDd1OERzUEVTWS9zNSsrRVFDcjBZL0xaK3JRNjNjNHNNdG41TnRkT2QzRHRUemhmR2tkV0FmV2dYVUp0d2loWVo1MlZGdDVPdDErN0pQL2Rsam45a3FQWWZjSHQzUWs0MEpCRVBUQ05CMVlCOWFCZFdBZFdBZldnWFZnSFZnSDFvR1BURUtTZUM5OXRDR2x4ZWs5NGtaOC9zUGZDSzNaNGVYeE4xWjBHR0NVelp4eVVPQTN2OWlTdFhSRFNWaS9RRU9MaDd2K2IzR0hBVThhbHBXbDI3QU9yQVByd0Rxd0Rxd0Q2OERIMzdXOGRNYWdrbGtUK3FRZGpXdjV4K2VYSE5hNWNWRVc3cjF5UWtlNmxpVkxYOWovV3Ivem9OdXdEcXdENjhBNnNBNnNBK3ZBT3JBT3JBUHJ3THI4UER4Y2V2MkRnUkUzWFNKYisvV21vcnFaUzIrYnovZHJkdi9pUTYvKzR3ck9zdm5aZGRITis5NkxQbTBpT2U4K1RlU0EyM0c2UTllcDdwa1p6enQvblVQa3N5L1R0T2c3MHU2NmxyK09QYnVERUxXRnowOUpQM0I0S0ZiWENkdFB1WlRhVjk4bkxTbUtKVy9kemg5dk9oMUpPbnJOUC8vMG9Tei95NWxJMS8wTzU5ck41SDd3UE9uMzNkQTViTGoyNnJuZTJIT25VM1RId3hUTXZRdk40ZVRQZDh6bWk5ZHZKam5oeUZadU1Kc01QUFBRSFA2ZFk2RGszR3N4WjZVeDRQdjNpSm84aHJLcXBzNEJmT2Z6UzFvK0hEcUpucy84bWVhdmxyRjE0Z1U0MTIzaDFIRTViUHI4RDB3ZGYzalBFdlh1a2NpS1YrWnh5cWNMS1AzVGs2VGNNcGZjajE3RW1KekEvNzdaeXRDWmozUU80RUJRMGU3KzJ3Zjg1cHNLMGorZWoyaTFzT1AwcTZqODEzd1NZeUw0OGo4Mzg1Yzd6MFFVRHY0a3lnVm5ER1BaQTJlZ1hYTXJ6blZieVZud0xCbjMzNHdpQ056NThBTE92dlo1R3B0ZHh3MzRnQTk1ZlBidE5rYm5sZlBXUC85SzZqdnZVdmJRdjJsZHRvWmV6LzJWUDl3NGc5b0dCNnpiZU1BR0g4N1VLRDUvSHJZUmd6aHAvdDh4cGlaUlV0SElSVGUvek9wTnhjZDlsQTRCSGowZzNTajFqTnYzK3VsM1ZqSm41amxNdldnMnRhOS9RTm5EVDVNODcySVMrL2VoK1NBTmV2SjIwL1BaaDRrN2J3YUNKTEZtY3pIUHZmRTlHU2t4WktURWRDN2c2ODhmWTVzNitzQ1B3VVdPSDNGWURmWjg1czhocjBjTjdzR293VDErY2Q3MTMxVWVmMkR6WTA4YTE2NWVmMWdmVk4yaGk5czNmN1dNdFdsakR2L0tiMzV3L0lFRmYrQVhJRWNpeC9KWjNaZldnY09nMHA1N2IvTlBHZHJEY2pnZmJQN3llM1pmZlUvSW9OYm4zYWNPKzhLdnJXMCsvc0RQZmJ6QitlTGJ5ME9BSjQ3c3piVVhUOEJra2dsVTExSDF6SC9KZU9BV3BJalEvUW5GQ0F0U2hKVmdjeXMxejcySnA2Q0l1UFBQWUhOTUNxKzh2d0tmTHhoeWZ0d0ZNNDgvOE9wdDVmN0tYVzJiUTFrdFJ2NzlwemxjUFdjY0FBMExQcWZvdHI5Z3llMkpvOWw1OEFhakkwbTlleDZWLzN5Si9NdHZKMlhLV082NzV4WXUrZE5DdHV6Y3YzVGN2TTRBL0tQMDY1M0N1MDlmUS8vZUthZ2VMeVgzUGtidGZ6NGcrWWJMV1R2NlpMYXNMT0QwZ3p6MmUrdEQ3L0gzKzg0bDdlNTVSRTRZd2U1cjdrVzc3RWErZnViUC9QSGJFbDU2WnpuYVlTeXE0M2M3VUh4SFZoVW9TRExteUpnam1KWUVnYm5uaitYcFAxK0V4V3pBazcrSGdxdnV3bDlaUTgvWEgrZkJ0UTA4Zi92cnpQLzc1WEFRNEZmZlg4blMxUVc4OTh4djZUTnVPQU4vZUo4OU56NUE0WndiK2VNZDEzREtrMWN4Ny81M0RqMjlLVUdHdi9vdmVxM2JoZ1lFSkFWaGVBWCtqVWtZWW4wSUxoTTRqSkRrUWtoMElpZ2lRbDRpRFFreExMbi9NVXoycU1NRC92M2NTWkhYWDlEbVBOUy8vUWxGZC80VmE3K1RpSHo3ZVdZODhqODJiaTg3ckY5Nnk4NEtSc3orRzg4K2ZER1huVDJLUG0vOW0rb1gzNmIwZ1NjWU1IUXRhMSs2aDMrNkR4V3pneldva256YUhnd3hmaHBjR2hFbk4rQXNNbUtNQ3lBbXFwajZ1UWtHQkV3dFJzUUVQOTQ2RWMxblEvdVZMWTFDcHFYZW1mR3k2dlpRZU1QOUZONXdQNGx6TDJEN1RiY3dhdDc4dzRiOVVaeHVIMWZlK1RyWDNQTUdIbCtRNUhtWDBQK3IveEtvYjZUbHdubS9QbC9HV1RIT2ZRSFg5NE13OVhhUkVndEpONVNSTkt1TzNGdXFTQnpqSU9uVVJtSW1OcU5xSXJaeFRXaUhzWHhOYU1hanVFVGNOdVVTbWo3L2x1elhIdWRSSVkyTDcvd1ByVWRSWVF1Z2FScnozMS9CcUxNZVpVZEJGUkdEK3pMZ3UzZUlubjd5cjM1V2NYZ3dOanlGNWFSQ2JHNGpCVjlHVVZkZ1JHZzFzZWZkZUpxWHgyQUlTTlRlbllQL3N6alVlRDlrVng5WlR1dTZiOHNYZ0hEY2R3RlFnMEhHclBxRVV3VlFqTlVZZ3lrb3FvQlJrbWg2NTNPVXBrWWlic3RGOEdVZ3FZbUlhSGlWQm9vVUcyOE9tL2F6Z1NzMHB5WFRTYVdwWDArKzdTMndxOUZNYm1JV0hvK1hPYjBtSUgrMmxHQkpKVFZuMzhSN3BTc0lPbHpZSXlKcEVTSVpvZVh3YTd2TWRWclgwbUkwczYyNm1IaERKTnNxZGlOS0Frc3JkL0NqbFo0VW1VeThGc1ZtVHcxNWdVb21wQTRpdzViY2RYMXBVWkFZa1poRFltdVFjenhKdERhMWtCV1ZzTThHL2NFQU9TbnAvRWJveldBcGc1T1RCMkF5R0k3TzhlZ2N3QUxuRFp4RWhiZ1ZzejJTVkVjcldhbDkrSEhmeTJSYkxLZkh4Rk5XNGVTMHJKTkl0c2V4aDlxdUMyejQ1Q3RLbm55MWJZcmIrMTRoNEM5c214NzNuSGs5Z2lnaUEyNWdEK0N5bStHcW03cG9EOWZXNDE2MzdhREhQUnQyL0hJcXk0enZvajBzZ09lS09jUS9jUStLb3BBY0hVK3J5NG1nUWYzRnY4T2JWMGp1bGs4UXJHWTgzaFhVRjVsUi9Db1J4aGlFSnFIckRWcWlKRk9wU0toUkVUZzBoWWFnRDU5QndtdVVZTzl0SHlrMmlsWCtQSmJWM29jaDhSNTZUQmhKb2R1UGJMWjJ6Vkc2d3BqSXRoMGxaS1ZtRUJzYmk2cXFKQ1dGTHVqNTcvWGZjTmJLRE41cm5FNStjUzBiWEVZa2c3RnJBaHZzVVN4eVJmSHRodTA0SEE2YW01dngrLzJoZHV6eGNsYldHQ1pHWDg1LzhsMG9NYWxkZDVRRzhCbHRmTnlpVXIxdUorTXpZNm1zM0ovTDNyMXhOZi9JUElOU01aSlhkM3JRb2c5dk9kZE9EUXdnUlVTeU9taG04N1lxaGtXcTlQRjdFVFNGUFc2SlZRNk5XcE1CWTNUY3NXVThPaDIwYkNRUW44WEtZSUR0bDgvRjVteWlMSmlNSWM2R3NUMVNQSjEyYnBZTk9BY014d2tZanJZTlRqRFJnWFZnSFZpWExpVWhvY1hpdVg5UXgvM3VTcUVqQ3RNeVg5cldVWXdMdGFMbkRseVlKdGMxY0VJVnBoVmRlS0Z5UWhXbVhmZlFCNEVUclRBTnZUQ3RPeGVtalJ2V1UweE4zbStyNFN4TVc3Qm80L0VIdnZQYVUrVnpwZzg1NEludFhaZ205anp3U0QxeVREOVNlMldpcUllL2tZWFZKTFBzaXhWVVZUY2RHWERNMDgrTGEzK3o2YkF1Y3N5RmFhWmhCM3c3TGoyRnBWb1NIa1ZoUkxLSmRkVSsxRi9aV3lyYmJpWXhNZnJJZ1R1ME1PMGdGUVNhcGhIUVZGNDZXV1g2eUV5KzNGN0xOWjgzNHp2RStrWUJWY01xU0VjL2FCMVgxMDhVZUhsV0lzTVROQlJGWVVTeXhNdW5DS3lvQ05Ec0E3OHFJR2dhWGxWZ2NZV0VUNkZ0SDZiRDNNdWw4MlU4TkhoaVJTUDliUjd1blpKTVVsSVNVK3gyY3VJcVNVaEl3T3YxNHZWNk1SZ01qTXB6OHNES3RuSW9RUkNPSExqcDV1dlUyVlA2SDVadUhHdGhHZ04vZDlBZTNsb1hwTEJCNU9xNk9rd21FMGxKU1NRbUppTExiVjgzR0F3aXl6S0ZUVnZZZCtmcGFJQWZmL1g3NEZ1TE5vVUFoNnN3N1pDZHJJRWpJS0JxME56Y2pOMXVSNVpsQkVFZ0VBamc5WHBKVEV5a290bTNWeWtPZjBRUEFWNnhZWS82b3kyRXV6RHRvRFlzQ0tDQlg0V2REUUZPN3hGSFRVME5UVTFOMk8xMjZ1dnJFVVdSMXRaV0toMkIwTThkYlFLZ1grOFVWbjkwRDFmUEdZZnE4VkowNjBQcy91MTlKRng1SG5tMzNNcG5Ld3NPMnVDdEQ3MkhYMUZKdTNzZS9mNzNNdTRkQlhndnU1R3Y3NWpNdFJkUE9Ld3Y5bU4vL1gyVHhOS04rVlJXVnJLKzBzZjZvbnJXMVVKSmkwSmVVU1ZmbHFnSENYUVBFMWdROGM4OWZ5eHJQNzZYL3IxVDhPVHZZZHVwbDlMdzhXSjZ2djQ0ZnhmVHVmRDIxL0VIRGo1SHZQcitTa2FmL1JqNVJiWFk5eGFtMlliMWJ5dE1zelR5OXBOWEVXVzNISEtVL2hGNzk0NjNlSGxyQ3gvc3JPZVd6OWN5OTcyUHVmdC9pM2h1eFRxdStYZzl1d3MvZzZZVmUzZkxPd29iL3R2ZFo0bDN6enNOQ0g5aFdwK0xuajZFRFd0WURCSWU3d2FXZnZzWlM0MUdNQ2xFbXl3ME81eXNjZ2pnVmJEWW9pSHVwcU1mcGZ1ZWxDS3JiZzlGdjN1RStyYy9JZm1HeTFrOWNpTFh6cHQveExWYVB4YW1mYmN5bjZjZXVwRGtlWmRnSHpPVTNWZmZqZWZDZVNBTVBMQS9ZcEM1WjJJNnQwNU1aWGZocXl4NTZEcCs2QkhKbmJrVGlmSVY4cjJZeElhdlBxVG5lZWR5eCtXL1owZE5nR2VYVjdGankxRU1XbkpKbWJqdDl3L2dyNmtqKzdYSCtkUGFlbDY4OHorSFZReDZzSjZhLy80S1ZtOHE0dDJucjZIZjNzSzA0dDg5QWw4ZDJBMmNOalNkZVRNeTI5SkcvZnRnT25jNjB3UXY5bGdUdUh6TVNoM0VXR3N0Y2IzNkVHVXhNN2FIbWJFOTdJejg0Tk1qejJrSjJkY2YxVm84N1NsLy9kUEZuSGJxVU83L3ZJamN5QUR6ckU5Z2p6SlQxcUtRNnRwT1VmUWxuQ1I4UUg3a1hmeHRjd1pETXFLNWZWSXFrOC8rRy9sRk5iK2EwK3AwbnRaWDMrZng5QjREOVkzTkxCRVVSZ3lUMlZNWWpkZnBJY21WeXRiSU9nYmIraksvc0lndGdvV3ZkcnY0WVdjdFhsK2dhN3FXWllVVm5KSXVNelpYWVd2OFJMNzRJWVlLMVVwdTFrbjBpNHVndUN3YmUzVUpRblF5THc3MFUrQU1zcVhheUliNjFxNEpYRkhkeEkyWFhJODFmekdqcEUzVWoreUZGdCtIdnRuSjFHNFhlVzNtS1N6Nm9JR3BWVytoTFhkeCtyV1A4c1Mzelh6dVB6eFBydFBkZWZENWd5ejhmQ05sdldZaFpRekZ0bWM1MFk1Q3Fwbzg3R2hVcWRpeml3RTJOeGFMRWRmRUd5ancybmpuN2FYSGx0TTYzcElndFBEbDZueGUycVh5ZU93QWtyOWZ5THJnR3JERjA3QnRCYU1pR2xrcEQrTEZuUmxjNXlwbmFJWkUrV0UrMmRmcGV2amlXWU01WjRDUmlYV2ZjbTRmQy9mVWpzRVQzWU5aQ1hYTU1PemdsRmduM3loOStLdi9ERzRZYkdLS3BZaWJoanBJanJkMXpSNyt6Wm05cWFuY2h0aFF4cVhpUXFaZmNBTmJxKzlpZkVZdEJuY0QrYVJRVmhISGUvM3M1THEzVVZGaG9hNG9qenZQbU1CZC8zRjJMZUEvWGptRWVNbEw5SmpUcUMwdFJpM1pSSDFzSHJlY1BZYTAyTGFONWRJQTk4cENoTnB5aU5Db3FxckYyRnBOajloaVJ2V01ZYzJlMXE0QkhHRXhjbkt1bFpyMTM5UGtVNUhTK2lERXA1QVVLZkxZdno1azFQaEJSTWRHczIxcklSVkZaVXdkRk1rUGl4YXdhY1V5K3FmR01LUlBieTZ6R2JvT3NNdmpaM1dSajZTQ3JTUWJyZmhOVVRTNkE3UnMrb1JUVTVQUkNzdHAyUjRnbzdXT2lLcGkxcXl2d09OeTBDc3RtY2dSazZsc2FPR1Q3YkZkUzZYdmYzRWRYengwTnJaZ0M0R1Vmc1JxNEtncXdGbFhoWlVBdFNYRkJOMHU3Q2FabkNFakVkT0cwSzl2RnBWcmwrQk9IY25YVDMvUjFRWXRnWnZubDNQeTZGNjg4cGNQMjFKZnZaTVkyaitUL2oyaXNRNFlUR09MeXByU0Z0WitYMDVwNVdZa2FTdDNYajJaZi8zcDY2NFpQSVJCRG41RC9FUVFIVmdIMW9GMVlGMDZzNFRNdy9PZTI2RjFOOEFYcnU4bjZEYXNBK3ZBN1N0eGRnTTlFaTNIQmZpNFJFc2pUb29rMGlKVFhPdnBuc0FDa0JSajRzYzdvYU42UjJFelNhelkyYnp2WG5CVmt3OU42eWJBR2hCaEVybnFsRlFTSXZjL2FYVC9uSjQwdTRLOC9tMGxsWTIrN21YRGhkVWVIbjYvaUlLcS9TdVdsRGQ0K2ZON2U4Z3JkM1ZQRy9ZSFZLS3RNaTZ2UWtEUmlJNHc0QTJvM1hmUXlrZ3dVOVhrNDQybDFRUlZqUXZISjVHYlptVkhXVGZ0NFVaSGdPZStLTjgzVUwyNnBCSzdSZXErUGV6MC9ySVl4dUZST2hSWTk3UjBZQjA0VkhMU3JCMzJaZnVrV284LzhFVVRra21MTmUxekllTWpEZTBHR0djMzdNdFF4TmtOWERVbDlaamJQT1pST3NJazhkdHBhZXlxZERNdzA4WmJ5NnFwYncyMEMzQ1VWZWJPczdMWVVlWWlQYzVFWklSOGZJQWpUQklEc213TTdtSERicEdKdE1va3g1ajRlRTBkMjBxZDdkYkRlMm84TE5wUXo2VW43OTlDK0lZWjZXd3FkcksxeEhGVVU5cFJxWFJjcElHVUdCT3BNYWFRdXV5YVpuKzcyMjF0aXora0dqb2wxa1JLakNra0NBbDdENWZXZVNtdDgvTHhtbHFlbTllWCt0WUFUbStRU3ljbFUxenJvZEhaUGlvZFlaYVllMG9hWlhWZVpFa2dOZGJFWXg4VUg5Q0I2UkFiTmtvaVhyL0tVNStWVXRQaUp5cENKc29pdHh0d2xGWG1zUStMYVhJR2lMTEsvUDc4YkF5eUNCd25ZRmtTZU9XYkNtcGEybFM1eFJXa3hSVnNOM1grYVl6YzRnN3k0bGZsU01KeEdMUitGSmRQWVd1Sms0NlN3dXBqVHducG5wWU9yQU1mdlVpaWNGanZkUnZnWHNrV1pvOU1RQklGQkFHbURZNWpRS2F0UTRFN05PT3h1OHJOTmRQU0dKUmx3eHRReVV3d2M5ZHJCZDBYV05XZ3BOYkx3Q3pidm1rbW9LamRVNldqckRJM25aR3hEL1pIRmIvanpDemk3WWJ1MThNWjhXYlc3bTVsN2U1V3pocVZnTVVoV3dITUFBQWdBRWxFUVZRbzhjNFBiZXRCcDhXWmFYQUUwTG9UOEUvRHh0UVlFNUZXbWRYNUxSMCtMUjJYdTRmckNsczdQQjk5WElITDZyMkgrM3h6OS9HME5PMEVBOVo5YVYzQ0kwS29YV2xIWFNBZVZGUU1FMTRFWUlIamJmb3IrNWN2LzhqWWwvdXNwOUcvWnl6YjNwelRzWUEvZTVKYXQyRWRXQWZXZ1hWZ0hWZ0gxb0YxWUIxWUI5YUJkZUFEU1VoTzYzOC9GTWNWVnJRZVZVT0s4dXM1bS9wbUQvOTZkMHZuQWY3bysrTGsrZi9iR2JhTDFUUjZ1UDFmS3pvUGNMU3pYaDZzVkI5em8xWkNhenhpVlEvdDBlN1J5T1pEQVEvWjlYMzBieDJMMi8yaUp3ZUxPZGxSZkZ5QSsrcWp0QTU4QWsxTG0zSk9idjVuV1d6OHNUYjZOL2RYWkN2N0YvbjdYdTdCczViUnh3bnhvWU1ETjl2aWc1dWw1R08raFB0bnV5RTFpaGJhbzkxMjcrR3pUKzVSUGJCWGJPN1JOS1FvR3I5N2F1VWh6MG1LdFhEdkZVTTdGUEQyaXc0QlBIdENqNGFqYlRpb3FMOEtIQjl0NGJZTEJ4MVhZSDJVMW9GMVlCMVlCOWFCZFdBZFdBZldnWFZnSFZnSDFvV2ZGYVpOdXV6VjhxVnJpdE9PdGRHeXBYZVFuaHg1VEcxb1ZUVzRoczA0WmtCcDdMQUs2NGZ6MDNVYjFvRjFZQjFZQjlhQmRXQWRXQWZXZ1hWZ0hWZ0gxb0YxWUIxWUI5YUJkV0FkV0FmV2dYVmdIVmdIMW9GMVlCMVlCOWFCZFdBZFdBZldnWFZnSFZpWGpwSFFyVHovUi9uR1J0SzZFK0RRV0NwZW1JMWVtS1lENjhBNnNBNnNBK3ZBT3JBT3JBUHJ3TWNvSWFzOFhKWkZ3WnlNN2hVOEdFVUtYamdZOElRRUdycGhwemJvTnF3RDY4QTZzQTZzQSt2QU9yQU9yQU9ITzNqNHRHQk1uRmN4ZGl0QXMrU1BnMVVIQm41OHpaemVTMHNHZFN2Z1NWbGJldjhVV0xkaEhWZ0gxb0YxWUIxWUI5YUJkV0FkV0FmVzViQ2szYmJ5L0RWeGI5ektybFBQUGVDeG5HOCt3RHAwWUxnWUZ3cUNjTDV1d3pxd0Rxd0Q2OEE2c0E2c0ErdkFPckFPckFQcndEcndUeVRrN3FGN3k0NElGQ1VzRi9MdTJuMVV4NDVaSkNuaW9BbUEvSmtYbHp0WHJPMVd4YVcyY1NNcituejJ0djVrbWc2c0ErdkFYVk5DUm1uWDV1MkxVSlFaNGJpUWQ5ZHVTbTY0KzRESHNwNzlPK2FjazhJMUxYMFJNYmovNlFlY2g2MkQrcm1PeDY5dXpqa3BuSGxwbDI3RE9yQU9yQVByd0Rxd0Rxd0Q2OEE2c0E2c0ErdkFPdkNKTGgxV21MWmVFQTU1ZkxpbWhZdFJMMHpyY0FrQ3lva0NyQUNPdVJZY0Z4cU9DN1RjRVJmUk5JMGdnQ0FnYUJxaVJRSk5RQ0JBNE9jRFNYY0FkamdjZU9mMHcyOFdVRGRvMkhLYkNYZ2tHa2YzeDVEand1ajI0WEE0c052dDNRTzRvdUFMeE4xNVNJV2duaVN6Y1hzMlFzQkhqbmtUZkJ4RVRZV0tYUXZJSFRHM2V3QUhmWHNvS3JmaGl6S2oxY2pVVldySUFaSDYvRmljTVJxR0dnOVI3dkx1bzlLaWJUemlKSkVFRkV3eFh0THNib3lBTnc2aUpJR21PZ2xEOUxqdUE1eVUwZ2R6ZGhDWFE2WE1KNUJzTmRQcVVTbFQvQ1JLS3ZTd2s1NDFyUHNBeHlja0llZWJvVDlFV2N6NHZWWUVtMFpVSHc4eG1nOURvWWZJcUpqdUF3d1F2Y0pQMUxSc3hOaHNwS1RoYUlvUFg5VUdqTDV5R2w4dDZGN1RFb0N0eFkvQmNEMktaaVZsNE9rSWdrQkoyWWRRWFVGazFjUGR6OU1TZkQ0ODExNlBVRnhCWEh3Q01iRnhTRFVOK081L0NFMVJ1alp3d08vSDdYYmo4L2tJQkFJb2U0Rjh5Y24wK08xdjhYdTlOR3pkU3ViVlYrTkxTVUVERkVVaDRQZmo4L2x3dTkwRS9QNnVvOUoxZFhVQVNMS01xcXFvaWdMMzNrdDgzNzRvaXNLWGwxMkdzYkdSdElzdUl1Nnh4L0RzMkVGMVZSV2lKQ0dLSXNGQUFFRVFTRTFyL3dxcUVEZDIxNlJKNVk2bFM5dmxLc0o5OXpIc2tVZEMzbk01blN5ZE40K1dUWnNRL0g3U0owMWkvRXN2SWZ3c1ZsNS8zMzN3NktQdEFtaWZOS2tpWituUzhOZHBlWjk4a29ybHkwUGVVelVOMStiTkJCb2JVVnRiQ1hxOWFEOEwvTXVYTGNQM3IzOTF2VUhMNVBWU2V0Tk51RnBiZitKaStvamN2WnVVdWpyU2Ftc3grSHlVZlB3eGpvYTJoUWxkcmEyVTNYd3pKcSszYTQ3U3hrMmIyUEhnZy90ZXUwdExzZnY5b0twNFJKR0dIVHZZZmYvOVNCWUxBRHNlZkJEajVzM2RLQUhnOWFJQ2RrMGpXbFZKek1zamF2aHd6R1p6OTVpSC9VT0cwUCtoaC9hOU5pUWtnQ0JnQUF5QXFHbEVUWm1DS0xaOWpYNFBQb2gvOE9DdUNldzFtOGw4K21tc1B3bnFZN096OFUrYWhFOFFjQWtDTGFlZVNwOHJyOXgzUENJeWtveW5uOFlYeGg0UEM3QUdXRzYvbmJUeDQwUGVseVFKYSsvZXlKcUdyR25ZYzNKK01TV2xUNWlBNmJiYnd1ZngvU3ozMUM1NTZjcUtDalJBbG1VVVJVRlZGR3FlZVlhSWZ2MHd4Y1RRdW5Famd0Rkl6TGh4dVBic3diVnpKOGszM1lRZ2lraVNSREFZUklEMmNqeEM4dEkvVDdZdDBOcEIvRDZmNW5hN05hL1hxL245ZmsxUkZHMGRhTXRTVTdXVyt2cDk1elhYMW1vL0pDVnA2MEJURkVYeisvMmExK3ZWM0c2MzV2ZjV0SGFTQldGWGFZUFJpTVZpNGYvWk8rLzRxS3JzZ1gvdmU5TW52ZEJDRGIxRDZDaFNWR3pZeGJJMnhGMWQrNHBsMWQraXNycFlzYTBkQ3dzS0ZteW8yS1VJMGtGYWdDUVEwa2lmMU9rejcvNytHQWlFa29TUWhCamUrWHo0a0psNTdmdnVPZWVlYys1OTk1bk5ab3hHWTVWVE11L2J4OTUzM3FuYUxtUDJiRXo1K2FFTFVSU01SaU5tc3htcjFZclJaUHJ6ZWVtam5hemlqVGVvS0N1am9yU1VpcmZlYXZMQ3VLR0p6NGN4STRQTS8vMFBHUXhpeXN4czZ0TTNQYkFLRkwvMkdnS3dRY3NIQnJDbnBIQ3lSQjg5MUlGMVlCMVlCOWFCZFdBZFdKZEdMd0JJS1UxRmxmN1N1RENqOWZDTlNsMEJibncvbVVXYmk1b2x4TVdENHBnenBROVJ0aU1qNWNKS256cyt6QlFsaFBBZHJ0TFhIdzBXSU1wbTRLczdCakJyY2pkTWh1WmpCU2FEd2d0WGR1Zkwyd2NjRlJZZ1BzeGtCYTZyMXNKU1NnT3dBNmoxaWNjMTZlVmM5ZlkyTW9vOUp4VzJjNnlGajIvcHgvQXVFWFhaUEJYb0xZUUlIZ0R1QW13QTZqUU1mN0pWdkNZVlBvYVVBRU9FRU9rS2dCQWlIUmk4TTgvcHFNdmVKMHZGNjZMQ2g4dU9YS2NER0x5ZjhhQU5DeUV5a3A1WXQyeldUM1d2UWt3N3V5UExIMGlpVTZ5bFNWVDR0d2VTdVBlc0RuWGU1L2tmTXhuODVMcGxRb2lNby9iRGJuOVF1Ly9UTkM1K2JRc2xya0NkRGpxaVN3Ui9UQi9PUlFQakdsV0ZOMDBmWGxkN3BjUVY0S0xYdHZEQXdqUzgvcUJXYStDeGFITVJnNTlZeTVyMGNrNm1pdGRIaFZmdktXZndFMnY1K2hqKzVaaFhsMUhzNFl6bk5uS3lWTHhUcklYbDlWRGhNNTdiVUdNUFVtTnorQUlhOVZIeFRTZW80aGNQaXVPUDZjTVpVUThWOWdmbGljZlN4NnZpMGZWVThjWlE0WG9uRDQydDRvMmx3aWVVTFRXV2lqZW1DamRJZXRoUUtsNGZGVjZUZm53cTNHRDU4SW1xZUgxVWVOWlBtWnp4M01ZVGl1TlBhT1RoZ0lvdlR5bGx6azE5aUs1REs0M29Fc0hlcDQ1dmJuVEovdGo5NndhSTNSc2tTamhlRlQ4ZU9WRVZiclFTVDMxVXZDbFV1RkZyV3ZYeDRqVjU0ZnMvVGNNWDBKcC9FZStBaW0vTXJEanVmVGRtVmpTb0NqY0pjSE9XUmdHK2FHQW9rRWpxZVB3UFhpVjFER2ZUOU9GYzJFanBab01DbXd3S3N5WjM0NnM3Qmh4UCtlV29nY3FpUnFxb05OalJEZ1FTMDg3dTJHQVgxeGdWRmFVaFZiaXVzZkR4eUlGWXZLRlVYR2xxRlY2VFhrN25oMytuODhPL0gxY3MzbEFxcmpTbENoOGFTQndJVkY1bzRvcUswaFFxWE9JS2NQRlJBZ2xmUU9PK2VxYWI5VlZ4cFNsVWVQQVRhMnNzMnRjbjNWeDB4d0Nlbjl3Tm95b2FCL2hFVmJpdXNmanhxUGg5WjNkaytRTkRqa3ZGbGFaVTRickU0c2VyNGlNVGowL0ZsWk9od28xUlVhbXJpaXNuUzRWUGxvb3JKMU9GNjZyaWw3eStoZElHVXZGcXdGYWpxcHdNRmE1TnZ2cWovaXB1TnFyVkdBK2Q4dEJwWjU1elk2ODI5cGpqVWVGSHZ0alQ0RWw2VFQ3bHFVc1RqOHZNZHVRNkhiM2IycE1PakNBZU9pQytFWWlxcXdwUCtaTU9pQjhBVm9HZC9NbW1QSHgwUzcrNitwbXFLUThIWmdBRWdhZnJvc0lOWFZTcnIrdzlQaS8rOUg3RzZ0T1dDaXQ5cGZ0bnZUUXJGVDRSRlQ5ODJ0SXBKMDIyWXRwSkZIM0ZOQjFZQjlhQjZ5NmVlaXhnRUFnRWNGWldObTlndjk5ZnRTcUxwbW00M1c3U0ZuN0w3eGZlVEVWRjNjZVljcllsODgyMWQrSXBQL28reFVWRnBHM2FVdS9yUEtFQmNVM1RDQWFERkN4Znc3NTNQMFh4QjhCcXdXdFNrWnQza2J0ck42MTdKS0o1dkZETGVuZk84Z3EyUHZjVzVlOStTc2VoQXdtTFBaakQrSHcrY3JjbWt6YjNjd0pha05ObTNOKzR3TUZnRUVWUnFoNWY5MVpVa3JGZ0VjNC9kbENjbFVQNDF0MnM3QlJKVkhFNW5iTktpVmFNWkdzZUVqcTBwOGVpdDRpTXI3bjhrdm45RWxJZm1ZVjF6ejdhQ2hWUFlUR3VTaWVlOGdyMkx2eVd2SVhmbzI3Y1NmVGw1OUR2dFJtWXplYnExeGNJVUpDeWg3WjllalFNY0VWUk1kdWZmWk0rZDA4RnE1bk4vL2NjbG9KU0FvNFNERnRTcWJRWUdGVWVnWnBUaVZreDRrUGkwelNDRlU3OEZjZCsvWXZINVdibmpKY3BlUHRqWXFTQ1dhZ0VrUGgycFBQTGlFdXdlUHlFVjdwcExRd0V1M2VoKzNNUEhRR3JhUnFiN3BsQjFCbkRvYUdBbzFxM0lpWTJsdVNobDFFeHFqL3RIN21GMWwwVDhidmNyTGo3TWV4ZDI5TjZTQko1TDcxSDY3UThMQWdNUWlHeXdrUGFGWGVqdmZNazdVWlVYd0t1S0dVMzZYZk1vR3p0WmxydnYwa09HY0F0ZzJnUzJoWlZFaVlVRkdFTXRXS1lEY1dnSG5GdFcvNzVOT3I4NzFEUEhkdXdOdHpyNGR0Wmw1ZVA1K3RmS2I3alB4VDUvZUIwb3ppS0tGcXlpdngzUDhXbkJUR3FkalFBc1gvK1ZId1U1dGpxODg3M2ZMYVk0Z2VmcDZTb2lEQmhvRWp6b3hGYUhTSmNHTEFwZ2lBQ2w5VHdvT0dSR21VYi9tRDN3Ly9oeWxjUEpuV2JIM3VSd096UGNLTVI0ZlUyTExBUWdvSFAvUi9SVjAyaWRmOWVHUFl2SGJYcGdaa0VQdjJScUw5ZmhaTWd1YS9NUlVHaGsycEJRMklmMHBlc0g1WVIyNjFMS0RGOWV6NmxENzFBVnNCRGxERGdsaG8rSkFZRVpxRlFJWU00TkEwcFFuZkFJaFJzblJMbzhzTERkQjkvY0ptTTdjKytTZkNWRHltUkFWUWgwTW9yR3c3WTUvTWhwV1QxRXk4dzhKYnJpWWc0bUhUSGpocU1aMEF2dWx4ekVkdUdYa0tFTU9CSFlrWVFSQkxXTTVFdVV5WlgrWUxpeDE5RDB6UmFLeWFLcFI4Qm1GRUlJUEZyUWV5S1Nvd3dZQlFDQXdKdnEyaTZmdm9xMFQyN1Z0bHMxcFprWEdsN2NWMXdPc1p2bHlIYnhlTk96MEpLZWNTNklNY043UGY3MmZ6eXUwUjI3WVJkTlpQNjV2K3c5T3REdjJzdVFRaEJ0OGtYb2hnTlpIM3hIYjZpTWdxMUFPSDdUeXBieFZDd2REVnFoN1lrbmpNT1oxWXUwdVVtSUNWbVJjRW9GUVJnRWdvMkJGYmxTQnMxVDcyMENqWjcyU3FLUHZrTzRYUVROcUkvWXVjZVpMOGVkUHJ2bzZTOHZRQ3YxMXZydWo2MUFodU5ScUk2ZFNCbitvc1krL1drTWpjZlUyNHhYSE5KcUxCbXRlRHplTm43MWtlWUFWV0FINEVFaE1WTTRzTzNFZDIxYytnRytQeFVFQ0JlTWVHUUFTU2hOUUc4VXNNdEpacndZMFRCS2hSTUtLaENFdGNsdFBaWHpwSlZaRjl4Rno1Rm9FbEo5RmRMY01zZ2xqdXZvZFdndmtTLy9CaEdvN0ZoSXEzMjU1eUJTYXFVcjltSU5YMGYzYTY1dUpycTVLM1poRzM5RHZ4U1VpbURhRUlTUUNLeUM5ajF6T3RWMjJadDJJd2RBd3Bna2dJTkRTT0NNS0VTcnFoRVljQWdCQlZha0FMcEkxUHpzdjJySC9CNnZaUnQySUxVSk9aMy9vMzFrMWxreDlpSUVnYU1RcWxxbUFhellXdGtCTkVQMzRMdDdwbTRManFERGhQSFZyUHY0amZuNDBMaWxCb1dvU0lRbE1vQTVxaHdPdHc5aGF6UHY2ZHNVekxCYjVaaEVvSVNMUkR5ckVMRmo4U1BSc1IrdXcxZGxTQXcrV3pDTGorYmdOMkswV2lrL2VSSmxNLy9sb3A3bjBhVEVsbGFCcGhnYnk2QlFBQ0R3ZEN3WGxvV2x5QVFHRmI4UVdWcEdXRlJrVlZPcEdKN0tsRkNKYWlBUCtCRFZjRXROV1N4Zyt3emI4YW1LS2dJTkMxSXFaRDRwVWFZb2hLNk5SSTNHa1dhbjBoaHdDWVVpbnEzcDgyd2ZwRG5JS0pMQWhXT0VneHhVWFQ3L2gzS2t0TW9UYzlBdnY0eE1pMEh0VmZuT3NNZUY3QW5NdzlwRUNqRlpWVHNTQ05zMUJBQUhMOXZSTXZJcFZ3SXZES0lxZ2hNQ013SWtPQWlpSkJRcVFWUWhJSWlJVXhSQ1VpSkZKSklZU0FDQTA2QzVHcytCQkMxZlMvdUIyYmhsU0dWRHhwVlJIUWtJc3lLNW5SaktDakJqS0NpZXdKSmQ5eFEvMWhhZkRvS2p1TFdlK3dNTU8zSEFLdEhhZHk2WEdIdXJWTjU2UDlzb0FwNjd2RHpQNkZnRVFwK3FZR0VHTVZFQkFxcUVCVExVRkJoRUFyaFFzVXBOUUpJWWhVaitacVBVZ0xFQ2lObW9SQW1WREtEWGt4Q0lVcW9lSUJLR1NRMm9FQmhhZWdmNEVHeVlHQ0F0NjdOdy9IemViV29wanpPRnZacmpGN3E1b016amV6cGFPVG0xWkplR1Q2ZWY4YkRPNU1VTWpxb1pGaUR4THMwaXJRQVVZcUtnc1FvRkFxbEh4OFFqb0tUQUZaaFJBTktOVCtLYXFTMVltSjMwSTFSRWZpbEpFWUoyYkZkaExxbmNLRVNFQXBGbWgrYlVNbUpsbXpwSlBsa25JRWR2VTJoTHFHaHN5VzdVK1BuYzYxa2R3NXQrdnhGWHY3dmN3c2l6Y3ZMcjZnVUtWNDZhQ2JDRkJVcHdJVEFqNlJBODVFbTNReFdJMEJLZkZMaWtocEJKQjQwU3JRQXBkS1BXU2pzdzBkWHhZcUtJRW9ZMkt0NUNCY0c3RUxCaENCYU1mQmhYejl2WG1Xa3NwV3hYcUFIcEhwUFA3bjlsUWpScDFvRFd4VEtvdzcyWHJ1NkdTZ1NmaTVKQ1MzL1pKUUNsNllSb2FoNGtWaUVna0VvbE1qUTZxT2FKaW5RL0RnSlloQ0NjS0dTcS9tSlVsWGNVc091cUxRV0pzcUV4cWNEZ3RncU5CSUNKcnhvQklGQ0djQW5OZm9VS2x5MkZ0eitJS21kRkRSam5hRjM4R24ySjNVR1BwcnM3S1lTbHU5bitENlZNS0hpRlJvV29WQXBnMVNpVVlJZkF3b3hRc1V1Rk95S2tRNnFPZVM1QlhpbHhJNktJZ1N0RlJNS2dwY21TZDY1M3Nxdmc4SGxDMkwxQ2d3YTJJSUtBb2xIYWdSOFFTYWxHdW16MlVkYUI0RWpSamx1NFBwVlBCVEJLOWNhR1pvZUlMRlVzTDJEeWg2N243N3BRZHFWS3hnUnRGZE5sR2tCTkNGUXBHUjF4eUJmalZJNWUxV1E4WmtXM0FSUjlvOERCTkJJYnlOQVFGRWJJN09uR0pudGw2QkpFdllGQ1hkS3VtVm8zUEdkUm9IYnorZW5LNXkrMU1QdXptRm9oZ2EyNFdNbUZEYVZMNFlIaUM0TDh1WmZ6RVNWRzNqbVNTZFdSVUUxRzFuZUprRFBISGpyWE1qc3BQSkhId09hV2NGcDl6RjB2c1RpQ1dsRUNRRnNRbVhHSi9CcG1wdGxJd3lrZHpFZ2pRSVE1SFFKdGVMT3Z0QTd1WklKdXdRMnFmRCtYNjJoZkxMSmFsb0MxaWRLaWhKTVlGSVl1dEZEdXdxQjBhaHd6ODBTMWE4d1lFZUFMeStwdm1yVzc2Tk4zQnJtNDVGNUFkcVdDUWhLY3FXUHNGS0ZlNVlabWJqZXo4cGVmbDY5eFZaOUlFaUFJeVprZzM1eHRJR2lKaWppN1I2NFB6TnhCN254SncyVHF2RFFqUW9iazB3b3ppQ1o3VUt0WXkwTFlxOElVdFErNU9oU0I1aTRhYWFCVGlsK1pyenNKaXFnWWxWVVhoOFRZUFprQzUzM0JzQ25oWUJNKysxVVFwdkMwSUsrV1czclgydzlidUNCNjMxRU9JS2s5VEdTMjBvQlZYRFJ6ejdhbGNBSFp4bFlPU0lVeEd0MmxYeTdDbjZONGV0OFRGbXNzYkZma0xjdk4rSzFLTFRORFRMdHN3QnROU01XUmVHakVScnZYR3RGS2xEVVd1SG1keXZwV1duaThkdU11TUpVSWdzQ0ROOERGa1VsdlgxVEFVdklqb0ZIUHdtU3VGQmpTNElrVmhnWW5XV2cyS1R4MGZpUVF6dFV1dTRPMEQ1WDh0a0VoVTZaR3U4LzVNWm1NOUttRENxQXZEaUZkeTVRV0RibVlIRXVZRkFvaTFXdzcvTHkvQXdmNjVPTVROd202Q1RON0lrTTRyRTJZajk4cU1SaytwaXcycytnRElqMkt2U3JNTkNtWEZCaTBDaXpDa2JzbElUdjg1UFZVY0ZyVmlBb01aUUhHYnBUY3QwUzZKS3I0WTFVMFF5Q3ZFakl0d1Q1ZFpEQ3lzRXFubkMxNnFaMjJPYkdGbFFvamhQMDJDTTVlN2VCT0tmQUt5UkNDanJ1OVpNZkJzV3QxTWJ0bGh3ZFRhUmxCbG5UUFVCQ1FPWEwwWUk5SFJRcXdnVUdUWERtQ2o4bE5vak85RlBlVHdWVlVKaG9Za09paTkwSnNIcW9oWkxZL1JlcENsb1ZHQmkvd3MrZ0RUNld4YWhvRmdVRXBBK3hZZnZEeTdETkFlWk50dkQ3RUlVdU9aQWREejZMd2hsckpJbXBQdmEyQjErazhYaDk3U0h5eWNpRkNIRjVUU3F0ZUxYUWhmazFNRGJnMEpRODVHb2tLQjROelNTT0hrWWUyRmJXd1ZOTCtSbFhycjZpZmpZc0NNRkN3OEllZnVzRmFGYWw5bTNyWWNyNmNLa09yQVByd0xvMFo2bm0yRmY4YlhyNTRIOWNIMjdyMDczYVJtVVZibTUrY0I2Zi8vREhjUjM4dnpPdTRvN3JRelhzRFYzSEVuQ1VIblBiSVduTE1NUkdzV3hOS3VPdmViSHVvYUtxTVAydTg1bCsxM21VTDF2RDdsc2V4bDhZV2pSS3Naangzbm1MWTh5Ly9oWjdWSlZXc3JJTjJ5ZGNTOEg3QzZ0Vit5TERyU3g4NHhaZWVmeEtMR1pqczJtdGRxMGorV25lM1V5Ly9SeHkvdk1hT3kvN2V4V3NwWHRuK3YwNm4rQlpZOTAxMnJEbTlaSSs3UWxTcHo1SXNLejZ4Skk3YnhqSDc1ODlRSTh1clU0NjdEbG45R0hUdC8vSDZFNVI3TGo0YitUTW1sM1ZTTEZYbkUrL0pRdXc5dTVXczlQU09yU3ZlckRBOGVXUGJEM2pTaXJYYjYyMnc2QSs3Vm4vOWNQODVhSmhKd1hVb0NyTWZQQml2cHR6SjhaTm05azZaaklWdjI4SXdaaE5kSGx4T3QzZW5vbHF0OVh1cFFOVHJ5dFBmSFVHaWlXVXFua3o5NUY4M28za3ZqSUh0SVBUL01Oc1pqNTQ2U2JlZWVZNjdEWlRrOEYyYUJ2TmtvL3U1WjkvUFl1c0dTK3o2NHJiQ1JTSC9JSWxzU045Zi9xQVZsT3VPT3Bnd2xHQmYvMTlWMzdNMVJlRjFLRkhZaWoyRGdUSmZPeEZkbDE1WjVWOUhKQ3BrMGV6NW90LzByZDcyMGFIblRTaFA1dStmWVJoYmV6c21EU1ZmUys5ZHpCdHZXUWkvWloraEsxL3oycjdsSlM1bUxOdzFkNWpBai94Nm5mcFoxejFBb1VSMGZSYk1wKzRheTZxK3EzMGw1VnNIVE9aOHVWcnF4MjBUL2UyclAzcUlXNitjblN0bysvMUVaUFJ3SE9QWE1haWQyNURXYk9CcldPdXBHSk5xTGNRUmdPZG4zMkk3dTg5aXhwdXI3YmZxbzE3R0h6QlRQNzMyZXE4R3AzV3FvMTdTSnIwRk4vOG5rclgxNThnOGJWL1Y2bTRQNytJSFpmY1F2Wi9Ya01HRHI3WXpXb3hNdnZwNi9qZ3BadUlDR3U0cDdrN3Q0OWwyY2ZUbUhiak9ES256MkxYMVhjUktDa0R3Tnl4SFgxL21FdnJ2MTF6aEFvLys5WlBqTHY2UlRMM09lb1dhVGxLblZ4NjYxdE1lM0loVVZkT0NxbDR6OFFEK1NVNXo3L05qb3YraWkrbjJzM2ptZ3VIc3Y3cmgwbnExK0dFWVM4OVp4QWJ2M21FUWJGbWtzK2ZRdTZyYzZ0K2l6NS9QUDJXZll4OWNOOXEreFNYT0prMDlYVWVldVlML0lIZzhZV1dVa3BlZXU5WFRyL2llZkxzVWZUN2RUN3gxMTVTOVh2RnFvMXNIWE1sSmQ4dHJiWmZ0MDd4L1A3WkE5eDE0N2g2dlZkWVVRUXZQM1lsbjcxeEMzTEZhcmFPbVZ6VlV3aURTcWYvM0UrUEQxN0VFRlg5YVpiZjFxVXgrSUwvc0hqcHRyclh0RVQwc0N1QmFqV3RmZmxselAxOE5kMjd0K08wdTYvQjBpbUJzbDlYSVFNQk5JK1g0cysrSjFoYVRzU1k0WWo5RThkVVZlRzhjWDJKalFrak9qTFVQZVMrTWdmTmZleVp0ZTN1dmduRlppRW15czdwQXp1UithOVpaRHp5SE5JYmVqYkRsTkNHWGd0ZkorYmlpZFZVV0VySnpOZC9ZT29EY3ltdGNCKzlwbFc2L3BQalNoNUt5OTFjZWNjNzNQWFl4MFFjNk5SN2RhMzZQZSt0K1NTZmN3T2UzZFVmcVVuc2NQeFBjZHRWMkg3dWplUzkrV0hWZDFFVHg5Qi8rY2VFRFIxUWJkdUM0Z3JPdmZGVnBzOWFSQ0JZdDZmajZwd3RTU2w1YmQ0eVJsLytIUHVzNFNFVnYrNmdpanMzNzJEYjJLc28rdlRiRTdKZDE5WmRPRGR0RDJtY3F0RHg4WC9RYzhFckdHS3FQelMzWkZVS2d5K1l5VThyZHRRL2VYaGg5cytiTzdhUEdWRGJUa2FEU2xMZkRyUnZHNDAzT3hmWDVwM1ZYc2RwN3RnT1cvK2VDUFdneGRRMWVRQndMUG9aeFdJbWJHai9JMEFCZHFUbHNXTjMzaEd2RUR5YVpHWTd0a3o3MjFrRGoxckVTK3JmTVhic2lPN0hkY2ZNN2R0aWJ0K3dnVWZNUldmVitIdnZibTNvM2ExTm5ZNjFiRTFxN0NsZEFLald3c1puWG83ZXNIbHJvNXlvSm5VRzJOQnQ3RkhWOTBURk9MQi85REdCaGRzbGFydXd4cFRHT0xkd3U0UmV4Tk9CZFdBZFdBZitVL2JEL2dmdktSazlvSk8xTVU2MG9Wdk5qOWtNV1BzbHhwam9Cai92NzFzeVN2aisvYU1EUzV0TkhvaG5HL3pPeGtUVjJNOGFZNkpwakhOTFc2RThaZ3R2M0pwWlhGUlNXYWMzcENhMGptSkkvNDRZRDM5NFN0TndKYWZoMlpOWmEweDh6SXYwQjNCdVRzYTNyK0RnRFltTnhqNmtIOUpvWkZOeUZoazVkWG9sQlpuWmp1SmpBdDgzODdOVW9NWnN5V0kyOHV6RGwzTDV1WU9QK00yN041dlVxUTlXcFhjOVBuaUo2QXZHSDM5MFpEUVFOcVEvQmRzK0krT2haOUgyUDRSbGlJbWk2eHRQTW5UaUdKSlQ4N2p6MFkrb2ROWDZnRlpxdloxV3QwN3hyRng0UDNmZU1PN0lPdGlpbjlsNnhwVlZzTVpXc2RnSDk2bS9MZ3BCcXlsWDBHL0ovS3A2V3NCUnlxNnI3aVRqLzU3bitrbEpyRnYwRUFONkhkOHJlK3NNZlBXRlE5bnd6Y01NN2x1OVFLZDV2ZXg5NENsU2I3eVA0UDRIS3lQR2pxRC9iNS9nall3OGJrNlAxMS90czdWM04vb3RXVUNyR3cvT3RjbDdmUjdiejcyUlRzTEhtaS8veWExL0dWUG5Fbkd0d0ZhTGtUZi84eGZtdnp5VmNIdjFFcXhuVHliSkUyOGcvNTJQcWxxbC9jTzMwK3V6Ti9sdXl6NCsrWGJqOFh2emJabEhqRklxVmd0ZFhucVVidThlckQ4N04yMW4yeGxYVWZuTno3eng1RFVzZUdVcWtlSFdFd1B1MWJVTnE3LzRKN2RjYy9vUnZ4Vi8vZ1BieGw2TmM4dk9LaFh1L2VYYnRMN3ZiOXovMU9kY2V1dGJSN1JXblRLbWdNYmsyMmR6OStPZjRQTlhYME1yOXJKejZMLzhFOEtHOUFNZ1dPa2s3ZVovc3VmdXg3bGlmQjgyZlAwd1EvdDNxaC93RFplTllQMmloK2pmczExMUZmYUVSaGZUYm42UVlHVjFGUzdwMm8weGs1L254ZmQrclZQNXBhYjYyYXR6bHpMNjh1ZlluVmxZdmNMU3VUMTlGcytoN2QxVHFyNHJuUGNGMjhiL2hUYVZKYXo4N0g3dXVXbjhNVlg4Q0dDN3pjUjd6OTdBbk9kdnhHYXRQbERtU2QzTDlyT3VDNDBmSDZiQ2l6ZnZJMm5TVE5iOHNiZkIrdENOMjdJWU11a3BQdmwyUTNWL1pqTFNjY2E5OUZyNEJzYTRVTERpVHRuRDlnblhVakx2QzE3ODF4Vjg4ZGF0eEVUWmF3WWVNN1JieE5vdkgyTEtGU09QMkxEbzAyL1pPdTVxWE50VHFxbHdxMmwvNWI2blB1ZXl2NzlGU1ptcndRT0g4a29QMTl6OUhyZFBYNERYVjEzRkk4OGNUZjhWQzRrWU82TEtnUjRZMjc1Z1dCYzJmZnNJa3liMFAzWk42OS8zWGRqbjhPS1k1dmF3NSs3SDJYM0xJMmd1OTFGVWVCWXZuYUFLMTBYRjMvendOMFpkOWl5cGV3dXFSMml0NCtqOStadDBlUFJ1eFA3VjRBNk1iVWZuWkhQZjM4N3FYbWVuNVU3Wnc3WXpyNlZ3M2hmSFZPRzFtL2ZTVlBKSGNqWkRMM3lhK1l2V0hhYW5DdTN1dlpuZWk5L0gzQ0ZVUVQwd3RxMSsvYjI5VHNCRkN4YXhiZHcxdUhla0hhSEMwMlorMW1ncVhKdFVPRDFjZis4Y2JubjR3eU42Z2ZEaGcraTMvSk9xa0ZZR2dxZ2JOcGxyQk5aY2JuYmZQcDNkdDArdkdvNEpRbUlBQUNBQVNVUkJWQXM2b01LT3hLNmNmc1h6dlB6K2trWlY0YnFvK0RzZnIyVEVKYyt3YzNmMUVVeERWQVRkNXp4UGx4ZitoV0kyMWV5MGxOM3B4bTNqLzBMUmdrVkhxUEEzbTdKSm1qU1RkVnN5bWsxdXUzWFhQb1pmL0F4elAxOXpaRmg2MDJUNi9qcS8ycnlWVTFLcTljNGJvM291Uk1oNnJaZ21ESkt3Z1FFcU50UStqOHZjUGdnU3ZEbTFUK0VQVC9KVHVkV0k5TmRYLzhWblNhVzdHbjdGdElqUmZ1SW0xMjB0alpnTGZNUk1xdHVhZkxGWCtvZ1k0Vyt3RmphYzZBRVVPM1I4eEVuNGFEOUNRSS8zeThsNjBvNTc5NUd0WjRyWDZQaVlDMXUva0ZuWitnZkptbUhEVjNqa2ZiZDJEOUxoRVNlV0xob1JJd0tVcjFUSmVpcU1vUE1rRi9FMEoyUThha1A2UVBwaDN5dEhod1h3RlNyc25XNUhCa0FHSUdPNi9haXdBTzVVbFgydjJKQkIwTHlTakVkUEhMWkJXaGpBMWxNajV6azdyaDBxWWNQOVZHNDZ0bTNhQndiWU15ME1rTmdIK1NsYmN1eUpiZWJPUVZKdWpNVGFLNEN0ZHhEbmRyWHhnWDBHaFpUSlZ1eGh3ZHFQMW1YLy8zK3JzVWgwV0JubDJGdW1ZNEh6RGpsMkRlK2xxcXd3MEhPaEMxTXRDd1BYQ3V4VkZlNXYzWlBYaDIzbmtvVDhadG5WZkpIZG12dlg5MkNodXFWVzREclpjSUhYeE9TVmc1bXlaZ0JsL3VZemZiak1iK1RHMVFPNDh2ZkJGSHBORGV1MHBJUVA5clpqMFBlbjhYTmU3RW1IL1RrdmxvSGZuOGFIR2UwNG5pajN1TDEwbHN2Q2VjdUhjZGVHUHJpQ2FwT0R1b0lxZDI3b3czbkxoNUh0T3Y1cGp2WHFscVNFTjlJNmt2VERhYXdxaW1veTJGVkZVU1Q5Y0JwdnBuV2t2cm5MQ2ZYRGFSVTJ4djA2Z2tlMjlNQ25pVVlEOVdtQ2g3ZjBaTnl2STBpcnNKM2N3Q01vQmMvdVNHVDRqNlBaVWhMZTRMQ2JTeU1ZL3VOb250dlJoYUE4OFp2YVlMSDB0ckp3UnY0OG1wbkppV2dOY0dGQktmalA5cTZNK21rVTI4b2E3a1lxRGExNmoyN3R3ZW0vakNTbHdsN3Y0K3lxc0hQNnp5TjViRnYzQmpjVlEyUFkzTnJpU0liK01Kci9ERXpscnU0SGExNkJFa0h4VjJZOHV4VlFGQ3lKQVdJdjltS0lPdWlCWGtucHhMKzI5R2kwSHFET0xSeGhDUENYVHZ1T3EvdTRkMk12emw0eW5FeW5oY3IxQmxLbVJKQS94NElhS1ZIdFFmTGZ0NUF5SllMS2pRWXluUmJPV2pLY2FadDZOMnAzVjJkZ24xU1lPM0lMdjB4WXkvaFdqanFmWUVsQkRHZCtPWnpVeDhNSmxJWFVNM0tjbjhqeG9SUXhVQ3BJZVN5Y2NWK01aR2xCREkwdGRWYnBOcFpRY2o4MjNzSFk4V3Y1S3JzVjE2NGVoQ2RZK3oyN1lITWhyYy8xSUgwQ3pRdGhBNE1nSmRIbitGQXRFb3h3d2RaQzNranEwT2pBZFc3aGpuWjNWZEFCY0hIN0FoN3N2YWRPKy9iTWMrTk1WbWs5MVUySGg5d0lvMFNZb01ORExscmQ1TUdWck5JenYybEt2blVHTmlraFVyOUxZZS8vMlNsMkdabll1bzR2S3BjU2Q3S0JuVmRHNHNzNTZIVjlPWUtkVjBYaVNqWlVyZXphYklBM09pS29ES2dZYlJwN3Q5dDQrZTB1RlBucWxqbHRieFhxUjJWUVlvalhrSDZRZm9FaFRxTHRMMWNseDl1YkY3RERaK1NhVllOdytJeDgrVUFjNjF4Ui9IMTl2enJ0KzgyZ09BSjJRZmpvSVA0OGxaMS9pV0RYdFJINEMxUWlSdnNKaEFzV045SzdTazhvOFBodVh6d2RGazNnMS9KWWZ1b2FRNTdiWE9zK1krSWQvSExaR3JvL1hvbDB3YTZid3ZFWEt2Z0tCQ2xUd3NFbjZQRjRCYjljdXBiVDQwdWFqNWMrTkpwS0xnK3JkVHVMcXZIRWdCVHU2WjZCSWlRTUEwdlhJSTR2emJoMmhsWmtzZlVNRW51cEYwTzBKSXdBdjQ1Znkwc3BuWmkrdFFmZW9OSThnT3NpU1RGbHpCbXhoVDRSMWN1TXhoaU4xbFBkeDFZM0labldjeS9udGkxa3lwb0JiSFJFbmx5VnJ2WHVDY21qL2RMNC9helZSOEFlai9TSmNQTDdXYXQ1dEc4YWhnWjIzdzBHM05BWGVlRG1yVHhyTmIwam5NMEgrSUFhcnAyNGtxU1lzZ1pYd1NFeFpheWJ1Sko3ZSt3TitZS1RDZHpGN3VhWDhldDRkdEJPTEdyanZTak9vbW84TjNnbnY0eGZSeGU3KytRQS82MXJGcHZPWGNHWWVBZE5KV1BpSFd3NmR3Vi83WnJkZE1EdHJCNitPV01EYnd6ZFRwZ2hTRk5MbUNISW0wTzM4ZldZRGJTMWVCc1grT3FPdWZ4eDdrck9iVnZJeVpiejJoV3krYndWWE5VeHIrR0JZODErUGhyOUJ4K00ya3lNeVU5emtSaVRudzlIL2NHQzBadUpOZGZ0dW1vTlBNd0JqUmZ6ZDJKZUtmbWExalhmUFVWRDAycS9oNG9DRW9tc1E3MnFMc2Uwb1BGaTJVN01kWGpEWnEzQXBxQkd2d1cxOTRPbVZoclJrM3prdjFmN2FFRGtPRDlJU2RteTJzZURXay8xNHZqR2lMK2d0aHZad0cveU9HWUwyS0gxRkRkaGZRS1kyMnNZSWpVY2k4eEhud0hRU2lQK0dpL2hJL3dnQldHRGdoVE9OeDl6QmtETUpCL1I0MzJFSi9sd0poc28rSisxZWN3QUtGdG14Tm9uaUJJcENlUXB4NTRCVUtCUStZY0JVMXNOVTBLUXlqOE1OYzRBOE9jcktCRVNXOThnWlV1TnpXY0dnTDlBeFp1dEVIQW8xUFlvdnVZUnVIZXJDQ0RvcXRtR1pWRGkvTU9BSVU3aUwyeVlTbWFEQUF0VkkrV21jR1JBWU81UWM5L3MyNmVRK3Rkd0VHQk9xSG5iOGxVbUNqKzJJSXhnak5PbzE3cU9wN28wM2FzOGEzc0lvL0htYnVxdjh0U0JXN0xVejBzdldRS2JONFBaRExmZDFyUlgvTVliNFBYQ3dJRXdmbndUdGZEbXpYRHZ2VEJ2WHRNMzBkeTVvWE52MmRJRUtwMlNBaVVsMExsejZITmlZdWh1NzlvRmJuZmpRYnJkb1hONHZhRnpRdWdhU2twQzExUmZrVkl1bERYSmlCRlNncFFXUytoL3MxbEtJVUovWjJiV3VLc01kVHpIL2xlVFpHU0V0aEVpZE01RHIySEVDRm1MTE5TOTlISFpUMGtKTEZnUStuekZGUWZWTGE0Ung0Ymk0dythemVYNzQ2S1BQZ3BkeTl5NWpRamNvd2RFUmNIZXZhSFBlL2FFUEhXUEhtQzFOaDZ3MVJvNmg5a2NPaWVFcmlFcUt2UjlvM2RMQXdmQ2l5K0N4ZEwwT25uRERYRFZWYUZyMEdOcFBaYldROHRUZThsME9YWnNkcTBCd3AvdDM5aXgyYnBLNjhBNnNBNnNBK3ZBZjRxYTF0S2xxMXRnTEwzNjBIUHJLcTBEdDJnYnJxdm9kZWttRkwwdXJkZWw5YnAwL1lIMXVyUmVsMjU4MGV2U3RZcGVsOWFCZFdsQlVzMlRqTDN1L2V4bGEvY21uT2hCczVaTm8zMmJpQk02aHN6Tng1bDA3Z2tEcXFPU2NteGZ2TmRldDJFZFdBZldnWFZnSFZnSDFvRjFZQjFZQjlhQmRXQWRXQWZXZ1hWZ0hWZ0gxb0YxWUIxWUI5YUJkV0FkV0FmV2dYVmdIVmdIMW9GMVlCMVlCOWFCZFdrYWFmVFp0SjVGUDFFMjViNDZiUnM1WnhhV2k4NXVhTVpUZXphdG9hbE9aQnp2eGREOTZPdkhCbEtOK0plWVd4WndjS01KNjErZHFEMnJRd2QzR2ZGK2JHK3lGbTR5bGRiS0JKVzNSeU85QjkyRzlJYSswOHBFeXdNK0FJMy9FRGkvYUZKWVBmRFFnWFZnSFZnSDFvRjE0R1lVUzN0L1dCWXJ2YjRHUFlGLy9aWkcyYmJPNmFEWkZIdE1ZT2QvNTNUMy83N2hwTjE5MTZ2L2EvaWtaZlNRN2llazBzYnhYcFJJZWZKdE1WSmluT0J0ZkJzMmRQY1Q5bnJKU1lWV0lpVmhyenN3ZFBPZm1BM1hWZFNlZmlJV0YxWlBCT3BxVTJGYXRiK2psdGJqUlRkR2lUQkwvTXZNVFFNY2NnWVN6Q2ZleW9mZUFMMWJhazRWRCtrVko2elNBTEpTcWJkS054bHdjSmV4M3BXS3FLV0ZWZEN5VXFGMFhIeTluVmFUQUFkU1F6V29wcTVVSENxaGNsRU1hcEt2OFlHYnFycFlGMmh0eVFsNmFmdGRVMUxsTFg5SmFNZ0w4Ni9mVXVjSXluYm5qUmlIRG1qbzBES1ZiK2NjSGRoOHp0amlrOWxxeHFFREdtUGtvVmhQRDNWZ0hWZ0gxb0YxWUIzNEZBUldJaVVZWmJXc3A2a3JKMHBUd29hOTdxaVcxZ216YlBKeVVaUE5BRkNUZlBpWG1ZOWFsbEdUZlBWS0JKbzFzSCtKdVZsa1d2ckV0Sll1MWNvV2F5WjBjeGszS2RhV0JPZ2ZyTGxIL0pwbTAvdGhIVmdIMW9GMVlCMVlCOWFCZFdBZFdBZHV3SHpZZTZGVzJlMFNUNk1uRHc1bmFIdzR4dDc0OTN0NzBGVEpyOGNBRHZUU2ZKSHRmSTErRVo5LzZVRUFVODV2L0xjSUJQWVpmQ2RkcFQvLzJjUG5QM3RPdmtvM2haUlZTbjVlNVVNSVFibFRFbUZ2NGM4OGZMdk1pejhBUHIvazIyWGVsdFBDVXNMOHhSN1diS2srVys3MWp3NitwdWo2aDh0WnRibjY3Nk1HR3JtbUVXMjcwWUNGZ0N2UHNiQmpkNEJuM25NZDgwVWRCMjZBRVBESTMreE1Qc2Z5NTFWcG93R2V2RHVNSDk2S29tM2NzVS9WTGw3aHA5bFJ6TGpEamtGdEFUWThZWVNKalF0amp2bjd4b1V4akJ0bWFsbE9LOXdtc0Z1UDlNaGhOa0dZdFFVK2l2ZlRLaDlPOTVHR1hPbVMvTHphMS9LQVAvODUxQVZOdmRSSzJlcDRTbGZGYzlNbGxtcS90WmpBdytlWExGL3ZaLzZ6RVZ4NWlCZWVQU09DTTBlYStOY3JUdnlCa0pOcmJLbG1QTS9QNjdXbFkzaWdmME9mcExnNFFEQWdhZFhhZU5UZjgvUDlHQXlDMk5pR0o4NnNNR3k5Ly9xZEE0N2F3dmV2YnBVQ29qOHRTbVFLN05RTEFEcXdEcXdENjhBNnNBNnNBK3ZBT3JBT3JNc0ppR3ZwaW16WndzUzFkRVcyYnNPbmtqUkppVWRLU2M3NkRjUjA3NFpqOXg2c01URm9VdUl2TFNHcWExZUtkNlhRZnRoUWhCQi9QbUMvMzQ4UUFpa2xnVUFBcTlXS3crRmd3NVJiS1c4YmozbExNdDYyclJGU29PYm5FeGcwZ1BDTUxHd3JmeUUyTmhhMzI0M0JZS2c2aHRGb2JMN0FVa28yUGpHVGdEME02ZlVRK081bjRsNTlucHdubmlIK2tmc3B1UEd2K0JIZ09QaXdjL0NYWCtrMjkxM1dUYjJWaE9rUFVYelhBeGpPUFJOaE1tRjB1eGsyNDlFR2Jma0diK0dnWW1ESHc0K2lTb2tKMkRYMGRNSzZKWkkwK3pXMmRVMGtJV1VQWlVnRUVJR2dlRkIvdXA0MWdSOGZmWUtNWVdNSVErQmJ2WVlnMFBmeGZ6VnZweVdFWU1EOTkrRHYzZ1UvNEFRa2d2RHp6eVU4UEp4NG80bnZDWkNCWkMrU0h3Z1NiellURVJGQnhBVVRrUWljZ0Ivd2QrOUN2MmwzTmJoZE4zZ0xXeXdXa3ZvTklDWWxBd0F2WUJneXVPckM4NUMwMnQvQ3VXaFZONnJIa0NFa29uTGdxUWhILzRGWXJkWS9oNWZXZ3NIUS8wZjU3UkhNN0VSREFCZGdKTzl3a3dEVVE0N3hwK2lISlpMMWFQd0hMeFdIcVdRV0d0Zmg0bHBjWkJ4MlM4cUY0Q204ckVkREl2ODh3QUZONHgxOHpNUFB6OWJxU3JRWERSL2dBL1ljQnZ5TDFjQmMvTHlMajRDbU5XL2dzcUlpL0Y0dlpVVkY1SlNWNHRyL2ZURWFUcGVMWUNCQVlWQ2o0SkNXY3lBcDhQa0lCZ0pVT3AyVTdQL05CZXdySzZPOHFBaS94ME5aWVdIenNtRk4wMWg3MTMxRWpoeEd4ZExsdEZtK21paWdQUXBSRW9wWHJXR0hhcUQzemxUY0NCTDIzK2Q0QkIwMmJXSEh3czl4ckZsSHBKUWtvQkFKdEZtK2lvMS92NHVJY1dNcFc3T09Nejk4SDBWUm1nZXdFSUtvRVVOSktTOURHWHNhY3N4by9PKzlSM2ROSXlyUFFmemNUd2pNL1pnWUJCTXdNSkxRdkFZYkFnVndUYm1OZUFSUjBlSDA2TndldjZLUWUvUE5JS0Nnb296dUk0WTBXUGZVWU1DRDc3d045OVBQNDNqemZWUWh1QWNWaVVxQjFjeEd0d2ZpWWxFTVJ3OFR0WUFmVVZSTXVNWE1QNlFSRVFUZW5rTlFTbUt2dTVyQmQ5N2V2SUFCREFZRENVa0RpWnIrSk5aRFJtRjdBRnNKMGlZN2wyTTllZWdGOHRIb2wrdEh6UzJxK3Q2TnhKNDBFSVBCMEx4c3VDWlJnWEFFMFloakFuc0FGd0tWeHBlVGtnOTc5LzlyVVFVQUNWUWM1ZnYvNGVjS1hFekd4UWNjdWFaZHhmNTkvMVRBUWVBUlBGeUNpM21IUUtXaDhUUmVkcUd4YzM4a2RtandNUTgvbCtMaS8vQVMvRE1CYnlQSTV3VElRdU1OZkZYcXV3dXRHa2dRMkxrZjJBTzhpWTlNTkQ3SHp3NytSTEYwd1NHUnNCTUk3djkwTkZYVnF2NlhWQjd5WGQ2ZklaYXVjTG5JUWxKOHlNVktxQW9aSThJRUZ2UEJMc3RxRmtTR2h6NlhISll1RkNQSlFsTHBkamUvOUZCS3lhNWx2NUgvekl0VUtJSWVtc0lYaEhMWmNpQVhXSWdmbndsdVA5dUlxd1NLOHFGdEwwSGFjbzFNTkd3b3pNWksySDVzSDFDaENIS2Ztb1VsTm80ZVk4YzBTUERSWU1DcEgzNkVkVjhlY1czYVZFMFY5a3FKdTdpSUh2NEFWZ3lZSEZEeEJXd2ZyeEUxU05KcmdVcUgvWEJ1SklWR0ExR3hjWmlGd0U1b1NqRzUrZXlhdDRBZVk4YzBURldtV3NZemQ4RXVjNStlUGVyVnQvcDhlUDJIdmJSQzA4ajQ1VmRrcFJ1VFVVVlJWQ284SHRhWExXUmZ1WmZ6MmwxRmpEME1UUXZpOHdmQlpxSHoyV2VpSHBZa21JMUd6S2I2emJiMUp1OUtpYnpobXA1SEJVNGhyTUZmVG5PNGxDaVNMVmRxR0NxZzE3Y3FzWTBmYTN6V2c4cW1mem1OQnVRblNTcnVrclNTQ3FvSlBIZEpDbnByTk9YaU5FMGFXZ29CU0VGc3VxQmRxYkpmeFpyMnFSWkRVOTdaVmhzRTdrMlNsS2thdGhKQngvOGVPNkZvTWNtRFZST29rU0Fza3BPeFVNMUp5WmJNSnRIb0QzTTBLK0NUS2ZyNGNHT0pNMXhTTWlIVThmdHRFbU5MYjJGdkdMaWlKZjVTMEF5aTViZXdDQXBreWY1OFVjcVdEMnp3UzJ3UklDTEJWd2tCYndzSERpOFJoTTBML2ExMmtGZzgrcHk0cGpHdHcvTGFScytXVG9LYzJxL3kxSUYxWUIxWWo2V3JpZWIyNHMvSng1OVhoRmJweEJBZmc3RjFITWFFVnZ0TEhpMEFXSE41S1AzMGU4cStYa0xGMG5VYzdiMXJodGF4Uko1M0JsRlhUQ1JzN0xBL1p6OHNneHFPdVYrUy85UnMvTGwxbjNnU2Rub1NiWis0Rzl2UWZuK2VmamhZV3M2ZVMrNGsrKzZaeHdVTFVMbGlJNmxuVHFYZ2hUbC9EcWZseThvamRkd1VLcGV1UFFFNzBNaDk3Rld5L3Y0NGFGcnpCZFpjYnZaZU5RM3Y3c3dHdVFESGg5K1ErKzgzbWk5dzFoMVA0TjZhMHFBWFVURHJmY3ErK3JYNUFUdC8zMFRwd2g4YjVVTDJQZklpRGYxV3pSTUczdmV2VnhydFFueVp1UlM5OVVuekFmYnMySU5yM2RaR3ZSakh2RVhOQjdqc202V05makdlblh2dzdzbHFIc0FuMUFVZFR4KzliRjN6QVBibkZEUUpzRDg3djVrQTV4VTFEZkMrd2tZOWZyWGtJZTI4VzBZNlYydzg2b2I5YzVlamhOa2FIZGd4YnhHYnc0YzIyUEhzcHllTmJPWXRYTkJjYkRqLzFMTGhpcVhyR3A5V1NpcWFpNWN1YjVKK09CMWZlbll6aWJSMjdzRzVka3VqWG94ajNsZk5LNWJPL2RjcmpUYnk1OHZjMTd4aWFRRG5xajhhSjF1U2tuMFB2NFQwK1pzWE1FRFduVS9nM3RJSStmQ2lacGdQaHlvZUh0S3Z1aGR2YWtZRFZUeStKbmZHNjgyMzRuR2dyMHdkUDRXS1g5ZlVYNHVER3JuVFh5SHI3ek5vU3FsLzFiS3NnajJYM2tYV25VOGVkM1JVdVh3OWFXZE9vZUNsdVRTMW5GZ2hYdE53L085TFNqNWVUUFRrYzRtOGFEemg0MFlnTEthamhxYmxpNWRUK3RtUFZDNWZ6OG1TaHBrZzd2SGhtTGNJeDd4RkNMTUpVMEpyREczaVVNUHRCSW9jK0hPTEdqMUdibExnYXZCZUg5NDlXWTFldVdoeUcvNnppZzZzQSt2QXV2eXBwUHFBT0xTNGlXbmlNRWJkaG5WZ0hWZ0gxb0YxWUIxWUI5YUJHMHVxVnp6S3kxM1liSGt0aTlCUUEzQjR1QTFvbzZ0MFMxVnBxL1VkajljckhhY01zTWVqV1lBWVhhVjFZQjFZQjlhQmRXQWRXQWZXZ1JzNjBtclZ5dW9CV2xSb1dYRFlPSHlMZnlSZUhMYVEzcW10MHBrVm1TNHBaTjRwQTl4cFFTZTlBS0FENjhBNnNBNnNBK3ZBT3JBT3JBUHJVc2ZzcVZwNjJGQVQwd0xrb1o1WVRKNVJTVjduK1EwUzEzL0dyZWdycHVuQU9yQU9yQVByd0Rxd0Rxd0Q2OEE2c0E2c0ErdkFPckFPckFQcndEcXdEcXdENjhBNnNBNnNBK3ZBT3JBT3JBUHJ3RHF3RHF3RDY4QTZzQTZzU3hOSnRZbHBZNjk3UDN2WjJyMEpKM3JRckdYVGFOOG00b1NPSVhQemNTYWRlOEtBNnFpa0hOc1g3N1hYYlZnSDFvRjFZQjFZQjlhQmRXQWRXQWZXZ1hWZ0hWZ0gxb0YxWUIxWUI5YUJkV0FkV0FmV2dYVmdIVmdIMW9GMVlCMVlCOWFCZFdBZFdBZldnWFZnWFpwR3FrMU1PLy9WKzcyVnhsa21oR3d4Z0NNalRuYy9lL1VLMjFGVk9yV3NuNXBkY3YycFpjUHBoWGRSN2hsdzZnQkxWSGJrUEUwZ0dIbnFlR2x2b0EwNzgvNE5VcHc2M1pLamNnd3QwWjVyN0lkYm9qM1hDTndTN2JuV1NLdWwyWE9kUXN1V1pNOTFqcVZiaWozWEdiaWwyUE54WlVzdHdaNnJ2YnFrbmJGRElCWFUydXk1VDl5UFhEVzQ5RThCR0paZVVQa3NLNDRPSEtaR2FuVTV5RHVyNDdoaHlDaEdkYkxYNmFUQmdKZWdwdUhPbTR1d0RjVmZzaGhGTmFGR1RFQnpiaUFzWVNvQ2lXb3dOeml3dDJDVjc0UUxBQUZOY3ZXOHZUaGN3VHB0N3lyOG1vcXMxL0FGakFSRkhDTGlZbVRZQlFSb2pUOW9vaXp6SFZ3RkM1dGVwWTlITWt0OTNQaFJCb3R1U2tUVVl0TDIxcGNSS0N2Rm9LaVlUQ2FXNXViUTFoWkx6L0I0Zk1iTDBUUU5lMlJrODNOYWg4czN5V1hNV2xaUSswa1VCVlUxWUxWYSthVmdJMWNzZVpUemZubUFNMys4bHd4ZkFhcXFvaWhLOHdjR2VIanhQbFpsT091MDdaNktmVXhmL3c2alkzdHltcVVyMlpVRmZKRHkzY256MGlkaXo1dW05U0xHcHRic01ZMVc1bzJmRG1tN3lkdWJ6YWZYdm9EZjU4Zmo4VFRQZnZoRXBaVWxtbjR4aVZoTlppSmo0aEUwZlg5K3dzQkdWZkR4OVoyUDJickJZSkNDZ2dJMDdXQ1BWNWE3RzAwZS9LeHBHZ1VGQlFTRHdlYXYwalBQYThmSUd2cGpUZFB3ZXIwaGIyMFBiZWZZbTB6QTNoVUFJUVJ1dDV0QUlJQ1VzbmtEWDlnbmt2dkd0cXJWUTFzc0ZnQUtDZ3F3MisxMEdYRStucUNKc3JJeUtpc3JzVmdzZUwxZWhCRE5GN2hqbElrNVYzZXF0UTlXVlJXejJVeDVlVG5idDIrbmUvZnVSSFVhVUhVRHNyT3pzVmdzREJ3NEVGVlZteWR3YlhaN3VFUkVSR0MzMjRtTGk4UHBkTEpyMXk0U0VoS0lpb29pSVNFQnM5bmNKTEJIQVBzcUtud1FhYTF0cHhtSlpRemNzUlQzanVNL29RMFlvR2xRV295NlA5andOU0pnSUR2YmNVemdpdlRNU3VMNjF4ampuWjI3aHVzKy96ZkYvR21HWTFMcTNTMGx1QXA1WWNNTENQNjhZMDkxQmpiSUFLK3ZmWW9vWDhXcFVmRjRhTnYvU0hMc1BEVnFXbWZucnVHVzFNOXBDYUtjQ25aYlorQ1dZcmQxQm00cGRsc240SlprdDdVQ3R6UzdyUkc0SmRwdGpjQXQwVzZQQ1R3aGQxMXVTN1RiVTFxcXArL1hmcFlOb3NZVjAxYlBHTWVJcnRGVm56OWJ0NDhyWGw3VGZBbWwvSXo1bCt1djh0U0JXNnBVcTNoMGJ4M21UczEzTnZoSkp2WnJsZlBRUlQxMm53eEFoOU9YZmNYOFl3QzNpN1pZR3dPNGQwSjR3dmcrOFFrbnFWRUxkUnMrWlczWWJGUmsrNWlhcTdRbVEvVjdaRFdwMUxhUDJ4OTBaeFM1eWs1S29DR0U2NWlCeDZJTisxd1hKclcxTnZSSlgvNWhOLytZdDBVUFBIUWIxb0ViMldsOXNTN1hNWGRGVm8zOTVjeXIrdEs5OWNIeDROVnBKY3hhbkZyalNSTGpiY1ZwTDV5VGVqSUFpeXU4dVNPT0ZYanNLYXhrMmM3aUdnOXcvd1hkNFJEZ25CSTNDOWZtMUxqUFBlZDBqZTNheWhaN01vQzd0ckxsNkRaOHl0cHdVWVd2VVlacVUvSXFpMy9aWHBCM1VnQlZwZmlZd050enlrMDB3bFNpN3pibngzNjNPZitrMkRCUzd0UnRXQWR1d1ZMTllEZWtsMzdVTnNvOHZHWW5JRXpLSVJPcU5DbTFRRkQ2YTlySHFDcCtreXI4SndPdzFPTmYyU25XZnV0Um5WWlM1MGdEMEtVbHRXaUV6YWc3clZNMzhIaDNhVWF1Mng5WTNaSUFyVVpEN2pHQi96cDdRMXVFR05taW1sUktQWG5RZ1U4WnAxWCs3b1V1bThtUTE1SUFYYjZBSytKWUZZOXdpOUVHdEdsSndQdVpkQnMrTlczNDRZK1RzeXM4dnVVdFM2Vk4yY2NFZm5yUnp2WUljVVlMQ3p6MDRWSWRXSmNXSk5WS1BLc21UeW52ZThlVThQQ3hZd0VvSzNOei8vMExlZWVkRlhVNldGN2VjN2p1dXgzSGh4OVdmZGN2TlpWL3pGckRtMi9XN3Z3N2RZcmxyZGV2WnREMkg5ajM2S09nS0NUTW5NbFpzeDFzM1Y3dkFQQXplUHZvNDhNaUw4ZVFNbTRjbWJmZFJyQzhuTWhJSzdOblg4OHZ2OXhMWW1KYzQ5bVZJcmp6enZGcy9QZ3lPajUyTTlrUFBvZ2NONG9PcTVmVDZwNTdFQXFNSGVZZ0tzTFRzRGJzdVBQeG92aS8vNTNDTjk4a3VXOWZ5cjc5Rm9BSkUzcXhkZXRqVEp0MkZvclNzSVg2WHIzYThOc3Y5L0J3ZERKN1R4K0ZOeTJORHUrOGcvdU9jOWkrZHluSlc5ZHc1ckJ0dEk0TDBqdlIzYkRBbDArWnYvNS83U2FSK1BPdkNJdUZ0RW1UU0wvMldnS0ZoZGhzSm1iTm1zenZ2LytUdm4zYm5mQ0pqVWFWUng0NWoxVnZuVTNrN1plVCs4UVRSRjU0SVgyVGsybDE4ODNFSmZTbWVOOGUzdnZ2YTdTTDhSRVpIbVQ5dHVpR0JYYTcvZHFqank1aTNMUVZlT1o4UTVzSEg4VHgwVWRzNzlNSHgwY2ZnWlNNR05HRmpSdi9qOGNlbTRUUldMOEhKSk9TT3JKdStULzR1M01wdThlZFFkRGhJSEhoUXJwKy9qbkd0bTN4K1FKODhGbUF0MS9lUVA2SzVhei9NWTBGWDFyeEJ4cXBXOXF5Slp1UlkxL2laVG1jeE9Vck1iWnJSL28xMTVCMjhjWDRjM0l3bVF3OC92aUZiTno0TDRZTjYxejMrcExWeU5OUFg4WXZUdzFIdWVZY0NsNSttZGdiYjZSUGNqTFJsMThlY3B5cjlqQm8wSk04K1o4ZitDMDFrVmhyT2FuNUVUaDlkZ1JCQk1HR0J3WUlCaldlZSs1SGhrLzVsc0lYRnREdWlTY28vK0VIdHZmcFE5SHMyU0FsL2ZxMVk5V3FmekpyMW1Sc05sT05KenJqak83ODhkczlYSjN5Q2J2UG1RaFMwdjJISCtqOC92c1lZbUp3T3IzY2ZmZEhqQm56SER0MmhPcHVya0FZZTB0anViN25XcWFQV01EMEVmTjVjTWhIdExVWE5sN2drWlpXd1BpelgyRkdkaGM2L3JZYVM5KytaTnh5Q3lsbm5vazNMUTFWVlpnMjdTeTJiSGtVaytub2p5TmZjODF3dnJxM0c1NEx4MUwwL3Z1MHV2dHUrbTdiUnNURWlRRDgrR015L2ZyTjRMLy9YVUl3V0gxMW5GMGxDYmdDQm94cUVDRWgzdVpDRWZVZjFhMTJoZlBuLzNYQWdBSEhudUxoTUtxMFcvd1R4b3cwcEpUSVF4WXA2Tm8xSG9DakxVazBabVFuM01sT3VpMWVqQm9SZ1RreHNVcUw4dkxLYWRzMmdxKy92Z05OQytMenVUQVlyQmlOeGxBck95dDRjdXAxNUJkTFNuelJkSW5JcG8yOWpKektoUDNualNFbXhzQzZkUVZZclFLM1c2T21JZDlxd0FsS1pYaWlkQno3OXZpQTdFSlFWUVFnL1g3YzI3WlYyK1JvbnpXUEIyRUluVXB6dWFwdEV3T1kvRDZjcW9wTkNNclVJRkZ4WVZoTGlsR0ZZRy9PWmlMVmNncXgwemRtTDd0S0VqQ3JvV0dxdm4xYnNXREI5Y3ljdVpoSmt3WlJWbGJHQ3krc3FYc0xXMTU1SWpMNTl5VU4ycy91dnZUU09zUjdBdXZqajlQcXZ2dXdhaG9lajRldEw3eUFhYzRjMWlWRVkrellscEg5TklRTUp5NnVnTi8ySkFLU08rNFlUa1NFamFsVHorREhIM2Z3K3VzYmprK2xUMkxPaXV1eHg5ZzZadzdxd0lGMGZ2MTF0cWxKaFBNcmVTUFBZR05LRXRkZVp1V2xsL3hjZjcwZmQrNXU0dUphOC92dkZucjFLbVRpeEZjQTgvSGI4TWtPNmczcDZXelBWZ2k4L1M0L3ZPc2pJZnBDQmczdWlTVzluS3dzRjlGUnBWUlVSRkZlZmhvbEpURjg4VVVGTzNaa0FoMkFnb2J4MGswdHlmNmhYUEg0ZUhZem1MS1NBR2w3TnBPWXVKMkNyTTMwN2JvWGozTVA1NSs3SGlqQTZSUnMySEErb05YUFMydUpQZjFSVnVXRVp0TlcvUEpMdGMrbVRwMHdkK3RXcDMyRHdFVmFLZDlzOFBOSCtXQzJpTk9ac3ZwRndrWTdNTHBCS2dJUGZoWjkweG00QXRnRkxLTlZxeTJZVEpWNHZYRVlEQllLQ3F3RWc2TDI5SERwMGwzWlk4ZjJPS0dwK3VuWFhYZEVlbGdYWUVkSkNWOS85d043TWpJeEdsUlN0bzZpUjQ4NEprNjBNUHV0NS9ENnlxa29MeWNzdkExVGJycU5mL3hqSTl1MzllZUtIamZUYy9CTzdCMjhPTFJvK3cxdWRnQUFJQUJKUkVGVTh2SUdzR1I1QjdLemJVZE5ENnUxOEd1dkxkMDlaODZxb3dJYkRBb1hYamlBU1pNR2hESW1LWEY4L0RIbDMzK1BVRlhpNzd3VDIrREJ4L0JKc21yWm1XQnBLWGxQUFlVL1B4OVQ1ODU0ci9vcjd5L1lTSDVoTmo1dEM2VU9CMGc3N2R2R01HQ0F3cVpOSmVUbU9vbUpEbUl4bThqT0xtWE9uR1cwYlJ0SCtxN0Y3Q2h1UjlEUm1qVXJkeEh3NTJBMngrSnlxWFZUNlU4LzNYRFVtRzNVcUVUZWZmY0dldmR1QzRBL0o0ZU0yMjZqN091dnNmYnZUOXMzM3VLeCtYdTR2MTNYbzU3a2lTZStaZUxFUG93Y21ZZ2FGVVhyQng4ays5NTd5WjB4QS9POGVVeDdhell2cmJiZzg0ZU92MmFseGxlZnIyTCtoMHM1YTdTVDJCZ3JQcCtmZ0tiUkljRkk1YjZmY1ZaYWNQb2pjRmg3Y2Q3MTU3UDRsb3Z3ZUFJWURBNmtqSzJmMDdMYnpiejAwcFdzWFBsZ0NGWktpbWJQWm51ZlBwUi8vejN0L3YxdkNsOVl3UEFwaTNuKytSK1BlWnpjM0RKT08rMVo3cjMzRTV4T0w0YllXRHJQblV1M3hZdVJmais3eno2VGdlVXBXTVBDYWRXNkRmMEhoMFo3Um96dFFuR2duSUw0YlBLc2JncU5Udkk2NzZZNExvdis0MFppdHd0R2plcEV4ODVkTVZ0Q3JpY1EySEJFZUZvbjRMUE82czIyYlk5eHp6MW5Jb1RBbTVaR3lwbG5rbkhMTFZqNjlLSERiNnQ1TEtzTEU4NzVMMmxwdFhjSm1pWjU2YVZmNk4vLzMvejhjMmhObThqenpxUFB0bTFFMzM0N2Z4VGs4K3YzaXlrcUxLQjFXdytqVHk5aitNQklZa2RFTW5ub1VybzZ2NmFpeTNmMFQxaE41ejQrenA4d2t1VGt4N242cWlUaTRsb3pjUENvQTI2enhpN3FDT0RvYUJ2dnZuc0RQLzMwRHpwM2prVUdnK1RQbWtYeWdBRTQxNnlodzBzdmtmclFHd3krL0dObXovNE5UVHUrcDhqVDA0czQrK3lYdVBubXVaU1d1bEFqSW1nM2F4YkdIajBwTHl0bHpXL0x5VXJQSUNZdVFIcCtQdm1sazNodEIvUStGNjd0Q29VVlVGQjVDVitzeVdQdjNueisySnpOTjEvT1pjV3lROWZXSzY4YjhJMDNqbXFUbkR5RHFWTlBxNHFEZDQwYVJmYjk5eE4yMm1tMC9XMHQ5NnkyYy9HbGI1S1RjMklybDc3MzNrcjY5SG1jTDc3WVJFWldOc2F3Y1ByMEh4akswSFltZzl2RDN5ODRnOHRIZENBZ0VsRlU2QkFCZVc2WVBHWW8vN3htQ0dQSHZzekszOVA1K3NzRmFKcUd6V2JiN3h3RGRYTmFOOTAwdW5PYk5oRkluNC9jbVRQSm16a1R4VzZuODN2djhiMnhOLzg0NXoyS2lpb2JMTWpJelMzanFxdmY0dTc3dTlLcWpaMHUzYnFUdW1zSFFnaWNBVC9mTDEvQmw0NSs5TzU0TmtiNUZ1VWU2R2pweEtjckFteE4zd1VJSkg1Y3p0QTEyV3cyWEM1WGphN3BpRitjYTlhd0l5bUozQmt6aUx6d1FtSitXY1VOQ3l1NTd2cjNHeFMycWdjNDNVbG0rbWEyYmQ3TTFqODJZbEJWT25YdXdxQmh3N0ZIR1JuVkk1eDdMcjJGbnpNRlhTT2dWZHVKWERXbUV4TUd0UW9CUzBGTWJEeXhzYkYwNjk1bi8xRWo2dGJDcXo3NDN1RklXNUVnNG5wVFB1VUswam9rOGZMNE55Z3ZyMXQ1OU8yM2Y2T2I2RURZMk11cXZsdnp5UmEyYk1rNVJwS2swYk4zQW9GQU9XRTJPMWFyQmFOcUlzN3NSL2k5T0xMenlRN3JTMzZSU25IWkpld28vSUtLMGxGc0t5L0RYVllCR0NncERqQnN4RERTVXJid3pQTnZNWDVNWHpRdHVtN0FENyt6UFFXaSt3T3dMQmY0OXJoYTY5RkhGKzMvNjVBYTlySWZqbjF5UTRBOXFadUpqWXVqUTRjT0pHL2JpcHEzRlY5MEJCaU1sS1p2cHF6ckdaUlcrb2d3am1aaHlnNFN3cUpwYndteWVrTUdJQ2dxZEhIV2VkZnkyOUpQMlpXeURVMkxxakZ6T3FuSmc5OXZ4T01Pa3BHK203M3A2WmlFaHMwVUpCZ0lVSkd6QTBYemM3cjhpWUdkSTBpTTcwcTNoTXZvMHpHQ0lXMXRkSXN5TW1KRVcvSnlTOW1YN2VDanJ6YXhiczJxL1NVRnRXNURMWERMUXVEeXBvUnUxUnE2ZHQxT1dGZ1lOcXVKT004ZU5La2hCQVNDRWdYWTBXTTRSaVl3NWN5T2ZMNXFKN01mdnB5MjBmRlVWTGo1OHYwUENOdnlPcnM4c1h5MUpSZFRkQ2QrKzAwRE9oODFsajdzVmd5NUV1alRsTUNhMzgzb2J0bG9xb25Ta2hMeW5Bb21vNEZnVUNQTXJPQU5hT1NVN2lPcjV6NStyOWhDVmx3Sy9vd3l6aG8wbW9xS01oTDdkQ09pVFVkNkRSdk54TWxUK083N3RSUVdWaElJMkE5WTdBN1k4RW16S1FDRVd5dEozeGRCNTFaRkJJTlcvS2hVdUFQWVRRS25ONENtV1RIdHMrUFk0U1IrcElFeWg0djNjbjdDL0hRTVNoRHk4anhVVkdwNFBIN2M3dDFZYkVPSmlNekg3WFkyejRwSFFWazhCV1h4N013cTVjenVPeGsyeE0xYjN3d2d2OVNJeDJkRkVlQUxDSlIwRHlVN3l2Rjd3eWh5R25tODlHZHdXZ0RCOEo3NVBIamxPaFovSDhsNzY4YitPVW84RmxlUWlWbDc4Y2NiK2ZiSmJ4aDMvOFVNVE16bHFuRnBkR3hWeU9LMUZWdzdRV1BsZHBWK1hTeDh0emFLVFdudEtITzI1ZE5IRi9QcGY2TTViMjg2dnhsNmtCcG8yOXlCSlJkYWs0a0kra2lUMGJTT0tXYkZ5MSt3Y3BzZm8wRmdNb1F4cWs5SDF1NHlFV1lMRXRRcWVPanFYQUxCSE5idlVoQkN3eEVWaThkbllLeDVONm1CTnNlc1RUY1RZTUZQbnA3TWR3M2kxcWp0ZkxzT1BGNC9iaytYLzJmdlBNT2pxcllHL0o1cG1jeWs5MHBJUWcyaEY1RU9TcE5tQWEvS0ZSRlFiSWdmZHIzMlhpOFdSQkZGRUJDUkRvSWd2YmRBYUNFaEJkSjduOTdPOTJOb2tZU2FCSko3MXZQTVE5aHoyanQ3cjdYWFdudWZ2Zm44ajA2a0YzaWU3VUZsZ0FpSXVHdU12SFQvUHNZT1NDRXVDUXl1Tmo0c0g0NE00YktKK0ZzbWlaZG1DMkJZM3hQYzMrY29jdHdaMGtWR2JvbVc5QUxmcy9VaXU2Z25sVkZwMEJMb1pVTW1VNUNRN3MvREExTjVZY3kySzZiemJoMGRWbGw1c0g4S1JyMG42VC9LY1F6eHBsUHprck0xV2wyTk9ZaHBXc0dXUHp4cHY2ZVlkRzlmV2plcHdOWEZodEdzdlBXQlRSWWx6MzQ3bEg2Y29KOHRpN3pEYWs0VWhsMm1lY3FZdHlHYTVxbG5TRE9Gc25ObU9EdXRMYkRhbFEyamhnSFNDM3laU3g4V1lxT1hMSUVkSjF0ZDl2alo2OXJSM04yWHBJcHdydmFkeVZzSytMeVBqWUl0eFZmZStjY2h5a21xYUhKTjE1WW1walYycWRMd2g4Nk1yNVZvNmRlSFkvRFZLbS9vR3NWNkt3Ly9tbEFiakV2WFBkbEJXcmhFQXBhQUpXQUpXQUtXZ0NWZ0NWZ0Nsb0FsWUFuNDVnT1hWQlJ5UFBYZytZM2hWbStldzViREY0WmlNL05UMFpzcUd3ZHdoYjZVSTBtN3FOQ1hJQ0NTZDNJT3NiNGVyTjQwaTAxSFZtSTJXMGpMT3NYYW5iL2hjTmdiUHJESnBLZXdOQSt0cXdlSVpwU3FNdHkxYWJ4Mnp5Qzg4U0N6SkpXV1RkdWlWcmh4NE9UMmhnOWNvaTlHYjZva05yb0xna3lEdTM5N0JFR09nSVhZWnY2azVwNGcwRGNVdmFrVVY3VzI0UU5uNWFkZ3RCaVJ5eFFZalVZRVpTUnl1UkxSWWNkY0ZrZGhlU0VDQWlhYm5vcUtvam9IcnZNMHJZdUxCbCt0UHlJaXJxNnVGS2Y5aWMyc3cyYTJZaklYazF0ZWdzbGlSS3YyeG1LM05uemdac0Z0T0pWMmhDT0p1eWsvVTA2bmJnOGlJa2VPQTR1b3A0MTVEd2NUZDZJMzYrZ1JNYWpoTitsZy95YmMwZVZlL3Z6cGF4d3lBekpYSlg0K1hwak1abmFkMklqU3JpQy9JSjAyRVowSThXL1M4SUVCbEhiUUtTd1V5WXY1L284dkFNZ29UNkFrYXgvbW9vT1U2QXRwR2RXdVhuYXJyUmZnMElnV3ZQZmU3K2dNZW9iMHVwdjAzQlJDUEp2UVBIb29aZmd6ZHNnVVBEVGU5ZkVvOVRlMnBGQ29lSFRFdENwbFRZT2JTNzYwQkN3QlM4QVNzQVFzQVV2QUVyQUVMQUZMd0JLd0pEZERxcVFZTnRPeTNsL2pxUWRaT29Day85MkphZFZtUEE1RmQrQjRrNWdHRGRZOEo1bmJrdzVjSFhDUnV3L0p3VkVOR3RoTFgzWnJXR21OMmNnZFI3ZlJOdjNFcmRPazYwcmFwWi9ncm9QcjBacWRXeEYyU2p2Q3FtN0RLTlY2TnE1K1dFQmt5T0dOak5tMUhGVk1GTnF0ODFGLzhRcVJsZms4dWY0bm1oYWtOeDVnQVpIUnUxZlM4K1JlWk04OGpQZlM2WlFIdTZLOGJ4Q2VXK2JpMmlxQ1I3Y3NwSFZtWXVNQUhueDRFKzNPSEVmMTFoUzBMendLTW9FdmpuM2ovREg4ZlhCZjlDV0t2bDM1MTU2VlJCUm1ObXpnMkl3RWVwN2NpK0tKQnhISERhWFVYSWJOWVNkZGw0bERGSWtyT3NLZWlpTm92M3NMUlV3ei9yM2pEOXhNK29ZSnJERWJHWEZ3UFdLMzlxaGZtb2pWYm1WMXhqcCtUVmxFdURhTXVPTERIQzA1UmhlL1RxQjJRVHY3UFZ5VUFuY2ZXTnN3Z2ZzZDM0NnIzWUw3Snk4Z3lHUzRxOXdaMS94QmhvYmZTYVZWeCs2OGZTZ0VCZThlK3BqNUtiL2o4UGZFOVQ5UDBqSXppZWE1YVEyclc5S2FEWFJOalVmMTcrRUlrYUVjS1RuRzl0emRKSlVsSXdoUVppa250ZklNSFgzYmMwZG9QL2JrN3lmUGtFL0ltQ0hJWnYvQmdNVGRkZWI0MUVrTmQwcU5SMkczbzNyc2ZnQ0NYSU9ZMG1ZeUw3YWZDZ2hZSFRhaTNacVFhY2lpM0ZMR2ZaRWpDZFdHSU1oa3FKNTRrTERjTXdTV0ZUUWM0TmpNa3dpM3RVTVdHZ2hBb0tzLzZib012a3Y0a2I3QnZRaFVlRkZrS3VHdXNJSDhsRFNmUTBYeEY1cmMwRDdnb3FKdFJrTERBSFl6NlFrcHprVTFwSGVWOGxQbEtielQrVFZzRGpzaEtoKzhWUjVrNkxONHU5TXJWTm91V0daQm8wYlJzeE50QzlJYUJuQklpWE5kV1hubk5sWEsrNGYwUlMxWGsybklZcUI3UjBZRzMwR0JzUkEzcFJ0OWczcFdPVmJlcVEzZVJYa283TFpiSHppd3JBQUVHZklXVGF0YVI4RzVnc1p6Ylo0aTJqV1lKcTdCREF3ZFVQMUR0WXhFY0RnSUtDOXNHRTNhNGVrT0xoZFdJMWJHbjBTUmxZdnFTQ0t1WlhxMEpnZWk2RUJSVklwZ3NlRnkycm5aaGpMRjZWUExBcDFMdkducndBbXBkV0MxMVl6Z2NXRkduZXp2blNBNlVGVVljQnhMUks2VW9hd3dvUzRwUi9oNU1YSzFDdHN2UzlBZVRVUzI3N0R6SkhmdCtXdmQ4djJ3QXdFdVdwUE83dUdHNGt3V2x2UWNiRzRhNUgvdnd0TENEL1crWTRoYURjSytlQlN0bTJGT1RJWEtzelZxYytxdUtBaTNQckJaNVlKWWZHSHhldUcyRHRpc2RwU3VLbXcyTzZMRGdTVS9GVnRmYnpUQnp2VXU3ZDNhNHhCRlpJSnorVWl4MGhrdm01VHFXNzlKbDd1Nkl5c3JSOVJmZ0hZbzVmaHJ0S2prY2l3eUdTNmVBZWlLMHAxclZJc2lEdEc1cnQ3NWY3T2NlenBVYUR4dS9Sck84M1k2RzQ2VWRPVHRMN3pETHdnQ3pYMzlTQ3pNNTc5cDgybVduc2RwTVpFWTM5Wms2M1B4ZGZIaFJHa2lYZnc3NHJackJTMlZTZ285Zkc1OTRGeWZJRVNaRFAyT2d6aGFPZjFodVV6QVRlV0NpMXhPQ3o4Zi9oWGRBNzFYTHEyTFNzRmRSYVM3c3d0cjQ5TU5FUEJLcktDeVNTaWlJTHYxbTdSSnFTWW5MQkw3cGoxVW1DMVVtTXo0dVdxUkNRSm11dzBCQmJjSERVRHQwUXU1elJ0bHNROUtzUjFLc1IxeVJ6dVUrV0Vvam1hU0hOVzI0VVJMY1VFdEdibC9MZkxVREd5K1NoTDJMeUxCUllOb0Z6RVlER2hkNUFnKzRjZ2p1MkU3dEF4RnkzN0l2WU1JY2l2RForbDhjZ1RZb1kxc09NRHhUZHN4SkdFYkFiOHZSUHZaT0FvRFIxS21kM3Bhbm9DYjBrS0FseEdIV0VGNVZDaUZSMVlTMnl1Q2FGOVA5bjIvaC94T0hTaXRBNE5WWjhCV2hZTGRMYnZSZi9GVzJreHJUV3o3UUd3T0dlVm1EWVY2TDRxTjdsU1lOYmpJcmJSb0YwQlRmejMrSVZveXY5eUx0ZERBSDUyN05yeU14OWJtM2RINStwRDh6RitZVFhDeUtKeWorVkhrNjcxUXlXMllyRXJ5ZE42Y3FRaW1hVXNmaER3OUdSL3Y0a1NYN3VSNUJUU3NqQWVBWFNabllZZmhQTGI1Vi9ZOUUwZkppOTBKMEpRUjZsR010MXFQUW01RExiY2hFeHpZS3N3Y0g3MEVuWmMzU3lMcmRvKzZPaDE1eVBBUFozMlBvUXorOVU5YVJRbTBlcTNUcFQrTXpzTHhNVXVweURIeGZiOUhzTXFWRFJjWVlHZDRSNVR0OVF4NDV5K1V4a3FpM3U2TklIZHFraVZmei9GN2wxQ1NXTWFQdlI2azFLM3VKNG5YeTlqU2xqYTlxRkM3TWVyenRaVHV5YWZOajRQUXgrZVQ5TlJheXBSdXpCb3d2bDVnNncwWUlDNjZBd1dlL3R5emZ3MzZWdCtCSUhDZ1pXZld0eDJBV2FtcXI4ZW8zOUhEVEw5UVpneDVqUFpuamxQZzZVdVdieWoxTGZXK25wWmRKdU5RVkR0dWxsUUxMQmNkeU92aFRjKzZGSm5EY2ZYQWR4elp5aDFIdHRJWVJacVkxdGlsU3Bic2tGZkxKUWppRFU5TTg3dmJ2RGZrT1dQM1c0UnhxYUo5Z2JSaW1nUXNBVXZBRXJBRUxBRkx3Qkt3QkN3QjF6ZHdnczMwdndYOGdiRUE4WDhGK0lUTlJLcmQzS0JyK1pxQU4xcDFXRVNSalZaZGd3V3VNV3VwRXgyWE5OMi9MQlZuLzYza1ViVlBsZXlCQUxnSnNvWUxmTmhtNUNORFB2a08yeVhnK1E0ci9jcFN6b01HeWhTOHFnbWt0MUxiY0p0MGI2V1dQenlhMHZjS0VIMlZidnpoMGJSQndGNjJoZ0cwZ293djNVSlpiYW5nSFgxZWxZMWZCT0FkYlJERFZCNlhMQW8xb3pDQVQrTDhiZzFDQVdEZHRSbXRXTG42a2wxdXhMUGxBZzFMcmdwNGc3WHkvSThWcTFCZlV0N29nSmVaeTlFS01tYTRoVEhQdlFrejNNTFFDREtXbWNzYkgzQ0szWXkvb0dDVlp5VGRsYzU5dVc5WGFsanBFWW12b0NEVmJtNVF3RmNjUGZRUTVQenEwZVFTWGZXVk9jdUxITGJHQlJ3Z1UxeTJlVnp1ZXlrOGxJQWxZQWxZQXBhQUpXQUpXQUtXZ0NWZ0NWaVNoaUpWd3R6bjM1NlNITlRPdmRsaDB6cE9sNXhzRklBaTR0Szl6NWlybjVoV2twdnUvZDc0Yi9tMzF3ZjhjTjhXaHJkK0JGZWxXK1BWNFFEeG1MYWlvb0xodzRleGNjRjZYdTAva3pXUG51YVYvak9JQ2V4U0w2djAxN1hJTC83UG15N0tkenFia08wMjJsaTFmaXVacDM1aCtNQm10QWtmdzhnMmsramY3RzRVY2hWWjVTbVliY2FHd25neWE2MTljUTFXV21DVW00by9ROTNwcEZidzgyL3AzRGxvREFYeGtWRHlPbEh1S3A3cjlSbXJ4cC9tM1VIejZCbytBSmtnYTdoR2EzMlBBRnZ6WElzY3dBNThXR3prbHdvelRVSUZWdjJvb2wwckFkUTl3ZjFSME40RGdvYmN5blJXSi96QzJzUmZLZEJsMy9KR3EwYmdjN0pVWitFL1JVWVVyaUlML3F0aTFNQ3pOU3J6QUxjSHdHMDh1SFRBSVlyc3k5akFxb1E1N0RxekRwdkRla3NDVjRGN09GejdwcS9PWHFXTnhxams5SFpWOG5lNWpkbXJiS2lVMEt1TERBRXptT09nOGljd3JFYkFUcmovVU81czhUQjN4MDdDUysxSHZpNlRjbFBKTGFYRFY2emhjMUprRjNtaVFNOGhrNDJIUnNxWi9iRVMxMyt1U1NDNE9KdTYrM2hROXdaa0hNblp4YXFFT1d4SlhZN0pacmpWbW5TZ3JYbXVXVjdUeVRZUjNpdzJzS2pTUXJmMk1sYjhvQ1E0b0lhdVNobmxiTzd1L3daNU1IcExCZXRQTFdKMXdoeVNDdU1iQnZBNVdWQmg1dDBTSXdHQkFpdG5LZWtjSzd0OHo2Y1o0cXgxMXlFZ0tFZ3VPc3FxaERsc09MV0lTblBaemZPMHJsYkdlcmd3TDhnTlF3SDB2dC9DNGo4djk0NlRIUXgvUXY0WXlHd0JwZS9TM011YjUvdjhsOVdQbnVhdE8zK21VMmlmZW5OcS9tRzAzQzR4V2pWSm1FTEdZSzJLelpWV2ZseGp4K0dBdnJmSnVPemlLcUlPVER1aFlnWlk0cERMdldnV1BJcTdXbzFqY01zSFVDczBaSmVuWWF6ZFNUT1hNMXBYMTZRdmxuS0h5RlA1ZXZhWWJOdzdXTTY4TDVSb05kZHdBVVdvczE5M0d3K0tVQnlpblYxbjFyRTY0UmYyWkt6SGZvT0RkWmZYNGRzRGJjM3pyZzBZd0M3Q2Y0b04vRjVwb1VPTWpKV3psRFFKdWRZbUtnUE5YZUErRVRRREFUbkZoanpXbkp6SG1wTnp5UzVQdTNXQXo4bVA1V1krTFRIaTV5ZXcvSHNsdDNlNlRyZFRFUTd1RThEOUVaQUhBM0FvZXh1ckV1YXdOWFVsRnJ2cDFnQUcrTnRnNWY4S0RkamtJajkrcEdUY3ZmSWJNekdhWWVBeENWenZBR1JVbXN0WWYrbzNWaVg4UWtyUjBSdjF0SzdlYU5VazBVbzUvVFJLL3RiWm1QK1hIWU1SQnR3dVF5YTd2Z2FKTlFsMHY0RnVBWWdHWEZ4amlRbnF4ejJ4ajlHejZWMElnb3lzOGxRc05jOUV1SXpScW9VYVBpY0ZkZ2VQNWVzNVpyWXpyTCtNaFYrcDhLaU5YSUtnQU0xd2NKOEVydjBCR1dhYmtVMHBTMW1kTUllanVYc1FMNXBLZHdYSEk4aldQTmRVSzhBQUpsRmtXcUdCdi9SV1lwb0xyUDVSUlZTVFd1eHZsVkZPWFhjYkIzSi9BRExLVHJFcVlRN3JFaGRRYWl5c0hjZmpha1V0Q055bFZTRUR6bVNKSEV1cTVZbkhvZ1ZFTTNBaE1ndnpqS1pEU0M5YUJYU3UzaDcrVTJWcXo2V0R6MHFNL0ZCdUppSk1ZTVVQS3RxM3JvM2FsWjExVlNlQ1p2QjVNNVJSbHN5YWs3K3dMbkVoeFlhOG1qdUF1cWpaQ29mSXN3VjZ0aHR0RExoZHh1L2ZLdkh6dmtGWWVZalRIM2QvRkJSaEFCaXRlamFuTEdYMXlWODRscnUzaXU3V0czQ3l4YzdqQlhyU3JRNm1QaXJuODllVUtLN2JLZ2pnT3Voc3QrUU1QQUNPNWUxbGRjSXZiRTVaaHVFYVp3UFdLdkJmZWlzdkZCbXdLMFRtZktway9PanJKSlVIWFZTYnpnMWNTd3dGckV0YXdKcVRjMGt2VGJydVoxVFVscjUrVVdwaVpwbUo0RUNCNWQrcjZOWmVkaDIxZWVmWjJod0tndExwVjU5ZXc1cVQ4OWlUL2xldHBJMXVHTGpTSVRLMTBNQldnNVhiTzhsWSt0MWxrZ0xWMW1hQTA0VjBud0NLcHY4d1FBc29OdVRYcXNyZEVIQ0sxYzdqK1hyT1dCMU0rcGVjYjk5UlhyeEM2K1hGZFlEVGVkQU1BMEdGMGFwbjA4bTVyRGs1OTZvTlVMMENiekJZZWI3UWdGa1FtZkd1a2lmSHlybmlRcU55UDZlVDRENEJsTkUzYklEcURmaS9wU1ptbEpudzlSSDRjNGFLdnJkZFFWL1ZmWjI2cVJrSmdvb1NRd0ZyajMzSm40bnpic2dBMVFMdzVhdEk1eEQ1djBJRG13eFdPclp4SnZGcWpIdGxQdUIrcmphYm53L3MxNXljeTU3MDlUY3RiMzNWTlp4bWRmQjR2bzQwcTRNSFJ6alR0QnJYNm1xenQxTTN0YU5BY0NHajdCU3JFMTdqcjZTRnRXNkE2Z3g0azhIS3RFSURla1ErZlVYQkM0OHBxdXFyek51WmpuV2ZDTXFXVGdPVXVJalZDYjl3UEc5Zm5SbWdPZ0grcXN6RU42VW1QRHdFMW42dFluQ2ZpL1JWM2VOc2JkNERncHFqdVh0WWZYSXltMU9XMVhZaXJtNkFMNjRIZzhNWjJtMHdPRU83RlQrb2FONVVBSmtudVAzYnFadXFHS2NCT3Z3ZGEwN09KYVBzRkxlNlZGdkRaNndPSnVmclNiYmFHVFZReHE5ZnFuRDN1YzFwYWJYMzRzQ0ZYV2ZXc3Via1d6ZlZBTlVLOEphek9ha0toOGhiejJsNTg3WEhrSGxPQkZXczB3RHRlZitXTVVBM0RIeXNpZGI2OHA1Y3VhdEd6cklmbithZUJ6L0VhQlBabUx5RU5TZW4zSElHNklhQms3MGlURTBqVGVxVnE5Wmg5NjNnZ3kzVGJta0RkTVBBa1IxNjU3NzRRRit2OTQrTWJSQUdTSktyQzBJdkNnaG80QXBhalF6NkI2TTB1VlFDbG9BbFlBbFlBcjdWbzZXNkZMbFdTOEM5OStMZXJoMGxtemRUdEc1ZDR3WDI2TnlaOXN1V29XN2lIRTNJbmpPbjhUWnBsOUJRT20zWWNCNFd3S2QvLzhZTDNPeTk5MUQ2K09Bd202azg3TndxTE9EdXV4c25zRnlySmVpQkJ3QXc1K1JncTNRbTNOMDdkR2pZd0VJTk0xZmMyclZENXVxS3JhSUNtWXNMM24yY3UzWG9reTRrNFFXRm9zYnpiMW5naUJkZnhLdEhEMXlqbzNIdjJCR0Z1N3NUNW14TzExWmFpdExIdVV1V3cyZ2s4WmxuOEIwOG1NNS8vODBBdlo0NzdYYjY1dWJTZHNFQzNOdTN2L1dCZmZyMW8rdXVYZlJLU2FIN29VUDB5YzBsNm8wMzBDVWtnQ2ppc0ZvUmxFcUsxNjluZDl1MitOMTFGNTMrK2d1dlhyMFFiVFlRUlZSQlFRUTk5QkMzeGNVUk9uSGlyUTNzRWhKeS9tL1Jha1d1MVJMOTdydjREQmhBN3NLRkNESVpaWHYyY0hqWU1EeTdkS0hKMUtrWVRwM0NuSnVMcmJnWVUyNHVlYi8vam1pekljamx0UDcrZTF5am9tNWQ0TXFqenBseGRyMmV0UGZmUDE4ZU1uNDhwNlpOdzI0eVViNWpCNkxEUVpObm42WHkyREZrR2cydWtaRzRoSWVqRGdsQjA3dzU1MmF4Q1FvRlRWOTY2ZGJOZUhqMTZFSFhYYnNBc0phVklWTW9rTHU1WVMwdVpudElDSzR0V2hBd2FoVDV2LytPS2pDUXNsMjdFR1F5bW4vNktSSFBQMS9sV3FWYnQzTDg0WWV4bFplZnQrcTFrZkdvT3ZVUTNyNFJZRk5tSm5LTkJxK2VQWkdyMVRnTUJreFpXU2g5ZlZGSFJGQzhiaDNsdTNkajArbFFCUVVSTm5FaTdwMDdrL1hkZDFRY1BJakszeDlqV2hycFgzNUowcFFwMk1yTGNWZ3NOMVNqdjhJN2RWYkRaMDB5a2ErOVJ2Uzc3eUxJWk5qMWVxekZ4VGpNWnV3NkhXbnZ2WWNwTzV2S3c0ZUpmUGxsZ3NlTlF4MFJRZGIzMzNQcWhSY1FyYlU3aXZIUEdxNnpKSjYyWlV1Q0hud1FUYXRXNEhCUWVlUUl1ZlBtWWM3TnBmVjMzNUU3Zno2NmhBVDZGUmRqVEV0RDA2d1p1ZlBtY2Z5UlJ4b204RG54N3QwYjd3RURFQzBXekxtNStBNGNpRWZYcm1UT21FSHhoZzMwU0VqQVVsQ0FvRlNpOVBibThQRGhGUDM1WjUwQjEybTBGUEg4ODdUNC9QTkw5RnpoNllsZHJ5ZHM4bVNuSWRGb3NKYVdvdlQySnVqQkIyc1Z1TjU4YWFXdkw4MCsvUEJzcHl3aTJ1MVlpb3FRcWRVb1BEd28zN01INzc1OW5RK2gwU0IzZFU0bjhPeldyV0VHRDBFUFBJQk1wY0pXWHM2Wnp6L0hXbGlJQUtqOC9TbGV2eDdkaVJPSWR1ZnJQK2FzTFBJV08rZHduM005NjBycVJJY1ZYbDUwM2I0ZHQ3Yk8vVWR0NWVVb1BEMmRjTG01N092U0JYTk9Ea0VQUGtqYmhRdEJGRGszaDZJaUxvNTlYYnJVbVE3WGZnMExBb0ZqeHFBS0RMendBNXlGTFZpNmxIMmRPMlBPeVFFZzc3ZmZPUGJRUTlqMUYvWUt6MXUwcU9IVk1JRGN6WTNBMGFOUlIwUmd5Y3VqZU9OR2pLbXAxUjdyR2hWRnQ5MjcwWjg4eWVGaHc3QWJESFZXdzdmTVlGcm94SW5rTFZwVXBiWWJOWEJkaVRSNktBRkx3Qkt3QkN3QlM4QVNzQ1QxSlZYY3JqMWp4bGZFUHZPb3U5dlpzWi80K0V3bVRKakw0Y09abDQ5OWd6ekl6ZjJNZUM4djdPWE9kZU1EcGs0bFllaGpEQm55OWVXYm1FemdxYWY2OGRiSUFQS2ZlUkp6YWlxQkw3L01NL0grckZoYks2dTJMWVZaMWI5T0s1U1h5cEw2OWlYanFhZXdWMVRRb1VNNCsvZS94b2NmM28yTFMrMW5nMXEyREdUN1gwL3hvcmlUOUVGM0lOTm9hSFhnQUtFZmZJQk5wcXg3SFQ1KzczTlpvUjkvVE5IUFA1TVFHMHY1dW5Vb0ZESmVmWFVvOGZGdjBLTkhkSzNjVktHUThjb3JROWoxZVhjOEpvMmdhUFpzUWovOGtGYjc5NlBwMkJHZHpreDJkbW5kQTA5NjRyZmpUK3h4eDMvalRsUVJFYVRjZFJkbnhvM0RWbHhNcTFaQjdOanhJbDk5OVMrMFdwZnJ2bUg3OW1IcysvdEpKdWV1NU15SVlhakN3b2lKanlmbzFWY1JsRXJXcno5QmJPdzdWMVNqV3JQU0sxY2VvZDJJQmV3ZS95Rk5ac3lnZFBseVRzVEVVTHBrQ1RLWndMUFBEdURZc1RlNTg4N1cxM1FqRnhjRjc3MDNpazJ2eDZCNFlCQ2xTNVlRL3ZYWHROaStIWFdyVnBTV0duamtrVGtNSGZvTjZlbkY5ZHN0bFpVWm1EQnBQZzh0dCtENTF3NDBuVHFSTm1ZTXFmZmRoelUzbDhoSVAvNysremxteng2SHA2ZnJGVy9TdlhzVWgvNStuSWZpZitiTS9hTnhiZHVXTnNlUEV6QmxDb0pjenRLbGg0aUplWXQ1OC9ZaWluVWJrbCsySDk2NDhTVHRCdi9NdWlFdkVERjNMcnF0V3prUkUwUHhMNytBS0RKeFlrOFNFdDVtOE9BMjFhZDU1REwrKytVWVZqOFJoR1ZVZnlvMmJpVGlwNTlvdm1FRHFxWk55Yyt2WVBUb0h4ZzkrZ2Z5OGlycXYxc2FPM2IyZG5kM2RlL3FEb3lPOXVmQndWR0ljNy9Ib2RQaE1YZ3dYdmZjVStXWWYzWkw0ZE9uVTdaeUpSWHIxaUhUYUFoODRRV1VaOGVROSs0OXpaSWxjZWoxMWErL3NYYnRjVEl5YW1XMXRTcFdSdkZYQUFBZ0FFbEVRVlRkVXBXKzVySEhla2YxN2R2aThxZi9ZeVRoU3VJMWFoUmVvMFpWMDh3ajZkNDlzc2J6Um95WVVWdkFWWHVJaS8rai92aFZyNk5qOTEzM3hjN1ZMa0RCVjE5UnVtVEpkVjhyS3Z6ZXl6b3JEb2Q0NDhCQ1Jhbk1tbDE3U3pYZXlMVVVJZFpxTGIwb3dzTVAzOGFjT2J1UnkyVllyZmJyQjc3VlpmRGdOcnowMG1EQ3c3MFpOQ2lHc1dOL2FyelJrbElwSnlyS2o5dHVpNlJKRXgvQ3dyeUppdksvc1NadGI5WE80dXZ2NFhxOUQxVzJjdVVsQnV0NlJWL2lBVnhZSU5CdWQ3Qmd3WDZHRDI5SFJJUVBIMzY0anB5Y3Noc0R0b3g3U2hmZHQ0WG45VDVrZGQzUzlVcjJpQmxWZ0IwT2tjTENTdDU1WncwSkNUa0VCWG1pMDVsdkRIanExTVhIbEVwWjZLVldVY2I5OTNmbTZhZjdvVllyRWExVzhqNzVoTElWSzNDSmpDVHc0MC9RUmw4Nm44cGlzYU5TT2VmTk9QUjZzdi96SDNRN2RxRHAwQUh6RXkveDNsYzdTVXlzZnQyYzVPU0Nhc3QzN0VnR29MajQrb1prcWdBZk9aSjV5VlZhdFFyaXA1L0duWStVREhGeG5Ka3dBZU94WXdROCt5eG5oajdLdytQK1lOZXVseSs1K0pZdGljeWR1NGV2djM0QVB6ODN3ci80Z3NLWk04bDY1UlhrYTlidzM2Ky9aWGFiRU41NVp3MG1VLzI4a2l1N25KRzRPQ3gwR0kxa3YvSUtpYmZkaG1peEVMNWhNeCthdTlMdnJwbWtwUlhWZUlQZmZqdEFUTXpiTEZwMEFHUXkvSjkrbWpiSGorUGF2ajNwL3hyRG1BTS9jdmp2eCtuWnMzWkNUMEVRNk5TcHliVjFTeDA3aHZQVFQ0L1FzV000QUxxZE8wbWZPUEY4TnVKb3Qzc1pPdUVQTWpPdkxtWXRMS3prd1FkbnMzRGhmcjcvZml3aEVSRTAvK3N2aXVmT0pmUC8vZzgyYjJiRmwxK3k2RjlkZVBXMUZkZWxtd0FqUjdhblJZdEErdmR2eWZidHA1ZytmUk5tczYzbUduWnpjNUYvOE1IZEhEandHaDA3aG1PdnJDUnp5aFNTK3ZSQnB0RVF2SEU3cjJZMlk5ZzlQMTQxN01XeWV2VlJZbUxlWnZic25TQUkrSTRmVDV1RUJOejc5eWQ5d2dRR3IvNlk0MzlQWk9EQTF0Y0ZuSjVlekNlZjNNdGRkOFhTc21WUXRVNUpGZURGaXlkM2ZPMjFvY2psTWlvMmJDQWhOcGJDV2JNSWZmOTlFbDc1Z1k0UExPZlhYMjhzaENzdk4vTFlZNzl5NTUzLzVmVHBJcFRCd1VRdlhVcnpkZXV3WkdiaXNuMDl2NDMxWnNqZ21HdTZybHF0NUxiYklrbE5MUVNncUVoSGJHem81WUUxR3FYQ1hsckttVWNmSlhud1lGUmhZUVJzMnNYVGNUNk1mdUFuOHZOckw0VGJ0Q21SdG0zZjVhdXZOdUVRd1dQSUVOb2tKQkE0YlJxQ2l3c3hwWW5YZEQyVHljcXNXVHY0NVpmZDNIWFhOeXhmZnBpalI3TXVyOE41dStPczhXLzhCRVVGOE1KYjdHZytnSmRHTHFDMDlQSlRFS3hXTzNGeDZkQ3NOUmljaHI1QTVzNnBVd1dYZHk3MFpwNTdiakhMbGgxbTNyd0poSWQ3STFNb1VOOHhDTmRWbWJBLzVacC95STgrK2d0UkZKSEpoQ3ZIdy9ENEV1QyttK1UrTGx3NENabE00SnR2TnJOclYycHRYYmJtZVBobXl3c3ZMQ0UvdjRMQVFJK3JQaWN5MG84elo0cXYycTdjVXNGRFRrNFpkcnZqcW4za05tMUNXTHo0Y2I3NjZsK28xY3FHQjN5dGtwQ1FTMkZoSllXRmxWZnRxU2xvNERKeTVJekdtd0Q0cDRpaWlNMTJiVDZCTkQ1OHRSSWM3RW5YcmswYlAzQ3ZYczBJQy9QbTdyczdNSHAwSi96ODNLNTUyT1ZteWpYcmNGWldLU2RPdkEyQVhPNGNhK3JiOS9QR1c4T0NJSkNXVm9pSGh4cXQxb1hDUWgwbVUvMXVxMTJUMjFqcndBRUI3a3laMHIrS2I1MlhWODdreWIySmpQU3JjMUMxV29sYXJlVFJSM3NnbDh0UXFSUjEyNlFMQ2lxWk51MFA3cjIzSTc2K1dvcUtkS3hlZlpUcDB6ZlZTODBPR2hURGE2OE5KU1RFaTBHRFluam9vWi9xWG9mQm1USWROT2dyOUhvekkwYTBxeGRZbFVwQnk1YUJkT2tTZ1Z3dUl5dkxoMWF0Z2poeEl1ZWFydk9QOVpBNzN3OWNNZkpPU3NwSHJ6ZGpzZGc1Zmp5blhvQWREcEdFaEZ4dXV5MFNpOFhPcTY4dUp5NHVBN3ZkY2FWVFQwTGM0Z2JuYVltaVNHbXBnVGZlV0VWQ1FpN0J3WjVZTExiNmFkSTNVM2J2ZHNiSlpXVUdKTG1hYnJWcUJCNi9CRkc4cjNFUkNrdjV2RVA5N1BQUXFJSUhDVmdDbG9BbFlBbFlBcGFBSldBSldBSytUSGo0eFlqZ0ZoRmVxa1lGbUY1bWFmRjhUVW5WclNtNkxQRTZaVXRLcFdpeU9zVGFGb1BGSVc1SnFienU4N2VtNkxKcU5RRmd0amxZZGFLQ2IzWVYwYU9KbHQ3UkdvYTE5cXlWMmxtVFVNNk9ORDE3MHcwODA4dVBrVzA4Y0ZISWJxNE91eWhrNkswT2RxVHArSHg3UGdGdXRmZStVWUNia2krMkY3RGp0QjZEVmJ4aDJGcXBZWUFXZmk0TWErVkptZGxHMnlEMUZZOC9sM2VUWCtINTI0VzQwcjJKRmk4WEJTMzhWTFZ2dEs1WE9vUzRzbVpTSkE3UjJjU3ZKQ3VPbHlHVENkd1RlL21tTDRvaTI1OXFqa3dHQnF2ajFnSFdxSnhWSlJQQVZTbTdEQUM4dUNhSDczWTdweW8rMWNPWHo0YUgxcmdUMThYWDBpaHJwd2V0dFg3NGF1YVVDQUo4T2l3RXUwUEVMc0tubDRHOTFtdlhPL0NNWFVWa2wxOTVua1ZLc1lrbGp6VGxqNGNqU0NtNjhweks3RElyTTNZWDFZM2pjYjNkMG5NcnM1bC9xSlJQdHVUemJHOS9YdXdYVUxPQjgxZlR3bDk5VmRmK2JHc0JYKzhzb016bzRFU2VrZW1qUW0rTmJ1bjlvU0hvelE1S2pBNm05Zkd2dGRwNHZtOEF4WG9IQm91REQ0WUUzenJkMHJGY0kzK01hMHBpb1psS3N3TXYxOXJad3JqTWFPZjFPd0pwR2VEQzBUd1QvYUxkYmczZzJuaVE2c1JISStmMU93UHJMbmlJeTlhWEZPbXRvWTBzZUNpcEVmajUxYm1uRU1XMmpTcGNFb1JUVWdKQUFwYUFKV0FKV0FLV2dDVmdDVmdDbG9BbHVURXA2VFhRSURwelpvM21VOUpyb0VIU1lRbFlBcGFBci9FdXN2TmJDZ0VZbTdYRTJLemxoZS9sOGlyZjE2WFUzUVJ4dFJwTUpnQ1dUdnlLVGJvZzNzaWFnODNOaFZGai93dkFpZ1hUVUZZYWVTOThBbmU0NVhIZmoxT2M1NnBVY0lPNzhOUXJjT0s0cDNoazZNczhWSDZTZG5GeExGdWVUTFI1RzF2RlNuNTg4ejVDVHIyRkhSWC92bjA0bVQvYk1DWVhzbHFwUlBQczE1eHFHY1VmYnFIOHNIRVdiWDZkMlFDYXRKc2JUd3g5Z2VEa2QvaTBUTWZSekVwZUxsOUJyRFdURlB6d3NHVVI2NXBJak1zSnRKVTUzSC83VExxSnE4QlN3UmN0Qi9LbTBZTm5iS040Y3ZBMHhMT2J6TjNTd01hd0NJNVVDcFFLZ1Zoa2Jzd2ErREFUUFI5amxib3pJbERpZmpjN3pQMDRaT21Hem1zWU1oK1J0MytKbzlmdG14anVYVVpBUUZQRzZqZHdWSy9BR05yazFtL1Nyb2tuZU15MWlLKzh4b01nSThwVFlFWDVkQXJSa2lnUFpvL1ZqRXdzd0ZWdXA4SmtaZC91RGlRbEJWTEpZTm8vTTR3WFBUd0k3dEdQd21IajBTU2VhQmc2UE9YM1QxZys1bk02KzhwWWxXbGp3bjN6S0VvdXBrV0VoZ0d1Rm5UZWs4RGh3RDIza1Bpd3dTVGxXUEh1SDgySFQ4UXp0V0FmSFRZdFJyRmlkc014V3VGcmx0RDE0UThvTnFpWVlUL0tQY1d6OElwZkQzRjJXRmJOQ1hJNTVkNERXUjR4bVc4Q3V4RHdyM2I4ZW4vTE9nR3VNdjUrYk1iU2d0Z0FSKzJNZDdab0FXZTNCY1RmSDhLZEN4bVJudy9uRmdjTURZVnptOWhrWmtLaGMxa1oycldEVTZkcTVUR09GOGdLMno1OVgvVUQxcnQzWjJmVjJveXlWMSs5RUxWTW5ueWgvS09QTHBSLzlOR0Y4c21UTDVTLy9ucXRQY2J1M2RsWi85T3VaZDE1V29MZ2RCblAvVzJ6WFZvTzFaZlhvWnRaZDFmdTBjTUpZN05CYkN3b2xjNVBhZW1GOHJLeUMrWHQyMThvNzltemdRY1BnbkRMTkdrSnVOYms2RkhvM3QzNVNVbUJQWHVjSHkrdkMrWEJ3UmZLazVNdmxCODUwZ0NCS3l0aDN6N25SNisvQUtOUVhDZzNHaStVNi9VWHlpc3FHbmlUL3Avb2xwbzBnZjg2QTMzS3krRzU1NXgvZTN0ZktDOHR2VkRlcHMyRmNvMm1mdWhyMWROYXV2VEMzOTkrZThHTGV2bmxDK1V2djN5aGZPYk1DK1hMbGpWQVQ2dDFhOURwcnQxS0d3d1FFMU0vVGZybzBjS1M0bUpUTFUxTWM2SHZubFc0QjNnNGpkQjk5MTNJVjUxYlNsMmx1bEJlVVFGcjFsQlpvbWViVDFkSVRxdVZwOGpPcnF4NVl0cmJiKzgrSllyVTJzUzBBTG1CdUtjelVlWm1YNEQ4K0dNWU04YjU5MGNmWFNqL3YvL0Q2b0NlM3lvcHNLMnZUUmVnL2lhbUZkZzFEUHhSUU4vMXlxNml2bXRQQnMwU0tMQ3BHNmlWUHBmQk5MclQ1c1VDUHYvclkwWSswZHU1aVd2VHBzNHZBd094N05qTnFwbmJlV0dUQnBQZ1Z1ZUd1WW8xQ1FyNmJva28xdDFDbmdJaTdaVkZ4QWFKeU9WeWp1WEJJWk52WFh1MVMvUHlucm81QzNtS0NNUmIvWW5QNUthSk5MWWtBVXZBRXJBRUxBRkx3SkxVbTFSeExUdUh2NThWSnc5dFZPOHRkYlpuWjhkbC9pZE0wbUVKV0FLV2dDVmdDVmdDbG9BbFlBbFlBcGFBcjBucU5DOHRsd3NvcjNHeEVhdk5nZDB1Tmt6Z0VYZUVzL3lIQVZYS3RpVHN4Rld2cGlTdkZFMHpEWDFiOVVDNGFEajFuc21iV2JFaG8yRUMvMU8ySisxaDJhR1ZaQmRtSVdJbnBMd0pLcVdTSHMyNk5UNGRkdGhNM0I3ZG1YczdqMFRqNG9tWEpwQXhYZTZtYTBRN0hEWmo0OURoODNwcEtzRlFYc2loQmF2b052a3BJdnRsSUtvQ0NBenB4STZ2dnFialF5Tnc5d2xFb2ZacCtEVXNpZzdzSmoyL2ZyeUU5dy9ZV2JsOFBxcUtaTlJsaDFqMisxdytqYmN4LzlNbFdJMDZSSWU5Zm12NGw4b1ZlOFZhM1BmUVE5OFBRUmpBMzkrdElGbmpqVkZmUXNXS1RWVGVZVWFRQ1ZSdVZLRzN0ZWRVaERjYnYxL0ppRmVuTUYyL2puZkx0dFlhb0FCNzI5Wm5relliOUVRUGJrYjg0aG44dTVNVkQ3MFJoejRhdTEyZ3U4OHhoTkJ5Q3ZRdVJBOStFck5CMy9CMTJKS1RpN3VmRC8yYm44WlYxQ0hMczNIbWpCM1JhaWV3U1RaZEFnb3h5N1I0K0hoaXlzNXEyTUJwc2txKysvdDVscWZIMGRaRFJyQjdERVZrRUtRb1JDWVh5Y01YZjFOVDBrb1RTUG5oSVNiSHRLV2J2QW51RFJYNGxMeVVYMDd0NDY2MlkxQXFsZVNVRmVIbUVVbUZqeHlGU29tTDFVcWFvUmlGWHk4Nkt6Uzh1RzhaMzhvMDlLakRaNnI2a29kWGx5VzFhYlFjTWhrTzViVzVpWEtyZ09CdzFDYmcwclpsQit0bmpvZk00VUIyemJ0amkzV3F3MUo0S0FGTHdCS3dCQ3dCUzhBU3NBUXNBVXZBRXJBa1Y0eUgweWJmazJtTTN4dldtQUJkTzNUUGl2cGhlWGkxOGJDQVE2aVBWR245MXFoRGtJeVdCQ3dCUzhBU3NBUXNBVXZBRXJBRVhOZkJROFdXdFZzZEZuUGZSbFdqS3BkdEh2M3Y2bGR0OE9EZWIyaFJJNnpVSWttSEpXQUpXQUtXZ0NWZ0NWZ0Nsb0FsNERxUUtyNzBydE5yZk0xV1U2TUNkRkdxZldzRVhuRGc4K2FIczdZMUt1Q09ZWDJiU3pvc0FVdkFFckFFTEFGTHdCS3dCQ3dCUzhDU1hMTlVHVnZLeFdzSkNQYzFMa1J4YVRCbG95VWRsb0FsWUFsWUFwYUFKV0FKV0FLV2dDVmdDVmdDbG9BbFlBbFlBbTZjWW9rN2tpQTJNckhFSFVtb3NZYVZuZG9sTkxaSy9DZVRwTU1Tc0FRc0FVdkFFckFFTEFGTHdCS3dCQ3dCUzhBU3NBUXNBVXZTNEtYS3hMUytxMS9NMnBaNy9JYTM4c3g4YUI1aFdyOGJ1MGg1Rm53U2Z1T0VrWDJ6aGNlM1NWdDVTc0FTc0FRc0FVdkFFckFFTEFGTHdCS3dCQ3dCUzhBU3NBUXNBVXZBRXJBRUxBRkx3Qkt3QkN3QlM4QVNzQVFzQVV2QUVyQUVMQUZMd0JLd0JDeEpQVW1WaVdtaUtJcU5EbEFRcEowdC82ZWt5cExwTzNmcS9yZDBHQTZLalEreGk2VERFckFFM0ZpTmx0Rm9iM1JHeTlWVkx0VDRaWDJzcStGd2lPSW5uK1RXMnpvZWwvMDE2dU1CRml3b0Z1R2d1SDU5K1UwQnJsZGZXcTkzMEtyVkNmcjBjU011enNEUm96R29WRUxqOWFVLyt5eVA1czFkV0xBZ2t2QndGVjkvWFhCekZieTJkRlNuczRzNm5WM1U2KzJpd1dBWGpVYTdtSkppRXQzZEQ0dkhqaGxFVVJURnBDU2o2T3Q3V016T3RqVHNKdTF3UU9mT0o0bVBOMVRUdkVBbUUzQTRSTTQxTklmajBtTjhmUlVrSnJiQjExZFI2MDI2VG96V3RtMlZvcHZiSWZITUdiTm9OTnJGVmF2S1JHL3Z3Mkpob2JYS2NhZFBtMFcxK3BDNFlVTzVhREE0VzRGR2Mwajg5dHVDaG1lbFI0OU9GUjk5OUxRb2lxTFl1WE9DK01VWGVkVWU5OXByV1dLUEhvbWlLSXJpZ3crbWllM2FuUkJ0TmtmREF6NTkyaXhxTklmRWFkTXl4YWlvWTZMWlhEMUVaYVZkREE0K0lrNmJsaW5DUVhIYnRzcUcydysvOEVLR0NBZkZ4WXRMTG52Y25EbEZJaHdVNzdzdnBjNk5scXh1cmI3VFhtaTFsNytOV3UwOHpzMU4zdkM2cFhPU21tb1NWYW80Y2N5WVZMRlZxK09pMVZwOWt5NHJzNGxCUVVmRVVhTlNSTG44b0JnZmIyaVlUZnJlZTFQRTBhTlRSWXZGSVVaRkhST25UOCt2OXJnbm4wd1hXN1E0TGxvc0RuSDA2RlN4ZCs5RTBlRm9ZTUJidGxTSVd1MGhNU1BEZk41Lzl2WStMQllWVmUyVzl1elJpVExaUVhIZE9xZGZuWjd1TkhRTEZoUTNITWZEYmhmcDNQa2t4NCtiMEdwbGlDSTRIQ0o2dlFOQkFLVlNRS1VTVUtsa21Fd09qRVlIU3FXQVhDNmdVQWdZalE0Q0FoUWtKY1hpNWlhcmRjZWoxb0Z0TnBIOGZOdDVUMG9RbkovY1hDdTllaVd4WkVrMFhidHFPSHJVeUxCaHllemExWXFvS0pmeng1MDdSNk9SSVpjTERjUFRxa25lZWl0YjdOdzVRYlJhSFdLM2JpZkYxMTdMYXR6aG9jSGdvR1hMRTdScXBTWXB5VVJpWWhzMG1yb04yRzVxRFYrY0FQajk5NUwvall6SE9mLzVacVY0L3VkR0Q2c0VuTjI3SjBwalM5TFlralR5SUFIZjBsTEZhTDMzWGtpakEzempqZi94YmtuU1lVa2FzK094QVJxZERnLzZCNk9rd3hLd0JDd0JTOERWU2JGU1NhRktkZE83Z2VzQ0ZvSHl5TWlyT2s0SEZONXpEMTJPN0NicXp3ZXdUWjE2eGZOc1p6OFZMcmRJUDF3SkJQNytPeWRYcnlSay9rS1UvL2plQ0ZoaVl6SGZkaHZ0NzdzUE1Td01GK0VZTm1zeE10ZUJuQmcwQ0kvTXpCcXZYeEVGYmsrQ2NXdFQ3Q2RsV05QU25BL3E3ZzZDZ0Z0RkJhcnI3SWV2YTA2Qk81QTZlell0WCs1Rldjc0hzYis5R0xYZGpoRnc5T3BGMkJOUDBHclVLSFE2NTNUa3BPTkw4VlpPeCtINUcyRitmbmcrK2lqV2Q5K3Q4ZWFtMXRDdUM1elJQb0h2dXdNNW5aUkVtTzlXSEs1ZEVCU3g1TTJaZyt6SEg2L3I0YTk3RWtYZzMzOVQydDlDNUtoUEtQRHZTL24yN1RRWlBwemdQbjFRcTlVWWpVYkt5c3JRNlhUNHVJUlFYQnhKb0o4SlB6OC9Pajc5TkZ0bXo4WXpKNmZhYTZ2L2hNMUo0UE9BamhBWEZ6cDI2MGJ5dWx6c2hiOVNzS1NZb0tRa3JuZGdWWEVqeWwveHpsN3lXK2ZpR2h0TGg5R2p5Y2pJb0xDd0VMMWVqNmU3TzRWSGo1S3piUnVxRlN2UVB2a2s4cGdBQUh6OC9WRU1IQWh6NTFaN2JROUFsdTJLVC9mdUJIaDVzV1hzV0RUYnR1RUMzT2hLd1RjMFRTYlFiS1p3N1ZvR3ZQc3VmMy8wRWRvalI3QVVGMk90cUNBbk54ZVZ3VURBV2VObEtTdkR6YzJOaW9vS1BEdzhhSHIzM1p5Wk94ZHREZGUyUHZBQVRXTmpTZHF5QmZWWjJGclBlRnlQMkZmOHhzRVdjYWhMRG1IWkJoN1c2aTJqcmJnWWxVcUYyV3dHb0VtZlBpUTNhUUlaR1pjY1h4NFFRSlB4NDdIYjdRaGxaZFRtdklBYjc0ZmRkVVJFSEVMakE0N0xYYTIwRklmRGdjMW1jelpySHg4TS9XNnI5bERseUpGNEJRUVFFUkZCZVZyYUpiM0FUUVVPVElPVDQ4SCtCWGlhYXo2dXpKeEpadm8rREFZRERvZURsTVNaaEEwN1RINUVCUGFMdXlSQTJiczN2cjYraUtLSUpUdWIycHlOcWFpTmkzZ1pMdis5MWNXRjRQdnVKZlBVcHhoOVN6R1docE9XbUVYbmZuL1JmcDhiOGQ5OVI5bXNXWGprNVdFUENjR25SUXRTVWxKd2MzUERkdlJvdzNJdHpVb2xYdE9uTS9pcGR4ajU0RFprN2w5Z3F0ak5iUVAveG13UjBCbU45SHpsRlhydDI0ZDE2bFFzUGo3b2RYbEVSVVZoTHlxQ3hOb2QvbEhVSmF4RkxzZnowMC9wOGNRVHp1WmFVWUhhMVoveVltOWNYVFVFQmdhaDErdkp6OC9IWkRMUjd2bm5TYnZMaFhDdnA4bk9YazMrdm4yNE5aVGd3UWE0dmZNT3ZaOTdEb0NjbkJ6MGVqMGRPM2Frc0NpWXpJd2pBR2kxV3BvMmJVcno1czN4OWZWRjdUNkFndkxCZUdqejBQcjZZcW5sNTZxekdqYU5HTUVkTDc0SVFFRkJBVEtaREQ4L1B3NHZYWXJ3WFJrSnY3NUNlc2ZiQ08zWGo2QnUzZkR5OWthdFZoTVIyUjY3dlRWcDhTTW9QZEViMTRhUXhLdUlqcWJKbkRtMDY5YU52THc4M04zZE1aZVhzLytOTnhCKyt3M1hzM09HUmNBQVdMeThVSGJxaE4zTkRTRWtoTUNPSGNrNWVnaXZIK2NnV0c2c2p2OFpQTlE2c0IxUWYvTVZyVWFQSVNzekVXUEo5OGl5N3lEdnpYZnh5TTYrcXBEU0JLaWhWcnFqV29tV3J2VEF4Wlc3U1QvK0ozcHpPR0UrK3psMklCS1pYSDdWVGM2MURnMXBuVFJwYzB3TXdkOThnM3RZR0NCaXR6czRuWkNBN2ZYWGNVMUtxdGNNUjUwMzZYTlNvbGFqR0QyYXUrZk1JVGtsQlpWS1JYRlNFb1hqeHFFc0tycHB3SFhXTGZtWVRIak1uODl2Ly9vWG9hR2hORzNhRkUyVEpwaW5UcjJwZWEwNjk3UUNsaTFqNjdoeGxPVGw0ZVBqUTlqZ3dlajY5c1VHRlBsQWVVQWpBeFlBOVlvVmJCc3dnUEtUSjRtSWlDRHF6VGNwaVFvaDVEOFE4VG9ZZkJwaG10WWpLWW5FWWNOSStPa25nbUppQ1BucUI4cDBEMUJ1QUtHMEVRSURhRTBtTXVmT0pTTWpnNURtelhHeHRhRDBQVkRXbzFJcjZ0dG9hRHc5c2R2dGJQMzVad0kvK3d5dmVyWmc5UW9zQWk3RHROZ3FQc0R2andOb2I4S1VrbnB0MGtiQTdEbWNwSFhOMEp5K09TOWExaXV3Q2ZBTGJVTFluMy9Xdnk3VnRhZFZrK2lnMW9QNlc4TFRxa25jdUxraWpROUx3SkkwYktrNnVmU0hUa3RBdUs5eElZcExoY21IUmtzNkxBRkx3Qkt3QkN3QlM4QVNzQVFzQVV2QU55WlZVMHYzek12RnhXdHZveUkwbCtVeU9iWUdZUDgyd1VEM3VyeS9UbWZoeUJGbnhySjkrd0RjM0ZSMVRCeWFYWE1OMTZHVWxabVpObTBUWldWRzJyY1BBdUR6ei9maDdlM0tsMS9lZ1plWFMvM1h2aWlLUytwaTRZSFNVcFBZdi85Q2NlM2FWTEd3MENBbUpCU0pKMDhXaTRXRkJ2SFBQMVBGL3YwWGlxV2xwcnBhOTJCSnpRa0E1NWUxbmdDWU1HRXRZOGEwSWl6TW5lSmlJd1VGUmtBa0lFQ0RyNjhybVptVkxGbVN5TTgvMzFVWDliaFVFSVQ2U3dEb2RCWktTNDEwN1JwTWNiR1JQWHR5U0UwdElTV2xqRDE3Y2lncE1kR3RXekJsWlViMGVtdkQ3NWFPSENtZ1E0Y2dpb29NRkJRWUVFV1JYYnV5MmJVckd4REp6emRRV0dpZ2Zmc2c0dVB6RzFNLzdOUWU1K3ZMd2xrVkVnQVJRUkNvcjNHMU9nZHUzejZBSTBmeThQTnpKVEJRQ3dqMDZCRkN6NTZoQ0FJRUJtcng4M1BseUpFOE9uUUlyR2ZIb3c3RXpVMkZsNWNyQnc3a0VoYm1Ubzhlb2VUbjZ3RW5ySStQbXYzN2MvRDJka1dyVlZLdlV0ZmQwcDkvVnRjdHBUUytidWxpeDZPMDFFaUhEa0ZuRFZvZVhsNTE3bmhVNlpicURmam11WlpWZ2F2bzhQd2pjM05OZGtQZEJ3OW5KMU9lUEZYM2FxcVdhM0pyTkZwVC81cGM1OEhEVFpCc0tRRWdBVXZBRXJBRUxBRkx3Qkt3QkN3QlM4Q1NYTE5VaVlmM1BqakoydUxCVVFwNTN6dDQvLzAvbVQ3OWI2eldDeStzdDJvVnhPYXhhbkxlZUlPQXFWTjVLQzZZblR1VHozOHZsOHQ0Y2x3WHBxcVBZVTg4UWNYanI5Qm1aRDgwbW11UGVVK2R5c2ZWVlVsNCtMVy84bEpaYWVMTW1TS2FOdy9FMVZWVjgvVGh3MjBHNlVzV0xhTHdrWWQ0LyttdXhNZS9SZCsrTGEvcUp0MjZSckQzM2JZOGRYZ20zdDA2RS8zWEJwYkdWK0x1L2pReE1XOHdmZnJmNlBYbUsxNW4vdnk5aElXOVNNdVdyOU9reVV0NGVVM2hnUWQrNE5DaDlDdWVtNU5UeGozM3pNREg1MW5hdFhzYk43ZW5Mem1teWh1UXAvTmF2ZkR6YWEybTU2aWVPTjU3R1c5TVBQM2QvOUc4VlFpN2Q2ZWlWaXQ1cEoyQ3lpMWIwSGJ2enRKY2QzUTZNOSsvZkR0VEM5ZmdxUlNKbkR1WGd4WWZSbzc2bHVYTER5T0tVRlNrWS8zNkU4eWN1Wlg4L0FvaUkvM3g5WFdqUkY5Q29hNFFyVXBMZm40bER6ODhtNDgrV2t0bHBlbjhNNW5OTms2Y3lHSFdyTzFzMlpLSXE2dVNGaTBDa2N1cm1wKzVjM2N6YXRRM3hNZG40bkNJNXpJNHdPRjNhbXpTdnI1VERjWEZPbGVBdTRlMzVhTjJaWWpyVnhQNjhjZlFyU2N6Wm14aHZQM1ErU2I5dTI5ZjdpN2FnZjNRQWNLblQ2Y2l0Qm5QUDcrWTMzN2J6NVhXQkkySzhtZnlpeDNKVWgvQVhPTENIKzlYVWxxcXYraFozQ2d1MXFGV0t6R1pxbzVJYUxVdWRPNGNRVmlZTnpLWndMWnRwOGpNTEtuaFRqL1YvTExsdkI4MldYdmYzdlI4RmtRUUJMekNnOUE2ekFoeUdUZ2M1TDcvUHZsZmZJSHZJNC9ROUpkZnNKZVZnVXhHWmJtQmlncmorVjhYNEZScU1XY0tqQnc2bE02aVJmc3BMemRXZVpUN0prU1RITHdFRjdrcnN1MEQyTGMxQnpjM0Y5NTYveTQ4MmhTaGNtaFI2dno0NXRQZDdOdVhkbFdxMWE5ZlM4YU83VTZMRm9Fa0pPVHc1SlA5YXdiZTFlTU9oOHZ1VGJXMmJJYlF1VHVkRHU0NWIwaG16OTdCZDk5dElTWEZtY1RyTXpBY1crL05wSmFkb2svcE5NcXk1TXo0Y1F3ejluL0JOeHUrNGNmeFAvSlF0NGRRSzlYczJwWENWMTl0Wk1XS3cxVU02VG54OUhUbGl5L3VaK0xFM2xXZjRYSXJpQ3VWY3NjLzlibzJKS2M0aHlKREVZUEdoRERsMlhmWnN2a1VhOVljb2FpMG5IUlJpVTIwY3UvWUdMcTBiY255dzR2NGF1Tlh2SExYSzR4b1B3SzFVZzFBejU3TjZObXpHWGw1NVN4Y3VJOWR1MUxJeWlwRkpoUG8yN2NsVTZZTUlEVFUrOXE2cFQzL25XT0tWcHN1bXlET2ZmOTlyTm5aQ0M0dWhFK2ZmdG1McDFYS09PTFppdWFkMU15Syt5L3g2Zkc4T3Z4VkJzWU1KTmdyR0pQVnhKTUxuMlQrM3Zuc2ZIRW5SN0tQTU9YM0tmUnMyb2VSM2sraXkxWFJzVk1vbmJzMkljamY5NnArM056Y2NsYXRpdWZVcVh4YXR3N21zY2Y2MUZ6RFB4d1J5MUpTeWdQUEdZWUpFM295K3Q2T2xNeWJSK1hHamRnblA0Ly9FMCtRODhZYitEL3hCQlVEN3lNNnlvL1NKVXNvK1gweHAvby94TGRyTTZpb2NGclo4bklqeDQ3dEo2eUpCNVBmN0UrMmV5NlB6SDZFNFoySDg5cVExMmdiMWhZL3JSODJ1NDNrb21SZVd2WVNBZG9nbXVZTjVlZEZCK2t5MEkzczVMMHNPNkNncVV0Ynh0N2ZoNmdvLzJwQlJWSGtoeCsyOGRKTFM2cFkrY3QyUzRXRnpkNUtTTWhWOWV3WnpYZmYvWnQyTHVXY2Z1Z2hySUtDTCt4ZCtIaldmc2ExdmRBdFBUd3poUTBiVG5ESFl5UHg3OXdPeFpmdk1MU1ZtalJ0T012WEhDYy92d0tBaW5JejhidEthQjBVUzJ6YmNGYWVYTXFXaEMyNHF6ekkxbVZ4TU9NZ0dxV0crS3g0cG5WNmo0VDBaTHk3WjdDNTlIY1NpdU9JMHJabDU1OEZ2UHJTS3Zic1NVVXVsK1BwNllxYm13dFdxNTN0MjA4eGFkSmN2djEyTXhhTDdSK0lsK21XZXZUNHlQaisrM2VyKzNRTUl1ZU5OekFsSnJLdjl6ais3NXM0aW9wME5YcGE3dTVxM241N0pNOCtNNER5QmI5UzhQWFhWSTZld05UVkZldy9jSWJRY0U4MEhuSzhmTlRJdFdidWVpaUNyYm1yT0p4MWdNN2h0N010N1c4NmhuZWlwVWNIRHVidUlpSHZHTUVlb1hUeTYwdVFPWVlUMjQzczJaSjdxVDRLemsxdGJMYXFXK3NwbFhLQ2dqekp5aXBGRkdmWDNLUmZlM1dvc2wzbWZrNU4reS9HTVJONDVtQVFlOTdhZGxXdTNQUFBMMmJPbkYzTW1ER1dIcHRHa2ZQNjYzd1hYa240aHE5WnRmOVBWc2F0SWIzOE5DWFdBbjQ5NWthSVp6QnVHamZLYlNqUkE0TUFBQ0FBU1VSQlZFVTgxZWNKdGlmdFlmNnhXWVI3UnZEdXlBL28xZngyV2dhMnhGS2hZbDNRTVFvek41eTM3aGMzWTV2dFFqZm80NlBsaXkvdVo4eVlMbWkxTHVqMVp0emNadGRzdEw2YTlrTnVNM3Roa01lUUlXU1hPeTV4SGhRS0diSXpxZVR0M01jcHM1WUZCeXNwS3JxdzczaTdkbUU4L25nZjJyUUpSYVZTNEdJc3d0akV5dHlkYzdHSk5zeDJNK1dWSm13T0cvbGxSWlRiOGdueENhWmJXQ2VPSm1mUU9ibzlrKzRZUzR2Z0ZwZjhxQTZIeUpvMVI1ZzVjeXZyMTUrNDVObEdqZXJBekprUEV4enNlZGx1NmJvSDB3b0xLOW0zN3pRWkdjWFk3UTU2OTI1Qmh3N2hWWTZ4MlcwVVZSWmhjOWpRdUdod1U3c2hGK1FVVmhTeGFOOWkzbG4vSnVGZTRjVDZObVZqNmw2S0RFVk02VCtGb2EySDBybHBaL3c5cWpkUStma1Y3TnVYUm1hbTg5WHl2bjFiRUJ0Yi9XcDVWd1Y4NkZBNjc3eXptZ01IVHFQUnFHamJOb3hCZzlvd2Zud1BYRjB2SC9tSW9zaFBQKzFrM3J6ZEpDYm0wYUpGSUowNlJmRDQ0MzJJalEzbGVOWng1dTZheStkYlAyZmk3Uk1KOFF6bWs3OCs1ZE14bjNJZzdRQUxEaTZndFg4Ym1nZ2RhYS91VDlwaE00TUh4L0x3dzdmajRuTDU4WHVIUTJUbXpLMHNYTGlYbEpRQ1dyWU1Zc2VPVjJvR1BuRWlaKzJ2dis0ZSt0bG42N0hiSFpkYzBOL2ZuU2VlNk12amovY2xMT3pTVGo0OXZaaEprK2F5Y1dOQ3RRYm01UTl1SnpkZ053c1B6ZVB0WVc4enNlZEVrcktPODhpdjQya1QxcDR4SWM5d09DT2VsUm0va0dNOGphZXJKNCszZVluRDY4MGMzbG5DazAvMlo5S2szcGMwVzRDVWxBSW1USmpEamgzSlYrOUw5KzM3YWRhMmJVbFhYRWxSTHBkeHh4MnQ2ZEVqbXZCd0h4UUtHVHQySkxObzBYNTB1dXBEd0dFUGhsSGVhaWRIOCtLWTNPRkZqRW1odElwcVFuaWduRDNsdnpJOWJqNVQyN3pQakZmU2FOcEJ5WURSL213dFhNbko0bmpHUjcvRW9XVVF0eWNQaFVMR3dJRnR1UDMyNkl1Q2h5UVdMVHFBMFdpNXR1RGhZdUNCQTJQbzJqVVN2ZDdNOGVQWjdOOS8rcklkK2ovOTJzR0RZMm5WS29pa3BEd09IODZnKzRBQWRLRW44SGRFc1g1K0FXZVNuWDEwVExTRy8weXg4bXJXZWtJMVRmRlBIa1JPaW8wN0I3Ykd1NmtOVWFuajVJa1NkcXdxSlBWVXlSWHY3ZU9qWmZEZ05qUnJGa0JpWWg1Ly9QSGs1UmNmaW83Mlo4NmNDZlR1M2J4S2VYbTVrZSsvMzhyWFgyOGlKNmVzeGh2ZWZYZEh2di8rWVFJRFBhcVViOStleFB6ZnRjeWJjNmhLVFFpQXVHczlkOTgraVh4ckJ2ZU02OHo5UXdaV09iZW91SktaSHR2NDl0dE5GQlJVMW5qdkJ4N294cmZmUG9TdnI5dEZxdlJremIvTzd0MnA2MDBtNjJWbmlGaXRkbkhwMGpoeHhJaXZSVi9mcVNKTUZBVmhrdGlodzl2aWI3L3R1NG9OSUF2RWwxNzZRNHlOZlZPVXlTYUpzZEhQaUF2dURSRmYvczlDTVNVajQ3TG5XaXcyY2RHaS9lSmRkMDBYdmIybmlEQlJsTWttaVowNnZTc3VYMzdvdW5iVU9qK0xwNmlvVXR5dzRZUzRjMmV5V0ZGaHJQRWg5SHF6V0Y1dXFHYXoxa0p4N2RxalltcHFnZWlvWWVkR204MHU1cVFtaTMrTUNhNVNialJheE0yYlQ0cDc5cVNLT2wzTnMzdDBPbE8xOTA1SktSRFhyajBxbmo1ZGVBbndKVTNhYUxUdzVwc3IrZXFyamVmalRrRVE2TjQ5aXVlZkg4UTk5M1JDSnJ1Z0Z2OU0wQ1VuNXpOcDBseTJiejlWUmE4bVRlck4xS2wzRWhMaVZjWDR1V25NQkhRelk3Tm1JY2hDK1BMTERiejk5aW9NQnN2NWUvZnUzWndYWGhqTThPSHR1TGhiMVdxckJuWUpDVGxNblBnTGUvZW1YVjE0K05sbmYrMmZOV3Q3MStUa211YzhObTNxeCtPUDkySDgrSjVWdWdlTHhjWTMzMnptalRkVzFHQXRuVDd1ZmZkMTR1a25JNG1OOVVBbTA2SXZ5U0Y3eHdOb09pL20wMDkzazU2UmdTaktPWEJRY1I3Nm5EUnJGc0RreVgwWk42NEhBUUh1VmZKZW4zKytubmZmWFYxTjhGQUwzZExGQmk0ODNBZEJFTmkzTCsyU0I2eitCL09tczg4aGRDZVYzS1BKUmhIbXo5Q2Ywdm40amtDMDVTVVVvY0hTVk1FaFRXK09KNVRYZUozbXpRTUpDL05HRkVYMjdUdGQ0NC84VCtCcVhaY1dMUUw1ejMrR2M5dHRVZWoxWm80ZXpXTERoaE1zWG55Z1NtU1NtbHBJYW1yaEplZVBHZE9GY2VONkVCTVRUR0ppSG9jT3BmUHp6enM1ZmJvSXZkN0NxQ1laeEJoVG5DdVpGQU41a1l3cjMzUCsxN2MyOWNkcjVuTDBlaHRIam1UeTExL0hXYmJzVUJWbktEazVuK3BhNHRpeDNmbjN2OC9sdEhJWk1lS25tcHYwdmZkK2w5S3FWVkQwVzIrTlFLVzY5TGZJekN6aDIyODM4L1BQTzZzRURlY2tLTWlUbVRQL3pkMTNkN3prTzd2ZHdiSmxoNWd4WXd2dGZEZng3elhyY2U4S2hnendudXhONWVKU1hQeEF2eG1DMTc1TzhKRDNxdWhyV2xvaDMzNjdtVjkrMlVWcDZhVnJ3NGFIK3pCcjFqaUdESW10L2VEQmJMYng1NTlIMmJFam1jek1Fa1JScEhmdjVqenlTRSs4dlRWWGJOYUplOStFYjkvRDl3SFE3UVdmQjZCc01iajFoTHhQSU9ETFIvSHY4SE8xNXhxTkZsYXZQbkkrcHlVSUFuMzd0dUNSUjNyZzRlRjZmY0dEd1dEaHA1OTJjT0RBbWZQQnc1MTN0cVpseTZDcjB1MmtwRHgrLy8wQWlZbTV0R2dSUktkT1RSZzZ0QzFLcFRQQlVwRTJDNWw4UHFtVldwb0hCYkUvcnBSdVhYeElLOHdueXNmQzZZTnF2bGh5TDY2dUttSmpReGswcUEzUjBmNVhkZThUSjNKWXZQakErZURocmJkR1hsNkhOMjA2eVlRSmM4aklLTG5FK1I4NXNqM1RwZzJpVDU4VzFkN01ibmZ3MldmcmVmdnRsZncvZStjWkhsVzFOZUQzbk9rbGs5NUlKNFZPNkUycGlrcFJVYTlTcmwzVXE5aTdLSFpVMUh2dHZZSmVMQjhYQmV3TlFVR3E5QklTSUtUM1BwbCt6dmRqUW1BZ21RU1loQ1RPZXA1NVp1YjA5NnkxMTE1N25YMzJ0dG1jeDVuY0hYZWN6YlhYbm9rWU5vTmRlOUk1ZE9nUUdidGtiRFlyNWI4WmNUcWQ1QWRGODhQUEIvand3eitPUEE4U0JTNjVaREIzM2ptUmtTT1RtenkzdytGaS92eHZtRC8vNitNeUlNMXFlTXFVbHc5Kzg4MzJ4SmJ1WXA4KzNianFxbEdNR3BYaTBYaDQ0WVVmMkxRcDIrdStlcjJhNmRPSE1tbFNQL3IzajBWVGY0amY3eDFCL3BndmVPU3BuNXZNT1I4dDZlbHhYSG5seUdNYUQvdFlzT0E3dG0vUE8vbkdnMTd2TmllejJVWkdScEhYdTlhVWhJWWE2ZEVqa295TVlzckw2NXJkYm14ZnVDN3lmZWJ2djQyTWJITmpRSktlSG9mRllpY3pzL2lFengwUkVVQnljZ1I3OXhaU1dmbXFkNU5XcVJUTW5UdUZCeDZZaEZhcmFnd3FmdnN0ZytlZi82SEp0dTdSRWhzYnpGdHZYY0hreWYwYXZXeHViZ1h2dkxPYU45NVlTVVdGK1ppaUlqZDhTd2lDd0kwM2p1WHBweTl1ZEg0Mm01T2ZmOTdOYzg5OTd4RzlOU1ZKU1dHODg4NlZuSDEyNzZPTy8ycnpPN3owMGsvcnRtM0w5UnJBYjl1V0s5OTAwOGR5UU1BY0dhNXIvQWpDYlBtNjZ6NlNxNnJxdmNiZDc3NjdXaDQwNkluRy9TYjB2MVplZEJieXhORVB5VC8vdk52cnVUZHZ6cFpuei81SU5oaHU5amkzS002VzU4ejVSSzZ0dFo3dzdMUWUxWkxUS2FGUUNEUTFaN0hUS2JGelozNWpUdXZNTTFNSkR3ODRiaHVsVW13Mkw3VmpSeDZXbkMxVUxiNmNpejhyd0JBVzNhcDlIUTRYTzNia2tadGIyVmdsSHQwa1BIci9saVpjWGlMTHN2ejk5enZsWWNPZWt0WHFHK1dBZ0RueWlCSHo1VWNlK1VvdUthbHBzZmxudHp2bEo1OWNJYWVtenBWRmNiYWNuUHlBZk9tbGI4by8vYlNyeWUxTGR2NGhMem9MMlZ6cW5wTjQ0OGFEOGpubi9FZlc2MitTQXdOdmtVZU5lbHArOHNrVmNubDVYWXZudGxvZDhzTVBmeWwzNy82QUxJcXo1ZFRVdWQ0MXZITGxucDhXTHZ6ejdJOCtXdFBrRGRIcDFGeCsrUWh1dW1rY0F3ZkdIN2QrNjlaY3Jybm1BN1p1YlhyaW1VR0RFcGd6Wnp3elpneHJiR1VWNy9pZEgrOGN3L2tMRC9MOEcxdDQ3cm52bW5SU0JvT0dxNjRheFUwM2pXc3lRN2xodzBHdXVlWkRkdTh1YUp2R1EvLytzUTNWVWpCS3BZTGZmOS9IOTkvdmJKVkhEUXpVTVhac0QvcjNqNlZIYURsODl5OCtNai9BTDJzS1crV0ZCdzZNUDY1YSt2SEhYVTBtSGxzRnJGSXBtRGx6T01PSEp6VTJIbGF1ekNBL3YzVkRqTWJGaFhEeHhZUG8zYnNiZS9jVzh0ZGZPYXhldmEvSlhnR1JvVnBtVFZEdzBoTDNhM3FpS0RCMWFqcG5uZFVMaThYT3RtMjVyRnlaUVZGUmRhdk9uWmdZeGlXWERDSXRMWXJkdXd0NCtlV1ozb0V0Rm52TVJ4OWRTNjllMGNjNWlzOCsyOENMTC83RWxpMDV6U1c5bVROblBNOCtlOGx4amZPTWpDSmVmUEVuUHY3NHoyYWJrV2xwa1h6d3dUV2NjVWFLeDNLNzNja25uNnpqcFpkK1pzZU92S1k3bklrQ2Q5MTFEazg4Y2FGSDd0eHJMSjJkWGJZaUlTRjBha3QzY2NPR2czejAwWnFqR2c4d2VuUXE5OTEzWHJOaDU5SEp3RVdMMXZMMTE5dlp2ajJQeWtvektTa1JYSExKWUI1NFlGS0xpZjQxYTdKWXVIRHRNUS9FMDNqd3dja01IOTY5eGNiRDM3dGoybDlCUFpZZ3lGMXJ4RFJaK04rZ3Fnei9pR2wrWUQrd0g5Z1A3QWYyQS91Qi9jQitZRC93S1lwSG1qYisxU2NMSmF1OVM0MllKbXJWaFZ4eFdkT3RwZllZMXVJMFNQc09ML1czTGNNN2lnOVE3empTejJ0MTlqYnNydVBIenlxdXE4UWxTVGdsRjBXMUZhekwzZFg1Z05jYzJzRnRLMTZteW5Ma0dkTnpxeGV6cGNDem02REZZV05iWVJhL0hkekM0NzkreU02U0E4eFovbUxuQXY0cGF4TjNmL2M2L3pmckNicVp3anpXaGVvOSswenFWQnJPU1IzSy8rMWNTVzYxdTI5MHNDNmc0d1BMc293c3kveDY0QzhlL1BGdGxsL3hER0g2UUVyTlZkejV6YXZrVlpjMnVkLytpbnordSswbnRoWm1JZEEydVRlZmphZFY3N0NTVlo1UC82aGtidjM2Slo2YWVEMy8vT0lKeGlVTjVJbGZQOElwdWRoU2tJbFdxZWFKbFI4ZHQvL2UwaHllV3JtUXREQjNuK3UyU2piNlRNUHJjL2N3WmRGOXpQNXlBZC90VzgvMVh6NUhuNGdraXVzcTJGV2NUVVpwTGpxVkJrbVdHNTNWbkJYL29kVHM3cmY1OUtxUCtUNXpQWXUzL1V4R2FRNi83Ti9jZUNNZS91bTlqcWZoY1VrRHFMYWFXWmV6RzUxU3c1NlM1dDhHalRHRm8xV3ErZTNBVnJZVlpYRjI4aEFDTlFhaWpLR042d0VNS2gxR3RZNlZCLzVDbG1YZmEvMVVSa3hidk8wbitiVS9sOHAxTm91OHZ6eGY3a0N5cEUwMFBMUC8yWTIvdTRkMDh3Y2VIYkx4OFA3Nzd4ZGFMSll1MVhqUTZYUmVuOEV1d1QyTldGZjZMUEVuQVB6QWZtQS9zQi9ZRCt3SDlnUDdnZjNBZm1DL25MQjQ1RXlTUHh3bmR6WEEvZGY4SnZqTHNCL1lEK3dIOWdQN2dmM0FmbUEvY0h1SXg1T0hhY2tUY2NrU0JxV2VhbnNOS2xGSnJhT2VFSzBKU1FhTnFLYmVhY0hpdE9LUVhIUXpobUcyVzlHcE5EaGRMb3JxU3hFRmdXN0dTQ3hPS3dnQ1NsbEFxOUt4cHlLTFdHTVVDbEdCTE11WU5FYnlhb3VJTlVhenN6eUR0T0JFYkM0SGFvVUtCU0o3S3c5aVVodUpNb1JqY1ZoUUtwVFluSGFDdENhMmx1d21OVGdSWkJrWEVvSHFBUExxaW9nemRtTnZSUmFKZ2JFNEpCZHFoWktuK2ExNURldVZPaXdPQzZOamhoS3VEU0ZVRjR6RDZRQlpRQ09xU0kvb2dVcFUwak9rTzZJSTlYWWJRWm9BK2dTbFluUFo2Qk9haWw1cElMUHlFSUZxRTBhRmppRlI2VVRySXdqVkJtRjEyVkVLN25zOE5Mdy9KcldSV0dNVUxsbkc0WFFScWcybWIwZ1BISktUZm1GcDZKVmFEbFRsRUtBMkVxVUxwMDlvS2pHR1NFSzF3ZFRiTFNoRkZYYW5nek9pQnhPc0NTVEtFSTdOWlVlU1pNSzBRZlFLU3ZYZWVNaXV6cFAzVlIwa3poaUZUcWtqdXlhZklJMlJJRTBnNVpaSzZwMVc0Z0xjTDNCdEs5dERlbGl2VnYvZVc3R2Z4TUJZdEFvTkpaWXlYSkpFdENFQ204dk9nZW9jZW9Xa3RQcFlSMS9qL3VvY0l2U2hCS2dNbUIwV0NzM0ZwQVFsTnU1ellmSkVyNE1ldEhscnlieDhPZlo5KzBDUzBBd2VqUDZzczlxMk9Yak1VL1IyYzFxT3JDd2NodzZobnpBQjdIWUVoUUxkNk5FNGMzTnhaR1YxTFM5ZCtlOS9ZOTI4R2R1bVRRaEdJNVkvL3NEOHd3OElhalhXalJ1eGJkbEM1WC8rMHpXQTY3NzZDdXVmZnlMVjFDQW9HeW9GcFJJVTdqRTlCSVVDVjNVMTFuWHJNQzliMXZtQnExNSttY0FiYnFCdTZWSzB3NGU3SVpWS2hBWmc3ZkRobUpjdUpmRDY2Nmw2NVpYT0QyemZ1eGZOa0NFNHNySVF0Tm9qR2hiZHB4WjBPaHo3OTZNZE1nVDduajJkSDFqVTZSQlVLaFJCUVkxQVIydll2bnMzWWxBUWdrYURvTmQzZm1EZGhBblk5KzVGZSthWjFDeGE1RjZvVURScXVPYmpqOUdlY1FhMjNidlJqeC9mdm5GbVczU1NzdTNaSTVmZWM0OXN6OHlVTS9WNnVYN1ZLcm5vNnF2bGdrc3ZsZXRYcjVhekRBYlp2bisvWEhyZmZiSnQ3MTZmbjcvZE5henUyUlBkNk5FSUtoV1JIM3hBd1pRcHVFcEtrTXJLS0pneWhjZ1BQMFJRcTlHTkhvMjZSNC9PcitIRDRxcXBrVzI3ZDh1bGMrZkttU3FWbktsU3ViVzZjNmZzcXF4c3MvTjZiUzIxcWJQUTYwRVVDWmcrSFlYSkJBNEgrZ3N2QkVGQU1CcFBUL1BRa1pXRlBTTURaVndjb2w2UDQrQkJ4T0JnRkVGQnVNcktrQzBXbEhIdTdyMjJMVnZRREJ6WTZ0LzJ2WHRSSlNRZzZ2WG96andUWEM1RW5RN1pacVArMjI5UjkrN2QrbU1kZlkxWldTZ2lJeEVEQXBEcTZuQVdGS0JPUzJ2Y3h5dHd5VTAzSVZrczRISWgyKzBJV2kxeVRRMktxQ2hraHdNa0NhbXVEa0duUTZxc1JCbmpIdU5FTXB0QmtwQWREdmROT1dxNWJEYWppSTdHc1g4L2lyQXdSS094OFZpdTBsSlVxYW5ZdDI1RjFWQitKYlBaSFgxVlZpSUFpdWpveHVWU1RRMnFoQVJzdTNlamlvbHhYNGZWM2U2V1NrdFJwYVJnMzdVTFZYTHlrZXZ5QnF3ZE9SS3B1cHFBR1RPdy9Qb3JnbDZQZmM4ZTk0VUdCYUVaTWdUcm1qVUlCZ1BPUTRkUUJBY2o2UFZvaHcvSHNuSWxxRlM0S2lxUXFxdFJkZStPb05PaDd0RURWM0V4MW5YckVBTUNRSzFHVktuUVQ1Nk1lZGt5MUgzNlVLZlZvdTdWQzBWSUNPcjBkR3pyMXlOVnVnY1drcXFxVU1iR29reE1SQkJGWktjVHhTKy9vSWlLY2djd0xoZkdpeS9Hdkh3NTZsNjkzTis5ZXlPR2hLRHAzUnNtVG15K1BielAzVld2UzBuYU1ZeitKSjRmMkEvc0IvWUQrNEg5d0g1Z1A3QmZmQ1NlTC9PTmVQT2t4d0NJalRDUXUrd0tBTExHamNOWmZHUTQ4K0FycnlUeXdRZFp2NnVFRWJPWHRpL2h1cHY4c2JRZjJBL3NCL1lEKzRIOXdINWdQN0FmMkEvc0IvWUR0eWdlejVhdVBiOVh0RW12T3FrREJRV29XOXdtT2t6UEhkUDd0eXZnUyt1OEFGODVLVFZoN01DMkcyVWxQdExJaTNlTWFsL2dPNzBBSy9NUEtTMWk2U21mUkxaN2p2THZMQzNGc20xYmh6QnBqMnpBMWxuWDFHdisrbFBYbGNwc3I3MTcvUmtQUDNCWEZnLzcvbVBGMnFKQmNmcklVejFvM2swMzRhbzhNcTlMd0tSSmhGeDExV2tCMUE4WTBQd1VZczZZQktjdS9kU3JKVUh0V1Njcnc4UFJwYWQzdk1CajBYZVpoNzVhbFIxek1nY0tDbER6NkhWRHZHNlRVMXpIaTU5dTd6akFINnpZVTNpeUI0cU5NTFFJWEZoV3owdWZuMTVndjVmMkEvdUIvY0IrWUQrd0g5Z1A3QWYyQS91Qi9jQitZTDl3N095MFMrN09XMVd3SStaVUQ1cDd6WCtKTllhZDBqRWN4U1hzUE91Q1V3WTBEaG1Zbjdid3JWaC9HZllEKzRIOXdINWdQN0FmMkEvc0IvWUQrNEg5d0g1Z1A3QWYyQS9zQi9ZRCs0SDl3SDVnUDdBZjJBL3NCL1lEKzRIOXdINWdQN0FmMkEvc0IvWUQrNEg5d0g1cEo4bU9HU1lmU2pwRHJubi9jMWwydVh3K1pMblRZWllsU1RyeTMxWWltdzlPbE0wSHhzb095MzdQWWRXZDFqWVpOcjMrbHpWeTNwQ3A4c0hnZnJLUUhUTk1sdXN0QUtnSDlDYjArWWZRRE83bnN4dnFzT1ZoTDM0UWhYNGtvbjQ4U0xWSXRtM2dLa013WElBb2dHVGRndFA4RzhyZ085RVkrL2pzM003Y0Fpb2VlcDc2cjM5cFhPYnhLcDU5NjI0S3o3a2M0NnhwQkQ5Mko0clFvRk0rcVZJZGcwdVRDcGFWeUtJZXFlNDdGRUlKeUE1Y2pnUEltaUhJdHEwb2xIcFUrbDQrQVpWdGRxcGYrWkRxRjk5RHR0bzgxbmxvMk1PYkJaa0lmdWhXQXE2NXRIRVNpcE1WZTkxbTVPTEpTQzQ5enBwdXVDclZDQW9Cd1ZpUEtyZ1loYUllS2VRanRFR1RUaG0yL29kVlZNeDlEdWZCM0NiWE53dDhXTlRwdmR4bVB1VGtoNk9RSkJjRlQ1eUQ0cU1pUkljSUZnRjdQenRTcFFoVkF1b1pJWVEvdGd5bFB1VGt6VGM3ajRvSEYxRC93eXJ2MVZMNE84OWFsZkhOdnpOczM3YUh3bk92b096V1IzQ1ZWWjRjc01XR296b1B4L2tXYkRmV0lKc2tpSk5nb0JYaGlscmtSZFc0Q210UHpueXROcXFlZVozOGtSZDVoUlYwV29JZnVoVkJsdVU2MldZelZMLzBBZFV2ZllCc3N6Vi9kNEpNQk0rOWhZQnJMZ05GNjgzY3VpZVQzRG1YRUhCdURiWUphb0pLek5qeUZZZ0dDZGRCSmFKZFFELyt2eGpHbjlnWUgvVmYvMExGdzgvanpDbnd1cDMrL0xNSm1YOHZ5dGhvTnpCZ0FIQWV5cWZpb2Vlby8zYWwxd09vKy9VazlQbTVhSVlOYU5XRm1YOWRRK1cxLzBKeHJnV3hRZ0cvYUNnYUpCSVdVMGZkOWlBQys5ZWdQKzk1VERNdmJKM24zNTlEeGYxUFkvbDFyZGZ0VkNtSmhEejNJTHB4STV1T3RKUUpNVVI4OGpLUi8vY21xdVNFNXMxOHgxNEtKMTFGMlMzemNKVld0QnpPYVRVNDBvQ0RTdVFRSjRKT3hoUmJnN1ZVZ1ZGUkR5dTBpRHBOeStaYmI2SHlpWmNwT09NaXI3Q2lRVS93WTNmU2JjMVNEMWpBVThNZUI3YzdxSG56WTZxZWZ4dHZUazBNRENCbzdpMllycDNlckpuYmN3c29tbmdPcXN2cnNNU3JDWmFzT0p5Z0RIRmh6VllpZm13ZzhMM1AwWG1wLzgzTGZxVHk0UmR3NWhkNXZTbUdpODhqNU1sN1VFUkhORjJXbXdNK0xLN0NFaXJtdllCNTZmY25iZWFTeTBYZTZMTlJqTTVHclFMYmZ3T3dESFlTb0hkUVhha253Q2tUdVhROUN0M3hnOFE0OWgyZy9QNW5zSzVhNzkxOGV5WVR1dUJCdEtPSG5WcmpRUkVkUWZoN3p4RzE0Z1BVdlZKYU52TTVEeDluNXFKQ2dXSE1PZGhYNjZqT0VCRXNFblcxVnVxeUJBTFh5S2k2blhNY3JGUm5wbUxldnlrWS9RK3ZzR0tBa1pDbjdxSGI2aVV0d3JaS3d4NW03blJSKzk1blZEMzdPbEpOWGZNWFlUSzZ6Znk2R1kxbWJqK1lTL1lOazZnZFlTR2hsNDM2UEJCbEVmbDdQUkV2L1E5TitwR1EwcnprV3lvZStUZXVJdThESVJrdm0wcndFM2VoaUdqOUN5VW5CTnhvNXFVVlZENytJbldmTGdjdmsyR3ErL1lnNUxtNWFFZTRaOUVwZnZrL3VOYS9nZXQzSGJhK2R1UWlGZnJMSmhMejRJdnVtN0luaTRyN25zYTZacFAzNHRNbmpaRG5IMm84N29uSVNRRWZGdHVtN1pUZjl6VDJyYnU5YTJMNitXNU5oSVZRZnZlVE9ENWFnZ0NJMHlZUy91N3pTT1o2cXA1OW5acjNQZ09ueTd1RGZIQ09oK1cwSzNCRDNFanR4MHVwZlBJVnBJb3E3MmIrd0J4TXMyZFFzMmdKc3JtZXdEbFhVZmY1MTFRKzlpS3Uwbkl2VnlsZ25IVWh3WS9jZ1NMODVNTlAzd0FmNXE2c3BuTCtxOVIrdEFRa3FVVnpGQTA2eXU5OUd0dUdyZDdOMXdleGZKc0FOM3JyN1hzcHY2OWxFRVRSNjQwUmd3TUpmdmhXQXE3Nnh5bTMxdG9VMk8zTzVTT21XbEoyZ2xrMmtZQXJMaVo0M20ySUlVSDRXdG9HK0xDWjE5WlI5ZXliMUx5NzJLc3pPaXlhUVgwSmVmNGhOQVA3MEZiU3BsbEwwV2hBM2E4bmlzQ0FWbTJ2NnBXS01qNm1MUytwN1RSczM3R1g4dnVld2JaK3k0bmRwT0JBZDZibGF0K1czVFlEbHFwcjNkNzZ3eS9BSlozMGNkb2lvZWhiWUZtbTdyOWZVdm5FeTE0ekk0SkdUZUJ0MTZBWjNJK0toMS9Ba1pYdHZmNzk1MFVFUDNxSFR4S0tQZ08yYjkxTitiM3pzVzNlNFQzemNPNVlRcDYrRDJWUzNKRW02QnVMcUhyaEhlOU5VQjhtRkU4SldLcW9vdkxKVjZqOWVLblhPbFdaR0V2SU0vZWpQM2RzMHdtNC9DSXFIM29lOC9LZjJqd0lPVGxnU2FKMjRSSXFuM29WcWJLNitZTnJOUVRlY1IyQnQxK0RvR2s1bzJGWnRZNksrNTdCa1htd2hUQnptdHZNdzRMYkhyaTFEUWI5bEFtRXpMOFBieG5SSmwyQncrazI4NVl5TFljVGl0ZGVka0ptM21wZ1YxbWx1MG00ZUpuWEpxRXFPWjZRQlhQUlRUaTFVWWFkQmNWdU0xLzJvM2N6NzkvVGJlWkQwMzBFN0pLb2VmOHpxcDU1SGFtNitkeXhvTmNSZFBmMW1PWmNoYUJXNFN1eHJscFArWDFQdDJ6bU15OGcrTEc3V2pSenI4RFdkVnVvdU85cDdEc3p2Q2ZPTGp5SDRLZnVRUmtUMVNiUmtleHdVdlBXSjFRLzl4YVN1ZjZVRW9wTkFydEt5cWg4OUVYcVBsL2hQUlJNNis1T25JMGRUbnVJcTdDRWlvZGZ3UHpseVNjVVBZQmxwNHZhZHhkVDlleWJTTFYxWG1Qa3dQdHV4SFRqNVFpcWRwdWsrb2pscmQ3Z052TjlCN3liK1l6ejNXWitWTktnRWRqNngwYjNRZmJ1OTI2Ky81aE15Qk4zbzRnSzUzU0s3SEJTOC9ZblZDOW9oWmtmbFJZU25BWEY1b3A1TCtoYnpEdjNTbkVuNU00WVFrZVNWdWZOKy9ZZzlQbTVDRG1wWXlSWFdhWFFVaTRxWVBZTUJLV0NqaXJXM3pkUWZ0OHpPREwyZXpYejVwOFBONWFCTzFHRWg5SVpwRFZtM2lUd2lUNGQ3R2ppS2lwMW0vbi92dk1PM05ncXVmclNrODc3ZGlnemI4SVJ1NEV0VmdJdXY0aWdSM3pYN3V3d1p1NTBVZnZPZjkxVmJaMlp2NTE0ZU9lMW43Ri9aQXJkajE2MnJSNHVPd0Q3YkIwYkpFMERYM1NIZEwzbjhqK3pPREJxQnNtTnRZNUg1cUtHNHhxdDZYclkxQnRtQkhkYzJKa2hzTG5YOGJCTk1iWEtNd1dJOEdsM2VEc2V0RUxIQWRVSzhFNENMRTRDWXl0REJBOWdjejBPYnh2ZkVBN3JlcnJOcHlPWThMcWVjSDBMajRhUFpmSUFudjRnVzk5cFliYmNqbURpM2t6NGFIbDdxWnVwV2VBNkM2NGJuNFpaRDBGdGZjY3o4ZGFhY0cwOXpKd0wvM3JhemRSaUdmNzBCeGh5T1d6YjUvMEMydFBFVzJ2QzIvYkI0TXZoc3g5YlVZYVBsbjA1TU9KcTZBZ21maUltUE9KcXlNeHBwZE02TGpTencrazA4Wk14WWF2OUJMeDBjM0k2VE54WEpueFN3TzF0NHI0MDRaTUdiZzhUYndzVFBpWGd0alR4dGpKaG53RDcyc1RiMG9SOUJ1d0xFMjhQRS9ZcDhLbVllSHVaY0pzQW42aUpiK3NEMjNxM2p3bTNHZkNKbUxoV0FLM1lQaWJjcHNBbmF1THRZY0x0QW53aUp0N1dKdHh1d0kxSnN4TUlQTnFqcGRsbXdHbnhzTzRqdVA2aTF1OXp3OFh1ZmRMaU94bnd6SE5oOHllUW5uYmkrNmFud2FaUFlNWTVuUUJZcTRaM0hvTEY4OEhvcGNxeFNtQ1J2UVFxZXZqMGFYaDdydnVZSFJLNHRTYThyUjc2NzRFQnU5eS8yOXZFeGZZMDRiZkxZTVJleUxTNkUvc2o5c0k3cGUxcjRtSjdtSEN0QkRNUHdMOE9nZlVvVTdiS2NHTU96RHJvM3FZOVRGeHNEeE1ldkFjKzgvSW03cWNWTUdSMys1aTQyRjRtM0dLZzBrNG1McmFuQ2JjWWk3ZURpWXVudzRSYmpNWGIwTVRGMDJYQ3A4dkV4ZE5wd3FmRHhNV09ZTUx0YWVKaVJ6SGg5akp4RDJDakRzWHBOT0cyTUhHakRrV3pUZEJ2WHVMZzVETkpiTW1FTHozWVBscjFXbXMwMDZmaldQbjJEN0tuM0VGU2t4bzI2RkYxRkJQMmxZa2Z5OVNxYXVsMG1iQ3ZUTHhaWUxVSjIrbnd3bTNweFp0aSt2dktTL0R4TFNCclFLYnJmSlkwYTlLaFlIZ1YyQS9jQW1pNm9GS2JkRm94UUZjRjkrcWx1eUo0cTZxbHJnUitRZ21BcmdCK1VpbWV6Z3grU2xuTHpnanVrN3gwWndMMzZhT1d6Z0RlSmcvVE9qSjRtejRmN29qZzdmSnlVa2NDOTNnWGR1TFltZUFHYXdBQUlBQkpSRUZVc1RaV3JXcHo4SmRDUXV5VlYxeVJYM0hOTlNXeVZpdTFKV0I1ZVhuQkdXZWMwZlJLK2ZMTGw4cnVOL3piNXhNVEk4dXZ2aXJMMXJZWlY3cEJsclM3U1RjcitmbHc2NjJRbkF5dnZRWTJXOWNvd3gwSi9OU0ErL1RwZE9BbkJ4d1hCNU1td1p3NWtKSUM1NTdiT1RWK1FrN3J6VGZkTHFHb1NKYURnenV5Y3p0RnB5VUlNSGt5UkVhNi8xZFV3STAzUW1CZ3AyZ3RuZmlZRkxJTTMzN3JCbCt4d2wyT24zMjJqU3J1R0hqZ0FiaitldEJvVGhQd1lmbnJMeWdzaEtpb1RnRjY2c0NGaGU3dm9xSk9BWHJxd0oxRW94MEx1QjFCbXdRK1ZKNXBTMmlIazFxQ2pmWnRsNDh0MkhybFdTVk9MUktaNzdiWnVYUktYV0d6d0w5WHJ0ZTBKWEIrRUR4N0hydzd1azV0VTM2VHlGL2ZKTFpINE5ydUpuMEVGR3luMldzby95NmdiUXJjRVVIYkJMZ2pnL29VdURPQStnUzRNNEdlRW5CbkJEMHA0TTRNZWtMQVhRRzBWY0JkQ2RRcmNGY0ViUks0M0lENTFobGRFL1J2S3g2OWFXVlpscnNjb09ENWZxdC9PbDQvc0IvWUQrd0g3ckxOd3hNU1djYVdtWW5qd0FFYytlNjhtaW9tQmxWU0VwcTB0Qk1iSGFFakE5dXpzeWwvNVJWcXYvb0srOEdtUi9KWEp5WVNNRzBhb2JmZGhqb3BxWE1HSGxKZEhjWHo1bEh4eGh2STl0WU50eUtvMVlUY2ZET1JUejZKYURTMlNlRFJKc0NPUTRjNGRNRUZXTGR2UDZuOXRmMzZFYjk4T2VyRXhJNFA3RGgwaVAwalJ1QTh4WWRzeW9nSXVxOWZmOHJRYlJwYVNuVjFITHJnZ2xPR0JYQ1dsSkJ6NFlWSWRYVWR0MW9xbmpmdnBNMjRLYkZ1MzA3eHd3OTNUS2RsUDNpUXpCNDlrQjBPMzE2Z1NrWHFuajJvazVNN2xrbVh2L0tLejJFQlpJZUQ4cGRlNm1BbUxjdlVMbHZXWm5WbnpYTHZzK0MyTzdBdE03UFpvTUluMVZ4T0RyYTllenNPc0NNN3U4MURRcnVQenVFYjRJS0NOZ2QyK3VnYy91Ymh5WWlxVzdjMnYxQ2xqODdoRzJBZnhMd3RpZHBINS9BSnNDWTF0VTJiZGFyNGVEUTllM2FnTWl3SUJGeDRZWnNCbXk2NHdHY0pBdCtHbGoxN3RycnRlMEtoNWQ2OXFMdDM3MWlocFRvcGlaQ2JiL2E1ZGtOdXZ2bWtZZHM4NHlIVjFYSGdqRE44MW1MUzl1OVA5elZyVGluNzBhYnRZZEZvSkdINWNwUSs2RktzaklnZ2Z0a3luNlY2Mml6d1VDVWtrTHh1SGRyKy9VOU5zejdJZHJSYnBLVktTS0Q3bWpXRTNuRUhncnIxWTdnSmFqV2hkOXhCOXpWcjJnVFc1Mlc0dWFDLy9KVlhxUDN5eTJZYkFLcUVCRXdYWFVUbzdiZjdITFJkc3BiTnRabHRlL2Rpejg1dWJBZ29vNk5SSnlhaTZkV3J6Ukx4cHcvNE5Jbi9nYmdmMkEvc0IvWUQrNld6eU5peFkvUG9XcU9seVExTS9qTHNCL1lEKzRIOXdFY09Lb3BjZE5GRko3My90R25URU5xb3VkZ213SklrTVduU0pHYk5tblhDKzg2YU5ZdEpreWJSTGkxVlg5YkRVNmRPbGMxbXM1eWFtdXF4UEI3a0QzcjNsdC92MlZPT1AyYWZsSlFVMld3Mnk1TW5UMjZ6ZXJqTmdKVktwWnlabVNtdlhidFdGa1ZSQnVSd2tEOEZlZitqajhyN0gzbEUvclJoR1NBTGdpQ3ZXYk5HM3Jkdm42eFFLRHBmNE9GME9wazNieDRqUjQ3a3ZQUE9Rd1FlQThLVlNnS0hEOGMwYkJqaENnV1BOVnpFcEVtVEdEVnFGUFBtemNQbGNyV1pGYmRwWDh2UFAvK2N2bjM3TW1EQUFQVGZma3Nhb0kyTlJkUzdoLzNXeE1TUWxwUER4VURhZ0FFODlkUlRmUDc1NTIxYWJEMkFmL3Z0dDNYQUpiNDhnZFZxNWJ2UFBtT0NUb2Rzc2FBTUNXbGNwd29OeFpxVHc3OTBPbXBTVTVrOGN5WVArN2hmRnJEdWFJL2Y1dld3VnFzbFlzMGFaSXNGQUlYK3lLRHVvazRIZ0d5eEVMbDJMWnAyR09uQlE4T2J6anh6Wk5XYU5UNDlnUXlzQjBZMC9IZFVIaG1LM0huVTcxL2ZmUmZ6dSsvNmZLSzR3QkVqem1qWFNHc2Y4UFZSLyszRnhRMTNRajd5dTJHYnJIYUl0TnE4Zy9nNllBdGdCYlNBbzZ3TWEyNHVTQktPaWdvQWJBM2JwRFo4T2pWd0JtQUhzb0hEblJZcWYva0ZXVG95Mk9IQmhtMzJkUVVObHh6MWZSalljdUNBUjFmQ2ttTytPelZ3NlRIZkFMMC8vQkJrbVRVcEtSN3IyZ1BZL3hxUHJ5VWNPTlR3ZlZoMlgzMjF4OVBDdytzaXVvS0dJNXFBMFhidmp2YW9mbDBSWFFtNEI2QUdqeWwrUXM0Nmk1Q3p6bXI4bjlTd1RWcFhNT2tSUUdaREhYdzRmdGJHeFlFZ29Bb054VkZlamdZWUNJenFDaHBPQTZZZTlWOGRHZGxZZnRXSGg0cHMyQ2FsdlRVODVJOC8vdlIxYXdsQU4zczIxdmZmZDJzNE9QaElhK21vMytPdXU0NHozM3V2TFJqWDBKNnRKYXZWU3RubzBRZ05MU05YUTZzSndGWHZuaTlJME9rb0d6MGFXenVNUHV5aDRYSC9IamRpMVQ3ZkRxZzlUQnhHbjRnKzFLWmJ1SEVkT01yTEc5Y2RqcVhmU3JkZ09yQ2FaKzU4Z3cydURiN04wNldOSGRGdVpWaXdDMXc1OGtvV1ppOWthVC9ZRnc2MnZEeGNaak11c3hsYmZqNFo0YkMwSHl3OHRKQ3JSbHlGYUJNN3I5UDZaOHcvK1d6RFowaGFDVW1BeDg2QlVxMkxtdlhycWRtd2dWS05rOGZQQVVrQWw4YkZaeHMvWTFic3JNNEpyS25YTUNCaEFIOVkvamdTVnh2Zy9pbXdhdFgvc2VxM0w3aC9pbnZaWWZtOS9uY0dKZzVFVzYvdGZQV3dUV2ZqZ1Q4ZjROaDU5bktDNE5xZ1BjMWV6UU5ySDhDaGMzUStZQVJ3cXB3bnZKdEQ1ZWk4WmJnamloL1lEK3dIOWdQN3BTT0x4NU9OWCtuUjVUcUlUeUREMzBIY0Qrd0g5Z1A3Z2YzQUhWWGFaNGk0aHBwUVlaVEFCWkpEUU5QTmlXUVJzWmNvRUpReXNsUG9HaHBXR053UHZpT20xeUtaUldKdXFVSVFJZndmdFlTY2EwWVpKQkU2eFF5QUtzelZlWUZGdFl5b2xkRjJkeEQ1enhvVVJnbER1ZzFqdWcxOWJ6dUNFa0luMXlHb1pJSkdXOUNuMlFrOHc0STZ3dFVKZ1FXUTdBS3h0MVVpT3dWQ0o1dXg3Rk1UT2JNR2JieURnTUZXQkZGR0Urc2svcDRLcXY3UWtmS2ZFcXJYNm9pWlV3bkNFY3ZvRkxHME90cEp0OW5WRkg0UVNPOVBDaW41dndDMENRNmlMcTlCY2dpSUdobEJLZU15aTRnYWlmSnZqTlQrcFNYeThocjJ6WWtrL01KYWNsOE13Vmw5NnZvNE5wYjJPYkEyd1lGeGdJMjY3UnA2dmxkRXhmY0dJcStvd2REVFR0ME9EYVZMamRSbnFFRUdYWXFEOEdsMUJBeTFZTjZsb1hScEFNRVR6T1MrRUlLOXlPMVBhelpxZlFyc2M1TzJIbExockZTUTlsb3hSWXRNeE41WmlTN0pRZVlkRWV5NnRCdWlSaWJxeWhxaXI2bEdGZXBpNy9XUjdKMGRoVGJlUWV5Y1NzcS9NUkk5dTVyUTgrdW8zYXJ4ZVpuMnFZYlZrVTZpcjZ2RzBNZE81VW85U1krVW9ReVIyRFFzZ1pBSlpwS2ZLMFhVZVo1Q2RncGtQeEZLOGVJQUJtL0lRYllKWkQ4VmlpYkdpVHJTeWY0SHduR1VLVHFlaGtXMWpHbVlsZm9NTlVVTFRYUzdzUXAxcEl2OWQ0Y2ptVVhzSlVxeTdvbWcrRk1Ua3RWOURUVWJ0R1RkRTA3dEZnMEt2Y3krV3lOUWhic0lPNytPMnMwYThsNFBKbVNpR1ZFdGQwd05DMHFaMEtsbUV1YVdvOUJKeUpMQTFyUGpRQUpudGRnWVhHZ1RIYWpDWE5SdWNwZFBVU09qREhhaE5FajBlSzhZZlM4YmRkdTFWUDZzcCtTekFLdzVxbzZuWVhXMGsvaDdLb20rdHByNnZXb1VKcG5TcFFIRTNsckptV1ZaaktuTHBQKzNlU2lESkt6WkttbzNhVkVZSlBxdnlHZDBkU1puRk80bi9vRUtTcFlFSURzRlhIVUNoajQyb3E2cFFadm91NmNSUGdPMkZ5a3ArOFpBem9JUTZyWm9VZWdsNmpQVUdQdlpHclZZOFowQlF5OGJDb09FcUpZSkdHd2o3N1VnaElhck1QUzNZZG1uUW1HUXFkdWlKZi9OSUhLZURjRjJDaHB1TTJCOW1oMURUenVtWVZhMFNRNWtGKzYrd3czK3B1SW5BODVxQllKYUptaU1oZENwZFNoTUxneDliZVMrNk83NklDaEFsZ1FRWkpBaGVIdzljZmRVRUREWTJ2R0FMUWRVYUdLY0dBZGFHN1dxVDdWVHY5czljRW5PZ2hEMHZXeG80NTFFWEZaTDNKMlZLSFF5Q3AxTTBTSVRza1BBdkZPRFB0V09xMVlrYkZvZEFVT3QySXVVMklzVkhROVlZWkRKZnlPSTdNZkNxUGhKajZ0V1FkaTBPZ28vQ3NSZXFFUlV5OVNzMVNFb1pZTFBNbU1hWWNWWkxXTGVxeWJ3REF2VmEzUVVmaEJJMk1WMUlFTEZEd2F5N295ZzhoYzkxdHdPYU5MT2FwR3dpK3VJdkx3R1M1YWFzaStOR05OdEJJMjJjUERSTVBTOTdEaktGTGpNSXVvWUo0SlNScklKeUU0QlExODdCZThIb2dwM0VqemVUTlZLUFRVYnRjVGVXa1hvZWI2dGxud2FhWlY4SG9CNXA1cW9xNnR4VklyVWJ0YVMvRUlKbGIvb3NSVW9FVlF5c3JPaGJEZFVpZ3FqUk8wbUxWVXI5ZlI0c3hoTHRvcnFOVHE2M1ZCRjhXY0I1TDhWaEdRVE9pQ3dEQXFkaEwxUXliNDVrUVNmWFUvNWR3WmNacEVobXc0aGFpUnNlU29jNVVwS2xwaW9YcXZEVWF5a2RwTVdWNTNBMEMzWkFPUy9Fa3pFakJyMlhoZUZKdGFKSnRicFM1MzR2dkdnQ25XUjhHQUZlYThIMGV1alFpcStNOUx0cGtyVWtTNXFOMm9wV1JLQUpVT05MSUV1MlVuNEpUVUVqYXZIc2w5TndUdUJoRjlVeDU2cm80aSt1b2FDOXdLeFpwOWErVzN6MXBMQ0tPRXlpNlMrVkVMUnh5YVNIaTJuNFAxQXVzOHZjMXVCVVVMVVNZaHFrQ3dDZ2tLbThsY0RWYi9yaUpoUlE5WmRFVVJjV3N1QkI4T1JmZEFrYm5QZ3cwZlY5N1FUT01LQ0xWOUo2QlF6bGIvb1NYeWtuTG90R21vMjZERDBjV2MvN01VS2lqNHhFVGJWVE5WcUhhNTZrWnIxV21TN2dLTmM0WFBndHNsNHlGQy9SNDE1dDRiS1h3eHVweU5Ed1R1QktFd1M1bDFxTEFkVjJBcVZsSDlqUkJEQlVhYWc5SDhCV1BhcnNCY3BmUUxiN2ttOG12VmFFR1FLM2dwQ05NZ1VMUXlrYm9zV1o2MklMVStKWlorS3NtVkdsQ0V1RGo0ZWlpSkF3cnhEYzhTTGQ1WVVUNU4zVmlzaldRVTBzVTVzK1VwMHlYWmtwNEExVytXdXJoeHRrNlk5MXFUYmJlcVN3MjFnVzU3N2xKYXNJMlBsdFJYc2FjbExkelR4QS91Qi9jQitZRCt3WHpxUWVOVDRpdjZMbG9COFNSZEQvSjlyKzVYLzhKZGhQN0FmMkEvc0IvWUQrNEg5d08wdUhpbWVUL2N2SERITW5OT2xBRGNZNGtkY2RybzFiRkdLV0pTS3Y0ZEp1NEFOTThlemNmcFlwTDhEc0ZtdndqaGxQUHBKWXpCcmxWMEh1RDRzc01ubHRyTkhFaFlkUlZoc0RKYXpoaCszWGdiTUlhYk9CVndkYk1DNi9GVXE0ejBIbTNFQTl2NHB1Rnd1QkVIQTNqK0ZZL3ZuVk1XRTRmenVUYXBEakowSHVPcnNVYmhVU21yT0dlbFJUdTBLQVlWR2h5ekwyTzEyMUFZakR1V1JTNUNBcW5OR1loY0ZxczhlMmZHQlphQktvMFI1OFFRRVFVQjczbWpzb1lHTnpxcHdWRjhLZENKR25SNkRWa3V1RmdxSDkyaThLZFlRRTRhcFl4RUVBZlVsWjFHdDluMFo5K2tScXlLQzJIanhHUXhLVGNSb05GS2IwSTNDd1drRUhpakVKY3ZZWjB3aXZIOVBkRVlEb2loaUdkZ1BoMEpGWlhFTkFnSlZLVEVFSnNaaU1CZ3dweVN5L3BwekdicjBENEpMcXpzbXNDVXNFTEZYTWlxVmlwS1NFa3dtRTZWWG5RL2RvakFhalFSWXJSUVdGbUsxV3BGbG1hcXFLcUtIOUlmUFIxQmRVME41Y1RIQm9raFpXUmtta3dtaFZ6SzI4SjNnUTJDZm1yU3hwSUs0MkJnS3NuTlFpQ0xGZWZtWTlEcFVLaFVPaHdPNzNVNWtaS1RiWk5WcW9xS2lHcGVyVkNxTUJpUEYrUVVvUkpIODdFTWt4TWFnTHlycnVDYXRMYXRGV1cvRGtOcU51TGc0OHZMeWNGVFZJTXN5b2loaU1wbFFxOVVZalVZRVFhQ21wZ2E3M1k3TDVVSVVSUUwwZXRRQlJycDE2d2FDUVAyQkhMUVY1bzRMTEFObW14MnB0cGJxNm1wcWEydXgxZFZpcmF0Qm9WQ2cxV294R0F5TmdPWGw1VmdzRmh3T0I0SWdvSklGTkxMa0xzTm1NL1VXaTg5SE1sWDZFcmJrL0RNd0dIVFUxOVdSazVPRDAycEZJNFBPNGdEQmdlU1VNTnZzbU0wTldyTTcwTm9kNkswT2tHV2NPalhXdWpweWMzTnhXQ3dZRFFhS0x4aER6UExWUGdQM0dYQk5lQ0RxSzZlaFU2dFJDNkF3bVhEWkpYUXFRSFhrdlFXNzNZNHFPZ1FSQVh0dUlTcVYxbU45UFRLS2dBQmNOaGQ2dlFicDhndW9YYmNkVTBsVnh3RjJxSlJJdDE5T1hQL2VBSlJWVjFNdnVRaUlqaURVNUJrbTJtdzJLaDEyUkVHZ1d3KzNSejlheXFxck1idWNCSFNMSU16a3JzTkw3cndLeHlPdm8zSTRPNGFYcmhuV2g0QVpVN0VvRlZpVUNod0tFVW1TY0NqRXhtVkhmeVJaeGlYTFRhNDd2SzlUY1dTWjhkTHpxQm5lcDJOVVN6WmtqUGZPUnFGUUlJcWl4MGNRaE9PV3RmUTV2TS9SK3lvVUNnejNYWS9OQjkxN1R0bWtGWUIxeVhmdzdWRWpyUmwwdUliMmdrMTdzTmRaUExhWFpCbjdvRFFFU1VhN05SUDUyUGtjakZxa0liMWh3MjdzOVVjNmhydXNWalFkb1F3ckVUQis4cTNITWcwUTdHVWZ2WmQxR3EvTEJkOEN6MHkrYWwwWGZIcTRqdTIvL0gyemxuNWdQN0FmMkEvc0IvWUQrNEg5MG41eDE5Ri9Dc2YwNjNJanBrV3YzdUVmTWMwUDNKV2w3Ui9RQ2lBclFkQ0p5Qllad1hITXNCWmFBV1c0RWpGRWlTSklpYUFWUVNOaTIxeUhsTy9vK01DU0doUnhHcFJCQ3NSQUJXS3dFbFdjQm0yVUdudXBrL28xMWRqWG1SRkNSTFREQWpBTU5pQ2FGRGlkRXJJa0l3Z2k5aUk3OHMrdXpxRmgwUVdpUWdDVmdPU1FrWXNjdUlvZE9JS1VtTTQwb2JrNGxOb1VEWVllZWhRYWQ0bVNBYWxHd3JMZmh1T2dEV21YMlQwalZhY3dhUmU0OWxrNXJCOGhUb1Z1YkFDQ1NxVDhxM0lDSndjVDBNK0FJQWpJa29RbHk0WjVzeG5IZml1Q1dVSndkZUl5TE9nVktMdXB3UTY2WGxvMGlSb0VsUUNDZ0szR2lWUWpJVVlwQ1pvV2pOTXFZVHRrdzdxNG92TUN5eFlYanZWbUhCdk0xUDlZVGREbFlTaGkxRGhkTW1xVEVnTEFWdW1rTHFNZTUwRWJ6dTIrZjViVXZsNWFQdXE3eWtYVkJ5V29CK25SSkdpeDJHWHNleTA0OWxnUW5FMkVmWjIyV2pwYTZtWHNmNWl4cnpVM1RxY3EwTDdTZm0rWDZnWEVlaGxGc2dhWFF3SzdqQ0FLSUFySXBRNnd0VThZMzdhUlZvUDZ4QVExeWhRTlFySUs0L1FRbEdGSzFPbDZBcThMUXdnVUVTSlZ5Q3JjanpHRXpxeGhnNGdzQ21oR0duSGsyZEdNTUtBT0VIR2s2MUZGcXhBQTdUQTljbzJFTWlxSXVwK3JrSEljQ0JhNTh3SExhbEFrcVZBbDZCQ05JcWF6VFVneXVDUlFKMmdRMUNKSUV1b0VIVXF0UU0xdk5hZ1NOZGl6SEc2N2t6cVRTYXNBV1NCd2FnaW9RUjJyQWJXSW9EdzhoR21ENXhZRUZDb0JsME5HTjlpSUprbUg2ZFlJaE80YVVIZWlTZE14S1ZDUENjQ2FiOGMwTEFCWkNRclJyVFJaQUVFVUd3dTV3eVdoVklCQ0w2S0pWMlBaWEk4aVJ1VzJnRTRCTElCNnNCNnNFcXBRRlM2bmhBRFlIUkpxcFlCYUlicS9HejVLcFloVEVwQUFwMDFHTTFpSFFpVkFnTmdtRHN6M1pWZ0JVcDRUMHo5REVVVndPQ1dVb2h0TUZJNG5VQ2tFbk1pSWdveFRDZG9JTmNvQkFoSUN0Z29Ib3EyamF6aEtoUkNseEo1dncybVhVUWdDVHBrbVlSdnZ1a0xBN25EWHk0NTZDVnVSQTlraUlZYW8ya2ZEWW9BSjNmbi9RRE4wRktoVU9MYi9SZjNTVDNHVnRUQ2RxaWlpaVIrRlp2QllWRDE2Z2FzUzJiSUJwZVZYV2hxTlJOUkhJNFRPUUJNeUVHVmNNUmJIRHpqWEwyN1pvQ0tpTUZ3K0c4MlFFU0FJMkxkdW92NS9uK0xJMnVzdE5IQkx5YXdwc3Y3Q3k5QlB2UVJCYi9Dc1p1dzJMQ3VXWVA1OEVhN2lRcytMTlFXaW16UU4vWVdYb29pSlA3NktxczJHZ2tWUXViNEpVZzFFWFFEZFppQW9QWWRsZFI0NlFOMzdyMkZkL1l2SDlMMEFpckFJOUpkZGdYN2FESVFtNWg1MzdONkI1WWZsQk43MWNQT0REOG15M0dLTkw4c3l0WVdGY3RXQmc1TFRaaU13TGs0SVNrd1FGV3AxaTlxb3FjcWxvblFmTmRXNUNJSklnS2tiMFhGRDBXaVA5SjYzbTgyb0RaNDN1NzZzWEs3TXpwWnI4dk1sZlhDd1lJcUxGUVBqNGdSUjJiSUxFZ1NoWmVDTXdnb1dMRi9QdHB3U0t1dXNERXlNNU1veGZiaHdzUGNKcjB0cjZubmhtNDBzK24wblJWVm00c05Nbk5jL2lmblR4eEFXb1BPNjd6ZGI5blAzSnl2SktLd2d3cVRuZ3NFcFBIWFphQ0lERFY3Myt6T3pnQVhMMTdQNVlCRm1tNFBoS2RIY2NzNGdKZzlJUmhCYUFONmVVeUsvL3VNVzN2OXRPMDdYOGFIT2hZTlRlVzdXV05LaVF6eVdsOVRVOCs5dk52TDZqMzlodGgyZmVBc0wwREYvK2hpdUc5Y2ZoZWpwdkRJS0s3aC84U3FXYmM0OGJyOUF2WWI3engvT2JlY054cUR4ZEdBcmQrZXdZUGw2ZnRoK3NNa2JrUm9WekhYaisvUEFCU09hQjJibUFnK1Q3aFpzUks5V2tWVjhaUHA2VVJCSUNET1JFaFdNUWFOaVIyNHBCMHFxUElxWUlFQktaREJsdFJZcXpVZVNVd2xoSmthbHhkQS9QaHlydzhYRy9ZWDh1Q083OGVhcWxRcEdwSFNqcU5yTXZzS0tvN3k0U005dUlhUkVCbE5qc2JNanQ1VFNtdm9qNVZrVUdKZ1lpVnFwWUV0Mk1SYjdVVDMyUHIzZk83QktJVEpqVkMvdW5UcU1mbkh1cVpDTHE4MjgwS0JCajRNZEl5TlN1bkhydVlPWU9pZ0ZrMDZOTE1QYXpIenUvZTlLL3N3czhGTE9ZTTdFUWN5ZlBnYVR6dTBMZHVTV2NzdUhQN042YjI3ekhsb1V1SDVDT2svODQwekNUZTdPVUdhYmc0V3JkL0xtejF2WW1Wdm1IZml4SlgvSTE0M3ZUMnhJUUpNbktLbXA1OVVmTnZQcnJoeDI1SlJpY1RoSkNnOWtYTzk0L25YV0FBWWxSVFo3Y1VzMzd1UEpwV3ZabGxQU2FBMmlJSEJ1ZWhMekx4dk53TVNtOS8xMjZ3RmUvSFlqV3crVlVGWnJRYU5Ta0JJWnpQamU4ZHcxWlNoSjRZSE5ublBqL2tLR3BYUnJuWmUyT1Z4a0ZWZFNYbWNoUFQ2Q1FMM21HRzhOTGtsQ3FmQ01YUnd1aVQ4eThzZ3RyeVUyeE1pdzVHaU0yaU1ldk1aaVoyZHVLWUlna0JZZFRLanhpRFA3NjJBeGYyYm0wejBpaURON3hoS2c5ZlQ4VmZVMlREcjFjVUZNZGIyTjdUbWxWRnRzREU2S0pEckkySG92YmJZNWVPSHJEZno3bTQzVVd1Mk5KbmZoNEZSZXYyWWkzWUtiZnAvSTRaSlk5UHRPNW4vNUp3ZVBla2NoVUsvaCtWbmptRDArbmVhQ3JlSnFNM2Qvc3BML3J0bmR1Q3hJcjJIKzlESGNlTmFBNHh6ZDBiWENnaFhyZWYzSExWZ2JldHFLZ3NDMElhbmNNV2tJbzN2R2VnZStmL0Z2OHNLR0txVXBNV3JWM0RWNUNPZjBUeUlsTWdpalZzM08zRExXWlJYdzhuZWJQRUNQbGVFcDBUdzlmUXlqMG1MUXF0ejFaMFdkbFRkLzNzS3p5OWRUMTNCemo1V2UzVUs1YS9JUWhpWkhreG9WVEszRnpzNjhNcGFzejJEaDZwMk5vRTFKaitnUU12NXpmZXU4ZEdKNElHZjNUVUNuVnZKblpnR2JEaFMxS2xiVnFCU01USTFoWUdJRXBUVVdmdGw1aU1LcU9nK1BteFlWak4wcGNiQzBDcGQweEwyZjJ6K0pzL3NtVUZobFp2bm1MSS9hd1p1TVRPM0d1ZjJUMEtnVXJOMVh3TGRiOXg4NTdqRk82N2hRWldoeU5QZE1HY28vaHZmd0tDdXI5dVR5NkpJL1dMV25hYThaR3hMQXY4NGV3QTBUMGhzOTVtRmY4T0ozRzNsMitYcXE2MjA0WFJLNzg4czk5azBLRCtTdDY4N2xuUDZKamN1ZW5UbVdsNzdieERQTDFubFViVWZMd01SSW5wNCtodlBTa3p5V1o1ZFc4ODZ2MjFpNGVpY0YzbUxwcmRuRmNucUM5OG5wMTJjVjhzdXVRMnpOTHFiV2FxZG50MURHOTQ1bnlzRGtac3ZhWWZOOTlZZk5yTnFUeTlaREpTZ1ZJajJpUTVnNXFoZlhUMGhIcFdpNjRWWmRiK09qMVR2WmRxaUVmWVVWUkFUcVNZc0tZVUtmQkk4YmRFcWhwU3pEZDlzT3NPMVFDWlZtZDJoNVhub1N3WWFXNTF6NDYyQXhILyt4aTd5S1d1SkNBemluWDlKeEdtaEs2cXgyL3ZQdEp0YnN5eU14TEpDcGc1STVmMURMMDZpN0pKa2w2elBZc0wrUVdxdWQ0U25SekJqWnF6RXlheEY0NWU0Yzd2bnZTdjQ2V094eDRBaVRudjljTVlGWm8zbzM2VzAzSFNqaThmK3Q0ZXN0KzVzTVNWKys2aXdTd3BwK1RmYnpQL2R5ejM5WGtsZFI2N0Y4WXI5RS9uMzUrTVlBNkZqUUw5YnQ1Y2t2MTdMbm1DSVNZdFF5ZTN3NjEwL29UMnBVU1BQQWZlNTlYOTZWNS8xTnNBRUpFVXpzbDBoYWRBZ0JXalhiYzBwWW0xbkFiN3U5angyZ1ZTbTVma0oveHZXT1oyQmlKSGFuaTgwSGluanR4Nys4Um1HaUlIQmVlbEtqbDY2M09kaVZWOGF5elZsa3QrWVZ2WlpDUzdxYUhBUHM3NWoydDVMN2YrKzc1Ni9pSUZtVzZUSWZyMW5MbkZwZHdQUnZoN0pnVXhwMlY5ZTA5dU9vSkZuZzNSMkpuTDk4Sk52TEFycys4R0haWDJYZzBxK0g4Y0xtVkJ5UzJQV0JBVnl5d0Z2Yms3aHcrUWgybFp1NlB2QmgyVmRwNU9LdmgvUFNsaFNja3REMWdkMmhuTUJyVzd0ejBZb1I3SzBNNlByQWgyVlBSUURUbG8vZ3RhM2RjWFZDYlorVU4zSktBaTl0U2VHU3I0ZVRXV1hzK3NDSFpXZTVpUXVXamVDdDdVbTRaS0V6QW84NTRRTTRKSkVYTnFkeTJUZTNzTDg2aDhZT1dCM21jNUlhRmhDWUVEZWMrV2Zjd1hjWHZjTVRJMjhqUWgvYXVINWJhUVlYTEx1WmQzZjhINUxjY1J0ZHJlb0IwQzhzalNkRzNrcS9zRFJxN1didS9mMTVSRUVrVkJ0RVNmMlJ4cmZOWldmQnB2ZjRLV2N0QzBiZlRaSXB0dk9WNFFseEkvaDA4Z3YwQzB2RDduSnc0eStQa1dpSzRZMEpqL0RDbUh1SkQ0ZytQczFUc3B2enY3cVpEM2N0N1hEYTlncmNJemlKMThZL2pGYmhmdXJ3NEpvWDJWQzBuVUp6S1R2SzlyRzJZQ3M1dFlWTjdtdDEyWmkvNFczKytkMDl6VzV6T3NURHRjNzg5dTY4RFVVN1lnNy9YMzdCNi9RT1RXbUl0cktaOHRXL2tKRVJFSkNSaWRDSGVwaDBjNkpUYXJodnlHd3U3M1UrUWp0M0p6MDJpZGVzaHNmRkRtdUVCWGhueHhjY2JsN0t5SXlKR1lKZTJicVpZeTFPRzQrdmU1MHJ2citmdkxyaWptblNGeVpQOEhCRzN4dzhNbXpGclFQK3lYc1RuK0w1MGZjU2E0eHM5Y25XRlc1ajhsYzNzbmp2TngwUGVIaFUvOGJmR1pYWk9DVG5VWW1DUW5KckM5bFd0dmVFTlZidnNQREluNjl3OVE4UFVtQXU2UmpBQ2xGQnVQNUl0NFl5aStkN0NGOGZYTVhFcGRleWFQZXlrejd4SHdWL01mbkxHL2xpMzNlbnJ4NnVYcjBSMHJTSXh6aVdZenYzdUNRWC9jTFNxTExWbnRMSjYyMzFySDNnY1VLWDNZa29uUWJnSStHaWs5TDZTaUlhdEJ5bTh4eDM1WVorbDNGeitrdzJGKy9pc1hXdmszc1MxVTVzbm9OcjNpOGovcEM5WTVUaFB3dTNOdjVPQzA1Q0tSNjVOOWsxK1lnSVZObHF5S3N0T3JFVFNqQmxSVFVQUDFIWTdyQmVnWmRrL3VCUmo0NkpHZUp4TXdZdi9nY2Y3RnFLZkFJaklNWGtPNWo3VkNIVHZxeEM0VHc5RVpoWERmK2FlNlNyNEp6MFdZMi9hKzFtdWhraktEU1h0bDZyWDFjejcvRkNFckx0bkU3eEdsck9YZk5pbzhtbWgvZGdmTnd3QUs3cGN6R0x6bDNBSFFPdklsd1gzRHF0TGoxOVdtMDFjSm1sa2l0L2VJQ3NLdmVUd1JmRzNFOXlVRHc1dFlYRUdDTUkwd1ZSYmE5clJxc3lrNyt1NlJCYVBhSFdVazV0SVJkL2ZSc2Y3bHFLVnFIbWc0bnpzVHB0blBuRlAvbGt6d3JzcnVPN0duYkxkL0RnVTBWY3RMU3lRMmkxMmNiRDVBZkc1R1drYVdPYTJ6aE1GOHhaY1NQb0hack1KM3RXa0ZsMTZEaXRudnRkTFJjc3EwTFpRVUJQYWQ3RE1rc2xuemNUR1VVWDJMbjIvUW9TRDlyb3lPSUJmREFpQVRpeDJGaVFCUXlIK2lBZFNPZjlrU0tNN0dDRWk2L2dwRFY4WE14dERpUm8xeWhVTldGMEZqa3BZTGRXZTJNNE1BQ2hrejFvVTU2VVZuZVBRbFVkUm1jVTVZbG9WWi9URytQK2RBUkpRV2VWVmdFcnpZRUVkbUt0bmhDdzRWQ2ZUcS9WVmdFcjYwMEU3aHFGcWpxY3JpVEtwclhhRytQK0FWMUdxODBDSytwTnRhRlpBMUZWaGVPWExpSWVnZlh3UmEyTzFuRHZBQUFnQUVsRVFWUkxYNXpJNHlKZk55R0MxWEJuTDZUem9wRXJxK0hPZVlpTGw3bzcrQ29VSUlvTjM0TDd1N3lTNWhzUFVnZnZXanE1Rzl6WkN3SlZpRXRXd0MwUFF2SFJTUmZIQ1piaGppclJPbml3RDR3SWc4Sml1T1lCK1BMYmRveWwyeTA3SWNEMGVQaFhHdWdVOE41LzRkN0hvZW9VWmpMcHNNQXBBZkJRWCtnVENQdXo0WWE3NGRjL1RsTnJxUzFGTGNJMXlYQlZFZ2d5L1B0TmVHUUIxRnRPWS9Pd3JTUTkySzNWUkFQczJBUFgzUUVidDNhQTlyQ3ZSYStFVzlMZ2tuaHdPTndhZmZaVjkrOE9rUUR3cFp3WkRnLzBnUWd0L0xrSlp0OEp1L2VCKzhHOTcrdkowNWF1Q0ZiRFV3UGdQNFBCSU1GdEQ4R1o1N3RoQWM0KysyeW1UcDE2cEd5cjFkeDQ0NDBvRksyUDd6WHFEZ0k4T1FiK2J6U2NFd1UvcklRK28rSFY5MEE2NnBIcGpoMDdXTDU4T1hQbnptWG8wS0ZzM0xpUnBLUWtYSzdXalJJNGRBRDg5VXNMb2VYUWhiUnByQld0ZzdsOVlIZ1lWRlRCbmZOZzBSZk5iNStWbFVWeWNySTdDcFFra3BPVHljN085dTdsVmZEWXZYRGZMU0RLSU1ZZ3RIc1pGZ1dZa1FBM3Byb0RpQytXd2Exem9jVExPMkhqeG8zRGNOVHdGdVhsNWJRMDZzYmdkUGpvRmVqYkUrcjN3UDdiVG9OSnB3VEEreVBnanA1UVdRclRyb0xwTnpRUEd4Z1l5TnR2djgzS2xTdUppb3BxWEI0ZUhzNm1UWnNZTzNic2NmdW9WUERFL2JEdVcraVRESGt2d0k2SllON2VqaWF0RnVHNkZMZ2lFUlFDdlBzSjNQY0VWTmQ0M3k4cUtvcVltQmgwT2gzZHUzZG40Y0tGWkdabTh1U1RUNkxYNjFFcWxTeGF0SWphV25kM2k0SDkzRnJ0M3h2TU8rSEE3ZTd2d3pMeUdNWTJBUjdRRUVBa0dOeGg0ZlYzd2NvMUoxRVVHcVlFZlBUUlIzbjExVmVQMCtwRGQ4RGMyOTNsTXU4L1VQQXF5TWZVM2NjQys3UU1HeG9DaUl2alFYTEI4Ni9EbzgrQjVTVEhtWlVraWUrLy81NUZpeFo1TE8vZkd4YStDZ1A2Z25rYjdMbmRYV1pQT0FGd0tob2VIUTczTndRUTIzZkRkWGZDSmgrRWhYRnhjZVRtdXQ5S1Z5cmh3ZHRnM2wwTlduMGVDbDRIMmN2TVlqN1hjTEFhN3VrTkU2UEFab2VIbjRIblh2ZGRXSGdZdG05UHQxWUg5WWU2cmJEN05yQmt0SE5vT1RYRzdYMU5LbGl6QVdiZkJYc3pmZXZsRlFxNC94WjQ5RjVReXBEekpCUytDZkpKamxKOFVzRGRkREMzTHd3TGhUb3ozUElJdlBIaGllVzZXaU85MCtDalY5MVJVOTFtZDFtMW5PSU5QU0hnd3dIRXYxSkJxNER2Zm9GLzNRczUrYjdYNmowM3crUDNnVXFDUTQ5QjRkdjRaS3pMVmdPbkJNRERmYUYzSUpSWHd2VVB3eWRMR2p5ZklDRDdTTDA5VTkzMTZ2QkJVTHNCOXR3QjF2M3QyRnBTaTNCVEdudzh5ZzM3MlZmUTY0d2pzQUJQUC8wMHBxTW1kQncwYUJBVEprdzR3VHJYcmRVdHY4RFFYcEQ5TU95NjBMZXdMV3I0NkFBaXZ4QnV1ZzlXL0hqOGRpRWhJYXhmdjU3cDA2Y3pjK1pNYnI3NVpoSVRFMXQ5RVduSjhPSExNR29vMVB3SmUrOEFhM2JiaExySzVnS0lXM3ZBUlhIdU52amJpOXhoWVUwem5XZC8vLzEzYnJqaEJyWnQyd2JBTysrOFEyVmxaYXUwZXZ2MU1IOHVhQ1RJbmd0Rkg3Ukp1Nzk1NERFUmNIOXZDTmRDNWdHNC9tNVl0YmI1QTVoTXB1UE10NjZ1cnNWeW5aTGsxdXFadzZGbWpWdXJ0cHkyYjdsNVJDRS9iME0rS3dwY0xuamhEWGpzZWJCNjZZVTBlZkprM25yckxlTGk0bzViOThVWFgzRHR0ZGNlbVhyMzhBa0Z1SFUyUFBPUVc2czVqMFB4b3JiVHF0ZkdnMXlNdkhXbk95ejhhM3RMVlllQ3RMUTB0Rm90V3EyV3h4OS9uSWtUSi9MVVUwK1JrWkdCVHFkajM3NTlyRnAxNUYySjdnbHVyWTRaQ2RXcjRjQ2RZTXRyVzQxNkJYN3dkdVRuWHdmblNjeDZlOXR0dDNILy9mZVRtSmlJNDVpNFVoRGc1bXRnd1R6UXV0ejFhc2tuN1pOTzhocExQL1B5eVI5NHpabzF2UFhXVzhmQkpzYkJCeS9EK0RPZ2FpVmszQVgyZ3RPWEpUMzJyYW1UTGtsS3BaS1FrQkJLU2tvYXRYcmpsZkQ4bzZCelFmWWpVUHBwK3dONk5XbGZ1WTZFV0hqL0pUaHJORlQ5QkFmdUJmdHBlaHV2VFJNQUFEZGNBUzg4QmpvbjdMOFZTcitnUTRuUGdPTzZ3WHN2d2puam9QSUgySFl2T0lycGNPSVQ0R3Rud1l0UGdONEZXVGRCMlZJNnJKd1NjRXcwdlB0dm1IUVdWSHdMMis0RFJ5a2RXazRhK09vWmJxMGFYWkI1QTVRdm8xUElDU2ZpdTBYQjE1KzRJeWJYS3RnMnV2UEFIcWZobzE4dFB2ejc2Ty9MTHNUMTJqTTRBMXdJV1RlaUxQL2FmY01FWC9yNkUzaWZXbWpOdG5iKzN1SnhqMjU3ZE5taFhWa2w4VjBKc0c5cWVQYkxqMDFMYXRwcENZTEM0WEIxTVpXSzRpazVyYzR1Zm1BL3NCKzRDMVZMVzNibi8rUnl5bWQzSlVDbFF2eCtRSjl1azVxc2x2cEY2ODF5MTlPb3VkblFNbVBhdENIVlIyVVp1NEtZeG84ZityY3V3NmNVOXV0NjlpUnM1a3lDemowWGRWd2Npb0FBSEtXbFdQYnNvWExGQ3NvKy9SUlhUVTNuQjFZR0JaSDQ0b3VFWDNtbCt3RlJnOGgyTzlydTNkRjI3MDd3bENuRXo1OVA3cU9QVXZUR0c3NS9XdDVlMVpJMkxZMStHemNTZnZYVkhyQUFlYzg4NDNsalFrTkpldTAxVWhjdlJsQ3BPaCt3S2p5YzN0OS9qemJsK05INUhTVWw1TTZmajczdytIeHMySXdaZEgvampWWTJZRHNRY09MTEw2Tkphbm9LZy9MLy9RL1o0YURpcTYrYVhCOHhlelloRjF6UWVZQU42ZW1Felp6WjdQcXl6ejkzZ3k5dFBtVVp2MkRCYWRkeXE1MVdhQU9zVkYrUDdIUTJPaUZabG5HVWxsSzllalVBMVN0WFl0Mi9INFhSNkg0K0xFa2d5NGhhTGJvZVBUQ2twMlBldXJYakF3ZU9Hd2VBWmQ4K01tYk53cktuNmI1K3NzdkY1bVBLdUduMGFOSSsvaGhsYUNpbWNlTk9LM0NyVFZvZDR4N1B4REJnQUFNMmJTTHFwcHRhRHV1VVNoTG16NmZ2eXBWb0VoSUEwTVRIZHg2bjFiaVRYay95RzIvUWE5a3lsS0doVFFjbHFhbjBYN3VXMkxsekVZNStUK0UwbCtGV0E5dnpqKzk5Rm5MQkJjVGNmWGZURHVySkp6RU9IZHFxNDNSSTRPcmZmbXUyT21weWVUUFZVL1hLbFowRHVHeng4Uk9uV2pJenFkdTgyZTNVeG8rbnovZmZvKy9kRzRES3I3OUdzbnAybExaa1pHRCs2Ni9PQVZ5L2ZUdGxuM28rd2kvNzdETUVsWXJFNTU2ajc4OC9FM1R1dWFSdjJrVDBMYmZncXF1ajZxZWZQTGJQdWYvKzB4NVRuNURUeXI3OWRxd0hEalRVUHpMbXJWdnB2MjRkTWZmZTJ4aFhpem9kM1Y5OWxkN2ZmRVBOSDBkZUJ5MTU3ejBxbGkvdlhLMGxSMmtwZXlaTm90ZTMzNkpKU0NEdDQ0OFI5Zm9tdHcyZVBMbXg3aTcvL0hNTzNIeHpoMmd4blhDMVpOMjNqeDFEaDFMMjZhZUlPdTh6emtvMkc5bTMzODYrbVRPUjIrTE55ZlpxRHpzcks4bTY4a29LRml3Z2RNWU1naVpPUkIwZmp6SXdFRWR4TWZWNzlsRDF6VGVVTFY2TXM2cXE2MlE4Nm5mdG9uN2VQSExuemVzMEtaNi9kMDZyeDFkZmJaSWg1di9aTysvd0tLcTFnZjltWmt1eW14N1NRNEJRUWtMdklFMUFSQlNRS3FoWVVjU0tWN3oyYSsrS29sZWtpQXFmWXFHcUZMazBDVVc2MUFDQmhKcmVlOW5kbWZQOUVZeEdRZ2trSVZubWZaNTlJTHVUTS92TFc4NTczblBtSEdjQ2xHQW4zdDZWQXg5SUxyS3FEdWVxVEJzVTJYcGVEWCs5WUhmazNrTkpUZ1hjb1ZWdzFEWHR3enF3RHF3RE8xRS9MRkFkWnBOemJRc25nWU5yV1NvOWNObXBBQy8xckJZOWFQMVpCTERiOGZmMzU4U0pFMWZ0U3dzaG1EMTc5amtQZ1YxT1F4Y1ZzOWxjZmlDWnpXWVRWME9lZXVvcEFZamh3NGNMVlZVdmVPMFZBUWNHQnBiRGhvV0ZpUmRmZkZIRXhjWFZHbWhHUm9aNDRva254Sll0VzRURlloR0ErUGUvLzEwendOMjZkU3VIdFZnczRwVlhYaEdBQ0E0T0ZrVkZSYlVDM0xkdlh3R0lNV1BHaUNWTGxnaEprb1NmbjU4NGN1Ukk5UUkvK09DRDViQ3lMSXN2di95eS9PZHZ2LzFXdlBUU1MyTFJva1UxQnJweDQwWnh4eDEzaU8zYnQ1ZHI5c1VYWHhSZmZ2bWxpSStQRjBJSWNlellzZW9CL3VLTEx5b2NKTGhvMFNKaE5Cb0ZJRjUvL1hVeFk4YU04ai9FMGFOSHF4MjJvS0JBTkdqUVFBRGk0WWNmTHRjc0lPYk9uU3VFRUdMYXRHbkMyOXRiSERwMDZNcUFkKzNhVlFIMnl5Ky9GRjVlWGdJUTk5NTdyMWl4WW9XUVpWa0E0b01QUHFneERhOWF0VW9vaWlJQU1XM2FOUEhCQng4SVFCaU5SckYrL1hveGNPQkFBWWdtVFpxSTFOVFV5d08yMld6bGY4ay9UYWhKa3lZQ0VQMzc5eGM3ZCs0VWJtNXVBaENUSmswU21xYWQ5d3RyTnB2SVdiTkduSGo4Y1JIVHA0L1kwNnlaMkIwYUtnNTA2U0tPamgwcjB1Yk9GZmFNakF0Q2YvNzU1MEtTSlBHZi8veEhhSnBXN21iZTN0NWk1ODZkSWpJeVVnQ2lSNDhlb3JpNCtQSTA3T2ZuSndBeGN1VEk4cUFWRlJVbFltSmlSRWhJaUFERTRNR0RoZDF1UHcrcEpqSysvMTc4MGJpeDJBb1hmRzAzbThXcFo1OFZqcHljODBJdldMQ2czTXdQSHo0c0Jnd1lJQURSckZrenNYdjNidUhuNXllZWVlYVpDbDFWbFgxNCtmTGw0cDU3N2hHQUNBZ0lFQWNQSGhUdDJyVVRnR2pmdnIzSXk4dXI5TXM1OHZMRWtXSERMZ3I2ejlmdTBGQlI4TWNmbGJhcHFxckl5Y2tSblR0M0ZpRWhJZUxRb1VPaVpjdVc1VmIzVDNPKzdDaTlmLzkrMGFKRkM3RjE2MVl4ZVBCZ0FZaVFrQkNSa0pCUTZmWDI3R3l4cjEyN0tzT1dhOXRpRVRscjE1NDNpTFZ2MzE0QW9rT0hEdUxBZ1FPaWFkT21ZdlhxMWRYYkQ5dnRkdkhPTys4SVFMaTd1NHQ5Ky9aVmJzVU9oemc4ZVBCbHcvNzUydW50TFVyT2Rqbi9sRE5uem9qZzRPRHkrSEdoak8rS1Jrc0ZCUVdNSHorZWh4OSttRUdEQmxWNlRjcC8vOHZKSjU2b2xwelp2V2RQV20zYVZPa3lpVC8rK0lObm5ubUcrZlBuRXhBUWNNbWpwV29kSHFwNWVleHAyaFJIUmtiVmNuZ2trcjFDU1BNTVF0WlVHbWZFNDFGY3RzVnd4TTgvNDMwRkM5citDVnl0RDB4bnpKOWZaZGdrNzRZczZqS2VCSitLcTNzNm50ekIwRDBMU1o0NjlZcUFMMWppdVZMSnJ1S0U5K2tHNGN6dU54bWJjdTRXbzM4MDdzcXBCdUZNalA2VTV1bnBHUDJxWjZQK2Fpc0FxQTZWM0kyYkx2bDZtOEhNTjljOVVDbnNuNUxwMW9CRm5lOGdmL1BtYWxOS3RRRm5KYVdScmxnditmb2Q0ZGVSYS9HKzZIWEhBbHFTZWlxNTdnSG5KNmFTNG5ucEU0ODdtdmErNUdzUG5NbXZlOEJXUHgvMmgzVzh0RURsRlVxS1o5Q2x1NHVydGU0Qit6WUtKamF3RmZrdUhoZnVnaVNabGUxSFZxbnRKbUVONmg2d3dXaWd1WnJKOXozdXAvUThKMDg3WkFQZjliaVBvNEdSVldvNzRvYnFPNGl0V3J1bDdwSCt6RDVwNHFQQkw5SDc2SHFhcHNiaVhaaEZpZEdWWTRHUmJHM1c1NXorOW1MU3ZEZ0Y3L0JHZGJNUW4zNGlrZHVmVzRKTnJyNEhPbDdzYkdiUWxQdXVUaUhlWnJQeHlDT1BzR3ZYcmtvLzkyc1N3dWlnNnR0bElMZ2trNEZQM2wzcFovdjM3MmZRb0VHa3BxYldqQThMSVhqMzNYZVpNV01HUTRjTzVmVHB5dmR6dS8vdFJ3aTFaMTh4ckZrdDViWEhCeUJYc2lkOGFtb3FRNGNPWmZYcTFiejMzbnNVRlJWVkwvQ3hZOGZvMUtrVE45eHdBNTA3ZHlZbEpZVWhRNGFRVjhsVFp5YUxLeCs4UGhZdlcvNFYrSm5nNmQ1K1JQVHZmczVuSlNVbERCOCtuTk9uVDlPalJ3OXV2LzEyd3NQRFdiSmtTZlVBRnhVVjhmYmJiN05ueng3R2pCbkRyRm16YU5pd0lRY09IR0RjdUhFNEt0bGVMU1FxbkdtdmppVElVZlZEVlR4Szgzbno1bEFHUFg1SHBWYVduSnpNZ0FFRGFOU29FYk5teldMMDZOR2twcWF5ZE9sU1ltSmlMcnFoNkFXQjU4MmJSL1BtelpreVpRb2RPM1lrS1NtSkNSTW1zR1RKRXR6ZDNmbjExMTk1OHNrbks3MUplSnVtZkRQM0NjYUZxVmhzRnpjNW8ycW5qeUdkcjk0ZVNlKzdobFo2emRLbFN3a01ET1ROTjk5azE2NWRQUGJZWStXYW5qQmhBcDA2ZFdMOCtQR1ZLdUdpRlErSHd5RjY5ZW9sQUJFUkVTRU9IVG9rUWtKQ3hQang0NFhkYmhjclY2NHNMOUYrOHNrbkY2NHRaMlNMUmUvUEZVK1BmVldNSHY2VzZEL21VM0g5YmY4Vk40K2FLaWFNZkUxODljd25JaVBteUFYYldMQmdnUUJFNTg2ZHk2dVM2OWF0RTYxYnR4WTdkdXdRL3Y3K0FoQVRKMDZzVUVHdFVva25QVDFkaEllSEMwRDA2OWRQbkQ1OVdnZ2hSR2xwcVpnN2Q2NllQbjE2ZVJGKzJiSmxWU3MyWDZDcyswL1p1WE9uY0hWMUZZQ1lPbldxK1Bqamo4VzJiZHVFRUVJVUZSV0pRWU1HbFJmeS9sbnVxWEpONi9EaHcrWEY5d2tUSmdpYnpTYjY5Kzh2QURGOStuUXhlZkprQVFpcjFTb1NFeE5yZEU3cGdRY2VLTmUwcTZ1ck9IUG1qQkJDaUxTME5ERm16QmlSbFpWVlBVVzhkZXZXQ1lQQklBRHgzbnZ2aVduVHBnbEFLSW9pVnF4WUlVYU9IQ2xtejU1ZFl6TVBtWm1aNHRsbm54Vy8vLzU3QlUwLzlkUlQ0cGxubmhHYXBwMTNRdSt5cTVaL24wQmJ0R2lSZU9TUlJ3UWdHalpzV0tIU1g1UHk2cXV2bGx2YTdObXpCU0FNQm9QWXUzZHZ6Y3dQUC9mY2MrWG10SFhyVmpGeDRrUVJFeE5UcTVQaGl4Y3ZGcXRXclNxM3VDKysrS0xtSnNSVlZSV2pSbzBTZ0JneFlvUzRXcko2OVdyaDZla3BubnJxcVl0ZWU4VkxIZ29MQzhYTEw3OWNhMlo4UGpseDRvUndPQnhWQnI3bWxpMWRjMUtSZmxUUVljWUV0YVNEcC9NUVJ2eDJnZkh3bVdKMzd0Z0Q3OFpCaWVhVUdqNTM4S0FKK1BvTTNMb1Q5dVJlQThCL3lza2luRkhiRng0UE82RzJMNjNFNDBUYXZ2UWkzdCsxL1VmdU5RRDhkMjNmdVFmZXFaL2F2cnlaQjAzQTNQcXA3U3ViYXFtSDJyN3l1YVY2cHUzcWV3U2dubWk3ZXA5NXFBZmFyakI3R0M0Q1NvNlRVeTNhbHU3WXc0VDV6eDVwTmJqVFZkMFU3MS84ZG43Z2hwWkFsK1BFVnN1TmhCQU1ObmRwT2RKckpGY1h1Q1pOK3R6QnQ1UDdzQTZzQXpzM3NQUDN3N3BKNjhBNnNBNnNBOWZnNEtFNE1ibWsydjZTa2l6a2RWdGk3TW01QlhVSnVJSUtlcHFzQ1Z0c2hWZTgyMUtrd1lXWm5tRjBORnF1T3FCN3l0NmFlOGhEUWVKSnF6L1B1d1ZpcnFPVGR0VUczUEtzVmp2VkFhM1dLTENDeEdTclB5L1VZYTFXRzNDRXdZVlo5VUNyVnd5c0lQR0UxWThYM1lMcWhWYXZDRGppcks5MnJrZGF2U3hnQlluSHJYNjg2QmFJaTFSL1I1V1hCTnpDNE1KTXo0WjBNVnFwNzJLNFdONzV1TldmbCtxNVZpOEp1TG5CekN6UE1LZlE2Z1dCblZHcjV3VU9WOHo1ci9rRzA4M0p0SHBOUzRXc1ljT0llK3dkSDcvSDRONnZIMElJUHY4OG11ZWZYMHArL3ZsSGpUTm4zc2t0eDM0aGRlcFVBUHdlZW9oTnZlOWovUGl2enZzN1ZxdVpOMTY5aGRzNVFQTExMMlBwMkpHVDQvL05UUSt2ckFuR3hUQjdkS1VGQU9GcUZVY0hET0RVZ3craTVlYnk2S1BYRXhQektqZmYzTHJhN243RERaSHNYVGlhbTM1OGllVFhYaVAwZ3crSTJMZ1JSOFB3MnE5NGZHNXZseGV3NkJmeTE2OG5KaXFLbktWTGFkalFteFVySG1mKy9BazBhT0IyMlRmeThiSHk5YXpibWRjdGc3eGhBekQ2KzlNcUpnYS9SeDhsSjYrRS8vdS9iYlVQdkhEaDdwS09relp3OEQ5ZjQzUG5uY1NQSGszOHFGSFlrNU81NDQ2dUhENzhHdVBIZDZ0eW1XZk1tRTdzK1hvUVhUNSttUFJaczJnOGJ4N05saS9IRkJiR29rVi9FQm41Q2dzVzdLcDlZSUQwOUh4dXYyOCtEeDBLdy92bk5aVEd4UkVURlVYR2wxL1N3TmZLTjkvY3o4cVZqeE1XNW5QUnhrTkN2UGpwdTd2NTBIOC82Y01IWStuVWlWYUhEK056eHgwa3ArUXhZc1FNeG95WlJVcEs3VTBobnpmeFdMbnlJQnMzSHVQZE56OWtaTUVPVGovNktGbno1OU5vOW13R0QyNU5UTXlydlBEQzBrb0xkWklrTVhGaWIxNGQ2RWJHVStQSUJacXRXSUhuNExMekZyLzRZaFBQUExPRW5KeWlXby9TRllBN2RHaG85UFd0NktjL0xZL2hXS3RtVEY2MUVmSForNXo1MTc4SWV2bGwzTHAwNGROUHgxRlNZaWZqcFlxSGlJOGUxWkZCdGtOa3p2d003OUdqQ1hydE5SUjNkNUtTY3ZqNDQ3WHMzWnRBNTg2TnpyR3NmZnNTYWhmNHRkZUd1UThkMnZiOFYxKy82SnkzWEZ6T2ZWYllaRGJnZSsrOStONTdiNFgzZzRPOStPQ0QwWlUydldMRkFZWU0rYXgyKytIby9zTWNudnUyVkhseldrZG1ac1cvNG5tT0pMcVFGTFRwUnE4Tm9UWGVEMWZRc0ZKY2VNNlh2eHk1bkRha3d0b3BYOWY1MFlHaXlPV0JNQ3pNQjFtV3FzK0g2NkpZTENibXpibVJsV3V5ZU85NUN3bkpEdlljc3JQdzUzVDI3VDFKUW1MSjVmdnc4dmtiaXdmMmFlSlMxUytWOFBUVFpKODlCdER6bGxzSW16bXp5bURyTnAvZzV0dS9yZkJlYUtnWFA4NXBRMlNUZkVyeVRtRXBYa0JPU1JEZW9RUEJITVJIYzgyODlzYld5L2ZocjVjY0t0eXdKKzBjWUhkM015TkdkS0JObXhBUWdxd2ZmNlJvMXk1Y1c3WEM5NTU3TUlYK0ZXeE1vYUVWZmk3ZXQ0L01iNzVCOGZBZ2U5QllscXlKSnplMytKeHZGUitmZnM1N1E0ZEUwVExjanB3OUg1RXZrMm9MeFVNK2cxUVNnNm9KN0tWTk1Ka00yR3lPeXpQcHhZdi9LUGxuQW5IZmZkZng0b3VEOGZLeVlEdDFpbE9USnBHL2JoMkJMN3pBQ2pVYzhjMTJCdnlqMFFVTGRwR1pXY2lrU1gxd2JkY096NHdNVGsyY2lEWnpKdmQvK0FsdmJYRXdZMGIwQlI5ZnYzRlFCQ1lQd1lsRUV4NE9JNXYzSGNGR0M3b0dHMmhrM2t1UkpZTFlvK2xWZ3IxZzBBb1BiOENhTlUveTVaZDM0K2x1SnUzVFQ0bHAxUW8xT3h2UDVldTU5M2N2N25ud08wcEt6ajFXeUc1WGVlU1I3K2pUNTBOaVkxTnhIekNBcVAzN3kxTEt1OFl4SlcwSm0zNjZoNGlJeXJkMkN3NzJJclIvQ3ROalh1SHAvLzFDNzg4enVmK3JVaVo5dFo5ZUh4UncwelJ2M2w5cTRYOXJ6MXh4bE00eUdHU21UQm5Jd1lPdk1tQkFTNHBqWW9qdDFZdkU1NThuK0kwMytIWE02N1FidVlBMWF3NWZ0UEhObStObzErNTEzbnBySmFySmhkQVBQNlRsdG0yVUhEMks5ZDViaUo3U2lKZGVISXpSV0xIclQwcktZZHYvdWZMVzhEZllkV3cvYWNscFpRdFhWU2hLejJWbjdGRm0vejZMeWU4MXhNM05mUG5BZmZ1MlNOMjY5VGsrL0hBMExySkcwcXV2Y3JoREJ4UjNkd3hMMW5Icmo2VTg5ZlJpQ2d0TEwva0dwYVVPWG5ycFp6cDNmcHRkdTA1aDdkS0Z5RjI3Q0pneWhjVEhIdUh1N2RQWitkUDRjMUxOUXpFcFpLUTRLTVdCOEhlaFVkZVd1RFVOeEs5REMyNGFQWXl3Wm1FYy84Tk1RVUhwNVFPLzl0clF5TTZkRzFHNGRTdUhPbllrN2ROUENaa3hrMis3UDBybllkK3dmZnZsN3hxK2YzOEMzYnUveTVRcEN5bTJDNEplZkpHb2ZmdlFTa3JReGd6a3ZaN24rbUlUMzZiTXZHYytwRDNDbDQ4dDRzMjdGMUpTK0M4V1BQOGxKdHFSNkpwMFpmMndWRlFnblhuaUNkSStLMHY2YzkvN2l2N1Avc3FoUTl1cnBVOVZWWTJQUGxyTFR6L3RaZGFzOGR4d1F5UVIwZEdrejV4SjBZL0xnRENhTmZGbTdvUmdESXFNdi9rRTVqd2pPOFo2NGI1bk5TMHRKdnFQY3BENi9YZE1ieDZGM2FFaHYrUkhyb3NYSTEvYVVmVisrTWFvcDlaYnNQVnp5QWFTVEEzWXR5OEJWYjN3NnZiUVVHK2FlUXJjSFdXcFlZSEJTbnkrd3VuVFdSZTllZXZXd1JnTVpmNWJsSlBQMFpNNTlPOFJ6S2VIUHVaUXNBM3ZZaGtYRjNEcmFhZDB0Um5OVzZOSTFsQmxPR0ZSYVgvSUJUZFZ3amg4QkJIelRGWHZoMWNmS2pqN0xXM0E2VXRMT2hLeVNhZ3dxcnYwbGZBSEQ1NXJrdkxaVk5LbnZ4MmZlQ09sWmtGU2xBcjdIRGc4Tk93U09DeUNsamFab3BIRldCWmJMdCtrNjBUdUxFc0lRSWsyNHpLeG1PUUVhT0FtOFBsM01hNUZNa1hwRWk3K2d2d1VpWnpUTWxrdGJRVFZaMkJaaG13aE9CVnFROTFxeE9DbGtSZW5VYkxFaGZSUUIyNkJBdjhBZ2JiUWhad0FCNmJXMVpSNFhEVXhtbW44K3V0MExPeUc3eW9YZ2pZMG83bm5hM2dySWJUYzYwSWp4MURjcFVjd0Y4bUVKcm5Udk0yYldNZU9xOGNhTnJuU2NQSmpCRTZjU01ZUFArRFd0enZ1NFpIazMzWWJlVnUyRUhqbm5TaEdJNmw5dWxIc0hVaWpmdjNPWm50TDZxZUdOWU1SK1lHMVBMcmdKTzYzamVTNzlTL2lOem1heFdsV1BNYmR4ZkFaTWJUK3oxWTJsWHpQSWQ4MkJEMjFrZnZtSHE2L0dzN0xMdVNSTWNIWVQ3ekZYVTl1NVkvaitZenNmSXFaeSs3aGdibXRlS0Q1YWp4eVZ6RHA4elQ2dHVuTG5hMUcwcUxGUkg2b3J6NThjTjlwUHJzemluY256MEJvTmxMekpJYjM2c3I3OTkvRjVCc2E4dUhrTjRrSWNxV2dWQ0lpeUkwUEgzdWR2aUdtK2htMGhnOW96TllodWJ3MGJ6Yy9iRS9pMFNHZFdmWEplL3dlbDRjc1NVenBFTTJieTA1Z3NmcHllc21YOUd6VmlJRlQ5NUErYXdiYnByWEUzOTlhUDB4YWxpVVd6MnZGOWVwMkVpY3Y1N3EyZ1l6WU1vQlFuNmRKeWlsaGNGZ1Bkbi8xQmlVbjV1TUlld2liTW9xUFB2WWtwK2doT2dUbjRmMzFOTHhHTnVQMGpoRk1lQ0dDK2QrZC94VHJmNVJrTzkwR1JOVW03UHQzaGVQZEtKaEJ2YllUZmV3MGtXNk5hWGQzTWNQN2R1VjRyamR2ajJ6R2ZSMnltZmY5TzJ5T2cvN0JSL2p5MmVmSXNia3pySjB2MC92Tnd0U2dNWTdlSHN6NzVYY2V2UDhHbWhYYUVJR2h4Qi9QQURnTXV4ZlVHWk1lS21KNXY5aytBcHVQeDgwRHBDYzlVVHdOaEhzSzV0MGJTYk1BQys5c2k2SjdjMDllR09aRjA4Yk5tYlhOekVkalczQlhPeXNtUmVCK0svenY0R2thaGZwZ3lpNW0wTVlaZE9uU3FHNzY4SEgvSnRnM3JTRlltMC9McGg3TStPWXcrNDhXc3kvR1R0ZXViL1B6OWlTK2lqNUJuUFVKRHZuOXdQOHliK0NyelVuTW1yZWQ2L3Q5UWs1SkdKdTJKMk15eVF6cTdZUHJyLy9GMml1U05ldGlMejVhZ29tTGdGRzFDWHpUalMxWS9rVXFrajBCREw3RW5sQlp1V1liUFR2NUU5RDRCbjVjN29VYTBJb0RtcFVkSi9NWjI4RVg5VUFzN1p0bTB6MXlHNHQrM282M2w0WDd4blpBMXJKQThTQzE2QzRhdHYzMno1RmVoZEhTVlFjR2lJZ0lZTmlRcGlTbHFCdzdsc3JYbndaeFpNODN4SjNNUXRNRXJTTWI0dTdsVDFCQUFEazVXY1RGeFhFMFBnMnJ4Y0FkdHcxZ3o4bUIvSGRtREQyNitsTllZbUxldk8ya3ArZFhPanlzRThDVnpUWk1lYklMZHd6TG9pQnpCL0hIRXhCQzBDalVpcCtQQzhkT2x0S2paei9pVWxyeDh0dkhXYi8reUNYWHBlc2s4TitsYVZNL3VuYnlvVjByVndJRDNEaVZxTEpyVHg0N2Q1MjUxSW4wOHhjQTZxTEV4NmNUSDUvTzk5WFY1Nk9MYzBzRkg1NThUQ3hDS3ZQaERzcVBHQ2toUTRRVEt1MWxyenFhdkNvVlUrcUlDQlovMGx3YWZVR1RsaEI0U29uczAwYlNVbDdOSHUwMm1zdnJuVUxEbFFOTEtya2loR2J5QmphcVQ5QkYrWVpFMGQ1NWdZVlFDSmIyRXlBZFlhamhXVkswU0FMbFE4NExESkJOR0RJT0RxckRDSlFPazY0MWQySU5JOUZZMm9hWkFwb3AwUWhKSWxnK1VETlpGZmJ5dUhIVmdHVlVEbXVEU1JNUkZBdFB0amttVUlSWHRkMDBUTnBaL3YvMmN0bFF0YlZTZGxhVHA1UlUrOEFhQ3Z2VVVWaklZcnQ2UHhIS0dtTFVvVmQ4czNieVlnQ2F5TC9UUWw2SGozU1M5c3BDWE1taGh6SWJUeW1KcnNwY0FIemxFN1hydzYyVVpSd1V0NUl0d3ZDU3pselJUU0xrTlppbEFrTGxQWFEzZkVreG5ndzFQb2UvZkpSd2VUTWRsQjl4azlJWlpYeWNRdUZMUitVSEl1V3l4ZUlXc21vSDJGYzZRYkhtUlVmbGUyTFZHNG1RMTFTNWNRK1NrZEJJRlMxNTNOaUhCSzA5dHltVFNCY1JwR2lSbk5TNnM5UStqVE9pTXhzZFQ3QmZIYnVJMVlRQUFDQUFTVVJCVklHR2dYSEdDUnh3akdDVTRYSGNwUFNhQjI0bWJ5QmU3VTJrL0N1ZGxmbW9HQW02aktEbHdJWDdqYU1JbDdjUXAvV252K0ZENXRoL0lsQTZpTHVVeG45TTRkeHB1cHVIVFFQcHJzekJRalk1b2lHTGJkTjUySHdqbW1RZ1RVUmdJUnMzS2ExYWdDc2RMWVZJZTRubFJzeFNBWmxhRXh5WThTSUJXWEtnaVVzYllEV1ROOUJJMnM0VzlXSHVNWTNsWi92N0hIQU1ZNnh4SXY1U3hmS0xoV3lheWRFMGs2UEpGY0Y4WjUvSFhuVU1KOFIxVERBT0o0c20vR1QvcU9ZMHZFY2JSeGY1RzR4U01SdlVmOUhmOEQ0blJZOUxoZ1dJMDY0blI0VHlvR2tJYXh3dmtDTGE4SkR4NW5OZy95bWVVaElQbVc3aXBOYWRuc29Na2tRN2x0by94a2d4SGlUWERIQlhlUzVyMU9kUk1UREM4QzkrY3p4TmdIU2t2TSs4bVBoSXB4aHRlSXoyeWlKK2MweGhyemFHZTR4ak1VbUZsL2lsVk80MWpXV2hmUWF1VWphdm1VTVpibndLQithYU1lbURZaGpoMG1hU3RMWkVLR3ZKSndBYkZsUXVmbzZTZ2gwMzB0aWxqU2RTWG9tUGRJTDI4a0s4cGROVittSXU1SEtENFYxT2FqM1lxZDdER2ExVHpabDBpaFpGZ0h5WTQxcHZmblc4UnJpOGhWaDE0Q1UxcUdLa0VGL2F5d3ZwYmZpTVRORzB2UCt0cXJTWEY1S3N0ZUZ1NHgzODI5U0JnWWEzcnpoNG5kY3BUMnJkYVN4djQ2VFduUWhwRFVmRWpaZmNhSTRJWmFkMkYyZHNIVWtsaW43SzVRVWNUeW1SQXZ6NFRaM0NjYTBYS1ZwVXpaaTBqRXFxRmtrM3c5ZW93a0NLMWdvWEtZOFM0WEVKRlFXTnB2Skdtc3UvMFVUZVFxdzJFSU4wK2Z1aFNKTEtFTVB6MklVcis5VVJiRkVua1NKYWxYOXVwQmc3cmxjK2VPaHBtRUdSOEthVDhoMzVCQkFscjdob1l5YXBFSUhNU2RHRExORVlrTWdVVGNrV2wzZklteDFYRE1MR09zZXpmR1Rid1dMSGZ5dkFTZ2hhS3YrcjBzRGpQTUF5Q25iOHBEaHlDYUdwRkUyeHVQaXhteEh5V295VUVDV3ZSTWJCWG0wMGNXcGZEbW1ETHd2NHNIWVRQcHlpcGJ5Sys0MGo2YXQ4Z2xrcXFORFg1NHRBR3N0YnJ3ejQzSEtYaEVDNmFGUTFpUUpNVWdGNzFURnNVeC9BazJTZWR1bklOblVDS3FZcUE2OTMvSnQreGcveGs0Nnh6UEV1MGVwa2JNSkNZM2tic3VTZ25id1ltN0FRTG0yNk1tQUpnWXFCZE5FY0Q1S0pGNzJ4U0JjKytDMUlqc0ZMU3VBNlpSWldLWk9CaHJkUU1mQ05iVDdlMG1sK3NiOWZaVmdmNlNSdXBMUFFQcE1nK1NEQjBuNmF5K3V4a3NGZzVSVVNSSHR1Tjk3UEZ1MWhyRkxHbFVScHdSYkhJM1F6Zk1VZjJ1MjRTUm5FYUxlY3R4R3psRStXYUVSbjVWczhTV1FYZDdISzhTcXk1T0FCNDYwRVNFZDQzN1lQeFdGanFPRTVKQzY4bkhHRDQxOXNWaC9tZXNNMFRvanI2R2Y0a0huMkh5Z1Fma3d5M2tTUjhDRktYa0VKbm54aC93VXorVVRLdjdKTmZlRHlmYmlzSCs3RkdhMFRnZEpCU29YN2VSdXhDVGVDNUJoVWpMUldmaUZjMm9TRW9JL3lYL2FxdHpIZHRvNFhUQkdrYUZGOGF0dE1qRHIwbkNSR0lITk02ODkwMnpwT2lXNUV5T3NJbEE3UlNOckJWL1lsV01qbVJzT2JSTWhyNktEOGlGa3FZSzgybWc3eWo0dzJQTVl1OWE0cjY0Y2J5ZHZZNEhpS0lPa0F5VnFic245Rm0wcXY5WmRpVVlTTnJZNEhzQWtyblF6ZjhZZnRkalk0eW5hR2ZjQjRLOXZVQ1RSVG9ta2d4Yk5EdlpzZkhiUHhrMkp4bFhJcEV0NFVDVit5UkdNbW1tN2hzRGFZL3NyN3ZGWjZHazhwa1NiU1pnTGx3M1JUdm1LdCtoeHhXai84T2NJZ3d4c2NFWU5ZWTMvaGtyTEE4Mm80UUQ1TXFoWkp1THlad2NaWE9LSDFKRUpaZTk1RzhrVUFiWlVsQk1xSFdPNTRtemp0ZWxyS3F3SHdrNDd5cytNRC91ZDRoVGJ5VCt4MGpPZGU0MWh1TUx6TmRZYlp0SldYNGkvRk1zejRid1lZM2lWTE5NSWlaYkhJTVoxMnlpS3lSR01pbERVMGt6ZndRZWxlbHR2ZjRZeldrUUdHOTRqVmJtQ1g0MDQ4NVVSQXVuemcxdEl2SEJlOUNKSU9JQWtOZHprVkU0WElVdVhyR292eHdrb21KN1NlQVB6bWVKb204aGI4cEtPa2l4YWtpeGFFeVR2NTN2NGxKb3BaN1hnUk13VWNWM3RqcEFnWmpYM3FLRnlrUEJZNXBtTVNoZXhSeDVJaG1qSFozQXM3RnI2d0xhTVlMeFJzM0dKNGtVSWFrQ2VDY1pWeU9LSU91bWd2Y2tIZ0hlSWVCaXB2WTVCcy9PVDRtUDdLQjZScEVlY2RIZ29rOXFpMzBWSDVvZnpuWHgydjBWSDVnV0JwUHdCbnRFNGMxM3BUZ2dlckhLK1NMd0xacHQ3UEdkR1pZMW8vZHFuanlSWmgySVNWdGVwemRKTG5NOEU0Z21qN1pKYlozMFU3dS80bVFsNUxPM2t4cWpCeVduUm12enJ5eWpPdFR2TDM3RkxIWXhjdTlGT21zczd4REUyVTN5ODRQTnl0M1VtQzFwNmh4dWVRSlFjQ21UWHFDL1ExZk1KZ3d5dmxrVGxHRzRKQVpwUDZHQ29tRHFpM2tpNmFvMkppaCtOZTJpZy9jN3ZoZnByTHYvRmYrd1oyYTNlVWQ1VWRsUjhZYlh5VU0xb25sanZlWVo4NnVzcER4a3BWbHFpMXcwUVJkaXo0eXNjeGFzVmtpNFlYRFF4SHRSdXdZZVZlNDFoK3RNK21VUGp5ZzMwT3ZRelRlZEEwbE5OYVYvWnFvMG5TMnBJcmdnRklGeTB3U3dWMFZlYlNWWjdMUVcwWTN6cStvVUQ0L3pWcVVoWXl5UEE2cnVTU29IVmdzL29JSjdTZWx4eW9MZ29jcC9XanIrRmpkamp1UlJNS3NuQ1FJaTV0cDRlVFdnOVdPTjVraU9GNVVyUlcvSzQreENiSFkyemlNVnpJSlVyNWxTakRTbFJNN0ZGdm81ZmhjenJMM3hLakRlRUwyM0x5Q0t5UUFBMVEzbU93OFdYU1JBUWIxY2VKZGp4NVdhQVhCQlpJWkdsTmNKVnkySzNkUVQvRFZEWTRucnJrUmxPMVNIN1VaaE1xNzJHRThVbVNSRnMyT3g2aEJFLytVTWVWMTUzdk00MGhYdTNOMU5KZEZVRC9GRGNwRFE4NWlhMk9COW1yalNGZTYzdkp3YW5LL2ZCQk1aVGU4bWNjMEVhUUl4cGUxbzBTdEE0czBHWmlvdWpzVUs2RWNIa1RvZkllWXJXQi9MYzBHanZuUHR0cG9nZ05CWk5VeEZMN05FUTFMbFNvZkR4OE5qRXZ4cHV1eXRkc2RFeW10ZklMQjlWaGwzVVRHMlVQWXZqTFJ5aWtBU1lLYVNadklFVGFRNXBvU1FaTjhlTW9VY3BLb3VTVkJFdjd5UlhCSklsMnBJa1daR3BOT1NvRzFGd0JRQk1Hb3VTVjVCR0VrV0s2Rzc0ay8yOUI1SExFU0RGMjRVcU9hTWg2OFRSbVVjREQ1a0VZS2NhZFZNeFN4UU9hTFZJMmlyQnpWQnRBc3RhR1BCRlVjeHIrczhSamtiSTVvZlhFVHo1S2t0YjJpbTVreDVVMEVmRm5rTUJNQWNzZGIrRkZZbm5od0lWY01rVlRja1FvT1NLVWRGSDlVN1NHQzlXSGkvR2l0Znd6KzdXUk5KRGpTRlNyYnhWQUhrSFZNa0ZYTFZWTEdaVmswWVpVTFpKbDZydGx1YldJd2hua3ZOT2xIaVFSTDNyVFYvbUVYZXA0UXRqcnZNQUFPWVRTVGw3Q1llMG0yaXNMT1NvR29FczlsQXJaeEIvZUxaenVzTmFPMlVlbFM2eGFPcWZvd0Rxd0Rxd0Q2OEE2Y0IyU0NxT2xmTmw0YlFIMzlldnRmSVNaTVpjMkhxNTIzNUVsT3JVSzQvcXVMUWp4TDF1Wm01aVd3NFlkUjlrZGN4cE5FN1d2NFpxUzRRUGE4ZTZVRVVRMHFYdzdxZGdUcVR3M2RTay9yZHRYdjRPVzBhQXcvZVZ4TFAxczBubGhBU0thQkxEMHMwbE1mM2tjUm9OU2Y0R252VENHUjI3dmU4blhQM0o3WHo1K2ZrejlCQjQrb0YyVllQK1VSKy9veTYwRDJ0VXZZRm1XZUhmS2lNdisvZmVtaktpeDA3aHFCTGhUcTdBTCt1ekZKS0pKQUoxYWhkVWY0T3U3dHFnVGJkUWE4Si85N0JXMUVlQlZmNEN2dWNGRFl0cVZIOHVkbUpwVGY0QTM3RGhhSjlxb05lRGRNYWVKUFpGNjJiOGZleUtWM1RHbjZ3K3dwZ21lbTdyMHNuLy8yYWxMTDdodmJaME1Xait0MjhmbjMwZFgrZmVtZnhmTnp6VTRpS2pSS1AzazJ3dVovbDEwbFdELzljN0MranQ0c0R0VUhudmpCNFkvTnZPQ1BoMTdJcFhoajgza3NUZCt3TzVRYXhTNFlzTGFjbEtOamNJbDZXOEZnTE5KUldMcVh3V0FtdkpaanN5c3ViTkxMeVJDQ0hZZFBNV3VnNmV1YXVKUkFUZzZmUlBPSm4wdkJPeXUyWEYyMFhOcEhWZ0gxb0YxWUIxWUI5YWwxcVJDWWkxQU9DR2d2akJOQjlhQmRXQWRXQWZXZ1hYZ3VnQXNSSzI4M2xyL0psdFAvVjQ3OTd1UWlGcVFxWnVtQ3A1SEdGOHlpaysyZkNKc0RsdU4zdS9DdVhTTlZjUEw1UDdGOS9QMTdxOHJ2T2RuOWVPdURuZnhaTThuYWVqWnNQcHo2WCtzanFrMUgvNzk5Ty9zVE5oWjRUMUZWa2d2VE9lanpSL1JmR3B6Zmp2K20zTUVyUkpIQ1kvOThoaXVSbGM4ekI0ODFlc3AyZ1MyWVZqTFlmUUk2d0dBU1RGeE5PT29jd0RQM3p1Zm94bEhzUnF0UE5MdEVYNCs4ak9IMHcvejg1R2ZPWjUxSEErekI1OE0rWVRzNG16aU11UHFMM0JNYWd4OVp2ZmhvWjhlUXBJa0duazE0djNONzlNbHVBc2pvMGJ5Wkk4bkNmTUt3OFhnd3FTZkptRlg3VFQyYmx5TEJZQnFERnFwQmFuY3YvaCtNb3N5dWFmalBTVG1KWktVbDhUWHU3OG14Q09FcFB3ay9LMytqTzh3bnBQWko0aytFVTFXVVJidGc5b3phOFFzT29kMHJwR2dWZU5SK3MzZjNtUkY3QXIySmUvRHB0cFFOUlV2Rnk5eVNpcXUwbW5vMlpBK1RmcVFWWlJGYkVZc1k5dU81ZTBiMzY0L3dLa0ZxYnl4L2cxbTdaaUZReXZiMHNiZnpaKzJnVzFwNHRPRWxnMWE4dUxxRnlseGxQejl5eEhzSHN5QXBnTzRvZGtOREc0eG1BYldCdFVLWENQenc1OXQvWXdYVjc5SXNhT1lZWkhEdUtuRlRid1gvUjd4V2ZGc09iV0Z0WEZyYVJ2UUZsV28vMHg4VUdRRms4RkVnYTJBck9Lc0t3YXVGUjkrYWMxTE9EUUh2aFpmbGg1YVNrNXhEa2N6anFKcWxTOW5hQjNRbXE2aFhWbDJaQmw1cFhsb1FtTmlsNGxNdlhrcVpvTzVXalZjSTFINmdjNFBrRmFReGd2L2U0R3RwN1p5T08wd3cxb080OFptTnhMcEg4bk5FVGZUd1BLWDVud3R2alR5YmtUbmtNNHN2MnM1aXFRd2ZkdDBlczNxeFpuY00zVlh3MFgySXQ3WjhBNGZidnFRRWtjSnJrWlhqTEtSdk5JOFhJMnVUT2sxaFdPWng3QTc3S1FVcHZEN3FkL1BhYU5WUUN0Nk5lckZ6UkUzRTVzUnk2RG1nMmdiMkxadUJxMHZkbjdCZC91K3c5dlZtMGkvU003a25tSCszdmxvUXF2c2k1UXZaQW56Q3VOMFRzV1ZkeDJDTy9CYzMrZTRyYzF0ZFR0S0x6dXlqS2RYUHMzUmpLT1lGQlA5d3Z0eGE5U3QrRm45ZUdqcFEyUVZWOXdDZlVqTElTeTdleGxKZVVtY3lUMURZbDRpYStMVzhNdmhYMGpLUzJMeWRaT1pObVJhM1FWT0wwd25yelFQYjFkdnZGeThrS1d5TUtFSmphaVBvNGpOcUxpLzlPQVdnMWw1NzhwejJuRm9EcFlmV2M2QmxBTThjZDBUZUxwNDFvL0U0MDk1ZitQN1BMdnEyWFBlTnh2TXhFMkpJOVF6dEdaU3lkb0dqcytLNTZrVlQ3RS9aVDhQZDN1WWpzRWRPWjUxbk9mLzl6d0Z0Z0xzbXAxT3daMVllZTlLL0t4K05RNWNveFdQMlBSWU1lbW5TV0pkM0RxaGFWcUZ6eklLTThUYnY3MHRUbWFmRksrc2ZVV00vWDZzeUM3T3J1V0toejU3cUpkcGRXQWRXQWZXZ1hWZ0hWZ0gxcVY2S2g0UDdoV0xFSFhyT041cUlGejhSZnVMSE9XcCs3QU9mR1hpWVFCWnVvYUEremFBZGg3WENMQXNRVzlmdUw3QjFRR3U5VFBFMjNxQWw3SHM1VytHdEZJbjEzQWYzNHFtN2RRbTdXdUNWaDd3MjIrL2NmTGtTWHI2Z0ZGMll1RGV2bVdaenVlZmY4N3MyYk94S05ERnkwbUJGUWw2K1VKeWNqSS8vZlFUYytiTW9iUzB0TmFEVjYwQnQvY3M2MysvK3VvckhBNEg2ZW5wTEY2OG1NWVdhR1J4UXVBK3ZxQ3FLck5uenk1LzcvUFBQd2RxdDR1cUZXQi9NMFM2dzZwVnF6aDkrcTlad2kxYnRyQnYzejY2ZW9GRmNTTGczbWU3b3Brelo1N3oyWXdaTXpESzBNUEhTWUFORXZUMGdkT25UN055NWJtemhOOSsreTI1dWJuMGJRQ1NNd0IzOEFJM0E4eVpNd2ROTzNkaXZMQ3drRysrK1laQU0wUzRPUUZ3WDErdzIrM01tVFBudk5kOC92bm5DQ0ZxSlhqVktIQ2dDN1J3ZzJYTGxwR2NmUDdEa2c4ZlBreDBkRFR0UGN0eTdIb0wzT2NDd2FveUxjdG5rNU42Q1d5VTRUb2ZpSXVMWTgyYWlpZk12emdCaHZlcmVQM1NwVXRKU2txaWoyL05GZ2RxRExqVDJiNzE3NGtHd0xDKzhPYWo4TzJiMFBadlo4ODRIQTdtekptRGw3Rm1pd055VFpwemFXa3BYMy85MTVML3lDWmxvQUJXVi9obEd2ajk3ZERiV2JObVliZmJhelI0MWN5dWh5N1F6QXBMbGl3aEk2UHNFRlV2ZC9qNVkzQzMvblZkb3lCWS9DR1l6Z2FxcEtRa2xpMWJScVI3V1haV2I0RDdOS2dZckJRWnZuc2JtbGV5TjJmdkR2RFpzL0RuMHBNLzgrdWFLZzVVTzdCWmh1N2VjT2pRSVRadTNBaVUrZXpnbnVmL25RZEh3bU5qeS82L2J0MDZqaHc1VW1QRmdXcHZzck1YdUNwbC9nZ3c5a1o0N3I2TC85N0hUOE1OM2Y2eWpKb3FEc2cxWWM1RlJVWE1temVQOWhIdzlXdVhXQ0NRWWVIN1pXWS9kKzVjQ2dzTGF5UjRWU3R3bUNzMHNjQ0NCUXN3U3JuODlCRzRWaUg0ZUxtWFJXN1VYTDcvL3ZzYUtRN0lOUkdzNW53eGd3WHZsVVhocWtyTHh2RER1ekRqODg5cUpMK3VObUFYR2JwNXc1NDllN2l0NXc3NmRibjh0bTY2RHU2NGZoL2J0bTJyOXVKQXRRRjM5UzZMMEFjMlBNVVR0MTk1ZTFQdWdnUFJUMWQ3Y2FCYWdLVS9nMVg2YjR6cnVhSGF2dHk5L1g4bkozRmx0UllIcWdXNGtRWENETW1JNHlQS3M2YnFFSk1SVEFsakNaUk9WMXR4b0ZxQSsvbVd3b2xSV0UyNTFkNk5XRXdGaVBoaDlQY3RyQnZBRmtYUXJlQXhLTnhhWXdtL1ZMS1Bkam4zNG0zVXJyaXRLNTQ5RERNa2NOd2VTRWIrdldTbS9GWFZFRWhuSCtUZ2JLSXMvZTM5djY0cE8xWlorbHMwT0x2Z1Z6cjd2Z0NQQnY3NHVvVVJMSjBrbS9DckMzeWt0Q0ZIU3Q4QUQ4cGVOU1dGZGNpSDY1UG9DOU9jWFNyMjU2MWVYUVJpbEpNaExpYm1WWDFobWc1Y0ZWR3dFK0NlZTYwQUN6cUZIcWRmUkJ3V1E4bTFvV0doYWpoS2JVNnFZYUVSN0psRHVFOGFmdFpzakpLREVKOGMyamZKcDZoRXc4dVlTN01HcVFSNTVpRGhxSFBBVlVzdGhhQi9pM2lHZERpRFF5MGxKdzl5aWl5azVGbzRrZWJCNlBaN2FSYVFoOVZGdzgwaXN5OHhpRysyUnFFS1kvMEVidXFYenBCMnAybnNuWTNWVmVKMFNpbGJUcCtrcVpjSlZ6Y1RPV2Z5OEc3b1Fidm1Wb3BLVmJ6ZE5lSlMzZGtjSDE0L2dRT3NoZmo3YXJpNXlSZ1VpZWFOWFBIM05iRjZheDRXVldQZ2RkNjBESGRGMWNEVGJNQnNGeGkwZ3ZwcjBpZXlyR1RsMm5BVWxwS1pvNUtkWnlNaDFVYkxKaGFFa0RsNnNvaGpKNHRvMHRBRm8wSEdaREdRYjdQV1grQkJiZE1aM0EwMjdaUzRxYmNYbVRrT1lvNFYwU2JDd3Bua1VocDR5M1J1N1U1eHFjck8vZm4wN1NKVFNoSzd2MjRNa2xJbmdLc1VwUmZ1Q0NmbXVJcUhtMHpESURQcnQrVXc2ZlpBR2dhWktTN1ZlR0JNSUVkUEZpRkpFZ043K3JCOWZ6NnpmMnRlWjJDckRGeG9kMlhwSHkzdzlUS1JrR3BqY0c4ZnR1L0xKeXZIVHF0bVZuWWVMQ0FzMEFWM040WDBMQnNGTk9LUGsvNzF1RnNDZnR3ZXpxSGQyNGs3bm9iZHJxR3FBazFUMFRTQndhQ2dLQklHUmNISDI0SzVjUStRNVBvTlhPSXdzZE0rSG54endKRVBhbkhaUzJqWUZWZFFYTUZnSmNma0RlbW1lcDU0bEE4eEZURDdscjMwNGFFT3JBUFhHUi8rSS9GN2tKeHNLdzhoMFZFM2FSMVlCOWFCZFdBZFdBZldnWFZnSFZnSDFvRjFZQjFZQjlhQmRXQmQ2ckZVM0l4M0pZdVFuR3pITk1GaTZXYXUzWVZwbFU2MS9IRENuMmtIS3ovc3lVK3hzMHphZi80V2V3QmVzSE9kRDVsWkVySU1tWEh1dFFiazFhZ1F5YWhoTWNqMHVUWDkwb0JUaXMxc3o2aDg4WE9Jb2ZUQ1QxeWNYYmhUVkF6OVIyUmlzOE5YcjNqaHlLLzVpVFU3Z29FUG5jTExUYkJocFU4MVJXbjFFbDNIWnVDM2xWNFU1Q2w0QnRUT0dpNTNIeHVhSnJGNXZTZTJYUE9sbTNTMWlDb1JzeWFJL2F2OXNRVFgwc0lXczUxNXI0Y2pseHBwMFRHL2xvSFBpcUlxbEo3eHJCWGVrbVEzTHJhNFFzKzBkR0FkV0FlK3ZEN1RzNUJzaXE4TjRGeXBoR0VQSlpEN2p6MHQ4MVFIR3BEdHNKUHBzSmZsTVVKUTRKK0pXNDhFNURaSlpKbXY3SWt0dzlVQUR1bWVnYnVsN0srdFJLU1NmY2lYZktXRThmOUtRcExBMDEyZ0dBVExvMDBFK2dyNmRMSnorSVJNMitZYVpsTXU2MzQzczJ0QlE5d3ZZMWx5clFPWGFocTkycGRRV0NpUnI2azhPQ21ickx3Y0FudzBrck9ncUJSS05iQklFQnFnRXVTbk1mc3JMeExTSUxGZklXNFdqZkJHTmx6dk84SCtIZTVvQmdkaWI4TkxmcjY0MW9GdFFzUGJVeU8vUUtLUnlaVnZ2cmN5NGU0Q1pCa0N2TUZrZ0JJN0ZKV0FwNWVLdlZUaC92dHltREhQeXE0Rm9SUUtsU0xWZ2RsRmNPUElUSktPdTFacDNYMnRBMnRDNEdJV0pLWEpLQklvUHFWTVh5clR1SUhDa0Q1MlRxUkNaaDQwOG9lTUhKbWNkSVdrVklVeFE0b3BISGlLbkx5eVlid3NDVXlLek9tZmd1cTJTVHNvQXk0dGxpalFWSG8yMUdqWFF1TlVhdGxEdGE0bU1DaGxXMHdsSlJrb2ptNUNyaVJ4UkZNcDBUVE1rb3hSbGtpMzIzamtqWlA4SWdvSmtheFhDRnlESzVja0pCd3FGQlJKK0JsTWJKZ1p6aXBOeGF0bkFyNGVOalFCQmhrc0x1QVhZQ2U1YlRKbUJUeGNOUXdtRFRjM2dkSFZ3YWptRGxLVERWV0NQVDl3RFE1dUROWlNpa29rYkVJZ0FBL0ZRTVRnSkFiMnQ1R1JKNkhJNEdrVkZKZEN2L1lhL3Yxenp4dVFORldpUUZWeFU1UzZhZEtxRUFTMXp5VStGY0xDN095VGlqRjZsZkN2NFlWSUVqVHdySnBwaFRkVXlWWHQxUUJjUTlzdEtwSkU3clpnanZ2R1VsQWkwV3BnS2xiWHY3YVdxbm9BQkdNVjEyUEw1M0cwR3ZSaHlNeFd5TWlVR0QraUdPOEdsVmREaWkraFNISXlVY0ZUTVZRRGNBMUtrYVp5YTI4TlVWeFc0K3JUVWVWMHFvVHRiNTJwcXBYdHZuUTZXV2IyRHhiZW11SEtpUlNKeExTS210aXozNFJabHFzaGFOVms0bUd5NGJCSkZLV1orV3lhaGJzZnlPSkFqSWt0RHBWUi9SMllETEJ1bDhLMmxiN1lFajN3TmhoeGFDcGlTQnhCSVJwL0hKSG8yTExNMTNPU1hlcis0TUhrb3RFNFJLTjl4eEpLanZqeHh1UW14QzRNNThpaXhpU2xsbjJkOVl2OGNFdjF4Y2RnUkFMY1pZVXY1bmdqeTVDY2F1Uy84OHFDVE1mdStXaDFIZGk5MEkxMzN2SWw3bjhoeUpKRWtLbXN1dWloR0RtVFhHWndYUWRtb2Y3anlFTGJHUThjS3JSdTd1Qkl0RzlaNnVrdUtOSFV1bTNTQVA0NWZraC9HK2hvVGRPSjZKSkw5L1oyRGg5WGlGbllHS3Z5bDcrVytPYlJybE1tc2dTNzlodnBQeTRac3dsMjdIVEZJaXQxSDFqNngyQkNvSkdYWW1icHoyWlNUcmhpL1Z1L2FoTWFtbnN4b3RqRU56OGFTYzNUOExjcWZQK2pDMmRPR3pBSWdhRUsvZHBWQWE3ZzA1SU04UUdreHAvL2M5UEpBREpQL3ZXRi96elExK1V5dWxDOXBxVUQ2OEE2OElWSFNJcUtTOFBhMmVQREpiZ0ExY1Yrd2VGOHpRRXJnalkzcDNEM2YrS3hHR3FwTXlneGNOL0x4K2swSWduRnJGWVQ4Q1gyODVMSlFaL0IyVmc5VkhKVGF1Y3AwNElzTTBpQ252MXpNWHVYWEhvL0hPaGFTcmNHZVpYK2dwOWl2M0RmZDdaRml5dXNYK3FMTEVuNEJ6aWdsdmIwMkxXcUFaSkp3MVdSTHgxNFhKTTB4alZKdTZJYmR4bVE5YmVmTXZRb3JjdFZ5T1BwMi9mRGhPam9veUZYMnVqLzlTMGdLdnE3T2dIWVdUOGwvaHFUS21jRW9hSGVKQ1JrWC9DYVBMOUcrTng1WjkwZ25ELy84b0g5L2QyWlBYczhOOS84M3d0ZWx4elJqU1p2dmwwbmdhdGswbmZlMlkzQmcxdlRwRWtENS9kaFNaSzQ3NzdyQUxqLy9wN081Y09TSkRGbVRDZTZkR21FTE10SUVyaTVtV25UcHF6SGV1aWgzbmg3LzdVOXY2WUo1c3paelA3OUNXVitmbWdUY1VPK3FEL0FRZ2lXTFBtRG9DQlAzbnp6VnR6Y0tpN1U5UE56NTlGSHJ3Y2dKaWFKQngvOHBod1d3SnFWVEc3MGl2cGwwZzZIeGllZnJDTXk4aFYrL25uZk9aL2I3U292dmZRekhUdSt4ZGF0eDUyblcwcEl5T2JiYjdkeDY2M3R6dmxzMXF5TjJHem5qb0kwb3htRGJ4M1pweWN6cytyZDB0MTM5d0FnUFQyZkZTc09NSDU4ZDR4R2hUdnU2TXFubjY0LzUvcGozVzdsbmpWZjFaSGtXYXBhbFBiM2QrZW1tMXJ4eFJlYmFObnlGZTY3Yng0ZE9yekJwazNIeXFPMlUyVmFiZHVHMHEvZlZMWnMrYXRTZnZCZ0VuMzdUdVh1dTd0ZlV1WlZyNERYcmozTStTTDV2SG1WNy96dm0zQ1lsSGNQTzBjdWZTblM0T1FCRXVkOVZ5ZUI5ZUhoTlZYeDJMZnZ6SythSm02NllwT1dpdkVSUlhVQzBOcWhnM1JlSDI3Yk5yUlFOMmxucm5pVUhEcGtFWnAyN2Zod2JOKytDZm5SMFNIT0JLaFhMYS9wYmlsdHhvemYxWnljSHM0RUdQVDg4OUo1Z1lVUWk4QzVIb21YSkVuMzRXdTNINDY3OWRhT1JidDNYenZBV202dXlaNllxSnUwMDJyWXBWV3JITW5GeGFreUxmNzNQL1J1U2UrV3JoVWZqdTNWNnpyYm1UUFgwSGo0eUJFdnh6K21KblNUMW9GMXFUL2o0YjVqVnlaRWIwOTFxc1NqYjdlQXhPZ2ZidzdWZlZnSDFvRjFZQjFZQjlhQmRXQWRXQWV1eVZ5NnRtcGFzYkd4V0sxV1FrTkRhNE54c1NSSlYyLzM0UjkrK0lGeDQ4Wnh5eTIzOE1NUFA5UzZobXYxa2ZqTm16Y1RGeGZId0lFRGNYTnpJelkybGgwN2R0QzFhMWZuOU9GdDI3Wng1NTEzWXJmYnljM05aZXpZc1d6ZnZ0MTVOV3cybTlteFl3ZXJWNjlHVlZYYXRtMkx4V0p4WHVDR0RSdGl0OXVKaW9xaXFLZ0lXWllKQ2dxcVZlQmFOZWwyN2RxeGV2VnF0bTNieHE1ZHUxaXpaZzN0MjdkM1hnMkhob1p5NU1nUkVoTEtubzg0ZlBnd3ZyVzhjcjVXTmZ6cHA1K3llZlBtOHA5MzdkckZhNis5ZHZXeUVDSEVJbEZEc25uelptR3hXQVJsV3d5V3Z3d0dnL2psbDE5RURjcWlXZ1hXTkUya3BxYUt5TWpJYzJEL2ZBVUZCWW40K0hpaHFtcjlCMTZ5WkltNCtlYWJ6d3Y3NSt1NjY2NFRjK2ZPclhIZ0d2WGh3c0pDcGsyYlJrNU9EZ01IRHNUSHArSlJCSklrNGVIaFFjZU9IZW5ldlR2dnZmY2VXVmxaOVRkbzdkaXhnNzE3OTVLZG5VM2Z2bjBaT25Rb0F3Y081Tk5QUDJYQWdBRk1temFON3QyN00yN2NPT2JNbVlQRlltSFRwazMxZDdRa2hDQTJOcGJaczJlemMrZE9qaDgvVG84ZVBUaCsvRGpYWFhjZGE5ZXV4ZE96N0lTQXZuMzdNbUhDQkNJaUltcDB0RlJydzhPU2toSnljbkpJU1VraExTME5TWklJRGc0bUtDZ0lpOFdDaTR0TFRTbTFBbkNGeE9QNm41L3FIcDI0di9iNndXTTFmNHUrSVcyNzZ5VWVIVmdIMW9GMVlCMVlCOWFCZFdBZFdKZHFIaDcrOWwyamhENitCVTYxTUcxanBsdGl2enRPNlF2VGRHQWRXQWZXZ1hWZ0hWZ0gxb0YxWUIzNENxWEN6TU1iUjRLT0dHWE5xUVlQZGswK0FxY3FCMTZmN3BaVGs4ZUhYUlVSNU9nK3JBUHJ3RHF3RHF3RDY4QTZzQTZzQTlmMDRLRjlqdDFURWNLcEFGVko4dHg3UHVEN2p1ZEh0cyt4T3hYd1hpOWo1R1RkaDNWZ0hWZ0gxb0YxWUIxWUI5YUJkZUFhQmphcG90alpBSjJScVVwU1lXSWxNNnI3SW9RMHlya0l4V0xmUTl0RzZ6NnNBK3ZBT3JBT3JBUHJ3RHF3RHF3RDY4QlhKaFdtV2l6L2ZxS0ZIQnprVklCYVVuSUw3dHRXT2JDaFZVc2ZRNWNPVGdYczJMbkhSL2RoSFZnSDFvR2RBM2hMV0tUVEFmNlRTVGRwSFZnSDFvSHI3K0JoZDJacFZrYUo2bFJQdFp3cWRHU2RGM2pLN3F5akNObzRsVW9sanVvK3JBUHJ3RHF3RHF3RDY4QTZzQTZzQSt2QXVsekdXT0p2OHN1WUJ4T1N0dTkycXVGaGNMZE9pY01XZnFIdm1LWUQ2OEE2c0E2c3dtQ1E3d0FBSUFCSlJFRlVBK3ZBT3JBT3JBUHJ3RHF3RHF3RG4zYzhYRnZIOGRheVhOM2plSFdUMW9GMVlCMVlCOWFCenk4VlZ2RXN1MjFpOTZUdHU1MEtNTGhiSi8wWVFCMVlCOWFCZFdBZFdBZldnWFZnSFZnSDFvRjFZQjM0bXBjS2hmaGtmSVd6QVFhUktlaytyQVByd0Rxd0Rxd0Q2OEE2OE5YUHRBRGg3SXk2U2V2QU9yQU9mTW5TcTFjdlZxNWNTWHg4UE45Kyt5M1BQdnNzclZ1M3ZxcC9BRkZUcnhkZWVFRm9taWFtVHAwcVhGMWR5OTkzYzNNVExpNHVBaEFoSVNFMWNlL2FCKzdkdTNjNTdJV3VXNzkrdlZBVVJRREN4Y1ZGR0F5RytnbThjdVZLa1orZkw5emMzQzU0blJCQzdONjlXM3ovL2ZkaTl1elpRcEtrK2dtY2twSWlObS9lWE9sbkhoNGU0dmJiYnhlTEZ5OFdmeGN2TDY4YU1lbXJIcVdGRU9VdnB3bGFmNXEwdTd2N1JVMTYxNjVkNHJ2dnZxdmZKdDJyVjY5TENscnIxcTF6anFBRmlPZWZmMTZvcWlvKyt1Z2o1KytXL3E3cEZTdFdpUGo0ZVBIdHQ5K0taNTk5VnJSdTNWclU4SDMxNGFHZVMrdkFPbkQ5bFFyTGg1dCtkYVBUQWNiZnYxbzNhUjFZQjlhQmRXQWRXQWZXZ1hXcC9iRmlkRVRyUmVCa1Iza2lGdmVOUGFnL0lhNEQ2OEE2c0E2c0ErdkFPckFPckFQcndEcHdQUUF1VXNwZTF3endsTllHbm84MFhoVmdRMjNmVUpYZ2hLdU1KdUc4d0NVeXFGSVo0V1lmaVI3WkduWkpZbDBEaGU3WkdnQ0tFTGhvVGdJOHJyTUpUUUpaUUtFQmpHZkJ0bnNyV0ZVRlRRSkZFeXpkYVhjT0g1NngzNDdWSVhqNHBBTkp3SXB0Tm43ZVljT293VU1uSGJnN1lPWitoL01FcmFBU3dmZTc3YXoxay9HeWx4WFNqQnBZTkVHMHI4ejgzVFlDU29YekJhMEdwWUt3SW8yaDNZeUF4QTNwS281YURsNjEyaTF0OGxYd1VBVU5peUdrUk1QTFZ2YWVVd0x2OUpJeENBRUNQdDl2WitZK0I2b01JTmpqV1h0Lzkxb3o2VFo1R3E4ZkViVE4rOHRYN3ordDBqRlgwREpmY3o1Z0Y0MEtzSDlLKzF6TmVYMVlIeTNwd0Rxd0Rxd0Q2OEE2c0E2c0ErdkFPckFPckV0ZGxRb1ZwZnpBZGs2NU1NMDlaWisrTUUwSDFvRjFZQjFZQjlhQmRXQWRXQWZXZ1hWZ0hWZ0gxb0YxWUIzWWVhVENHZyszNUwzT1NTbEp1a25yd0Rxd0Rxd0Q2OEE2c0E2c0ErdkFPckFPckFQcndEcXdEcXdENjFKdnBlS2pqaDNtTEFLdWVHR2FZK0hFRkVYV0FxK29qVlE1NWN3ZEhvSFZ3TGc0L0VTT3ZqQk5COWFCZFdBZCtJSlNVQXdPOWVvRDE4anp3OWs1a3V6cERzYXptN0hrbElMbUNYblpZTkdnTU4rRUFQd2IyRENaS204ak1WMVc2Z1d3cDV6T2lwOGlmRHg5c2hrK1BCa0FSWUF0RndwL2xkaWVHRWFSVHp0cytXa29MdG5jZG1jc0x1YUtiV3pjNHNuUnZVMTh3anlTYUo1bnE5c21mVXZZTnN6QzIxQ1kzb1RvVGQ0QXVMdUFpQVZEbHNESFZvS0xTY2JWcktEWnZFblByTGduejVHakxwdzQyQnczRjZ0eXVtTWdSWFhiaHdWaGxtUktiQnBGcFNwN2R3VlRlbFpCcHJaZ0hRQ1dQZzZLODFJQmNMSGs0K3RWY1hlV1AzWUdrMWNnRUFLS0xFWVNqWExkTldtam1vMkJJbEt6RlVvZEdxcERJcjhRekNad2NZQjdZOURjc3ptd1J5QkxFTm9rR1l2bEg3NmJJbEZTWUNlbjBBNENzczBHc052cUpyQ0JZanl0UmxSTllEWVlrUDVtcmE1bmc1UFZvdUZRUzhtM0d3a0lMRG1uRFhlTGdrRXprRmZvd05OcVJDaFNIVFpwU1NhLzJFR3BRNk93eEU1UmlZTWpSMTNKTHdBaFFOTWdMdDZDUVRKaE1Ta2NQKzZHL2V3V1BFWEZjUHlraVZLYklEVzdCS05CSWptckNFczFBMWQ3bERZYlpZeUtoRTJXTUp2QXZ0eUgyTFhnNGxhSTBhQWhjajFwbzZZQkFpbmR3ckVqM2lnR2xjSThDOFhGWm56OU5USU5NbWFqZ3NsUS9UMVQ5UUlMRFUwSWlrbzFKTUJ1MExoK1pSSlN0cURVQkFjaW9OM0JQSEtIZ3ZBRDYwOFE3d2NOczhFOU5RK0ExSWxCdUpqY1NNOHR3Y05pcEVnVmRSaFlrdkd5bGptcnFnbk1mOXNSN05TL0lYd21GRWFCK3c5Z2RvV1VFbWoySXlUTUJPUEQ0R0lITjRzQmk4MkF4YVhzcTFucXJBKzc1SU5TK1o1WTJSNGdCNEJQSnBpUFFzNGV5RDhHU2d5NE9zQTFGekt2dTREaHRGRVJVbDBBbGdSWXNpRjBQL1NhZ3hwNG90TExyQVhnTUVKVzB6SXQrdlFGcVR2NDdvVWlieUFTVE1mUEF5dUJhR1d2Tmx1OHNtYUVCTTIyUU5ScUtIVkJ6Z3FpdE5rQlhEU2xRdTFJTTBEWWM1QTJHYmdkTkFFMk94UXJrTDhKR2p3Q3B0VEtieEgxVEM1dStZS2lhdG85cm1JWURCcDJHeEJWcFJZeUcwT2VQNXh1aWV5V1NYYnpQVVFXZVNJSlVBeUM3VTFHRVREM0dMOGFoeUdpTEVUMVQ4TGlCKzRCWVBXSFJEV0F0UXpEWjJZQzgvTW1JZnZrVVZENmwrODM4czFBV1dCRVpGNjJNUjcrSktka1FmVUZMWWNKOGdLaDdUSlVKUmRORWloSWlMTW5DdjVSOUFhYm52OElNREtxL1RpRTJQbjNoWEVVQ2c5V3hjNW4xWE1Pd01pQThGdUJ4TE1HcEpGMXdJajFxRlRIb3JURERHNlpTR2VDR2FSWjJlQ1JTdDlzLzcvTVNDbWhTYk5mV2ZUZFRBS0NZaWdxTUJBWW5JTEQ0Y0hYc3o3bjdDNTU1elFiMERpZmdwVm13RmJIb25SZUFLejlGM0p1Q0w5NEpMRGRQUU1rMEJ3U1puTWVrVzFuRWRaNEtVYmpjUlRaU0c2ZU40VUY3aFFVdUdFeTJlalc4MzBhTi8wT0lUUU1odUsvY25NWEI0Njg2azBHcTY4MUlXSHZ1Z3FickRFMnZURUNzRGswUnR6MENxV0ZrU1FuOXNkdWI0WERvZUhtbm8zQldFQ2pSc21vYWdISlNXMDRjL0kyUmcxOUc1TTRVemE2c3RpeEYxZi9kcTdWQjF6cWh2bW54eG1SRTBxUjNjRm16M1JTM0hKbzZ2OHRMZHhtNG1JdndXckpKeTh2aUphUmUya1ptVXhDZ2l2NWVaMXhOK1J6VTQraDNIYkRmN0JheXpUc0Y1WkgyaW1QdXAxYVNpVldzZzAyVnZrbWtlUmF6QVNzMk5aSTJBdFRhT0h6Q2crLy9CTC90MmdpeHc0TnhHaXlVWkpsWU56ZzBXUWNscEd5alJ5TlVXallPSVA0T0Y4a21SbzVTYlhhQncrdVFrR1JaWHJsdS9GSzczeThKd21zSFhZVE9sbGdzMGswa0pZaU8vd1JtcGtTTllPT2tRZklOVXNrVDdNUWxLalMvSlZDRWpKUGtIRXlwSDVVTGNOTDNIZ216Ni8wNVM3NUZINHB3QTRCajVlcGF1MmFVQXB6cmFSbXBwR2RtVVZCcVoxTjY1b1IyTXBPNTl0eXNLNkZvbFhRWjJBMkpqbTlxQ2FPMmE1MjRFUHAzdHcyOWxST3MrY0VMaHNncHkwb2ZyQjhlU0I1YVdHWTNiT3dXaFE4WEEyWXJUa1U1bnF5ZGxVNDloc1VDdHBCMFdkUThnYU1IWnllNTM0MHE0NERDNDFGeHpyaTdpYUUrMHRBSUdTN2dDcWdZY05pQXB2RUVSS1dpNHZraGlKTGVMc2JhZFkrbHNDUUhCQ0NZaHQ0NTRMa0NZb0NYVTdta0pOdiszLzJ6ak04anVwcXdPL01iSmUwNmwyeVZTekpsaXczeVFVM2pCdTloUjVDYndFQ2hCSVNra0FDQkFncFFQSWxRRUl2b1JtYlpwckJCZHNZTjl3dHliWmtXMWJ2WmJWOVorYjdzY2J5MnBJdDJlck1lWjU5cEoyZDlzNDk5OXh6enoxejc4Q3R3MDRoR3FmaWIwcXMrV0JkQU1WTi9walcrUEV0ZUgwdGJONGNqbVJ3b3NnR3dpTGJ5Si9Rak1ub1YxM3ZQOEZ0Zy9oWThOV0FWWUU4bnd5aU1FQ05sbmgwVkgxRStHRkJQaDFNbXRpRU5kUkJlWVdadWFjMUJ3WUJMZjdQNFdJUkIzaUlweXVTbGVFbUk5M2RINWZ1bjhFMFFmRFgwUjhOY0grS0Jxd0JhOENhRENvSmFOVzNMNXoyUGdKRGE4WTBsWVc1RjMzNzQwMU02OURUY3Z5OUJPL2E1a0VOcHA4U2h1WGVkTTFvYWNBYXNBYmNBeTFGVGdpTUQvMlJBRXNDdHRFeDJES2pRTi8zNjRqMWJRRGdqR2lrV1ZHRU5Yc0JBZUdSVVNpcjZsRS9xeDNrSlp4aWdWRDlVVDZkTk55Q1lwZVI5OXFSUzJ6ZzhFR3k2V2lWRDlNanBGc0dCN0NhYTBXYUg0V2FhRHJTeGNPN3JnblZKS0dmRW81K1NoUktrSWk4dnVWb2Z6ZlJoRFEzR2pYWE9yQ0JWUUYwRTBNUm80d0lLWlpESmFzbVc1Qitsb2d1d29COHdJRmM3OGJYNE1LMzM0MFVvVWU2S2dtR213OTU5a0tLQlNIR2dHNWlHS280Z091d01ENFVJVUtQR0dsQXpBbkd0N29SWVdRUWhndmlrTUwxaUhxUS8xaU1XdTRmTUpPU3paZ2ZHb0hpQTNGa01PNlBhNkN3RFYxT01HS1lEaHdLMHJoUWxFMHRBMVNsZlNDRzZsSDFBc2JNSUlSSUE0cGJoK3Z6WnVSV0h3Z0M1bCttb0pwRlZJdUU4WmNwSUFnb2JUTE9MMXBRblNKQ3BBRmpoZ1dNRWtLWURsa2V3Q290VGdwRnRPcVEzUW82SStpdlRVU3lPNUZXVmVQOWJSRnluUWQ5bkJGcFhqVGl2R2owc1Via1dnK2UzeFNpVzFXRnp1WENjRzBTT3BPRTdGRVFRM1hvOGtNSHNORnlxNmlDZ0M1WXd0T21ZaHBod1h4WHFqOUJWRlp4THFuRFZldUZyQkFZR1l5cjFvTnJhYjEvTEVZbllMb3pGWE9hQ1UrTEY4a2srZk16UFFNMEUwOFZBTE9JN1BBaGhlcEJWZEVaUlhUeEJseVh4S04rMzByYi9EUmtuNGVXeUJCQXdDbzdjYzFOeFhyQWhUalJpakhPLzJxQTJpd2pvdUp6S0FnSDF6a1YxQUVHTEtoK0l5dVpKRlN2aXFyNlA5NVdHWFZqQ3kxWFovUG5nbG40OURvdWpOcktvcG94TlBpQ0NSRmNQSEsxUXRqcnUvRE9qVUlmckFOVlJaWUZKTE9JcXZZY2JJOWJhYm5OaCtSVzhNcGdqTllqTzJRRVFVV2NGSWJMcG5CTCtscStyNDluVGtZWjlTNExLZVptbGpablluRTRFQ2VHSXFnQ1hwZU1aSlp3MTNrUUJGQ2J2QU96RHF0aGVxUlVDNHFpb2pNTDRGUHgyaFFFU2NCNllTenh3MlVXbEkvaG5NUmRnRUJlZERWNm8wcTJ1Ukp6a29HUUMySlE5ZUJ0VTVCOUtwSkpBZ1hreFRVREUxaG85cUs0Wkh6ZnQ2SVAwcUY0RmRBSitMd0N6aG9QRFU0am14ekRxR3dMWVVWUkhBYkZUVVpZSTFhVGh3YTdHVmV0RjlVRGdpU0FSMFVmTE9GZDA0VGdrZ2V1bFZhK3FrZG84T0RhM0lKa0ZKRWRDbktiRjJPa25tYTdrVm5XWGZnRWdjWDFvNmwzQmZGU3dWamk5RGFhSERwTVVYcDhkaCt5UTBZeUM3ZzJ0NkF1cVJ2Z3ZhVjlEblNYeE9ONXZCakhuQ2dNODZJUUVMQ1h1VWl6ZXNqVnQxS0p5TnlNRmRRQ0k0TzJVWVhDVktPSHRqS1FEQUtDQ1BhUGF4RldOaUNZUlBBcUF4ZFlzUGxRdkNxcVdVSmNYSVBueXpxRTA2TlJBUDJrTU1ZRUM2eDFHR2pRK3k4YjZmV1JaL2FoY3lsNDFyWGdVeFJZVW9mb1ZmQmRtb2p1Z0FPK2F4cll2U1hQcStVSWVYN3ZTUEFxc0xvUktUc0VTNXFadUNpSk9iWVdadUhnTk1ISm5OWVc0cUoxbUZQTWlLT0MvSENpd1A2N0pxTk9pZWJiMk5FRHYzc29IWENnbXhGK0tDOURPVDhXUTRvSlo1Mkh0aFZObUlkWlNJL1hrUlluWVl3M1lWdmFnTFBXalhHWUNlWFNCTVR6WXBDdGVsUXZUSnZjaUdvWXdDOXFIV3FQeTkzb0hzNUVGeXloQUo2TnJmaStxa04wS2lqanJQNzBZUUVRQllSUGEzRXZxMGVhRyszdmNNUWJHUm5iaGs2blVyWkxUMlNRQkI1bFlBTVRwRVBXaVNpdFB1UW5TeEFjc2o4VC9TZnhTQ1lSUjVVYlZEQ0U2eEZPRFVkYVdBMnZITUFyZ0hKS0JMcjBJTHpmTlJKVmJCOGNJUjcxazJwbzlhRnNhVVZ3K050UjRmdzR6R2RGNDIyVGtmUVNvbEhFYS9kaE9Tc1c0Ynk0USs2cHRLWVI5WTB5NkFYWVhnTVdpdTBvcjViaDI5dCswL0szVFhodFBpU2pnQ3FvcUFKSUJoRzN6WWU4cG9tK2tsNkxXZ3BWTG5SVjdlOFdpdlZ1dkgvWmkrZjBhSXpad1FnQ3VMZTBvWDVaaDFqdkh2ekFuVDBFNFg4VmVQS3MvaDdRcGxaLzB6Vms0OUlBWGdXaEg0ZGl0YkVsRFZnREh0elNvZEhxS0RkQ0syRk5Cb2NFakVpZityTlh5cjlaZi9Mdno1UjljdzlKY1NjMzhxZFcxV0NmY01iSmQxZFBtVkJoK2VEbEpNMUthOEFhc0Fhc0FXdkFHckFHckFGcndCcXdCcXdCYThBYXNBYXNBV3ZBR3JBR3JBRnJ3QnF3QnF3QmE4QWFzQWFzQVd2QUdyQUdyQUZyd0Jxd0JxeEozMGhBWXBxcXFqMnlsQ2ZuVHFxbXFqeHVRQkNxTEJRMlZXbExlV3JBR3JBR3JBRnJ3QnF3QnF3QmE4QWFzQWFzQVd2QUdyQUdyQUVQSGVtVlNROVNIZytoMUJNNk1BZ0ZJSzlLVTJrTldBUFdnRFZnRFZnRDFvQTFZQTFZQTlhQU5XQU5XQVBXZ0RWZ1RRYXRCQ1NtVGZ2cEd6MlRtRFpBSkNXc2hibHBwVHV2dSsrdmg2WWk3NUdvcFY0djRmWEtBNmNVQlpYVDAwdTVja3dCdXhzaVFnNy9yVWVBbzhMTXROamNPRnplZm9jTk1YcTROWDhyNCtNN1hoQ2pSNENETFhva1NjQlIzYi9BT2RIMTNENXBDK0ZtVjZmN25CU3d4YVRINGZJU2JERmdOdWtwcjdZUmJESFE1dkQwS2Fna0tsdzBhZzhYakN4R09NNUtOdDF1bGt5RzltYzBQanZXWDhKQkJpSkQvWXZDalI4VkcvQkFlbHVpTEU0ZU9uVXRGNDdhYzF6WUV3TFc2UVR5Y3Z5WndTT0doUk1hWWlURVlpQWl6SXhCTDVFeklncUE1SGdyYWNsaHZRbzdPYW1LSitldEpET3lzZWNkajVoSUM2SWcwT2J3a3BjVFIweWtoWm9HTytlY09vSWdpNTZJVURPblRSNkd6ZTdCWk5CeCswOG5zTFBZdjlaS3VOWFVvNkFHU2ViR0NkdjU1WlR2c2VnN3R4dHExRlNpSnR3a25oQndZN09MYXk0Y1RXaXdrYS9YN09lUHQwK25vc2JHK1hNeUNBa3lFQmxtNHR4Wkk2aXN0WEh2OVpQWXNhY09WWVU1VTRZVEVkcHp3RW5XTmg2YnM0bzVhYVdkbDZJbENuWE1IeGcyNDA0RVM1elNMV0NkSkJJYkdZUlBWdmhvV1RGLytkVnBtSXdTUGxubDlPbXBKTVFFTTN2eWNFWm5SRE51VkN3VGN1S1lOeldGSmQvdTQxZlhUMGFTUkVySy9GT2s2M1VuN3NrS2dzcWN0Rkllbjd1U0pHdGJKenRKZUpNdUllcTBweG1XUHVxSGNoYTY3V2tseDFzNWQ5WUlOdXlvd3VueThkUnZack45ZHgwVGMrTVJoY0FGVjFVVkNrcnFFVVdCVFR1citjKzdXNWd5TG9HSVVETXJOeDZndGEzN0Zqekk0T1dtQ2R1WW5GVFZ1ZnFHWm1QSytUa3hzVEVCMnpjVlZKZmw1Y1FQNjFhelZGYlZ5a3NMdDNMdmRaUElTb2xnVDJrVGs4Y2tkRklTa0RNaWl0MzdHM0Y3WlY1LzhoemUvYnlRVDVZWG4xREpaa1kyY3NlVXpVU1puUjJycno0SVY4cE5wT1ZNUVJBNnVoK2g2KzJ3WGk4eEpqT2FjU05qY1hsOGZMZWxFcGZieHdWek00OS9veWtSdUQweXYzdm1HMlJaSlg5MFBLSUFSZnNhdWxUS29xQnkvc2hpTHM3ZWpkaEpjK09Obmt2MHVKK1NHTnoxaFYyUENlejF5bnkvczVxdFJiVk16MHZpdk5rWlRCd2QzK0dUN0VnU1lvTDUyLzJ6K1daREdjdlhsVkpRVW8vYWhSWHVJa3d1YnB1OGhaem8rbzYxeUpLSWt2VUwwbEpTdTkwTTZUcDJGUTFFaEpxSUNEUDcvNGFhaUFnMVU5dGdaMTlGTTJsSlhXdGYyeHhlVm04cW82SEpTWHgwTUFhOVJHT0xrNFptVjZmZTJQajRHbTZkdUpVUXc5Ry9DNkllUitKUFNSMDNINzFPNnRJOUtNY0RsaVFCZzBGQ0ZBVjhQZ1dueTBlcjVFRlJ3T09WeVVxTjdMTDZLSXBDU0pBUkFRR1RVWWMxMkVoMGhJVTJoNGVHWmljSHFscHh1bndIV3dPRkszTUxPR1BFL282MUxUUVA2NWdiU1lvSzcrTEQ5ckRnaTExOHRHelh4bU1DeTdKS1k3T1R4bVpuUUltZk5UT04rZE5TR1JiZjlabkJZNk9DY0xwbFB2Mm1tSy9YN01mdTdOaEpTQWhwNDQ3Sm0wa0o2MkF0WW1Nb3JwUmJHWkU5cmt2WGJMRzVlZmZ6UWhZdTJYWHdlcXFuNjBaTEo1S2JHYzJvOUNnYW01Mzg1YVYxekorV3lybXpSblNwSG04dHF1V0ZCVnNKRHpVeGYxb3FCNnBhS1N4cE9OU05GQVNWbWNNcnVHN2Nkb3c2K2FqWWhDUG1QSkluL0FTTDJkZ0Z4OGpKMjU4VjhzSFh1M0c1ZlNkb3RId0ttd3BxMkZSUVEzUzRoZC9mT3BXbVZoZXJ2eTlqUm43eU1XOWcrKzQ2NnB1Y1BITG5EUDd5NGxvKytIcDN3Tzltdlk4YkpteG5XbkxGVWNmNkxPbm9zbThqSy9uNDA5WFhOanA0YS9GT1BsNVdqS2NMUVlndXRjTTVJNkxJell6bXNlZlhrSm9jeHFOM3ptRFY5MlhNeUV0R1VWUkVVUWlvRXBzTHEwbU1EZUhqWlh2NDkxdWJPSE5HR2pHUlFTejVkaCtLb3BJZTNzeWRVellSRStRNHdsRXlZa3U4bnN6eE01REVZM3RsVlhWdHZQSHhUajVmV1lMWHAvUk1zL1NEYTFsOG9JbWR4ZlVreG9adzdRVzUzUHpRRi96cWhza3NYMWZLNk14b1d0czhCRnYwaEZ0TnZQMXBJUmZOeitLNjMzN0szZGRNcEtTc21RVmZGaUVJRUd6U2MycnlMaTRmWFlRa0J0NmtJM1E2MFJPdUlTa3M1TGhPMEJzZjcrVExiL2NpeTkxZnhmVzR3RDVad1NlRHlhamoxSW5KM1AzbnBTVEhoUkJzTWZEd3YxYnp5aE5uODhGWHU1azFLWm50dSt2WXRhK0JqNWJ0Wm1aK01yOTVhZ1VYemMraXB0NE92bFp1elYvSDJOakExU29WWXd6ZUViZVRsWmwxelB2WVY5N01heC90WU5sM3BTanFpUzlYMitXSWgxRXY4ZGJpQWdCT241N0dBMCt0SUM0Nm1NWExpMmxvOXJldFM5YnNJelV4bFArOHU0WDdycDhNd0lJdmlwaVI0ZURLckc4Sk5ia0RIUDNXbUV0SXp6c0hrN0h6MjlpOXY1SFhQdHpCeW8wSFVIdGdXZDR1QTdlMCtXODJKTWpBNnUvTHFLeHRJeThuam9WZjdTSXhKb1NHWmljYnRsZVJPVHdDUlZINXp6dWJ5VTRMSjlmOExlZGxsUVNjeTJVWmpXWE1MZVRFUjNkNnZZTGllbDc5Y0R0ck5sZjBhRis2MnpFdHA4dkhscUphQU1xcmJkUTJPQWdOTnRMWTRrUlJWTGJ2OGF1c1VXM2k4cFFWcEljMXRQZG9wR0JzdzI0bWUreWtUcHUxTFVXMXZQYmhkalpzcitxVktFbTNnWDF5dTdIWlVWeC95SVZzT09pb0ZCVFhNelc1a2hzbmJNT3NiMjhQVzhMT0lEbnZNb1paelIyZWQrT09LbDc5WVB1aGg5bGJjbEpSeXgrQzd6KzRpa2FkekxWanR6SXJwZXpRUG03ak1JU3NXeG1kM3JHanYyWnpCYTk5dUoyZHhmVjlFdUhza2JpMDNlSEZLTmZ5K0p4VkpJUzBIWEwwRzJLdUludmluS01jZlZXRmxSc1A4TnFITzlpOXY1RytsSk1HRmdTVitlbjcrRm51SGlUOGJtdHIwRVFpeDkzQTJKakFYcFdpcWl4Ylc4cnJIKzVnYjNuL3JJeDNVc0FoQmcrM1ROeEszc0ZoRFo4VWppUGxObkxHNUI3VklWbXlaaCt2ZjdTRHNxcldmaDJkT0dIZzdPZ0dicCs4bVFpVEN4Q29ENytRakVubkUyd3hCdmppbjY4czRZMlBkMUpWMThaQWtHNERTNkxDVDBidDRjS0R3eHB0K2d4TXViY3lmbmg3ak12amxmbGtlVEgvVzd5VDJnWUhBMG02QlJ4bGR2S0x5WnZKaW1wRUVVM1V4OTdBMkluVGtTUi9vK3B5Ky9odzZSN2UrclFnb0Q4OUtJRW5KbFJ6Uy81V2dneGU2aTJ6U0pwNEpjTVBEcjNhblY0V2ZiV0xkejRycE1YbVppRExjWUVOa3N6UHhoUXdMNzBVcHhTSGJjUnRqTS8yUnkxdGRnOEx2aWhpd1pkRjJPd2VCb01jRXpqSjJzYWRVNzRueWVxZ092eG5qRDdsZE14R1BjMnRMdDc1dkpCRlMzWVBpRUh3a3dZV0JKWFRVc3U0WnV4T2JLYlJNTzVHSmlaRjA5RHM1TVVGMi9obzZSNWNIaCtEVVk0Q3R1aTkzSnkzamZISmRwb1Q3Mlo4Zmg1MWpRNmVlblVEaTFkMExZd3lhSUFueE5kR1hEZCtPNTZvMlVSTXVSaXpXK2F2TDYzajg1VjdBem9OUXdaNGZxNmNZc3IvSTVIV2NQNzExbWErV3VPUFFXa3lpQ1dnRzE0eW1TV0pmMldlY1VUSE96czJ3cjRyUURtQkZlc3RFeUg5bzQ1L0t6a2ZIQnU2ZjA0eENGTGZCa3QreDcrNzkwREZmWHlWdm9INWg0NEpBRnBIYS9HWjBQeCtKemVkRHltdmdXanUvczI1Q2poNm9BZi9OdGZPRTRBMSsrK2xNOWltQlZCOEpqZzJFTkJiT1NyNHE5aWg3QzRvdnh1VUR0S2RncWJDOEpkQk1IYnZCaFU3dVBkMVVBcDdRZW1tdXkwWS9mY1FOTFdENjdqODkxNStWOGZuN1RqYXJVTFR1MUJ5RnJnN0dNY09QaFdHL1JlRWJtWWxPYmQzYmRzeFlmVXcvTC8rZStoSWhVdk85Tjk3cDVweFREVXM4cXRGMDRLamY3UE9nK1JuUWVoRzk4TzFvd1BnSGQyQTFjR3c1eUJrWHVjcTdOcDFuS3JRRlZVczcwVEZROCtHcEgrQUlIV3hoTGQxOEJDNldNS0NCRW4vQk90WjNWUGhiZ01mZW9LZHFIalloWkQ0dDY2ZDZZUlZXdlJmSSt5QzdxdndDUU1mUzhYREw0UEV4NDlzNUk0V3VRVzg1ZTNmUFdYK2JjZHJPQk9mOEY4am9BRGU2NW9LbnhUd3NWUTg0bXFJZi9qNDBJZVg2SEhWV2ZDZk0rS3FEbFQ0bDkyMzdpY0VIS0RpWi9yVjZsQkU1RWFJKysyeG9ROEhQcVk2Q3hEM08vODVUMGFGZXd3WS9PcDBwSXBIM3c0eDk1dzhjT3c5RUgzYnlhdHdqd0tEWDYyT1ZQSFllLzNnSFFMdk9ENXc5QzhnNXQ2ZVVlRWVCKzVNeFk5VXh4L0VWK00zZnE1QzhOVjFFQ2k4NldDMTZDRVY3alhnamxROC9oRy9NV3VQcEFBUzdKa05lK2I0L3o5OEZESHltb09HcndkVnVOdEJ2Qk5WY2ZzYVNIakMzMXc1Ti9sVldSY0g0WmVES2F2OUFUVzlBOTRxTUkrR2hNZjhLbHo1UU0rV2FxOENINjdpemkxK0I5KzVBeUt2ODZ1NWVGaGFaT2hCSTFmOUdEUzhBcFVQK2g5VVQ1ZHFwLzFoMjl1VTZtSVo1dG5yNzhXNFM5by9jdE9KWHlUeU9uL3BIVXNxZndzTnI1NUV5VVdBSVEyTTZRYy9hV0JJQjdtR0E4R1hNN3pERWhZTVNLYVJZQnJaZ1pmVTNBN3YrZUZoSEh3d2FpZXhkMEVBWGJ5L1pJOG5jYitIMWkvQlcrM3ZyWFZvY0V4Z1NBMEVNaDZFbERwSi83UTNJcDJRU2t0aFlNbnpmNDdzd0hzckF6WGlod2ZpcWZTN2hHSVhzbnRGaTc5KzEvNFRESWtIZ1E0dnNYVFFKeHpmayt2OU9peUNQc24vQ1o1NVdQTlRENFZqMmcxVVY4U1VCY2lRdmhoMFViMVRoN1VwNHJyZkRvR240ckI2WGRLdTNraCtpOXZWeWVKY3UvekhsSng5VUozVHdEaWl2WjdxRS90UXBlV21neURGN1VDZXZmNDQxYkdNVnRNNy9xYm5lUFZZc2Z2M1JmRjNHejFsMFBaTkIwWXJ4UTkvcEVXV3drOEFXUFVndXdyOVFKNGptNlVUU01sUVZiOVRVZjNZOFp1bDZzZjgreDd6b2JnT3VxVkZIUmpWOEVDTitPR0I0RVh1RkhqL0ZXeFFZVmhQMVJkVEZnU2Q0bmNxVVAxTno1RWxyZGdQT2g2dlF1UzEwTFlHM0x1N2Z5MjVDUnpmK3o5SE9Cb2Irc1RUQ3I4TUVoNEgwZUFQc2plODZtOW5qK2xhL2drVXQ5OEpHVFN1cFdqMis5RGhsL3EvVjl3UHpvT0JkbSsxdjUwOXBHUVNoNEx6emgxUThRQWtQZ2xKVC9zMW8vSUJVSG80YzZKSG15VlRGb3o0dkIyMjhrRm9mUFB3U3UySHpWZ0dHVXNQZ2gvbVZUVytBVlVQSGRTUVMvM25NbVlPVU9Ed3l5RDlzL1liclA0VE5MelVnVXJGK2wxWDB5ai8vMGRLL1l2K09nMytjNDM0L09nQVhyOENpMlpJZXNhdmhqK01PZFg4SGVxZTdYaC84MkU1YStiUkhlOVQ5MitvL2Z0aDUzL2FmNDBUR2RQcVVlQWpWUmlnN3YvYWI3WkQ0TkhIQno3MDBQNTFtQVlkVlBIdXVLbzlDbnlrQ2dQVS94ZXFuemoyY1FFbG5IdWN0dmx4cUgraC9ic3gwMy9OazFIeGJnT0xGdi93eXVFcURQNW1wK3FQeHovK2NFaFQ3dkgzci9vRE5MeDJSQlU2Q1JVWFQwaUZMemtpdXZFT1ZIYWh6eXVGKzN0VlA0Z2h1Zk4rN0pIQmdTUGI1Uk5WY2JIYktwd1J1TDE1RVpUZjEzbW5QYUIwYzQ1ZHB6djNVYUg4WG1qK0lIRHppYWk0ZUtJcUROQ3kyQit3bzRzSlB1WXhIV2hOYmhmdlZJSHlPLzNYUEtxVjZJYUtpeWVpd2dDdFM2RHNkbEM3a2JiVkVadzV0K3ZIcTdML21xMWZkYUNCWFZUeFRvSERMKzlZaFFGc3krSEFUYUIyTSt1d0kvWHRra29mRHUzMVg5dTI0dWpmdXFMaVlxY3EvRlRIS3RLMkdnN2MwSDFZTWRqZmJUdnFKdFA5MlRqZGd2YkFnZXZCL20wbmp0QXhWRHdBMkRJUmEyY3FER0JmRDZYWGRwenNjdHpTemU0a1dpR0FLZnNFQWkwdTJIOU41K2xPUDZpNFpTSldmc3dTK016L1M0L01tS2JvQWlSdUFBQWdBRWxFUVZUY1JLTUFFU2QxRWg4TjZJbnNBY2FGQW1oTGVXckFHckFHckFGcndCcXdCcXdCYThBYXNBYXNBV3ZBR3JBR3JBRnJ3QnF3QnF3QmE4QWFzQWFzQVd2QUdyQUdyQUZyd0Jxd0Jxd0JhOEFhc0Fhc1NSOUpRR0thc29FaHRaVG5RVmtvVHRRUzB6UmdEVmdEMW9DN2MxVnp6N3hYTjJpQXd5K0c4UDVwL1hUOWNWRWgraFpBUlcxNDgwY0FiTTZCNEdrSC84OEdaOEhRVm1raDZxWU8veCthd0tJWm9xNXAveDUxVFo4YnI3NEZEcjg0OE8xS0tielBqVmRBSGI2dVlXUlZzNkpiMjFzWGV5cmpnWncwQ0ZnVWJXL0VBN1o3aTdiczdLMXJob20rS2lqcUdIaW54eElQd3BUZXVIQmFTQnBwb2FPTzJwNGVtaDFpTUkrYXNzKzJ0MWVBS3pCVTlJdEtYempzd21QOGRzSGdhSllFQk1aRWpDSFNHSWxWYnlWRWI4V3FEOEZxQ01XcUQybi9yZzhsSVNpaDAvTmNubllGTStOT3BkWFRRcXZYaHMzYlNxdlhkc1QzVmhyY0RXeHIzSWFLMmovQUtpb2lJZytNK1MxaGhyQ1RlbkNKbGtRU0xaMnZaTm5zYWVaWEcrNDdLZGdlVWVuTmpadTVadFhWN08ybE9naFFZaXZobWxWWHM2Vnh5OEJvbGlvZGxWeS8ranBXMTZ6dWNkalZOYXU1WWZYMVZEb3FCMVk3YlBmWnVYZkRQYnhaMG5QKzhac2xiM0R2aG51dysrd0R3MmdkS1lxcThJK0NaOWhyMjh0dngvd1duYWpydE80THg1ajZ6S2Y0ZUh6YjQzeFM5dkhnOExRK0tmdVkyNzY3bFdaUGM2ZEc2bGpHNmRidmZ0NHJzTDNhRG05dTNNekRXLzdZN2VQK3VPV1BQV0tjK3NXWEhoNDAvQVNPR2RhYnQ5Uzd3SGxSZWQwL0pqSy83enl0ekRLeHltWlJlNlR6SUlvNllXSkVmajRnZGVlNFNaSDVjbUtUYnFPaStIcGtHYUFRaDFpMXNUUGdaLzVQMTJPZEI5M29rWml1N21SdVIxa0dCSkNPVmpDVDNpSzk4bkgyWk4vT29oNHFVN1hpcmI1UWFjT2tDUjF1OTY3ZlJPTTVWOUo0N2sveGJ0amM0VDc2U2VNSFh4M1dUdzZzdjJwTEs3YmZQVWJ6dFhjZzd6K0F2TzhBemRmOEF0dnZIMGR0dFFVK3JNbDVnd3hZa3REbmpUMzAxZjNKbHpTZWZRV3VSWjhTc0M2MnF1SmF1SmpHc3k3SHZYaEorOFBLSHdlU05IaUE5VGtqRVlJc3lPV1Z0TngwTjYzM1A0elMwUG1NM0VwREU2Mi8raU10TjkyTlhGNkpFR1JCbDVNMWVJQjFlV053dlBRbVRlZitETS9xZFYwK3pyTjZIVTNuL2d6SFMyK2luekIyNEFVQU9oUFh1eCtpT2s1c0JrN1Y1Y0wrdDJjUkxPYkJVOEluQ3R2VDUraHpUMnNnaWdhc0FXdkFtZ3dxQ1lpMXJNNGEyeU9KYVQvSnVJbzZmZEJKblNQYWEyZlJuamQ2Z25IaDlGMWJ0Y1EwRFZnRDFvQTFZQTE0U0FBSFo5cC9QTUNXRkNkeDU5U2pEL1ArQ0lCRmlKclpqQ0NwaEk1cCt4RUFxeEE2d1VaWW5nMVZFUVl0c0s0N3dFVVBwV05PZHRLNk0zam9BNGRrMnhseGJ5bTZJSm1tOVZaS25oazJLRXU2U3lvdEdoU1NMcTlCRitTZkFUOThVaXNoT2ZhaFc0ZE5jUjVVM3hFYmZhQUw5UTFONEpDY05pb1h4ZUNwMTRNQ3RVc2pNQ1o1VUp6aTBLekRqV3REeVhwd0g0MXJ3dkMxU1FTUHRDUGJKQlNQT0RSTDJOdWtaOWRqcWFncUdPUGROS3dPcC96ZHVLRmxwZVBPclNOaXFuL04rb0lIUmhCM1p2MGhRMldLOWVCcmtqQ251NGljNXMvVTJmVm9LckpER3J6QXhpZ3ZRYW4rNFE1ZGtFelovK0tKUEtXRmtGd2JGZS9GNG0zU0V6YXA5ZEErb3FRaUQ1VTZiTTF0STJKcWU4N1Y4T3NxOGJWSktPNGhhclE4OVhwYXRsaFJGUlhGTFNIcFZSUVpna1k0aHFiUmNsVWJRWVdZdVUyRTV0bVFRcjA0OXBtSGx0RTZYSUpHT0VtNHVCWlVhQ3V5RUp4bFJ4OHVkMnZwb2NGVHdqSVlvendZSWozSVRoRlRraHRydG9Qd3ZGWVV1MjRJQWt2Z2JkWmpLd3JHMjZSRGRvaElGaGxia1FYQklnL05PbXdyTXRPME9oUnZnd0ZFZ1phdFZtcVdSQ0xxMUtGWmgvVmhQdXhWUmx5Tk9uUW04RGxFUkVsaE1FcVhnSU16bmNTYzNoRFlXYktKT010TVF4TzRma1VZaGlnUHBqai8ydG1xS2xEL2RUaGhrMXFIVGgyV1hTSytOaDIrTmgyaVVhSHFneGdjQjh6b3JUNnFGMGZSV2hpTTRwSU83YU9xd3VBdTRmSzM0eWgvTzdCSFZQVmhORlVmUnJmdjgyNHM1ZS9HRGowclBaUkVBOWFBTldBTldBUFdaQUJKb0h2MG02dmVCMkdJelppbUx1VFBiMmlKYVJxd0Jxd0JhOEFhY0dkaWtoUk0vUlFUNnhmZzArUHJtUjlmLytNQXZqWHpBTy9QMk1UQ0dadTRQYk4wYUFFbm1sMWNOcnlhTWVIdHI4dStWSng4NlA4WGl0dmY5eDhYM3NybHc2dElOTHNHTC9DWWNCdHZUdDNDbk5qMkVHK0kza2ZVKzNPSWVuOE9JWHAvVW93Z3dKeTRCdDZZdXBXeDRiMGJDZTNWd2FIUEs2TzVjR1VlaXl2YUEzOE5iajE2U1Flb2VMMytvUnBWaGI4WHBySzdOWWpQS21NR1h3a2JEN1BBaDhQR2hZUWlDQUp2WG5ZTGIxNzJjMFJCSUM0azlORHZuMVRFQkZqeVFRRjhXbXdqeStlc1kxaFFZRjAwNmZSOGRjUDlYSlNUejZXNWs3ZzBkeEkveWNubjZ4dCtqVmx2Q05oM3VNWEY4cm5ybUIzYk1QQ0JZMHdlSmthMkVDUUZqaXpPU00yaXdkSEdnM1BPUDdUdHdUbm4wK2hzWTBaS1pzQyt3WG9mK1JFdFJKdThBeC80eThwSTRoZk5vZFFlT082VUdoNUZlVXNUWStMYXJmU1l1R1FPTkRlU0doRWRzRytwM1V6Q290a3NxWW9jK0VhcjJhdnZjTHZENnlIRWVQVGdtOVZvd3U1eEIyeHI4MG0wK1hvbkJhcFhyTFJGYitEdTZXZFE3N0N4cktTQVBmVTFGTlpXa2hCeTlEUnlDZFp3Q21vcUVRU0JqTWhZWnFkbkV4VVV6Tk9ydnp6cVFReFlZRWtVMmROUVRYcEVESGRQT3dPcnljeXphNWRTMXRKSWZsSnF3TDVsTFEyWTlYcmV2UFFXV3QxT3lsb2EyVk5mZ3lTSUE3K0VKVkhraSt2dVkzWjZOcUxnRDVkNVpabjE1WHU1NDVTNUdDUWRUVTQ3NFdiL2k1ak5MZ2NHU2NlZFUrZVRGQnJPNU9SMEpGRTgyRGFyTEMwcDRNeFgvbzVQa1FjbXNLd29MQ3NwWU82SW5FUGI5SkxFdE9FWk1EeURzcFpHckViellmWFhURzVjTXNtaEVVZWRTeEFFbHBVVTlDaHNyMWpwcDFkL3lkZkZIYys4bWh3YWNhZ0VBVVJCNkJBV1lHbEpBYzk4dTJUZ04wdjN6VHlUT3J1TmhUczJvcWdkSjcyczJGdkVOL3M2bmsxSlZWVVc3ZHhJWFZzcjk4NDRvK2Z0UzhDMzZXTXZCU0g3WkU2NGN0OHVBT1psakdacDhVNXNiaGN0YmlkQkJpTU9yNGNudi9rVXA4OUR2ZDNHcDd1Mk1qNWhPTEtpc0t1dW10MzFWU3piVzBoS1dCUXZiMXpGOCt1Vzl3UmpJYXUzdmRkclZ0cWlOL0RsN2gxOHVYc0g0eE9HTXlvbW5sQ1RCWjBvb3FncWM5S3plWDdkTWtEZzFpbXorZk0zaXhFRkFaK3MwT3l5VTFSWHhlYktVbFFWZ2d6R0htK2FlaHo0cWduVG1IaEUwK09URllvYmF0aFdYY1l6MzM2SjIrZnZGbjYyYXl1bnBvMGtOemFKaktnNEpGRmdVbklhVjAvd1Q2bStzWHovd1ljemdJSC9zMjY1Mzhtd2hoLzFXNFFsbUF0ejh2MXRyT0MzNmdEbHJVMlV0d2JPeGxUUjBzU3EvYnNHaCtPeGN0OHVacVptTVQ5amRNY1hGVVZVMm9HUGxLLzI3T3dWMkY0TkFLemN0NHVONWZ2NDVmVFR5WTVKUE1wQlFWV1JqN0RpaGJXVlBQTnQ3N2lVZlJMeGNIZzlQTEZpTVNFR0U2ZW1qZVRNekRIRUJGc0RTcmpPM3NwbnU3YXhjbDhSTnJlcjA2WnNVQUQvMEs2MnVwMThVcmlaVHdvM0UyYXlrR0FOUXdXcWJTMDB1eHlvYXQ4bHFmWjV3bk96eTBHenEvOWVIZENHV2pSZ0RWZ0Qxb0ExWUUzNlR3SVQwKzcrV2gxeWhFL1BGYlE2M0xmU3YwclVONzYwdXcxMEJzeTR1U0FxaUNDOXl2SktMMUdSS2o1RlpXZWpqQnNkcXQ0MGlJRmxMOGhlSnNmcmVmRzBhbmEwaldicWlEUWNUVGFhRC9pNGFZcURrRkFya1pHeDJCb2FxR3RaeGpNN1VxbHZybWRwWTlUZ0FyYTQ3WHgrMW5yYWdzNGdYdDVCOC92L3h1d05abW1OajR6d3ZieGFhbVNueFVhVTNzdHA1cEdNdENZUkdydWZWeTY1R1pkZzVlcUZOaXBkT2dwYUpGeUNZWUJhYVVWQlVMMDhtQmZDdWVrUkdBc3ZvYlFvaGRaOXU4a2NINHc4NXJja1o2UmhhYndOMGhmendwTG4ySE5nRDAxdEZWd2RlUm9KZGMrenEwWWdLU09QNkRrWGt4YXlobThyWnpMbjB3aVE5RDFtcFh1a2hIV0N5bjNqamVSSzBlVEV4RkQxOVl2NHF1c1F3c2N5L2FZcEpNU0xFR1drV29rbTJIUXorMXViYUdobzR0eXBGN0Z5MDFMbTMzSTcwcjRObU1zdVkvdWlKNUZldXBleXNWZVRlL0ZwM0wxM0hUdWEzWHhWR3p3d1N0Z29DZHhvOFhKbDlpaHE5OWRTdWVvWnhvLzVucFNaNGNSTWZSdDUvM1BVRzZheW9kekNaL3NFQkFGV2xuc1pZWFpUNHpOeldiYUpkSXVUN05SSVVxTk5OSlYrd003OXFaaVgzYzB1ODFsY2RFa0RkdU9WcEw0Y2pGMnc5SE1KcXdxMzVlaTROU3VmMWEvdlFiUTlTdTdrUnZMT3pzRmhPSjhkVlM2K0xUMkhlNzl1UXFjMGs2VldJS2t5SWFqVTRvZC9vZExBYm4wNkV5TnJlUExNZUh6ZXM4ak05bUNObTRXeWNEVWZ2VDZkc3g0OWk0dFRWckMwMmtXNTI5Ui9SaXRCMThZbEUwYVRtQkpNZGMxOVRFMnZZc3JWdjhmZVdNOFc5d1F1ZmFXUVdwOFpWSW1MZGJ1WmttRDB4N2hhV3pHWlRCZ01CbFRWeVRzSGRyTzJhVFNudmxwQnFGSGdsNk45M0RmM0RuSWZHby8rcVJ3MnYvMGFML3o4ZHI3ZnRvL3BiKzVDbGt4OUQyeVFYWHg2VlRoakVzdDU5Y21ueUEvYlM5ZzV0K0wwR1BqTHBwRTh1YjBNV1F6eGoxNHBBZzdGUDR3bENBS2pza2RSWFYyTklpdjRmRDRhWENvWVZEQllhRkhoa1cweWphcVgrYWtibVgxT05MLzUweDlRREZtRWhJM201aXdMenhXZmVFclRDWHRhVVVhRjlQUnhsRy80SjhNSzMrSXRjejVLeUZ4dS96eVVmK3d5STR1SFdWWlJvc0huZjdheUxKTStJcDFody8xcGgzYTduVWJGN0UvSCs2R21DQkwvdDBQbHNUVWV2RkVQVVIyVFF0bnlwOG1hRmNGOTgwWWlPVnY2R2xqbDdCRVc2aHVhS053NGl2WDZWTUtTRWxtd3ZwSTM5aHF3KzQ1K2w3aEtpTUR0ZHVQMWVjblB6MmZVcUZFNG5VNks2dXkwaFNSMmFFL1hOdWo0OWFkNjRqTEdzYk8rZ08xclZ4SmlEdUtHTVNHZ0tuMEhIS3JZZU95Y1JGSlNVbkMxZklLYWxjbU0wWE41YXBNVHhJNnpiOG9NeVh4UjZzRVVFWXNvaW1SbloxTmo5N0xPTUI1VjEva2tLTnVhSURzMWp3T1JWandybithRnE3ZHl5YWhVakdJZmxuQ1NWMDliNFRyVy9lTjA0cjNWekpnWXpzYUdZTnpCOFowZjVIR1FINnZubExIdHc4OHo4MGVUeExHejdiNnIwN05scjhoUHIzdVlyMHUyY08yTEl4aWRHa1dTd2RGSFJrdFJPRzljR0UzMlBGcHFQc0xGTEU0YmZ4MFB2K1dmbk1qZ3NSRXQyWTlxNGcyS0RaUFB6cVRKa3c1dEd6bHlKT0hMQzBpVWE0NTJ4WDBlcWcySklJcnNGVEtJQ3dtbHhHdkVhYS9Cb1ZobzlvcDlCQ3g3R1JFV2c4Y3BvN3JMQ0k5eVVHMDNzcjdDQlpJZXI5N010Q1NWLzd0MkZqR1I0Y2M4Vlc1dUxwOCttM3ZVOXUrTDluTGJXNXVwYnZOREZUZTZHUlczbjVGV0czdmV2SkRUZnZGM0hwNmJ5aTgrcXdhZG9aZFZXbTlrU1VFRExyc0xVVEZqVFB3cFJ1ZGVURWJEUVF1cjQ3MEtLNmYrYlRsTDF1L29uaWxVVmY2eDZCdm0vM2M3Njl2YWs5aEM5QjRFV3hsanJLZGdpcjBBd1R5V1VJTUtLSDFSd2g0bXhVVVNQZHlLTCtGZHdsTU1mTFByZTJ4SFhMdklIY29GYisvbjNzSUsvbkRsSEhTNlkxK3F0cUdKTzE1ZHdZSnlDNm9RNkRkdmJ6YXlwR295U1pPTVZPODNzZmhmVGo0M3Q0RE8xQWRHU3pKUTFOcks1K3NXc0h6ekY1ak1CczZhbmtlWWNIVHF2bE13ODZldEVtYys4U0g3RHBSM2VzcXYxKzlnMXQrVzgxNkZGVlU0K3NIRUdCUm1UOHdsK3BUemVidnFjOUltUlRJdXhBU3lydytBZlI1R2pReG5VOTB5ZGxXdnhSd0J1L1lVRTJFV08rMmZmTjBRd283QzNaMmVjdW0yZlJTNlE0K3A2cUlnWUhlMlVPSGV4MWR2YktmYTVRSkoxd2ZBT2dOcmltdFFRcHpZRFhWczJMQ2F2UEhqK05ub1VQQjVPandrWHE1ajdzeFRPajNsNmJsSkNFcm5wWFhCQ0NNTkRRMjgvOFVidUJRN01ha1dpanE1VnErMHc1L3VkWk9aTUJhYmF1UDc3MVlnQ0FMWjhTRllqQjAvOGRtcHdaak43YzdGc3FYTDJMbXpQVnR2NXNTeGpOUTNkZHArWDNIS0NNeEdJM3ZydHBFZU5ZcUVFZUhZM0gzb2Fia01JVGpGWEp5S25RTTFPL0Y2dmN6S1RTRkY2bmh4MXJsWmtZZjg1cGRmZXBuMTY5Yno4WWNmOCtFSEgvclZWUlNabTlseEV6WXpTY2NwbzVJcDJiNGFtNitKdXk1OWdLWVltWFVOUXQ4QnF5cFV0eG1ZbERhRGpOSDVmUDN1UHhBRWdROXV5aWRTQ0p5a04wcHU0Q2N6eGxGWVdNanp6ejFQVTJNVGVyMGVnOEhBbnQxN2VPN1o1NmlwcldQK3lNaWovR1BCMmNSdCtWRTBOeld4ZjlzcVJzVk1aR3p1V0w0OFVJdEgxUFVkTUFpc2E3R1NrRENiZVRNdW8ySnZJWXJzUVZCOC9IcHlLSEhtOWh1ZmxXemtqUy9YOFA1Nzd4OFZraFpGRWFmRHlhLy85aElJRW1saSsrdDV5UmFGajYvS1pNNjRWSFp2L1lwWWF6UTNYUFpMRml6ZndNY1Y0bEdlWEs5M0QvZllKUDY2MFV0RFl5T1R6N2lTai83ekc5TFQwemwvWER6VElweUhBdTZiU3lwNFp0bGVEQWJETVdKaUNwZTh2UmY1WU82SG9QcTROTVhMbE13RVBHNGJMWHUrWmV6Y3kwbE1TT1NsemMzVU8wODgxbmhTSXc5N0hYcVdWNEV4S3Ayb2hGUytlTzBSaGc4ZnptM1RrL2xGRGdUcm9jU2NoVlYxNFBWMi9vWktwRUhHaFk1U1l3b0dRZWJOYzZMNC9jVlRjVGphS1BqNm44VEhUNkdrMmM1bC8xckt5Z2JMeWR6eVNRNjFpRG9lV20zbnNjOEx5SjExRlhaYkxWOCsvd0FUc2xLNWYzNFdENDV4YzBjT0pPazZCL2I1Zk9oOExxeEtHMWRsQ0R3K1NlVHkwOGJqZHRrcFh2SlhZbUpHa3pqMWRENHBzdkZ4cFhFQWpDMkpFdS90TjdDOHFJcmgwMjdHN1czbXUwVi94TzFxNWQ3TFQrZlJpL09KTVhrUmhNN3JuTmZuNVRmNVJwNjlhaEpYek1pbXVHZ2RPNzk4bU5ENDhZdzQ5UXIrdWFTQXh6ZDZUcmplOW5oY1dwRU1YTGU0Z2FrSk9wNCs4MTZxTjd6TDNpV1BVSlkwbmVHNVoyRkM3ZlJleFI4eTVEMHVuQTRicFR2ZXB1RzdwYVNkY3lkMW5pak8rTnVYZk5zU0doQUNHaGdqRHdkbGZtUUxiOTg2aTkwRjY2ajUrbG1hWlprQ3oxZ3NKaFBCd1IwSDAydHJhekdhMjVqazNVbEk3bVJDc3k4aE5pNlpYeS9hemh2Rkp3bmFHeU1QaDh0WGphR2M5OXhhSnNiQXIyOTdoWVh2dllTKzBuWk1iWlFraVZhUGp0anpma1ZJekNodWVyZVFOWldWS01hZ25yNjluZ2RXVmZpMndjaTNEYkI0LzFweWhEQnkxRmFFWXhCTGtrUkJZelNYZnV5ajJya0RseFFFUm5wRmVuVjh1TmhwcHBnUjdHaTJjVVd5NjFDWTlnZElSVkh3ZUR5c2J6YXgzREFlbjhmWXpSWEhCeGp3RDFJU05wNVhtaXJKYUt5aFNiV2dJQkFsdVduMTZTa1hFcWt4OXQzTWlYMldUVnVoUzZDQ3VNTmFRcVhEUmRON1c4VCt1MXovNU5Ob2lXbERYUUxhaWxOLzlrcjVOK3YzSjU3c1NjdSt1WWVrT092Sk5XOVZOZGdublB5cmVOSXBFeW9zSDd5YzlLTlZhUTFZQTlhQU5XQU5XQVBXZ0RWZ0RWZ0Qxb0ExWUExWUE5YUFOV0FOV0FQV2dEVmdEVmdEMW9BMVlBMVlBOWFBTldBTldBUFdnRFZnRFZnRDFvQTE2V01KU0V6N1Budm0rOEFRVzhxVGhYa0ZLN1dsUERWZ0RWZ0RIcHdTOEFyQVRkbXVLWnVzOHBBQ25OQXFUYUdnbjB0WUVIcnNSYlBCb2RKVG91MU1pYmIzdjByM2xWeVUwb1FBZkZjYjlPTW80WXVHTjNGeGF0UFFMZUg4S0FjUGphL0VJS2pvUlpXVUVQK1VGTXZPM0kxSEZ2Q3FBbzlzaVdkRFhkRFFLT0dOOVJZZTNSSlB1dFhON0lUMmhWdFBpN2VSRWVybTBUNkM3VEhnTWVITzQrNnpvUzZJOFI5bTAreHBmN213MVNNeC9xTlJyTzhDYkZldTBXZkE4eE83dHFMczhHQTNZUVlabTFlaTFTTmhOY2lrQkhWdHhwWFRrMW9IRHZBcHNXMWQydS9pMUdZMjFsdVk4TkVveG4wNGluVjFRVjAyWHBON3FCbnJFZUM4U0FkeDV1T3ZNN3EzMWNEVXhTTXBiald5cjgzSTlNVlo3R2s1L292QzhXWXYrVkVEQ0xqR3FlZkNsT2JqN3ZkR1NTUmVwZDNGOHFrQ2I1UWNmMzNTQzFLYXFYYnFCdzV3dVVQUGZhTnJNRWc5UHp1NFFWTDVWVzRONVhiRHdBRmVVUlZDV29pYjIwYlc5VGp3YlNQclNBMTJzNklxZU9BQWYxVHFuNy91c2J3S3hrZjIzTkpDRXlJZFBKWlg0Yi9HZ2JDQkEzekFibUJKaFJXTFR1R2p1U1VrQnAzOFFzbUpRVjQrbkZ1Q1JhZXdwTUpLMlVCU2FZQmZiMHhFVlNFNXlNUDZjd3VaZUJMTnlNUm9PK3ZQTFNRNXlJT2krczg5NEZ6TExRMFdudHZsWHlrNndlSmw1Vm03K2YzWUtpeTZyczlzWnRFcC9INXNGU3ZQMmsyQ3hhOGx6eFZGcytVa0p4enF0YzdETDljbWt4dm1aRVpjR3laSjRkRzhTbTdMcnVQWmdtZytLZ3RqZTZPNVU3Znh2R0hOM0paZFIveGg3Zm5LNm1EdVhwYzhjSHRMWGtYZ0owdlQrV1IrOGFFT2Zyelp5Nk41bFR5YVYwbWxRODkrbTVHS2cyMXFvdGxMU29qN1VHa2VMdC9WQm5IUjB2U0FkbnRBZGcvcjNUcG1mWnJGYzFOTHVTNHpjS0xkQkl1M1E3Z2o1Wlhka2R5NlpqaHVwZWZqUUwzU1BYUXJBdGV2VG1IV1o1bGQ2Z245SU92cmdwajFXU2JYcjA3cEZkaGVEd0I4VXgzQzVFOUdNakhhemdYRG1wbVhZR05Zc0ljWWt4Y1ZxSFBwT2RCbTRLdktFRDQ4RU5ZbmZlSStpWGhzcUF0aVExMFF2L3YrNEVVRjlaQXZQU1JEUEVkS2Y0RDJhWWhuSUlrR1BOUWxvQTYvVUdCYXk5RExBRmlicDZtMEJxd0JhOENhREJJSjhQR1czdkNnZDhvOVYra3MyUmxVVkRkejVTOWZadVg2NHFPN2IzKzltdk9EUGV5Ni9JNUQyOExtenlEcjNYOWhIWDAzYlk3QVplM1Roa1h4em1PWFluMzJSWm8rWDBIaXIyNW0yQXM3K29weG9icnZ1WTRUMDZUYU9tSG43Q3VwZldVQmliR2hMSHZyYm43L2l6T1JUbUk2eG92UEhNKzNqNTZIOVBQN2FOdXdsWkdMbmlmcGdkc0dSaDB1dStJS1Y4UlBUbWZmUFg5aXozVy9RclcxOGNnOTUvTEZhM2NRRjkyOU9lNU1SajMvZnZoUy9wR2xwL1FuTjJNYW5zam9sZThST21zS1pWVk5Bd1A0eGo4c2FQbGcvS21rL2ZzUm1wZXNZdnVNUzJqYnVJMDVVN1BZOHRudm1EdHRaSmRPbXBFU3c1cVhibUgyNHZjNThJZW5pYi96T2taKytGOE1jZEY4c25RNzQ4OStmR0FBZTd5eWV2OFRpN2grYVFWSkg3Mk1hREZUY09hMVZEN3pNakhoUVh6NStoMDhldTk1aU1kSXdibmtyQW1zZXVnczFCdnZvbTNqZHJMZWY1YmtCKzlBRmdUdS9kUDdYSER6OHpRMjIvc051TVArOEtmTGR6QzVzSnkzL3Y0WUNlKzhTOW5ELzZCMTFYclNuM3VNMzkxK0JyVU5OdGk0dWNNVC9tbVl5djZMYnlFNGZ3d2pYdjRMaG9SWVNpc2F1ZnlPRjFtM1pmL0E2anpNbURUQ0VCc1ZjdWo3djk3NWprdlB2cEM1bDU5TDdXdUxLUHZUdjRpNzVRcGljakxwYkt6UVdWaE0yck4vSXZLaU14QWtpZlZiOS9QY215dEpqZzhuT2I1OThZcjNQOS9jLzhEMzNUd3YrTnc1dVIzdWFKMlczNlVUcHYzN2tZRHZrOGFtTUdsc3l0RjFLZTIyL2dlMlB2TnZ3NGFydDNUcFFNVVJtSFBSdkdRVkd4S25kUDNLeGduOUR5eDR2VWVCZEVlNmRXd0hBLy9YWDMwS1Frb29vblJpczJvcnNnOVhZU1AvVzdDaGUwYXJ2OFFZSGNTekhoRTZXL1hqcy9jZ05oSHlwblg4dTB2bWxtaEw5NjEwdjRvaytUOC95SUZpOEhyOTJhZzdOa0JqTFVRZm5IRThLQVJpRWc0N1Z1eWVTcmZlZGJ2bnpKa2p6VjI1citZdlYxSjh3NjhEakZybXUvL1hkYkRjKzdxMjMzK2VoTHBxY2pKU21UZDlBcysrOFQ2UFJuaFl1bW9kUzlMejRaYmZuSGdkL3V1cks5cGVYL3g5QVBDTWlSbmNmTVYwakVZZDN1bzZxdjc5QnNrUDNZa1VGS2c2WXBBWktjaUNyN21WbXVmK2gzUFBQaUl2UG91dDRmRzh0R0FOYnJmdnhFcjhzUmY4RGsyaXhHTy9lWWlSTjkzQk5aZE1ZM2ViaW5EWmZVZXZPYTkyQTNqVittTFBELzBuaTluQVAvNXdLVGRjT2hXQWh2Yy9ZOTh2SDhVOE1nMWJjK2Q1V2Jvd0t3bjMzMExsMzE5ZzkxVjNFMy9hS1R6dzZ6djU2UjhXc3EybzRzU2dWWlZ4SVhwOGlzTDIxaUsyaUJOWmVkNW9WTEg3QWYwT2xUNDdJNTUxSC82YUd5NmRpdUowc2UrdWh5bSs2UUdpcjdtSXdqdnY0dFB2OW5SNndyc2VmZytQckpCNC95MWtmL0lpam9JOXVINTJPMS9mTTR1YnI1aCt6RFZianJYNmhWa25NWE5VT2xoYU9lK3IzNUt0S3dlZjgrU0FCVkhndW90UFljTkh2eUVuSXg3bjdyM3NtSE1sRFI5OVJkcHJmK012WWhLWDNmMGFIbS9ucndtOHN1QTdKbC93Skx2MzFSSXlOWS9jMVFzSW5wQkR5YVczODN0ekkyOC9mUzJoSWVidTNhVWdjUHIyTnI0cDhQZk5wOGVONU96a0NTQWVuYnNsSEdmVjJnRGdKKzQvMy9yU1g2N0NiTkpULy9iSDdKaDFCWkxGaFBYdDV6bmpoWTA4OTcrVnFPcnhjN0cyRlZXUWYrNFR2UG5oZW5RUllXUys5UStHUDNFL2xmLzNLcU9mL1JjYlhyamhCRUlWQWdnd0oza0VmNTkwTGUvdTN3ckNTUzRET0dwRXZFNXhPQ201N1VGS2JudVFtT3N1WWVjdjdtVFNMUyt6ZVdkWnQwN2M1bkJ6emIydmNlT3YzOFRwOWhGM3kwL0pXZklHM3ZwR1dpNjdwYnNhVGFKQjRQVTdydWFhTVpPNFpjWHpMRzFRajM1eFF1MG1zSzYwVE54eDJrOXArbXc1cWEvK2pUOExpVnh4Nyt1MHRybE8wTmFvdkx4Z0RaUE8vek1GZTZvSUdqdUswU3ZlSWV6MG1kMCsxd3V4RHU1K2RTRlhmL29XNjF2MmdITWJkTEJXb25xY2tjbUFYNFhVVy92MVpjdGI3NXZIczBZVEdBTDl6c25PclZ6Ui9DR3RlL2J4a0M0ZFlrcEJVU0hoTGdnZWMxaFh6Y0V0VFczODl6OHJ1eGJUNnYrWWNXRHBpSUxLTk1kNkxtcjVndDl4SlhaVklORjhXSlBvcWVxZ0JJWEI0MW9LRGhjVEtqZUJ5Vy9GSitrTG1jSm1uaXlkeVhCOUljc0xSWEptMUZJaFNDQkFVc00rNGxyWHRxdXp5NDZzSHpsNGdGMk5MbTdlK0I5Q1hQN3NkMk13bUJMZ3BxSmlmRzZWQlFkOGhKNGFBUVNESURDdmNDbHpxejg1ZEh5dE5ZR1ZpWGQzMy9Ib0wxbngzVjVxaG8wLzlOM2RCcTM3SUdNRTZBMENxZ3BPU2ZEWFgxWEZmRVFUMlpJK2tiVmJEZ3dlNE9MU2VvejVGd2RhWFMvWUt5QW5HNGJId0c3UmNLZzVhanVzZCtTUkRCaHl6cVc2cm0zd0FBTXMvTHlCWFJNdUROZ211NkdsSEg1MWtZRTk2RUZXeWNSS2FZZ2VGVkFGZ1YxbjNNY2JDMHBPekpmdVQ5bTR2WlFEaG5uc3pnbGNtTVpqaDMwN2paemZyT1BDMGpiZWpwckp6OVVFRUFRS1oxNVAwZjRZaWtxcWo5L2REckNTNFJNdkJiTDdHM3ByUVNYR2hJbkVuejZidG9vOUJMdGEvT3B0OTVGVDNVcDJpd2RSbENob2RPSzYvQW1XckRXeVpHVmhaNmNycEhuamV3TTM0bkZRbHF3cTRwdDFPbTY5NmlHODVyMTR0eTRqOGNBbUZFR2tLbTB5dFZtenFZbE41b1VuMStGd2RuMjE2UUVMRE9EMitIam1wVy9SU1NMVDg4NW0xa1czby9oVUZuKzltODNMUzFIVi9TY1h0UnlvNHBNVlZxemZ5NHIxZTN2QW0vdVJpUWFzQVd2QUdyQUdyQUZyMG85UmxZQytwNnIyV1JCdmM5L05UYk53QW1nenBtbkFRMVZPdUxkVS9OSXQ3SEUwdHA5STlUQnQ2dTFZOHVjUFRlQUQ5Z1pxUTg4OTlOM3BkRENscVZSVGFRMVlBeDRFd0J2Zi95K09wTE1CVUJRRlZWVUpDYkh5VFoySG1rM2ZEVjZqcGJyZGVPc0NKeU94bCs5bll4Y1U4RndBQUNBQVNVUkJWTDJDeFNJaFNTS1NKT0gxZWhFRWdRcWJqdGJ0VzdrNEp2QzlmVUdTME1mSEQzemd0bFh2ODg3dW5haENlNGF0MFdnbUxDd1dSVkZSVlJWWmxoRUVBVm1XQ1FrSlFhOFhlZldUMXdQT0U2ZHM1THpiRncxOFlFRlFrY1VFek9hUWdPMXV0d2RGVVFnTEMwT1daWXhHSTQyTmpVaVNoTTNtd0dnSm5IZkQxbFkrdU50aHZWNlBMTXNrSlNYaDgvbG9hbXBDcDlPaEtNcUFOMW9uQk96MWV0SHI5Unc0Y0FDZFRvZkpaTUxyOWFJb3luSHlzQWE2U3B2RGlmVjlncy9XUGhtQk1UZ2FoMmtjSG84WGo4ZHpVUFVGSkVsQ0VBU3NJVVo4bFY4RzFtSDNnY0VCSERUMWJDNmNlblpnL1cxbzRKWDMzaVVvT09TZ0VUUGljcm5RNi9XMHRMUmdGV3hjOG90WGhrNDdiSXlNNUxMVFpwR2tLMFlRQkR3ZUQ2SW80bkk1bVJYYXlQa1hYei8wSEkvd2tkbW9kVHNEdG5rOEhvWkZ4U0ZhTEVNUFdQT2xmd3dCQUFFMW9OMVZGSmtqRWdxR0Z2RFl6TG1rMXF4cGZ3REJZTXk0YStnQ1I1eHhLeEZhSGRhQU5XQU5XQVBXZ0RWZ0RWZ0Qxb0ExWUExWUE5YUFOV0JOQnFJRWpJczBaVTErWHgxaUUza0tzREI4MXpvdE1VMEQxb0ExWUExWUE5YUFOZUMrbDRDeHBVelhaTG8wM2NtZ2N5YlhhU3F0QVd2QUdyQUdyQUZyd0Jwd1AzdGF0WXYrT1NRaGhUeE5wVFZnRFZnRDFvQTFZQTFZQSs1dlQwdllmdTRReGZ4RVUya05XQVBXZ0RWZ0RWZ0Qxb0ExNlhVSlNFemJIcFkvSkJQVGNwczNhb2xwR3JBR3JBRnJ3QnF3QnF3Qjk3MmMwS1FIOTV5bDQrc1IvZnVzNWhZclBQV1pUeXRoRGJnblZQcGt4YVF6Y0U3bU5HWU1INHRYOGJGaS8yWjIxSlJRMWxxTDNNdXpydlU1OEpTa0hGNjU4SGVraE1YejBMSVgrUHVhZDFCVVpXaVc4Qlc1ODNqem9vZnd5RDZtdm5nTG02dDJEOTA2bkdpTjVybHo3a01VUkI1YTlrSy93UFlwOEYvbTNVYW9LWmlpK2xMK3Z1YWRvVzJsOVpLTzgwZjZWN1A4b0hCbG45YlpmZ0ZPQ0lraXlHQUNZSGRELzg2QXFEa2V2U0dWdG5yc0h2K0NyNW1SdzRZK3NGZjI4VkdSZndIVkMwZk5SQlRFb2EvUzkzLzFMQzJ1TmtaR0RlZmVxWmNQZmVDSzFqcHVYZnczRkZYaGtkazNNVDQrYytnYnJiZTNmOFhVRjI5aGYzTVZhMjc4RC9kUHY3TFAxYnZQSzlPNjhnTEdQM2N0UDF2NE1Ja2gwVHc1NzFiT3lackc4TEE0SkxIM2I2ZGZla3N1bjRlRkJTdFlXTEJDYTRjMTRJR2cwaWNTUzlKS1dBUFdnRFZnRFZnRDFvQTFZQzB4N1VjbDAzVmlPZjZKUEhybEk0QnFFVkNEQlZUZHdmK0ZYcndlb0I1azZydnU0U2lkU0x6b3YvcFBqQkxSZ3NBS3I0SVB5SkFFSWtXQnRWNkZaUjRaandybFN1OU9uTklyd0JJd1ZpZHlzMWxIa2F4Z1Z5RlJGSENwc0V0UnFWTlVUQUlVeXlBREUzVWljYUpBcGF4aUZtQ2JUMkdWVnhrY3dGWkI0T2RtaVFrNmtWZGNNcW1TUUtnQVpZcUtRMVZ4cVZDcnFGZ0VBUW1WL2JKS2lpUVFMUW9rU3dKRlBvVlREUkpuR2lVZWJQTWlEMVJnUFRCQ0ovSndrSTQxWG9WRmJwa01TYUJSVmRrbHF6UXA0RkpWUElBUDBLRmlPRmpSeWhYL1E0a1hCYklrZ1ZaRnBWaFZlUy9Vd0M5dFhzcDZVTTE3QkZnRTVoa2tyak5Mdk95VXlkVUpTQUo4NTFXb1UxWGNLdGdQbHE0S0tJY2RweGZBQURoRWFGWlVTbVYvYWM4MGlDeDB5OXdmcE9NMWw4ekdIbEx4SGdHZW9SZkoxNHRzOENxa1N3TEx2QXJ5UWRXdFB3Z00vbHpsZUZFZ1RoVHdBbFdLU3IyaTRrTEZKb05CZ0VnQlFnVDR6QzJUSmdtMHFUQkxMNktxOEwxUDZYL2dMRWxndUNRUUt3b3Njc3RZQlFHbkNxVUhqWlVLcEVzQ2QxcDBuR21RaUJjRDExVGJMYXQ4N0paNTN1bWpSbEdwVVZVY0tzUkxBbW5BQnEvQ1BJTkVuUTRxRlpXcWsxVHZrL0swVEFMazZrVHk5Q0pydkRJNkJIYjRGTXBrbFRiVi96VC9HS1JuVTRTSjYwMjZvMkFCTWlXQit5dzZka1NZdU5Hc1F3R2FWWlVHUmFYQTU0Yy9JQ3ZFaWY1bXJGOWR5K0dpd0hpOVNKTUMxWXBLbTZwU280Qk5WZEVEYjRVYXVOZWk2OUpGVEFJOEhhem4wU0E5QUkyS1NxbWlZbE5WTnZsVW9nNWVLMWpvUitBVVNjUU0xQ2dxQWdJVkIyOVFCUjRPMW5PR29mdnJMOTFsMFhHbFNjSUh0Q2dxcmFyZnlOVW9LaW1pd0RCSjdKODZiQUt1TVVuWVZEQUpLZzJxU29QaXI3T2hvb0FKZ1ZkY0o5YUtaa2dpSWpJKy9Kb2pBRVUrOE9wZ2pFNmdvS2VDcGlmcVN3dWdtZ1JVc1JkOFlSRy8zOTBydnZSZFptblB6NUVTaDFLSHlBaDdWdHVVam9IUE1vZ042Z0JmaXJPN0lxaHFneGJ4MElBMVlBMVlBOWFBTldBTldBUFdnSHRCQW56cDVXbGhrVjdkMFBLbDlUNDFrb2Fham9GZm14aVhzVEU1ZUVnQjU1ZTFaYkNoUnF2REdyQUdyQUZyd0Jxd0Jxd0JhOEFhc0Fhc1NmY2tzQy80ODlQZnB3ZG1UTnYvcDllcmgwZkd4SjNNT1ZSWnJ0NFNuUjEzMG9TcXNIQkM4eTV0eGpRTldBUFdnRFZnRFZnRDFvQTFZQTFZQXg2MHdHci9ySUxiNTVNZXROVHVaOGNYLzZOMDNSTHFYQlptWFhJRFk4KzRlT2dCbCt4ZGo5bmVTdEVYNzZJYUZacThDdXUzRlZDMDcwRk8yN2FSUysvLzg5QlNhYjFrUUhTdUpTMHZDWjNlZ3FBUEl5TFlDRjQzMno5N2w4SnZ2eG82d083NmRRUUhSMURRRmtsOWF6RDFOYlY4dDZjR2E0aUpoSmhncE5CZ1BubnhyME1IV0FvYlM5bUJUYVNFUmROVTMwUnRZeFdKSVNyRHg1eENjRlFDUHNsQ1RhTjk4QVB2THY2Tzhvb0MxUDI3RUNRZGtucy9NZEZlUEZJMHNqR1lUVnNLbVhQZDd4aDd4dVZFcE9mUTBGREc1cTJmRDE1ZzFkZUdRZkt5cXFTT2pVMUdxcHVEU0U3TlprSnVMdWFRR094ZWhmODk5UkFtczRsNWw5MUFZLzF1d2tLc2c5ZEtaMlNleXNwVmJ4Q1pQWTlGNjlheHNVd2wwaDJCR0JYTzlIUDFUR3lKeGU0Y1NaZ3BsREdqaC9QMXlyYzRZOTZ0Z3hkWUZBM285RVpTZ2wwOE1tY0tDM1kxVWxwZHlvWUQ1V3owbVFrSkhvZkQ3U2JQYUNYWDFZWmViMEtuTXcvdWRuamFwUFA1ZXRXYlJJU2xFQnd6SG4xakNmK0syc0pIK3hUTVl5L2hqTkVqY2RRVlUxQzhudm1uWGozNHJiU2dDMkhLeEVzeDZoeU1yUCtjR1dFSzI0eDVwS2VQSWQzZ3BIcmZScXdXSGRsWnN4SDB2WjlCMUNlZVZraHdKRG1qZjBKMXpSNHNUUlZFNm1LdzFEVmpENUtJakVwbldOSm9qaHdUR1BTdXBTQUl4TWRsRWgrWDZlODQ5TlBMSlAzVFcrckhOMmUwL3JBR3JBRnJ3QnF3QnF3QmE4QWFzQWFzQVd2U3RYN0w0Vi95T0xkOEUvSDlNdW5CNzFqRkJSVDFCdURDUE5RZmIySmFRQUJBTXBza25QMTBJekhSR0syOU1JMnppb21TUFIwRFI0L1BEV1ZOZWI4QUp6NzJHS052bk43ajUyMzc1cHR4ekpyVk1YQlhaRlJxTXpkZFdNanNpUlVrUkR1b2J6YXhaWGNrbjY0YXpudGZwZUgxaVlOSHBkMU5MVjZndzhDd0pLbzhjY2M2N3I1eU81S29zbXB6SEw5L2RoTGZmQitQemFGSEVsVWlRdDNVTjVzT2pYWEhSem1vcXJjZ0NNY2YvM1p1MjBiTHB5MDlEdWpadTYrcFUrQ213dDAyaUQ5cXJFTVE0TTAvTGVPeStTV29LdHp6MUNrODgxWnV3RDZ5SWxEWFpPTFVDVlZzM2hXSkpLbWNPN09VL3k0YXhmK3pkNTdoVVZSZEFINW50bVd6Nlkwa2hEUkM3ejJBU0JGUWloVVE3QW9vQ0IrQ2lBb29JbFVGVWFRSWdnVlJFQlFMU0JGQlFIb25RRUluQ2VtOVo3Tjl2aDlSTUpCQUFrbEl3cHpuMlNmWm5kbVplZmVjZSs0NVorN2MyNmRUREp2MzNYeU5scFNGaTdpMHNFSzg5UGt5Qng3L2V6S2N3YjB2QS9EdTUrMXZnQVh3ZHRjakNCQ1Y0TWpTZC9iUXNuNDZMUnVrODFpM2FCb0ZaUUhnNVZiQTNaNzVwb2lHZGJWOTdJZ3Z1b085bllXcEk0NEJjUHFTR3g5OTI2TFlBOWtrZ2ErbjdtTEZoZ2EwckovT2g2OGR3dFhSeUpEZWwzank3VjdNbjdDZnJmdnJzR1YvbldLLzc5aXpKMTVOSHlwM1FGdE9yZzlmZjFrOHNHT0FuejN4UmIxMDc5QTQzSnlNQUh5em9RRTJXL0VxU3NuUU11dXIxdXo3K2plY2RHWTA2bXR6YVcyWS93Zmo1M1VzRVJiQWJmQ1QxS2tZTHgxUUluQngwcXBoMnRYLzk1K3NWZXcrTGV1bjg5S2o1K2tkR29jZ1VBVDJYNGMzZW5BRWZUckg4dlg2Qm16ZTUzL1h2SGtSNE56b0dEMklSYnkwaTZQcDZ2L0pHZmJGSGlUc2dqdmpQdTdFQy8wdnNIVHk3aHUycTVRMmpwMzE1TlhaOTFGZ0xQNDN6dmpoQjJKUC9sanVnSmJjM09nU2dmTVRrZzNnVStRTDZWbDJWLyt2NWFiblNxSkRpUm9POU1rbFBsVkhrRzl1a2UxbWk0aUxvNUd2cC83Tm1xMTFpOVZ3N282ZHBPeW9FQytkVkNZdmZlQ1UxOVgvdTdkTktGSERZK2QyWXU3S0ZyZzVHY25JMFJUWm5wWmx4NWxJVjU2YS9BRHIvdzY4cThGSkVRMjdOcXJ2eU5taTJ0bDUxSmNyaVE0RStPUXhaa2c0eTM1dFJPWjFRQUQxL2JQcDF5V0dGa01Hc3Z2TERld0w4NmFPZHg3dXprYWVmYmNIYlJxbE1xQkhGRC92Q0NyMlFyekcvSStRQndNcUl2Qm93R3RqaWdmV3VEcXJvQ2l3eFNyeTlvSlExbnl3SFY5UFBaOU4yTS96NzNXLzRjQnhLVG9tTFd4UGsrQk1WdjhSd3BaOS9qemVQWXAxMjRQcDBpcVJqNzV0aVZaaktUSHEwalp2am5PL0N2SFNyaVZxdUNUNWNWc3dMUnUwWk9LTFlUemI5eUlGUmdVVFB1MUlybDUxZFIrOVFYbTEzMzV2U1Z2czdTd0UrT1N5LzFRdC91VXJ5V0hkdFFKQWUrMmd4Q01GcmlVK0RUYjhzWE44OU5vaFhKMk1YRWwwNElOdld2SFg0ZG9rWjJqeDlkQ1RxMWVSbUhiTms3czZHWXMxLytKa3F0YzVCamdsVmtSNnVLblo1WXY5Yjd2aTRlSm9ZbkN2eTNSdkYwK2RXdmxrNWFtNUdPUE16MzhGcytmRTdUODVWMWtWanpMYldGYXVtaTkrYWNRWHZ6U3EvaFVQNzA3dDNPNVdBU0JnK1RMYVZFeG9HZnJmQXNDOVhkTnkxZGhNd2Y0dTJydHhJZHE4REF6bno1ZjdjYzNKeVlZU3ZmUXhoSFZTT1R3L1hKVkVMdFArOTQxRGp3ZGNCTFdxUmdGS0pyTUxPN1lYdnpGMzE2NDRxWVpKN3E1ZGNXV3VhZFZZazg3WnVpMUpIeFpXb3liVXRpU25KcFVJblBUQjdHZ0oydFF3THgwdG0vVFYwSExTNUVCbExVOXFtRWtIOHNFczJVdmZteWFkTUgzbU9VSDlVWTN5MHBMSmZLNUU0THdkZjJWSk5VeWpBbVRKSnYydkJLMWQwMUxib2tXTkFpdzRlYklsZ3djWEQ2eXFWY3ZPcmtHRG10VXRKU1haM2RNbWZjOUprWXJIMHZ1Sm1OK1R4dWU4YXhEaEswVVppNWgwd3lTY2o4eUNJVWRxcm9admFNTU9SdmhoT1N4ZURXckxQUUQ4cjR6YUJmcytnc0QwZXdRWW9PMFZPRDRESGo1NWp3QUR1T3BoL2VmdzBjK2d0TjBEd0FDQ0JHOXRoUjN6d0RmckhnRCtWN3BjaEJNejRJRno5d2d3Z0ZjdS9Qa3BUTmxVcVBrYUR3d2dTakI5UFd4WkFCNTU5d0R3di9KZ1JLR0pkNHk4UjRBQi9ETGg3N253K3ZacUdFc25Od3U2NkhVNkt1UjJENWJjcVduYXdjL0duVGU1T2xXWkdPM0prQ2U3bFZnQVVKczFwZGU0R2pBVi9halcvbkNQM24wbU9oMTk4ODNveklZTkM2cTh1bmRCbkZRNGpPcldyd0ZJa3VlTm41dEJLZ0RwNVFwWXVQVTJYM2ZXaG0zL0hxVUg4Qjlqc1FBN0FRV0ZTL1V1QTc0RjdLdXowOW9NUEFxOHJnR3BOZEFkOG9IcHdFZEEyK3Vjd3ZQQUlhQmhkUVErQXp6MWp3YTFkV0RySWRpWUQ2RUswQUJ2QUk3RmZLOHBjQVFZVWtXQWJ6MU9xdzRZQjhITFA0SmpGc3g1Q2p3N3diTmZBMWI0YlNJRUcvK1ppMFFFTW9DVmdQRS9PVGJ3QTlBRmVQMUdYMWZGZ0dOQnN3UDZkSU1Pb1pEZi9FT21MRHFFczU4ZGpnNDY5QU9mNVlwaERZR0twWERnbjhackxDSEhCdG9EZzdqdUhtYVZNK2t3ZUhjOXVNZjdNSHZCVWM2ZXZZUktwZUtCbnIzNC9JczFaQ21lSkgrZVdLaSt6Qm9TYVJsejRidGZuVWhQVDJmdDJyWDA2dFVMaThYQ3BFbVRtTC80V3pJdnRTcDA0VGVSeFVEbnU2amRVZ01uQUYwQnZVckowQ0VkVUp1TzBhaXVIYzJDOUpDeWhKZTYxZUtqMU5RU2VmUCtjWGovdTh2dHQzUnRHSWdDZ29FRkhoR0l6U0lRMHFIV1I2QnNET29oVUNjRTdGTGdNQkI2M1hmRGdZRmM5M2hZZFlpMGJDQkpzNUdrYjVDazJ2L1oxaFZKMm80azliN3hPOStDWkYvRklxM1NoNVpxSkdrWWtxUXNacHNYa3ZUa3RmY0ZJQTJ2b3FGbGtXeXBvR1hMeTNaaFljRWw1bFhTTGZJdUNXeCtmc2JjNWN1dm1OdTJyUkxKZzZlblo4c1MyN0FkQ1NYNzJWdVZjeVNnVTYwMGNVSHJjODdPWDF2SitycnE1OE5TSytJNFFlM2JjbjFqL25IRlZRMndmVkhHTzMvTXBCWXdHMmgyTDVSNE9nTGZWeC9ZMjlld0NMd0N2RVJsVFVkNUY0SGRnSm4vSkwvVlVNb0czQXFZQlhoUWJhVjB3QUx3M0QvNVhUVWZGWEpyWUVmZy9YK3k5eG9nTndkdUJIekk5YzlRMTFEZ1FjQTRvR1k5ODFFTXNEMHdHZWhOalpTaUxpaVFiTDZ0dWJEM3BCU0prem9NL2M0bUNMZU9uU1JLZnllOHZCZmRjWFcwWS94VDdlamRJUkJyZGpaWEprd2c3ZnZ2UVJRUlJMSElYMFNSZG1scEpTY1BFcElnVmVHNytuMDZCdlA2a0xZNE8yakkrUFZYb2thUHhweFl0cWZLbGRYQkRIMDhISmo0WEFkQ20vcGlUazdtd291anlmajU1MHBNSG9xTFQrejA1Qm0xU0ZMNVpST2lJUEJrejRhTWZMd2xXbzJTMUcrKzRjb2JiMkRKdlAzaTl4MEhpcDBhRkk1YUc5dDNOVjBiSFVlcHNOSTY2T3dkdzliMWMrSExkeDdpOVNGdEVSTmlPZHU3TjVlSERyMGoySExSOENmUGZjSlBoM3BpTUdsb0ZYU09JWjIza3EzWGNUenE5dVlJVUNzVnZOaS9LUy8wYllwU2dNUlBQeVYyeWhScytlV3pXay9SYVMyR3JpeVZ5eEpGRzgvZnZ4RkpFa2pNOU1Kc1VkQ3gvaWx5RGZiOGNiSVR2Wm9kSkN2ZmlTdHAzdXc3MzdMVUY5TWl4SXZKTDRZUzZPTk1RVVFFbDRjTkkrL1FvVHV0VWR4NWljZG1FN0ZYRzlHYk5BUjZ4ak9zeDI5WHR3ME0zYzdJNWUvdzNvRGx6UGhsZUttT1oyK25ZdlRBVmd6bzFnRE1KdUxlZjUvNER6NUFNcFgvZllyYkFsWXBMQlNZTk95TWFNdWFzWk9LYkxOVG1YaXgyd1orUGRJTnMvWFdoNyt2aFI5dlA5Y0JMMWQ3OGc0ZTVQTHc0UlJFUkZSU2FGbEtlYno5VGw3czlqdEswWVpZekhBOFg5ZFVzdlNPZlBiQ1hQemRrNG9QSUp6c21EbWlDL05lNjQ2SFdpSjYzRGpDTzNjdVYxaEJyUzRmRGY5NG9CY0ptWjRJU09RVTZIRFNGblVvcDJQcTRlMlN6cUQ1YzhnMzNEaHBSTjlPaFFHRWswNUQ5clp0Ukw3eUNzYm82SExWcEs1MWErcXVXQUhObTkrNWhnVkJZbkRIcmJ6VWZRUFQxbzJnd0hSdHZwMkxpZjc4ZExBbnozWFpSTXVBOHpjRUVBdkdQOERVWVoyeE4rWnorY1VYT2R1N2Q3bkNDaW9WZGFaUHArbWhRMmlhTmlvZkRTdEVHNHUyRGthak12Tm8yMTI4K1BrMFFyeGp5U25RWVRTckdSajZGMjk4TjU2OEF2dXJBY1RnWGcwWjhWaGhBSkgrNDQ5RXYvWWE1dVRrOHRWcXk1YlVYYkVDK3hZdHVKeDVtaG43WGl3ZllJdFZ3Zm1FUUJ6dDlIU3NkNHFMaWY0ODJtNFhGeElDRUFRSmkwM0JxU3YxcmdZUTc3ellrU1pCSHBnU0VqZy9haFNaNjllWGJ3YWtVbEY3OG1ScXYvTU9WZ1Y4ZldvNjM1eWFpY1ZtTHQvQXcyQldYMjJucnJwY2ZqdmFqY1JNRDl3Y3NsRXJGUXg5dUJuUDlXbUNVaFJJV2I2Y0syKytpVFc3ZktkanRXL2VuTG9yVnFCcjFZcUxHV0hNMlA4U0Z6UENLaWJTTWx1VlY3dWVwZHNIWEkyai9YM3JNZm1GamdSNE8yRzRmSmtMTDc5TXpzNmQ1YXRWcFJMZmlSUHhlKzg5ckFwWUh2WWVLOE0vTEZhckZaSThTSktBVHF0aTlJRFdQTkd0UHRpc0pNeWRTOXpVcWRnS3l2Zk9xWDNUcG9WYWJkT0c4eG5IbWJudkpTNWxucXJjYktsTEN6L2UraWVBMEo4OHllVmh3OGcvZHF4OHRhcFE0UHYyMi9oTm5ZcEZDVXRQdk1QMzRYT3dTcVVmdkh2SHdLNU9kcnp4VkR0NnRRL0VaalFTKzg0N0pNeVpnMlFwM3hIRTJzYU5xYnRpQlE3dDJuRTI3UWd6OTc5RVpGYlpnNVE3QXU3ZnVTNWpCN2ZCU2FjaGQrOWVJbDkrbVlKejU4cGRxejRUSnVBM2JScFdKWHgrZkNLcklqN0dKbGtyTDViMjlYQmcwZ3VodEcvc2d6VTNsNmpSNDBsZXNxVGNDMWphaGcwTHRkcWhBK0dwQjVtMWZ5alIyWGVXYTVjSldCUUZodlJzeElqSFcyQ25WcEsxZVRPUkkwZGlpbzB0NXdoZnhHZjhlT3JNbUlGRkJRdVBUbUROMlUreFNYZitwRmlwZ1VQOFhIbm54WTQwRG5MSGtwYkdwWEhqU0Z1MXF0eXpHYnY2OWFtN1lnV09IVHR5T25VL00vY05KU2FuL0VaNTNSSllyVlF3N0pIbVBOZW5DUXBSSUczMWFxTEhqc1dTbGxiK1doMDNqam96WjJKV3cvd2pyL1BUdVFYbG90VlNBN2VzNzNVMWdEREZ4WEZ4NUVpeU5tMHFmNjNXcTBmZGI3N0JzWE5ud2xMMk1HdmZVT0p5TDFWSVBsd3NzRTZyNG44RFcvTjQxL29JU0NSLy9qa3hFeWRpemMwdDM3TUxBdDZ2dlliL0J4OWdVa2w4Y3ZnMTFwMWJWS1pDL3gwRGQybnB4OXZQZHNEVDFaNkM4K2VKZlBsbGN2ZnNLWCt0MXExTDhOZGY0M1QvL1J4UDJzWHNBOE9JejYzNEo3NktBRTk0cHQyaFFUMGFkcEFzRnVKbnp5WisrblJzUm1QNWEzWDBhUHcvK2dpajJzYkhoMGJ6eS9rbEZhclZFb0VIOVdnWWwzLzhlSWZJWWNQSUR3c3I5NU5wZ29LbysvWFhPSFhyeHRHa0hjemVQNHpFdkdncVU0b0FYMzdoaFdacHExWWhXYTNscnRWYXI3NWFxRldOeEVjSFI3TCt3ckpLMDJxUlMvbnZtd09VL3hWb0FnSUt0ZHFqQjRjVHR6RjcvM0NTODJNcURmRGdDK1U5OVBBbVVtdkVDUHpuenNWZ0p6RjcvM0Irdi9RVmQxc3FCRmpqNzAvd2wxL2kzS3NYQitLMzhPSFdWMGpSeDFFVnBOeUJ2WVlQSjJEZVBBcnNiTXpjOXhLYkxxK2dLa201QWF2OS9Bais4a3RjSG55UWZYRWIrZkRQRWFUcEU2aHFVaTdBWGtPSEV2REpKK2kxTnFidmZaNHRrZDlSVmVXT2dOVzFheE84ZkRrdWZmcXdPM1k5Yy80Y1NYcEJFbFZaYmh2WTg0VVhDSmcvbjN5dGxmZjJQTTIycUIrb0RsSm1ZSldQRDhITGx1SGF2eis3WW41aDdwK2p5REFrVTExRWVYMUVkUDMvd3IrZkNRTHVRNFlRdUdBQmVudUo5L2MreTEvUlB5SkpFZ3BCZVpNZ3EyeGpQb1N5akRndjFiR04zTk5TZE1oRDE3bjZ3L3BnYlUwQ2JHOGZXWEQ0N3pldlBwa3ZMOGNyQTh2QU1uQzFrdkpQRDQwcFlOV2pGblBSS3ZQSU5ibGhFK3hCNVF4S3B4b0NiRFBpcDlsTlE0OGpQTmdwaVJDL0ROUmlBYnYyUTc5ZUlnbXBPZzZHZTNIa2ZDQVJ5WjNKVWJTb3ZzQkJUb2Q0cU1GUHZQNThGQUYxcmdVL0tXbHc5aUswYTJrak9UV1hnWDF6eWMyN3pKbEx1NW03c2lVN3JyeEVucVZXOVFFV01ORS9aQWxqbnRoRHQ4NDNsc0lrQ2M1ZWdOQ0hZT1ZpOFBNRlJ3Zm8wTkxNVjhGSCtHSDlXWmJ1ZUk0ekdUMnJ2dE5TQ2dhR05KckN3amQzRnd1YmtRWFBqSVN2VnNHZ1I2SEpkWlB4T0R2QnlPZnlXUHpxY3U3ei9iYnFBejlTZHpaZno3cUVid21UOWk1ZEFYc1BRYSt1OE5iL1NqNU81L1lXNW96Y1NBdjMzNm91Y0svZ0ZVeDdOUUtGb3VSOVdqV0R2emZBZ3owS243VzRtYlJ0WWVQMVIzN0MxK0ZzNWJmaHg1MlA1TDFxTzFWaThwQWxaRkM3eDFZYTNHSVN1WWQ2d0tkTDRlZU5FTm9HMnJlKytmNkRIelp3K2VnbkJGL3NWKzZBU2M3R3ZNTWxBVGUxaXpWMVVoWS9HRVVDdnZlOXdHTVAzM3l3U2xZT0hEa0JFMmY4WS83UFF1eEpVTjNra1Q2RkFwNGFtc0c1NlgvVDFWeStubnUvbmRKMFd5WjlXcDlQazc2M25zUnkxVHFJK1U4Sk9pY1BUT1piSHo4a0dCTDhNaW13MnFwR0c0NTF6YUplbzF2ZmMvS3ZEV3QvZzRFUFF5MVBXRElYZEtXY0p5NmtTd0ZSQnVQZEI3WktrT2VWWDZKWC9xODhjRCtZVExEN0lEemVEMTRZWFBxTHFkdkVRckpUYnVVNXJaSkViN1VpNmtwM1I5RmVDODhNaFBoRUNBdUgrVjlBbXhiUUpmVFczN1hUUUk3S0JOYTdyT0Y4cXcyZGUrbXY0c0VlY0NHeU1OS3lXcUYxODlKOVQyY1ArU3BUMVdqRFpaSExVYkJ1QTBURkZHcTRLaTIwVnlwZ25VSWtQMTFScGdPLy94WjA3UVN6MzRYSUs2WDdUcjRlZEdiMTNRZTJWeWdndi9UQStYcUlTd0JmYndqeUIwMHBHUW9NNEdUVzNIMWdoUUQyS1RyaVMvSGtha29hREgydHNEOTIwTUY5SFNEUXY1Uk5JVnhKclJ5SHF0R0cvVE5kdUhUdTFscmVkd2g4dktGLzc4SnNhZE8yMGwvTXBYMWFndXcwVlFPNG1iMk9pTTA2YkxjSWhNNWRndm16NEtjTllMUEJrbTlLZC93TGw4RXYzZzJ0b21MTGJFWDY0VEJYUlVhNldpaHhQaTNCSE1UNlRlRTgvbkRKWFZTamV0Qzg4YlgzcFJrbmJySEFqNnNkQ1Bhc3plL2xEQmlyRXpOS0JKN1NRbk1CNldhVFJXbnBsVnliUmhkamFGaXYrRDM2OWlyc2h2cjFLalRub2MvYytxTFcvcUhneTdvTlNkQld3RjBlZ1F0MzFBOXZjNi9IdFBXdUpXcE9yUUtqQ2NhK0FzT2ZMZXlhYmlhSHd3UStpdzBtUWV0Y2RTc2U2NE5hTU93VEorS0tHY0x4MjJZSWJnTzlCOEdYMzROL1MzaCtkT0dQY0wzc09TSXljYjgvWWQ3K1ZKYmNGckJGVkxBbXFBM2oxbnV6YzU5UUpEVjhhZ1NrcGhjdDVxMzVGWjRjZGcwNkt3YytYNlBrZnljYnNOY25oTXFVMjY1YVNrcVJEZDVOT0gzQmk5NWhVZmlhYzNsL2JzbVBQV3o1Q3g1N0hpWlBVUERaUGpkMjFLcFBucnRkcFllV2QxeVhqbkx4NUF0N043eFBYaUdvWFRKQ2xwRzBKQ3Y2QWxBcEMydGFEbzRDcmo1S290VTZIdnZMajl6NmxWK1BMamZnUWsrbElLbGRNTFFMaGt3REZGaFFtOHlvUlNzNXFNaFRLVWx5VW9QdTdtY1I1WDl2eWRVT1hBdG5HVFpSOVVTK1hTb0R5OEF5c0N4VldZb01URHMzcmJ2ZTd1UytHalV3emRDaWMwSERxVHZsZ1dreXNBd3NBOHZBTXJBTUxBUEx3REt3REZ5ZXljT1IvY3RUR3VQbVdaTUF6NUNSMnE3VHkxNy92aTlTeERQV2IyR3lkMjlYWVNlM1pxV1F2M2N0NWl1bkFWQUZORU4zMzJBVUxsNFZkazVqK3BFaXRjUkttMjQ1Zjk5UFpDeDdEVnRla1p0NVpQODBHN2RYRnFEclBLaFNya05aV2JCcG56eGI3RFpiWHNiVmJaVUJYZUZPeTVxVlFzYXkxMjY1WDhheTE3Qm1wVlIvNFB5OWEyOHc0NUkwcmQvM1kvVUgvdGRCbFVaTTBhZXFQL0E5RjNpb0FrcS8zSlk2c0huMUI5YmROeGpSd2UzV0YrTGdodjE5ZzZzL3NNTEZDN2RYRnR4eVA3ZFhGcUJ3OXF3WmJWalhlUkFlNDc4dlZ0T2lneHNlNDcrdldZSEh2OUIyVGJxaTMvZmpWVytzRG15Ty9YMkRLMFd6eFFLZnlEcVRrV2JNcWwyaFoyelZvUEIxdGFNT0sxeDV2WUlrdGlDaDVJRnBrOFBuWHFCYXJXSllLcmxRNlcxWUxnREl3REt3REN3RHk4QXlzQXdzQTh2QXNsUi9LWEp2eVdjNjY0QUJ0M3V3VGdIZGQ2OTdmc2Y5NVhtQkExZjIyTDMveXM0N09lYlBpZTh4VUc3RE1yQU1MQVBMd0tVVmk4VkNTa2J5dlFOc01wazRIWC9pM2dIZWRtRVRlNkwvUXJvTHkxbFhPckRCWUNBdE80VkxhV2Z2RGVBZkQzL0h3VXU3eWM3UDRlc2RTekNZRERVWDJHS3hJT3FWcUNRTmlkbXhuSW9PSXprenNXWUNXNndXUHYvclkzNDYveTNINGc1Z3RwcklzYVd4NS9KZmxRcGNhVGZUanNjZUlpNGpHb1drUXFWVTRhaXVoVUhRRTUwWmlTUkpaWjU0dThwcitGeE1CT0VaWVdTWjAzSFhlUkJqdWtSMlZqNzZuRHdzTmt2Tk1tbWoyY0RGOUhPazU2WGg1dWlLVFlBUXA4YTRhZDM0NDhxdmZMaDVDaGFMcGVZQVg0dy96NTdZN1hqcWZOQ2dKY0VjZCtTOU1RQUFJQUJKUkVGVVJYVHVKVkRiYUY2ckRSY3pJbmgrNVNOWWJkYWEwWVozWDk1T1E3ZW1aR1NsNDYzeHcyRFFjOFo0aXVQeEI4bFdwdU9zY09ldCs2ZFRHYXNSVmJpR0M0eDYzSFZlUkNTSGNTYm5CT0hwWVdqdDdaR3dZUzg2SUpxVUdDMEdOcHo2aVYzbnRsVi9EZSs1OUJkdmJSNkdXV0ZHWlZQaDVPcEF0aUVMbTAzQ1lESmdVMXN3U0JZT3BleENlMEJMajhZUFZxakhybkFOOTJyY253ZnFQSXdLRGI3YVFQSU0rUmlrQXV5VVd1enN0Q0NDdDRNZkErcy96K0RXTC9IM3VlM1YyNlEzbmZnTkR5Y3Y3dlB0U1k5R2ZXbnMwd3lUMVlCVk1PT3FkaWZZdmdIcGVjbWtHOUlJaXo5S3U2Q08xZHVrYXp2VndjWGVFenVsbGkrUGZRb0tVRXNhN0ZVTytMc0ZjeUp6UDU0Nlg3enQ2dUJoNTBGS1ZqSkIzZzdWVThONXhseDJudCtDeFdvbVBUK1ZwdTd0NkIzd0NNNzJiaUJJWEk2L1FKQXVCSk9wZ0w5aU5ySS82bThXN1poVGZVMDZKU3VaUEhNQmVjWk1MbWFlSVR6ckNNZmlEMkl5V1RCWmpOVHk5U0xCRUVlR0tZMVczaDF3VnJ1aVVXcEp5SXlyZnNBcDJVbkVaVjNCeDlFSHE5Vkd0aWtiSjQwYjZaWVU5T1pjeklLWmcvRzdpZEZmeGtGMHdXUXg0dTdpVFMwWEw4SmlqbFMvTnB5Umw4NzJzNXRaR2Y0NTlncDdzb3dab0lBZ2RRTlVhaFVKQlZjSTlHaEFlTTVSQ3F5NTdJelpqTjZVUzdCN0E3eWQvTWpVcCtOcTcxNDlnR1BTb3huMFhVOUVRUUtyUkpZMUUxOUZJQWxFazJTTnBhVXVsQmo5WlRMeUNvZjhCempYbzZGTFUveGQ2eUhackp5TmkrQ2hGbzlVSHczN3V3Znk5K2h3dHAzWlNGanNFUnpzSFRrVXN3ZGJscFVrVXl3SFVuYUFBS25XSkpBZzBMMHU5VDJhNHFCMklNZVlqWjFLaTBwVVZTK1R6amZsY1RycEZKSkNRaFJFaHJRZWlvdldGYXZWeXBvVFgzTWc4Vy8yamJ5QXlXckMzeU1RUVJDUUpBbWJ6WVlvaWhVV2JWVVljQjMzQUdZK09xL1k1UDVnekc1T3BSN0YzY0VUdGZyYXRLYUNJS0JRS0toSXFmQklxeVJONVJwektxM0tjZGVLZVA4Vms5VklhbTd5dlFIY3lMTVpEOVY3REwwcHY5TFByYndid00rRUR1ZnBEc01RUmZIZUFCWUU0YTYwMzd2YWh1K1d5TUF5c0N6Vlc0cTR5cTdmVDRuN08vYk1IVCszRkR2NkMvd2M3eXkxaTh0TnA4N2lFWGNNMkxWTzQvaS9uNTNoSjdkaEdWZ0dsb0ZsWUJsWUJwYUJaV0FaV0FhV2dXVmdHVmdHbG9GbFlCbFlCcGFCWldBWldBYVdnV1ZnR1ZnR2xvRmxZQmxZQnBhQlpXQVpXQWFXZ1dXcEhDazZodmVWQStzUXBBRTFpbEFTZm1aWlIzbkdOQmxZQnBhQlpXQVpXQWFXZ1dWZ0dWZ0d2a01wOHV6aHZFRUI5UVBjMVRVSzhFcTZxZjRieTBvQWJ1UHY0TmExdm1QRkpDMDJNeVo5TEVxTko0YmNpMGcyTXhySFlFUlJqYWpRSW9nVjgwUC9mU0hYcmRKTjJtWTFZTWk5aUtqUW9sQTVrcS8wb2tEdGgwcmppYzFxSkQvak9FaTJtdE9HYzVKM29kYjVvOUw2SU5uTTVGc2h6eUloMmN5bzdMeXdkMjFCWHNiUlNvR3VjR0JqWGlRT0hoMVFLQXNuRk1yT1QwUjFlaGVLaUoxazU4VVhYb1JDaThxdUZpWjlYT1U2cllvUVErNGxuSDE2QTJBMVpmUEI3M05RNm5WWTFRcXNzUWY0Y01Cc0ZCb1hOTG9BY2xQM285YjVWMjlnVWFtNyt2K21QZk1ZMlc4Y2hndm5zRmRyc1FYNnNIbmZYQjd1TVFzQVFWUldmdzA3ZW5ZR29DQS9HY241QU9rcEcxQzRXY2hHaVQ1SkNTNGU2UFVwMk50NzRlRGV2dm9EMnl4NlJLVTlhdzlNSTlYZ1NtU0tIeWpBWmhNeG13U1E4a25QbU1tTFBSZGdzK1FYc1locWF0TDJtQTNKOUc0eURwTkpRaEtWV0FXUXJCSXFoWUJnc3lJS0VoWlRPa3FWYS9YWHNDUlpLTWcrZzdkbkIwU2xmYkg3V0MxNTZETlA0ZURlRGtHbzJJNmpFcWFtVWFKemIwZGUyZ0dNZVpFM2JMZVlNdEZubmtMbjFocWhnbVpZcWxRTkF5aVVEampXNm9aWkgwOXU2ajVVV204a3F4R3pJUVcxMWhkSHowNTNKM2s0RnBPWGtaWnZxc0NsUEhWQXcvKzhyL1hQMy9TS1RCNUtYc3J6alordVhFQ1FhdFpTbnBJZ0wrVXBBOHZBTXJBTUxBUEx3REt3REN3RHk4Q3kzRVorL3Q4M213YThxRGNlT3FpdFNZQ2FEcUVGL1g1ZVlTKzNZUmxZQnBhQlpXQVpXQWFXZ1dWZ0dWZ0dMc2ZrWWZlcXpTbkJ6cUpuVFFLTXpMYWwzdjlNWDY5LzN4ZTV0NlJ1MnN4VXU3bGZqZEpvM0trNGs5eUdaV0FaV0FhV2dXVmdHVmdHbG9GbDRBcVFJckgwNll0SkdaazUrdG8xQ1RBdU9hZmtnV216bCsyNkFEU3JZVXFWQjZiSndES3dEQ3dEeThBeXNBd3NBOHZBTXJBc1paY2k5NWJTRzRldVF4SnVhOFkwaC9telVmZnVSdmpGZUpyMWY3L0l0aWIxZkFuZk9BMkF2SEh2WVBwelp5VVNTais3bnprb3o1Z21BOHZBTXJBTUxBUEx3REt3REN3RHk4QXlzQXg4VXlseU04MXB4ZWVoeW5hdEt2U0VEdk5uVlNxZzVjaUpVTnEzbGpVTXdQZjdMbWlqRDhiZTBRRlRNbkp2L0N3OWwvY1hicmdyZ0lIV0FtMkp3RDhmdXFUZGVEeTYzRSthbXBITHRFVy8zeFhnL3EwRHRiS1hsb0h2RmFjMW9FTklRWnRPemU3b2NkcVVqRnlXck41VjVETlBOMGRHUGQzdGJqbXRnbzFycnIwdlVxWTFIejRlcDJ6WDZvNUc4ZHlxVEZ2WllqbHlJbDdWdnJXZmJOSUFPUytPT25pbmhmaGJ5VjBveEIrVXZiUU1MQVBMd0RLd0RDd0R5OEF5c0F3c0E4dkFNckFzSlVyb3doOEpYVmo3WGpMcFFRaUs0NFF1ZXRlaC9hZENqUWUydDFrWWtSSHVwWmFzMC9ORTVTVkNGemFzMGNDU0FEM3pFd2lML0ZrWWtCTVZySkdzWittNGVJWVl1cUJXamZYU0prRkVJOW1ZazNLWW4rTCtvb1VoN1YyYnFEbE02TUxuYTJ5M0pQM3phbXpNWkgzTVZ0NU9QZUt2czFtK0pYVFJEa0lYK3RUb2Z0Z2lpTHlXSHNHNnVPMzB6WXZwamlDRUU3cm9iVEYwZ2JaR0FnTVVpQXJxbTdMNU5Pa0FLK04ydXRsTDVnOXNndUswRUxxd1ZZMEUvdGZNRlVqY3IwOGsvUEk2WVZEMjVib2F5WHFjam92bkNLRUxQR3BzYUdrUlJDUUU1cVFjWW5YY0RqcnFrOTZVUk0xUlFoZStVbU5qYVFtd0l0RGNtTUYzOFR1WmtYd2dRQ05adnlCMDRaSHE0TlNLQUF0SU4rNWhMVnlwVHJMYVFMcHgrOURNYzJ5SjJVcnYvTGkyQWx5azQrTFh4ZEFGemxVZVdBQUVoS3VBQU5na1ZNRjE4Rm93Q2RleHoyRGZyVDNZcmtGTFZpc0ZvcElBY3c2TEV2ZnpYZnhPblp1bDRCT2JvRHdvaEM3c1V1VTFMRmtzMkhkcmkyQ25Saktac2UvZWpscGZ2by9qVTMxeG56cUtXc3ZmeDJGQXo2dWFkM3lrTzVMWmdvU0FpRVNuZ21UQ29uN21tYXp6RGRXU2RUZWhpejRuZEtGejFXM0Rvb2pwd2hVODU3MkZ3c1VSNTFGRDBMUzhGbEtMcms2NFR4dU4wcThXTHY5N0dzSEJ2b2laMnhBd29XQjJ5aEZXeGUva2ZuM2lxNGlxVTRRdWVyVnF0bUZSd0pLUWd1aWt3MjNLU0FUeFJwOG0ybXZSOWUrSzg2dFBrcnQ2RTRMNnhsV3d6SUpJSzBNNnl4TDM4RW5pSG4rbFpGdE02TUpUaEM3MHY5dkFWOU5BK3c2ZlNsOGw3S1pkUVNxcXdOclUzcklFaFVmSmk3WWxQREdXZ2ozSGIza0NPOGxLbkZMSE8xN3QrTnZleDJZUkZlTkV5ZnE5N2VCcm1WV21XekpIeGhMLzBFanlOKys1WVp2eDVEbmlIeHBCd2U1anBUcUJRVkRnWlMzZ2k4UTlmSlA0dCtobnlsMWdFOVY3Q0YzWXA4cG8rSm9UczZMMGNrUGJ0UzJDS0tJL0hJNHBNZzVCcGJ6dGs2a2tHek04VzdIQ3BUNVdoRFhBeXh3Y2sxZnB3Tm9PbjBwZkpleWhmVUZLMFQxc0VwTEZnZ0NFT1hpeDFyVWVLc21HcmZoZXUxU2lrYXdjMG5weFh1ME1rQW04RHl6ajRCaERSUU1ycjQraWJqUjY0YXBqYW1YS1pKUFZ4RGR1VGNGbStSYUJLSzRiQ1ZUNmtFMzY3NC91RER3S3JLMVU0RnVKRFppVmNoUUIrTnFsd2NOSXRPSGdtT2lhbHp4STE4eGFMeXFabEJiR3NLenpib2pLNDJMb2dxNDFDMWlTRUhSYTdMdDFRTEpZcjlyZ3ROUmp2SkorMnRVbUtOY1R1ckIrdFFlVzlBWThabzVGV2NzZDE5ZWV4VzNpTUVTZEZvOXBveEYxV2dwUThHNWFHTU16STV4Qk9DNkVMdWhRYllHbEFpTTJ2UjVWZ0ErMWQzeU44OGduMGJScVNKM2RLM0FlOFNTbUs3RkkrZ0pNZ3NqRXRKT015RHlqazBUMVpqRjB3WDNWRDlocXcvT2o4Zml1K3d4RkxYZVV0ZHdSZFZvRXRRcFZjQjFzT1huNGZEVWIzM1dmZ0Zqb29OOVBQYzdJOUpOdU5zUS9DRjNZb0hvQml3S1pDMWRoMTc0cG1sWTMxdUpGVnljY24rcEQxbWVyNEo4Mm5TOHFlU3Y5RkNNenorZ1F4S05pNklJSHFnZXdCSUphaGZPd0p4RGRiNUxWcVpRNFB2Y3dDamVYcS9teERZRkphV0dNempqdFlCUFY2NFRRaFcyclJ6NThmeHZzUXB0ejB6REtKcUZwMlFDSFFiMlIvcE1lbWdTUmQxTERHSlYrMGtXQzNZUXViRk8xU3p3cUpmbC9IaURwaFhld0pwZThSSzVrTkpIeTh2dGtMVm1Eb0JDTHhLbDZVY240OU5PTXpvalFJaXAzaUtFTEhxcmFiVmdBbDllZVFlbm5qUzBuLzBaWXN3VkJGUEdZODhaTm84cDMwc0lZa3hibVpCTVU2d2hkMkx3S0F3dGtMMW5MUlUxejlIL3VSOUliQ3NzNFpndTJyQnd3VzdqZzBKems0Vk1STmVvU0Q1d3ZLbmt6L1RSajBrL3BRRGdvVkJGSFZpeXdOVDBiUVdPSHNyWVhzUThNSlhmdEg1aWo0cm5TWmpEbVMxZFExL2JIbXA2SlpMWGVOQTB6Q1NLdlo0UXpOdU8wVmhMVlAxY0Y2Q0xwNFpjSmUranczL1JRa3BDc05sUkJ0ZEYyYmtYT3lnMUlGaXNLRjBja2s3blVKM0d3bWZuUW93WHozWm9aZ0U0Y0hIT2lpc2JTQW9KU2dlVktBcmxydGlDb1ZZajJkbVdDQmNnVFZieVdFY0hyR2FmdEVNUzlZdWlDUjZvbXNIQ3Rtbm1uWWtOZ2ZQcHB4cWVGMmR0RTFTcENGM2ErdThBU2lFZ29KQWtGRmZNeUN5SnZwNS9pcmRSakRrcEoya0hvd2twUExhOFdBR3lDd0NXMU0zYVNyY0pQMnJFZ2hZZnlZOVViSGZ3M0VycndPUTZPK2EzU25SYWhDeVVFOGJZck5yZGo1UCtVZVl6L09MTGp5RktSR2dZSUdpZlZPTUtvK1VMWmExbzFTR1JnR1ZnR2xvRmxZQmxZQnBhQlpXQVpXQWFXZ1dWZ0daaDdmV3FhalNQK3JIR0EvU2ZlQkxoZjQxalpwR3UwU1c4OVcvYUhTNVVhUnl6RzNDcU1lSzVrNEllV2x1N2VkUzBQUjVMVENpR25qT25OekMrMklVa1NBYlZkaVUzTXdtYVRxaXp3YlpuMGsvMWEwcnRMNFdDZFFYMWIwaWlrRm43ZUxzeWEwSytLd1paVEc5NjI5enpybHczbnlYNHRhVnJmbXlIOVcvSG55cEZjaWs2N3VvOWFwYWo2YmZobW9sSXFHRCs4RzNZYUpYL3R1MGhTYWc1ckY3NXcxYXdCTW5QMHpCamZod2JCWG95YjhSc0p5ZGxWRHJoTWR4NVVTZ1hmem51YXB4NXVYZUkrRjZOVDZmNzBZdUtUcWdqc25keDVrQ1NKeFN2M0VwZVVWZUkrbTNhY0ljRFhEWTFhV1NWTnVsUWFGZ1NCUGwwYk1tWE1nNFMyQ3JqbGozSThJbzZOZjUxaDBjbzlwR1htVnlrTmwvbG1XbTF2Wi9hc0hVTlFIZmRpdDArY3M1R1BsdjVWZFZSNkp5WnRwMUd5YlBaZ0F2M2MwQmVZYnRnZWw1VEZoMi8xNTQzaDNhcC90eVNLQXM4OTNvNTFtOFB3YnY4ZVVYRVpaT2NXUHBPUi9vL1pmcmprTDN3NnZFZHlXaDVONm5sWDN6Wjh2Zmg0T1hGMjJ5UzZQNzJJWDVjT1krbXFmUWlDUUxmUUVCNThZV25WSXJ6T3BHL0xsWFpzRmNqRHc1ZHpJaUtlN2Z2T3MvZG9GSHVQUm1JMFdYQnlzQ01uejFCbFRmcTJOR3l2VlY5dHc0OC8ySXd0dTg1aU1GcXU5dFZtaTdWbWFmaS9EbXZEOWdpcy8zbm11RXJCVmtRKy9GOVl1UUFnQTh2QXNsUnF0M1I1eUpDTERwMDdoM2krL0RLQ1JnT0F6U2F4ZXZWaDNuLy9keTVmVGkzekNiNzdiaWpQUHR1QjJISGpTUG5zcytKTFJtKzhnZC9ISC9QbGwzdDUrZVh2RUFRQlFlQzZ2OFYvSm9vQ2ZmczI1YjBwL2ZDSjJFdlMzTG1ZRXhQQmFrWGJvZ1gxdDI0dE9aYTJKQ1pxWThlTTRYUndNQ2tMRm1BekdCQkZnV2VmN2NEWnM5Tll1dlFaYXRkMnFYQXRTSktFelNaaHRkcXdXR3lZelZaTUpndEdvd1dEd1V4QmdSbTkzc1Q5OTlkaisvYlhXVHJZQTU1NmlNakJnOUVmUFlySzB4UC9wVXVwOThjZk4yL0Qva3VXblBSNCtXVXNLU25FamgxTGVIQXd5WjkraXEyZ0FKVkt3WWdSOTNQcDBrdysvbmdnSGg0T3QyOVdDaEJVdC8rRDlPM2JsTU9ISi9IRHE0RTR2anFBeTA4OFFjSHAwMmliTjZmdUw3L1E2UGh4WEI1OWxOeGN3ODJCeDN4eU5PajM1azhSY3ZvTTdzOC9qeVVsaGJqeDR3a1BDaUo1M2p4c2VqMTJkaXJlZUtNWGtaR3ptRGJ0WVp5YzdNb0dxd1NITGdxY2V5c1JOR1VEN2RldldTSG9tSG80L204d2x4NTVCUDN4NDJpYk5DSDRwNTlvSEJhR3krT1BrNU5yWk1hTVRRUUVUTG81Y0h4OGx2MllNV3RvMHVzcnRvUU9KU1RzRks2REIyTk9TU0Z1d2dST0J3YVNOR2NPdHZ4OEhCM3RlTys5L2tSRnplYk5OM3VqMVpaT1pibzJDb0srMWhLdzJBNWRTMFdwUVk4Y21jenFjUTF4R3ZjTUYvdjBJZi93WWV3YU5TSjR6Um9hbnpxRjY4Q0JaT2NZbURadEl3RUJrM2p2dlExa1p1cHZEbXkxMmdTQXVMaE1SbzFhVGJOKzM3Rzl4MmpxSFR1QnkyT1BZVWxOSmY3dHR3dkJQL2dBYTI0dWJtNDY1c3dad09YTHN4ZzFxaHVxVzFRcjgwOVlTZjNTUk1wU0UvbGhOdzlEKy9kdnpwRWprMW56Vm5NYzMzaWVpNzE2a2JkL1AzWU5HaEMwYWhWTndzTnhIVHlZckJ3RDc3Ly9PNEdCazNuLy9kL0p5dEtYcmgrMjJXeEZQRnBNVEFZalJueFBpeWZXc3F2L0JPb2RQSXh6bno1WTB0S0luenlaOE1CQUVtZk94SnFUZzQrUE00c1hQOFg1ODlONS92bFFSTEg0Z2VhU0NSSm5tMGo4MElSa0xQNmlIbjY0T1VlUFR1YUhTYTF3ZW5zbzU3dDJKVy8zYmpRaElRU3VYRW5qaUFqY25uNmF6R3dENzcyM2djREF5VXlidHZHbW9DVm91UGpoOE5IUjZRd2Z2cExXejZ4bjMrQXBoT3paaTJQMzdsZ3lNa2lZTW9YVGdZRWtUcCtPTlR1Ym9DQVB2djMySlU2Zm5zb1RUN1JDS01NQSsrYk4vVGgyN0IxK2VMY2RUdStNNEh6bnp1VHUySUVtT0pqQWI3Nmh5Ymx6dUQvM0hKblpCdDU5ZHoyQmdaT1lNV01UMmRrRnQ5Y1BmL3p4bjRlVGtuTGFXYTAyL24xWkxOZitMM3hKQkFkN01IYnNBNmhQSFNaejdWcHNCUVdGWFpoV2krZUlFZWc2ZGl5U1hDZ1VZcW42WVlDQ2t5ZkozcklGQkFGQkZGSFZybzNyazA4aUtBc1R1NGlJQkJZdDJrbE9qZ0ZKa3BBa3J2dGI5TE5mZjMxVnVGbi90MDZxSUlrWk8xYmFpSU0wZ0M1U0k4VUFxYm4yY2VseDdwYzI0Q2pGdnZGR1JaMzJodnkrU0Q0Y1AybFNpQ20yWXU0Ujc5d1R5UmllUkkrSyswTlQ4UEkwc082M1JteWhIdk4vUEVEdnBHY3JKYlFzQXB4LzRJQkg3dDkvbCtxTEtoOEJjMkxwYnB6bG9PSHRmMkFCbmh3UWc0ZTdrWFcvK1dOQXlhVFlldFJkdFJaWFNsY2FVdFVTTUNkTGR3NWNxaSs0Q3VoQ0ZkVDZuNXJrQlNaeWRscVFURGYvemtIcTROdlV5TExKeDdDenM5QzVZeHBxbFkyTjYzWmhzWWg4OUdsajloM3lwejhYYnU1aDdjQ2hzNUphWTFVa2Yyb2kvNWdOYTA3WndNdWNIbHF5SkJ6YUszRHNxa0RVY2t0WWdMTjRjQ3JjbFNrem1sUGIxNENUb3hrN095dU5HdVR3NFNlTk9YRElnN040M3ZJNE5nT292QVdjZWloeDZLekVtbHQyTFpjOUg1WWdaNmVGMDAzeU1jYVU3b1NPRlA0cUVXZWRPWERJNHg4SENjZkMzRGg0MktQSVByY1N3d1ViNGMzeXlkMWo0WFptUDdxdEFrRHViaXVtS3piMHgwdFhzT3ZDbGNMbW9MUnhYNmNVK2cvc1J2YytQV25lTkF1ZHpscGtuMXRKL2hFcnhpZ2J1WC9mWHJHd1NCK1Z2V1BIZG96R0NubW9lZFRvTld6TkZoQkZpWlRVd29URDFjV0V2YjJGVG1xUkw1Y01xUkN2N055blQ4bGxXcWZ1M2JNcXFqdVk5ZGgyZEovczRudGFYRFBQTEpISHM4NHg1Zlg3Y1hxb2N1WkdLQUxjbzhlbkhmYnN1WEMxa2xCY3hhRnhZeDltelhxTW5qMGJGVGxRM3I1OVpQLytlK0ZqOGpZYjlxMWE0ZmIwMDFlZlBWWUk4QXJIZUpaVFhNSU5DWUVRTXRCaFFpbmVYM0tYOXVlZnBIejJHZGJzYkJCRjFMVnI0ejE1TW9mU05VeWMrQXZoNFFtMzM0WnROcHZ3YjRYaCt1cUNoNGNEQ3hjT1lmLyt0NHZBNm84ZjUxTGZ2cHkvN3o2U1B2cUk3TjkvUjlleEkrcEhCeko5NW1aKytPRkkwYnNXbUdsT01pMUlRbmVkbzlxeUpad0pFOWFSbkp4enplcDY5eVpvOVdxY0hueVFndkJ3TXRhczRVekxsZ1FzbjhhT2xRUDQ3TFBCdUxob3ljODNGdnNxczlQeThuTGtzODhHYytIQ2RGNThzUk9LZitidE1KdzlTK1NnUVp4dDI1YnNMVnRRKy9zVDhOVlgxRDEra20valhBbXUreTVUcC81ZWJHQmZVc1VqUDkvRXZIbmJDQXFhek5peGEwbElLR3hoQ21kbmZLWk1vVmwwTkw0elpxQjBjU0ZqOVdyT05XbE16OE1yT2ZQM0tHYlBmZ3huWiszdGUybG5aeTB6Wmp6SzVjdXplTzIxSHFqL0djSmdqSW9pK29VWE9OT3NHWm5yMXFIMDhLRE8vUGswT251T0RUU2dRYVAzZWYzMUgwbE5MWDZ3bXNKQndQa2hKUzc5bFNnY2k0L3JDd3JNTEZpd2crRGdkeGc5K2dkaVl3dG5oRlE0T2VIejdyczBqWTdHZCtaTUZFNU9wQzFieHVXbURYa3ViVHZuRDQvbjlkZDdYcjNXVWdGcnRTcmVmTE0za1pHemVQZmR2amc0Rk5aaHpBa0p4SXdhUlVTREJxU3ZYSW1vMCtFN2ZUcE5MMTltZCswdU5HdnpJY09HclNRbUp1T212N0FtUk1SL2dSMTE1dG1oQ2JtNWdSbU5GajcvZkJjaEllL3l5aXZmRXgxZE9IdU13dEVSbjNmZW9XbDBOTFZuejBiVTZVais1Qk1TMnpabGdtTTRaNDY5eFRQUGRFQW9KamN0Y3NiSEgyOFZkK25TVE9iTUdZQ2JtNjR3c2twUEorN05Od2tQQ1NGMXlSSUVwWkphRXliUU5ES1MweDBHMEtIN1FnWU4rb0p6NTVKSzVUUUt6bGhKWG1naWVZR0pnak9sNjB0TkpndkxsKytoWHIxM2VlbWxiN2wwS2VVcXVQZWtTVFNManFiMkJ4OGdhRFFrVHA5T1hyYzJ6R3VSenBIOUUyNE9QSFpzanpoZjM4SXlyRFVuaDRTcFV3c0xlQjkvakdRMjR6bGlCRTB2WFNKKzRDaDZEL3FXQngvOGpHUEhycFRKUzBvbVNKNXZJbmwreVJXUEVzTmFpNDBWSy9iVHNPRlVubjMyNjZzL3N1amdnUGZFaVRTTGlxTDJSeCtCS0JMMzFsdW9CblM5dFVuYkNncEltak9IOEtDZ3dpcEdYaDV1VHo5TmszUG55QjN6SG9ORy9VWm82SWZzM0huK3J0MDlzRnB0ckZwMWlDWk4zbWZJa09WRVJDUmNBMy9yTFpwRlJlRTNadzZTMlh6elNPdnZsYTl2eUQ5MnFBdjVlcVZrUTVEVUtwdW1kYk1NMGNQRGVQUllvdHZSWTRudWtsUzJXUkc2M0ZjbnVYVkxyeXpqbVF0TzFpdXh1bUlkV1VDZGZFM2oramxuejJVNC9yazl5cmZNNGFJZzBLeXBSMGFiMWo2WkNvVWdDUUtJb2lDSlZxdnd3T0JQNjVVSXZIZTFkM1RuTmtrQk5lcGVVZ1BrT1FCa1lCbFlCcGFCWldBWldBYVdnV1ZnR1ZpVzIwZ20vdnZtNHZUUGpKNGRXcWlkZTNmRllyVXgvNXNEVEYrMGk5ejg0ak4xTzQwU2ZkZzdIUGU1Vm10dW5YZ1MrNWF6cm82ZnZsNGM3TlZNSFhrZno1Z2pTWnEzQk1kTzdiai9zRDJKb24xRk1mN01wUmtEaXpWcDkxWk5WSkhEMytEeWMyT3d4aWN5WVhobnptNGR3NU45bXhaYkh5cHJ6anJ3b1NhY25ONlpQdDkvUXRxS05RUXQvWWlRMVlzckV2Ym1iZmlSVmRIYmN6OWZBa29GWnpvOVF1SzhwZmk0YUZqNzJaUDh1ZUo1R2diZjNucHc5WVBjK1hOdVArWVlqNUkxYWp5dS9YdlJaTjhHWFByMFlNK3htTHZudFBZZXZaTFRiZnhHcHJyZGg5dkNEMGxmdTRFelhSNG5aOGRlZW5hcXk2bE5vL2xnUWk5MFduV3BEbTZ2VlRGN2JIZDJQdXFFKzlqL1ljbktvY21lMy9DZE5JYlVmQXZQVGZpWnJrOS9YYW5BTnhSd0pVbGkxWVpUYk54cHgvUlJFeG1RZFliTHo0L0ZxZWQ5MUpueE5oTkhkT0daUjVvemJ1WVd0dXkrV0tMNVB0YXJFWE1mOHNVMDkxUFNjL01JV2pRYmwzNFBZSk5nd2NxRFRQMXNCMWs1bGY4d1NJbmRVbmF1Z2JFZmJhZnYzMVlLbGkwQm0wUkVwNGRKbXI4Y1AzY3RQeThld3ZxbFR4ZjczZld6Ky9DSmRKS2NrV054ZnFnN1RmYi9qa3YvbnV3L0VVdnJSNWN3ZHNibXV3SjdnNWNlTXU3SDNRNzI2aTQzN2lRUTJzcVBSNE0xR0RadlF4QVZ1RDdSRjIzRHVrZ1c2dzFlT243YVBOUyszcmdPNklmS3k1M2NmQ1ByL29qZ3dJazRpaGxZUTFSY0puL3RqeXlUQXl6dU9LWHgwa1ZNZW5SRFphTkd6c1VkU0FKTERGd0F1NUJBQVBSaHA5R0huVWE2N29udzlCODNvRzFTdUpKSnpvNXJDMVE5QWp6U3RQZ3JPdWpwd0YvN1M2K2xVVSszNWZQVlI4c0NYWHdiVnYvK3V5NzYwT0U3TXBrclk2ZVUrVHRPN1RvQXQ1NXd3ZGZMQ2IzQnhLdGlGR2M3QkhBMk1wM003SUlTKy94cUgxbzJEdkhneUdBM0RNdFhzQ2p0TDZhOTBBYWp5WHI3R3JZMmJtenk4SEVyMjFLN2trVG0rcTFYMzdyMDcxbTRZR1FaSk1QSkd5N2Uram5qN2ZzaitUV2dNWSswYm9tdFlYMWVtYnZyemt4NmY0T09Wd0w5WEp1WDFLZTJhT0NOYnkxSHNFa1lvMklvdUJTRjh3TmRpZ0FITDU4SFNCZ3VSR0tNakVGZHg0ZHNUeC9DTHFXakx5aCtxdlVESjJLQmZhVzY0Q3dITjlwRUIvTnk2NmJVOGp4RGNtcmU3UU5QK0hEclJhQUlzRWF0NUkxaG5YaDNWRmUwZGlweTl4MGg1dTJaMlBMMXVMMDNnZUlXT01uTU0rSFd1RDRJQWpGdno2TGc3QVZhdkRXR0pUbWV6UDE2UDBhVDViYk5ldmJ5dlFETS8vNzJmTTFOMjNDdnpuVTV0WEUwczhiM1JKbWRSZFRJdDduNDVDdTQ5bjJBdytPbjAySGU2V0svMTZ6ZjV5eGJjeFM3aGlFMFdQOE4vck1uay9icFVwN2Vzb3l3T1QxNHNFdEloYlh6b1FOYWxoM1l6OXVKSHhjTTVzOFZMMUN2amd2SlMxY1NFZG9mUzNvRzBsZkxlT0s0SGNPbmJ5RzloQUhaR2RsNlJrelpRT2pBNVJ3TlQ4QnRVSCthSE55RVE0Zlc2SWVONGd1WFNINzVvQjkxZklwZkFFZWhFSzhPclNpdDlPMWFqOEg5bXpISlBaMEJEemFpY1lqbnJZRzFHcVg0NXZEN09QZm5hd3pxMDRTOGc4YzQyMk1nS1V1K3hXUE9WT1kzZm9RTzR6Wng2R1JjcVM3aThLazRRZ2N0WitTVTM4bVJGTlNaTlpGR2YvMkU0ZnhsZ2llUDUrQ0xma3g4K2NZMXFSN3FHTURnWG1WYnRpazZQcFBwdGxQa0xGN095L1dVWEl6T3VIVWJQcmR0YkU5L0gyZk1LV2xFVDVoSHhpK2JxVFhxUmJZSGQrRE5qL2VRbWxIMkdSdXNWaHRmckRuQ3oxc2orUEROM2d3YjFKb0d2MzlMK28rL0UvZit4N3dRNE1mM05sL2lSQjJONm5yU3A3MC9BeHl6VU5uMGVEL2RoazBIcjNBK011Mlc1emx6S1kyTUlhRVlncHB5d3VaVTRtTzlSVFRzNGFqUnBpeGZSVVJvZjB5SktZamZMT2ZKY0VkZWZQK1AyNEw5cjZSbDZoaysrVGM2RGxyT2lYUEp1QTk1bEthSE5xTnIzWXhoaHNJSmdzNWVUcVdCSWcvdGtzOVJMZnVTWVBSY2lFb3ZmYjY5L0N6ZEYwZXcrSmZ3MHNYU25rRVROZ1JJZVE5SEtSeEpGMjc5UEpJb0NqeDRYMTNxcFVSZHE1cDRCYkYxNytVeVRVSmtoeFVEaFUvRHRHM215NnBHdVFpQ3dLQXdMU2ZQSjVkcnhhT0lTYWNxdEtaVVNoOTMyR3dTVzNaZllrdVJkbkdwekZmMEx5eUFrODZPbGh0U0VVV0I5czNkS3o0ZnZ0dXk0K0MxckdubndTaTVUQ3NEeThBeXNBeGM3ZVJPSmllcmxzQnpYK3R5MjVNTVZodGdoVUtrYVgwdi9MeWQ2SDFpSzgvMmFVUndIVmQ4UEIxckpyRFZhdVBCZHY3OFZUK1IvQTFiZVgzbmw2eGYvWHpKQUFBZ0FFbEVRVlI0cmtHSlZaUWFZZEx6VmgzbFNHQnJsSjd1S09yWDVmN1pCOGt1NDFSVzFhNE51OVQxNDFIM2ZoenQ5aWhkMnBaOUhLeXl1Z0UvTm1NbkZvdU41K2Z0UjZVc3UrT3FkaHEyV081czdpNDU4SkNCWldBWldBYVdwUXBKa1RKdFpyTkdXWUJ6bWMzRTJ4dW5QM2RVVGNEckJwaVZhTktDL2JYQllvcVFZT3hHamJtMlVhMisvcWpWdncycmV2VkcrZkREaGZGbml6WW91M1FCcFJKQnEwWDd4cHMxejJtWi90eUtkdGdyQ0k0T21QL2VpV1hiVnJCWXNKOHpEMXQwVkxVRkxqbDVLQ2pBdEhNSHVrV2ZZd2svamJKcEM5UlpXWWgxZ3pHT0dWVnRUYnBZWUZYSGp1RHFqbVhiSDZpNmRFWGRvaFdTa3lQcWdRT3g3dGlKc2xObkVFVXNSdzZEMFZqOU5XejM1aVJRS3BCeXNoSHN0YUJRSUdYbllTdlFJN1pxaWE1WEx5UkpRajkxQ3BaREI2cy9jUDcvUnFBWi9CU1N4WXJnNElpaWRtMVFpQmdtdm9VdE94dkJ3UkVFa1BMeWFvYlRrdEl6c0dWbUlLaFVLSUtEa1ZRcUxPZk9ZVGR4TW9KT2g1U1hpNVNiKysraTUxVGVRdXNWQld3MFlseXhBbHRxQ3RiTGtlU1BHb0hoczA4eHJmOE4rdy9tSUhwNlVsMmwrRzVKYTQvakR6OGhPTHRTOE9GTXNCWldGaXdIRDFEdytRSWNsaTVITTJoUXpRRzJuelViNitrVEdCYmRPR21mN2R4NThpZStoZnJSQVFpdUx0VU91TnhpYVlmdmY2aVNnSXBhM25jK0tmNE5XazlLSXFkbmR6a2Zsb0ZsWUJsWUJwYUJaV0FaV0FhV2dXWGdHaXpsa2p4a3F5VStiRjFGVjZVOVhRSEErU3BZMnNRbW03UU1MQVBMd0RLd0RDd0R5OEF5c0F3c0E4dFNjNlRJalNaSmt0WUJBeXJqeE9tVEptRTZmYnJDeitPN2FWUDUzMHk3SFRFY09FQkJLUmV6a3R1d0RGekp3QkVST2ZjVzhKUXBFVVJHNXQ4YndMbTVGalp2VHVUSEgyUHZEZUNOR3hNeEdtMnNYUnRYTFlETDNDMzk5bHNDMzM0YmpjMVdPSzFGZUhoaCt3MEx5NkpQbjcwb0ZJWGRYbENRanRtem0rTG9xS3pld0k4OTVrdCt2b1ZYWHoxT2JtN1JhYUwrK0tOdzdaUWhRK293YzJhVEtnZDcyeWI5ekRQK2hJWDFvbFdyb3VPMEJBRysrYVl0cTFkM3dObFpWYlBhY0hDd2p1RGdva3V2U0JLRWhycFg2ZUhUdHcyczExdlpzaVVKUVlEUm8rc1NFbEs0aVByUFAxZHQ1M1hid0gvK21ZeTd1NGFkTzd1eWFGRXJUcHpveVN1dkJMTnVYWHpOOHRML2JhOG5UL2JFMWJYd0NSY0hCeVZmZk5HYTMzOVBKQ1BEaEp1YnVtWUJQL3BvOGNzaVBmeXdqNXc4eU1CVnhhU2pvdkkxeWNtVjg1U0taMGh6N0F5Vk1PWHlvVU1sQTY5WWNhWDI5T2xuS2dWNDI3WjM2ZG5UcStKUGRGMVFJTGRoR1ZnR2xvRXJSYXdaR2ZjV2NOYWlSUmhQbnJ4SGdDV0puRldyeUY2NTh0NEFOaHc3aHVuQ0JYSlhyMGF5V083b1dGVnl0cVdDdlh2Si92TEx3Z1hZclZhTVo4OENZRWxLSXI1dlgwUW5wMEp0dWJqZ01YMDZTbC9mNmcyc3ZlOCtiUG41SkEwZmppV3VhRUVoZjlzMkFIUVBQb2pYL1BsbGdxM1NKcTE3OEVHQ3dzTnhmT0tKRzdaNWZmb3BmbHUyb1BUenExbHRXSFIyUm5TL2NRWmlwYmYzYmM4N1VLV0JKWk9Kdko5L1J0QnE4Wm8zRDVjUkl3RElXYldxWmptdGYwVy9iUnZxcGszeC91b3IxQ0dGS3djNERoNU04cWhSV05QU1VIaDQxQ3hnVlVnSS9qdDNnbmpORU8yN2R5ZmcyREZzV1ZrMVQ4UHFCc1d2QkNEYTJ5UGEyOWU4Tml4blN6S3dEQ3pMOVZJa1hEbm5FckpPUUxyamdXbkJaL2FoOUtsMVI4ZXdKQ1lUMmJqem5RY3ZDRDgzekxvMFVHN0RNckFNTEFQTHdES3dEQ3dEeThBeWNEbExwVmM4ekdZOUJvd1l6Zm5ZS1J4eDBEalhYT0NrN0doK08vMEZab3NKaTJSQmg0YStyWWJpNTlLdzVwaTBoSVJOa2tncFNDVThhUjhhbFJOanVzMWpYUGQ1V0ZSYVRpYnNJU28zbmxXWE41Smx5cW4rR3Y0aGFodXhPYkVNRGVtUFdxMURJVXBZTUtHd1dyRlhnSVBLaWJlUGY4N2g5UE5FNXFjeHBmbUwxVmZEWVJrWG1IZnVWMzVMUEVhYVJjKzVHQVZKR1hhOHMrNER6a1N2cFpsWGJkcDZCdFBEcXlsZUdqV0hZazZSa0pGWVBZRk5WaE5URDgzQ2tuK0ZBWFh1SnpMNkNpTjM1alB4Z0MrMVRYb0VTVXQ2ZWpJeFdja01yZDJNQ2Y2RFNDR044NGFvNmdsOFBpY1NPenMzUEpVQ3ZYeGFFK1NtWTFmanZaeHV0b2Nrc3djNStrUVVtVlpTOCtOQVZQQmo0aVp5RFNuTVBmdEw5UVRXS094eFVMdGprZ1RXUm03Q3pkbVpyYllHL0dKcndBL3hEdFJ5YjR4R3NxZU9Td01zQ2dmcXU5YWppYU12clIwQ3FxZlR5aXhJNWEra0V6aEpWczdtSnFKUFRhUk9TZ0lTSXFNVUVpN25WSWdHY0Q0VHkrR0FWTlpGNzZTM1V4dk9aVjhpdVNBRDkrb0czTktqQ1pOYURHZnhpZm0wZGczQlpmOXhIbGkrRnZXenVZaitackpQS1RCLzRVeGFOeHRCWFVaZzBtajVQZWNrUmtIZ1FtNE1IZkdwYmladFI0NCtFYVdkTjRmU3dzazdjeEgxZXhrSURVMUlPZ0hSeDRybXpVeVVUUTJJWjYvUTE2VVphaEZlQ081TEY2K1cxYk5iNnVYWG1UeUxub1NjYU1UNnZwQ2lBVHNSbTRPSTdZd095MGtkcG1rT3BJVjRZdE1xZWI1T0wxNXk3MVo5KytHV2JnMTR0OFZRZEVvN0ZyZHdSZXZ5Rm9xVDNaQzIreUtaWGRFNFBZREwvRmRaR3B6TnIvRkhRV05IdzRCRzFUdlNlaTc0SWV3VkdyNDV2NDZaZGYwWnFtcUZXNm9mUXA0Si9JTDRxYlUzR1RHbjZPWGJrdjcrdmF0L2FDa2dNTkMvSzkwT1grQnljaXlSTmozeFNvanlrZ2kzaTZaMVpBN0xYQjdEdGZQak5TaGJFaFI0REJxSndwUlBCN1Y5a1o5RGJ5M0FYcUdsc3FSUzAwTlh0ZTZHenlvVFZpN3h5TUF5c0F3c0E4dkFNckFNTEFQTHdMTGNTZmIySDRrTWRKRnFHbUJ3ZEpZZ3QyRVpXQWFXZ1dWZ0dWZ0dsb0h2ZnFSVm1YUFRWaHBnYVJkTkwxZVJiSmhPZkVmKzkwOWdLZEJ6N0syMzJEVmhBaWYyN1NOdjVjT1lJMzRGU1VJeVpGZjRwVlI0SWQ1MC9Gc0VqU09HdnovQ2xuR1o2SGZmSU9DVHBVVC85aHROUTF6STM3b2Q2NVg5YUExWm1NLzhodTdaM3lwMGllNkswN0RWakRYeEpQb05veW5ZUEFGTmg1RUlkczZZRTdLd0F6VHg4Vmd2Rmo3dHJXNy9Nb2Fkc3pCZi9CUHp4VCtxcDlNeTdKcU41Y3BlMUUyZXdKYWJpRFU1QW9WZkJ3QWNnTUFwVTRqNE14blJ1d1dTUGdOclRqektvSzdZTXFJdzdsOVkvWUF0MGJzcDJEd0JtODZib3puUGtCa1RqaUw0Mm9LdWpoa1pxSStmUnF6ZkQzMzBZUTRuRDhUaTRFZkI1amN3N3ZzRXJLYnFBMnpMakViVitIRkVSeC95enU5RWUrQTBCcGUybU1OL1FycXVmZG91YlVIdjFRR0hQY2ZJaXdsRGRLNkR0dTg4YkhuSjFRZlllSEF4aGoxelVUVjVBbFhyRjlCa1pxTHliSWk2elZCTS82eFdmYlhiY0t1SDZGNFhiVTRPOWc4dlFkVnNFUHIxb3lqWU5MNGFlV21iQlNrdkJlUEJ4ZVRWNllzaVBSMWozRVdzNlplcE5leFZqam80NEhUMEtIbFdLeWcwVU9jK3hQaTNTZDgyQzgva3JZVk5JbVkva2pFSFFlTlU5WUVWZFVMUnVnWWhHWFBKRnoyUjJFV2N4WnNUK1I3RVIwVGcwYTBiMmExYWtaNlNRbkt1SzQ3bnp1TU8yUGYvRkNkbkVXdENXSVhBVmhpd09meG56T2QrTDFSMjBHTUlhalZwK2JBN09nNkZRa0ZhV2hwcXRacTB6RXgybnNpbWZZc1d1QU1GRzhhUWsvcFg0WVhWN1lHNjFYUFZBMWhvOWpScXRRNGtHNUt1R1FpN3Vad2k0aHpRbFFLYkhRaDVTR28xS28wU2U1V1Y2QXdqVFFRQjZuUkFWY3UxTURpcjA2WDZ0T0c5K3JaY1VUWWtLakdiTTRmU21lSG1TUTlsT244NGg1SjJPWVkrL1ZwZ0VWVDgrc3NoSEJvRzBqM3ZNSGJPN3J4OW9EV0JmajFwRnVTT2kwbkRZOVVGdUhQeldtdzlGSWVUVHNrVDNldVJwSGlDOXY5bjc3empveXEyQi82OWU3ZW05NTVBUWd1OVN5OENDcWhZUUJGN0I4djc2VlBzK2hRclB1dlRaMEVFQ3o3Rmh1MnBLRHpwU0FtZDBFSk43MzE3dWZmM3gwWWdFQ0Jsayt5dTkzdytseVRzM3RuNTdwdzVjODZadVROem55WWk0RTMyRHh6TW1rNHZVMlYwTUMzdkoxTG0vMFJIczRrVk45ekpGZWQzNDNCK0ZUdXl5bm5xOWdHKzA4TFpSVVpxakRhS3lrMGN5YXNoSlhVU0NhOEhVNXU1ajd6emIyUG45aklrQ2ZaT2VaQ3cyRmdPUlVld0tXWWl1WnR6c0RsbEFuVWkrYVVtSWtKMHZoRWVTcEpNVWJtRlc1OWJ6Uis3aStuZEtaenVxV0dzMlZsSWxkSE84RjZ4cUVXQlRYdEswV3RFenVzUlEyNkppZTBIeWpoL1lEeGZ2amdCblVaRXBXcDVFSEZxZU5ocThiQkxraW1yc3JMN1VEay9yTTdoU0ZFdGc5T2ppSXNJWk8zT1FpUkpZbUI2REtYVlpuWmtsZE1wTVppckwraE1oN2dnT3NZSHQxbzgzR3Job2FnU2lJMHdzS3JLVHBlVUVEb2xCeUVqSUFzU3ZkTENjRWt5R3AyS3lCQTlJM3JIb2hGVkhNcXBaa3ovMXQyOXVNMHlIait0eithRDcvYVJsVnVMdytGQ0VFQ2pVVEVnUFlxN3AvWmtlSi9ZMWdGc0s1VnVNQm5na0RCYUhCU1VtcWlzZGRBckxZeXdZRjJyN2lsL1ZtQmw5dEFQUlFGV2dCVmdCVmdCVm9BVllFWGFSOGJDMDFXd1YzWWZuZVF2MTlvenF2UXFDSWlHcnN2Z2o3OU1IM2FBT0JHRzN3YmJaYWoreXhpdEQ2Ri9GN0JVdzc0MnIxVVVjQ1BRMVNPbHlXY0RyaGRLSFlhNEdPaTZ2QzFWWEEvTUJlNEN1clhEc0dRSDhVSVlmbnRicWZnTW9EK2dBUzQ4dFFuYWNCeGVXS2ZpTmEydDRzTk9VVzFERzZyMHFYSVk0cUtoUzZ1cWVOeEp2MnVCbERyMWZncm8ydzZlbGgzVUY4THdtYkN0VlZUY2ZOTHZpY0Q3d0czQXBjQk5kZi9YQW1sMm12WURHTEFTaXJaQ1FRZzAvem4yS1NlcDhVN0Fla3J0VHE3aGFLQWpjRE5RMDBZdGZMSWM4b1NLL3hkWUFIUUJIZ0o2bitQOUtjQWRiZFNIUGE3aXVycnhkZ3B1QjdDeE9kT0xnZVEyVm1tUHFQalRkVU5QWTZVVWlBWkM2b2F1M0RaV2FZRGV2WHVmcHVLL04wYkZCd0xqbXZoaDI0SFp3Rkhna2ticm8yZFVXaEFFVWxKUytPR0hIN2owMGt1SmlJZzRydUlUenFYaWFtQm1BL3BWRHV3L3d3Y1cxcjAyRS9mS3R2em1OVmV6VzdoLy8vN3MyTEdEMU5SVWZ2amhCMmJNbUhHYWluZDFPeXFuSTRUZzFvR2ZnRStBMzRBM2dMOEJUOWFCbnlwaGRaQ3pnQkpnQWpDNDVWM3h0VG9WYU5UMTdMUFB5cklzeXdVRkJXZDhqeFljdjhQNkpzV3dGeUhMSzVIbDljanlscE91QytwZWZ4aFozb1FzTDBhV05lY3NiOFhaakZhVHJQUzJiZHRJU2twaTFLaFI2UFY2ckEyY1ZHa0g5Zmc2Rlo4SG5RVjMrNTVkZmdHeTZ3eVRDVWl0RzY2NkFGdnJmbDlaMThJVGdLWE5iK0hYejlhaU9wMU9ib29HbkhwMWhjSnEyTmZrcklVR1diNnRybVcvUVpiZlE1WTdJTXYvUnBadmFWb0xOd240d3c4L2xMVmE3VG5CQkVHUVI0d1k0VGtWQjFuV0lzdURrZVZPZFg5SElNdS9JTXZudHdMdzhPSEQ1VysvL1ZhV1pWbGVzMmFOZk9PTk41NFJOaTB0VFg3cXFhZmtvcUlpZWZiczJYSkFRRUNENzVzSld5V29iaEswZ0N4M1I1WnZRcGEvUUpidmJOUjl2emQ1V05xd1lRUGw1VzdUR1JvYXloZGZmSEhHYjZ5NHVKaUxMNzZZMk5oWXdzUERNWnZORGI1dlBneElCM1BObVFlaUJvWUdZR0pkeVBneU1LK1ZQQzFabHFtcXF1SysrKzVqekpneE9CeU9NNzdYWkRLeGJOa3l2dnJxSzBwTFM4OWFicGJiVVluNkZmNDRINGFmMjByV1hSNlVOODZrcXFJb0h1K2ZnaUMweUhnMWROMEpXNXFzNG8yNy90Y3NUOHRWdDg1WmxtVmsyZk1ySStiQndIUXcxY0NCZHNsYU5rZlMwdEo0N2JYWDBPdjF6Ym8vQytLam9kUEtWc3lvZUJTNHFxcUtrcEtTQmgyUXBvU2I0MkQ0M2JCVmhscFBwMmxQbFRjOTNUZGJjbldEZ2hyWTM4SSt2THpWV3RqVGNxQk94VmQ3VU1WYkJDd0lBdmZmZjMrclF0dEFQZGF6S3Q0OGxSNDBhSkQ4M0hQUHlTNlhTNTQzYjU0OGR1eFliMVh4WldjRGZxdXhIeDRSRVNIdjJyVkxsbVZaM3JWcmx4d1lHTmdtL1ZvSGpsVk44OFdYZVNTblZWRlJ3Ylp0MjlpN2R5OFJFUkdZVEtZMjZkZC9xdmhkc1BVZDZDcEFpOVlhdjlXVWJ6czhQRndHNUtDZ29QYXk0dm1OVVBIZlBKYW1yYXlzQk1Cb05MYVhGVStJaHJRMVRiRGlQcitveFFhYU1URDhua1phY2I5WnhmTXVET3dPdGJXUTFhb3pEMTdtcUNSRVErcmFzNmk0MzYzVHNvRm1OQXovUDlqU2tJcjc3Y0swdDJGUUQ2alpBOFg4bGFWZW4vMTA2ZEVEMzYvSjcvcnRxanhrLzNuNllRa2JaelI4bEdkeWJHRGdOeStPWU1YYjU5TzNTNWhmdG5DRGZYanNnQmkyZlh3aDh4NFpSSFNZenYrQmNSU2hVc25NdXF3akI3K2F5Tit2N29wR3JmSmZZTmwyR09uWXJVZzVzd2dOMXZIRzMvdXo2ejhUbVR3czNnK0JuU1hJcGU4aTF5d0ZSeUZJN3Z4VWVvY1Fmbmw5TkQrL05wcHVLY0YrQkt5T1FkVmhQa0xBUUlTNFI4Q1JYKy9saTRiSGsvbjVaRjY3dHg5aFFSby82Y09xUUZUSmJ5RUVqUVpkbDlPL0UxSGdnV3U2a2ZYMXhjeTh2Qk9pU3ZCeFlBQmQ1M1BlSEIybTQvMUhCckgxNHdzWjB6L2F4NEdiSUgyN2hMSHEzWEY4OWNKd09zWUgrai93bjNMVnVHVDJmVEdaNTJiMkp0Q2c5a05nUnpHNDZpL1UwV3RGbnJ5bEJ3ZSt2SWpySm5abzFXZUQyeGJZZGdTcGJENXkrY2R1OEZNa01kckFmK1lNWmYzOENRenVIdUdyd05JSjU4U3lHeVF6c3JNVTJYNmt3ZmNBRE9zVnllWVBMK0NqSjg4alBzcmdPOEN1L1lPUVM5OUJOcTUyaDFrQmZjQlZCYTVxQklON05aNWM5VDF5Nlh0SVdXTlB1Ly9taTFQSit1b2lIcjJ4TzNxdDZPWEFraFZWMUIzSWxVdVFUWnZCVlF2YWp1NTBrUmdPcWlCd0ZDTGJEaUJWTEVhSXVMYkJZb0lNYXViZTFZYzluMC9pOHRHSjdkSy9HMmRLVlhyUUpDT0VUa0cyYkVjdVg0aHNPNHhjL1RNSUdpVFppcUNPQS9NT1ZHR1hnLzdzVDJla0pRYngzVDlIOHZ1V1l2Nyt4bll5ajFSN0dUQWdoRjRFZ1lPUnl4eElSWE5QaWpUc3lPV2ZJQU9xK0tjUklxNEhzWEg3WUkwZkZNdk9UeTlnM25kSGVlcUQzWlJYMjcxQXBXMUhrR3VXZzdNVTFORlF6MENkRW1VNUN0MndqaUwzUFk2aU01ZHJ6M1AzLzhxUHVYdGFadzUrZlRIL2QxV1hWZzlEejk3Q2ppS2txbS9BVllOYy9TT29ETWpWdjV3WnVQSUxKTWtJa2czVTRjaVdIYWlpWm9KNCtpblNzbkVOVXNFVENQcWVZQmhJZUhCZjNucGdBSGRlMFpuNzM5ek9zazFGclE4ODBISVU5d3JzazJzbWdld0MyZW4rNmZHc21zcDkvZG0vN1NXOGsvTUp0UWZXZTZaOFdXQkFvMXRZRTRjcTRtcGsyekVFUXg5UVJ5SkpSdVNxN3h1dWUvZzFxQktlZGF1MFpiZjdIckhoTThLRjRER0kzWGNpVnkxQk1QVEJWVlZENGR3M0tmdG9NYkxUMVk1R1M1dUtvRTA5cnVKb1U4N2NXSnBvOTlpc2lVUFF4SjI5WEUzZDh6aGhOMUM2NERPS1hub0xaMFdWOTFocHVlb0haTnQrc094RkZmOGtzdldndTZVRkRVTDRsUWpxV0dUakJtVEpnaEF3QUNGNHdqbkxyRjI5Z2J6SFg4QzY3NkNYRFV1UzFaMzVxUDRaSWZReWhJaWJFY1FnSk5rQjZ1Z1Rhb3dMdWZwSEJESHNyTlBVdG1PNTVEODVsK3FsSzJqckJIamp4Z0NWSHFuOFk0VHc2UkE0Q01SZ3NCOXpHeHRYT1VoR3R4cnJ1cUFLdnc2NThzdUd2emVUbVlKblhtWGZzSXVvL3VWMzJpUGIzMmlWRnRNMzF3VUc3dTlJTnU5eXU1V3l5MjJnQW9jaGhGME9TQWpSZDU1MmYvbG5TeWg4L2cwY3hhWHRHanlvbTZzUVFrQmZONmc2RUVHYmRrYWxNV1ZzSisvUkZ6QnYzKzBWNFdIejB4TGFqcWlpN25ENzJRME1QWTdDWXZLZmZvWEtKVC9oVFJOVkxjdkRhRTdmMWsyeTJTaDVheUhGYjg1SE1sdThMc1hqMGNSVDVmZExLWGo2WmV5NUJWNmJ4UE1Jc0dYM1B2SWVld0hqSHhsNHU1d1oySGJvbkxscFoxa0ZCYysvUWNWblM1QmRMbnhCR2dhV3pFaDU5eVBFUG9TZ2lUOXQ5a0YydWloOS94T0tYbmtYVjAwdHZpU25BenRMa1BKbXUxTTVSWE1SMHBiVWU3bG0yU3J5bm53SjI2R2orS0tjRHF5T1FZaWE1UjVQQmJWNzJBR3NCNCtRLy9pTDFQeStGbCtXQmxWYTBIVkI2UGd4eUJLdTZtb0svL2t1WlFzL1IzWTQ4WFZSbjNGOGxTVEtQdm1Ld3JsdjRTeXJ3RitrUVdEanVzM2tQZlk4bGowSDhEZFIxOCtyRlptTzN2Ui9WUDIwSEg5YXQvU1hsbE4zSDI1U3MwYmZGSVhWWWZWcVFPTmlrN0lacndLc0FDdkFDckFDckFBcndIOEJZRUVRRUZWaXV3S3Iyd3AwK3ZEcEFIejF4MWYrRFJ3U0VNSjdzK2FoVld1WS91cjBNKzRRRWFBTHdHd3oremF3WHFQbnk5bGZNYmp6WUhyZDEvT3MyMkZNNkRNQmpWckRrZzFMQ05BRkVoVWNTVTVaam0vMTRlZXZlNEdSM1VmeXhickZGRldkZmMxR2hiR0NEKzVld0RzejMySExLMXRhTFFwck5lQ2V5VDI1NHdMM2ZveEx0NTM5QU5ZaFhZZnc5MHYramtiVWNPUFltL2hpM1dKS3FrdDhDM2pXeEZtbzZoYXI3RHkyNDR6dkN3OEtwMS9IZnBqdEorYWhyaHQ5UFlrUmlhMVNyMVpKQUlncWthUHpqaEVlNUQ3U0wvYVdXTXcyMHprdGVkR0hSZHd6L3g1TU5qTjZqWTd2Tm4zbjhRUkFxeGl0eE1pazQ3QUFJWWJnY3dMTHNzeTd2NzdMTnh1KzhUM0hJemt5cWQ3ZjNSSWJ0elAyaTkrODZKdWUxcWxxUHFuLzVFYmQ1M0E1ZkJPNG9LTCsvUEExbzY0aDJPQWREM2UxQ25CaFpTR0hpdzRmL3pzeU9KSkhwejdtMzhIRHR4dnJ6enJlZS9HOXpCZzVvOGsrdU04QXYvZnJlMWpzOWRkNHZIL1hmQjY0ZEhhalFPTEQ0NW5ZYjVMdkFKZldsUExRSncvVi96QkJ4VE16bm1IVmM2dVpQT0FpZEpyVG4wMU9pRWpnOFdtUDg4WHNMMW03YjQxdk9CNG5xK1RjNjEvaW5zbjNOUGk2MldabWQvWnVpcXVMMGFtMUpFZWwwQ081QjZVMXBZeC9laHhIaTFzKzZYNnE0OUhxVXkyQ0lIRFA1SHQ0K3VvNTZEWG4zaXR2NitHdDNQam1EUjZMbE5wOHFrV1daZDcrNVcwR1BUaUl6OWI4QjVPMVlZOXJYOTQrN3B4M0p4Zk1tZEFxWVdHYnRYQkRnWDdmam4xSmkwMURwUktwTWxXeC9jZzI4c3J6V2dXd3pWVzZ2VVdaUFZTQUZXQUZXQUZXZ0JWZ0JWaVJ0cEpUWGN0dmdHbCt4cmhFRUlRcmxUNnNBQ3ZBQ3JBQ3JBQXJ3QXF3QXF3QUs4QUtzQUtzQUN2QUNyQUM3RGRTYitsaC9xVi9HMnJkc05PdkFQWEQrZzVWVkZvQlZvQVZZQVZZQVZhQUZXQUZXQUZXZ0JWZ0JWZ0JWb0FWWUFWWUVWK1dlZ3ZUeGx6L1VkN3F6Y2RhL0doMjd1b0hTSW9MYVZFWmNtRXhwZ0V0ZnpKTkhEWWdQK0M3RDVPVVBxd0FLOEFLc0FLc0FDdkFDckFDckFBcndBcXdBcXdBSzhBS3NBS3NBQ3ZBQ3JBQ3JBQXJ3QXF3QXF3QUs4QUtzQUtzQUN2QUNyQUNyQUFyd0Fxd0ltMGo5UmFtN2VrM1FZNjU3dzRpcjV1S29LbDc4RlNTcURYWmVmSDlkYnorNFhyc2pxYWZGWDcvTGNONS9mRkpITHR0TmxVLy9sYnZ0YkRMSnRKeHdXczg4T0t2dlBIUkgwMHVXNnNSdVdYYUFCNi9mUmlCcTFaUS9PWUM3TGtGQ0ZvdGtkZFBKZmxiK3hJT1BkZndqbW5Pc2dyeUhucVdmZWROcHV6anI5d0hMS3RVQkFmcm1mdkFPTW8yUGNLanMwYWoxWWp0M2xKYWpjaXNHWU01dVBRZVh1aHN3WGpGdGVRKytDeU80aktpYnAxQmo0eWxKUDN6eWJQMzRZN3JmeUo2MWczMXdULzYwcXZBR3d1cVNZZzl0OUhxZXZXbmZKazJxajc0dzg5NUJiaFdJM0xuTldjQjNmSnJQVkNYemM2WFAyZWVIYmk0ek1qc3ViOTZGZmpKb005M09nSHFMQ2tuNnJaclRvREd4N2k3WlIxb3dwZzNtUEgzcnhvM0xKMExmTy9nU2EwT2ZpN1E3aGxMU1hycGlkTkFFK3RBUzhwTlRSK0h6d1R1S3E4OEFmN2hGOGgyaDhmQW13UDYxUy9uQm0yUzQzRlc4RWVlWis5NWs4OEtMb3JuUHJsREZJVm1nMTU5MzdsQkd4eUhrMGErMHFoTjhhTWlBcm43MnNGY016SUY0MmZmVVBuTlQwZzJHNXE0R0tKdXZZYndxUmZWRzhkdERnbWRUbjNXY2JpNnlveTAvSGZLUGx5TXZhQVlsVlpIMkxUSlJOOTJEZXJvcUJORHA5M0IwclZIZU9yTjN5bXJQUGV4Z1hsRk5mWEc0UmFkQXRCVU9SdHdhNGdzeTZpNlBsMFB1TjQrSHFkV3h0UGlLQ2hxOFA5YTYzTWJhcjk2TGJ3OXFtZXJ0ckFueEFVMHhSVDJENXQ2WnRmU1c2VlNMN01ueHUzRGEvbzdrTHM1Y0RXekxKOEEvcUd2bmM4SDJiQ3FaYXpiMVJSVVJlTFNxcEY4R1ZnT2RDRjFhZmlRdUg1NUFjeGVHWWd0TklTY0FaM1FTUUo1M1JLb2lnbytSZDNQM1NQcm4zdllDa2QyMWFjNi9zOEppWFFSZG84SnNaZkVvNTlwbVNSSzlENXc0cGlpd3RRWXFpOGV4bmFYQTVVZ2dOTkZhVDhublg3ZFNrUzU4WGlkTTZJZHJPanRKTW9vRUdGVWNjbCtEUnBKT0R0d3Y1TGRyY3JiMExCa3VHd3c0Wk5XNFJER2NqUnlLN1VQMzA2L0tiT1JaUmxCRU9qcGNGRDIwZnNVNWVlZ0VVVUV0VWl2TWVjell1NXJxRlFuRkxTWDAwblF5dmQ1OWRmWEVBUVgybGxYOHZpTTU2SHIwMmNHM3JBOXQvR1pBMEVnSVRhWXhKaGdSRkYxOGxpQXM3UWNlMkVKc3QyQm9CTFFkZXFJR0JaeXhqNGw2UzZqakR1eE9xWXdzTXRRZGgvYXh2N2RtNWlVT0pSeVV4SHhzU0lSNGJGVTE1b3htZlE0REtsczJwbGZ2eHpCUXVlZ3JUdzYrVVBlWC9rb2Rrc1FHM2ZrbmIyRmgwLy9vRkcrN29PM2orU3hPMFlRRktpRnVtOVp0anNvLy9RYml0OWFnS09nR0pWQlQrVE5WeE55eHcyc08xREJtQ0VOQXd0bFVZaVJUL1BiTDRzSjFCclluNVBKdTh0ZVJTVnFXQjYxa29mVUFaU3UyMENWelVsTVNpQjVuY0xZbmIyTlhYc3Y0VC9mSFRxZWdabDE2VjZ1djNBdjAvK1dpRW9jeDFwdE1jOWFQamhISC9ZUWFQUmROeEZ5eHcxOHNQd0lMMDlmeExWVCtqQm1TTWZUeXF6V1NzelZyNFIvNzZXcVBKaGFpOFRieTE1QlZJbE1HVENOdXk5K0FKd0NGMTllemNIWDV2SHQ1NThoOXk0ajdwYWozSlF3Z0tlVzNzUGNCUnY0K051dDNETTFrK1RvYWlLQ3pTVEYxRkJhR1VTaGhhWUROd2Qwd2YrTzhQTFZpeWdxTlo2MTdGQzdpaUNYbHAxbFdRZ0lpRnFCUTV2UEkxQ01KN2ovZVFnMm1hKy8vNGI5K3c2Z0M5VXhZdEV6R0d1ZjRYODVFcnMydjg5OUM1Ynp3Z016bWZOTEg4S1loeXpEK3cvK3p1RHVsVXg1WkRLRkZjR05CejRPT25NRVFRR2VCVDFaSmtnZENlemFpdzFacXlqUFNhR3FvQ05WcUpqOTNDcmUrZTVUTHVpYXlyYTFxM2p0bFZkSjdkMlZ0Ny9kUTZwaEMzOTBQOHB2SlhtTWUyQU9xUXR0ME5kdHNDOGVYc1F2ZnlSeHFDQ2lFY05TRzRMK0tjT2tKSzYrL1JXdWZISTJGZUlHd0lGV1owTlV1eWpPRDZFaWNnOFJzWkZzLzJNRis3ZHZaRmpLZWF6UDNzYURZMnc4S1duUlRFcW1SOSs5QUZpTkFwYXNteGt3N0g1dXZHSVRIeTNaZGxxV3RSN3c0M2VOYVRQUWVoWldwYUpqMEVSVzVGWVNHbHVBdVNLQ3FBQVZiLzV0Sy85YUo5QWhyQk4yaHhPbjAwenRvYU4waWJtRU1sTXhPcFVaS2EwRHU3THRoTlhZY2J4dXdiSDd2MmlUdC9IQy9YZncyTko3NkRqaHJUTUR2L0QzODlzVTlEUWpWcHFDSU1BVjQzZmhpdHJOOHh0VU9BVVhZK0k3WUxiSnJNamZoVk13bzlhcUNTbnRpRWFxWlBHMmRXek03Y3p3Ym1NWS9FSmZFbjdZUXMxL3ZpZjNnVGxva3hPQklXZFJhWldxWFVEemk5M2paV2lRalV1R0hxSElacUxTTENOb1hXaUFGVldiS05GRW93b3hFYVJ4bjNwN3JMWWZSeHpQOFk4ZXUwbnVxT2EzWGYvbDA3WHo2UnpUbmJuTEZxRDVkQ2tWbnk0QncxbDg2YktGaTdUb3NHd0FBQ0FBU1VSQlZOazdlQko1ajc2QXE3S2E2THR1SW5YOVQzeVZPb0t1VnkvaWdSZC85VGhzZ1d4ays1SE51T3hIMGV0cVdiRTluQkpOL1lNZXpZRUY1QW96eUplbUk4dFFLUS9qc090QkpIUWtCbjdBditmdFlWcnZmL0tQeTE3RWFLdGhiVUVHU1hNZnAvdVdwV2VQaCtuOGp6WS9uRWF0TmRIai9KOFJCSUhjWGYzb2taWk5sYjRTYllEdHVHdGZZaHZENEs2ejBJc3FkbVhkUWFZOHoxMTF5Y25ubysvbFFLNk4xNzhhVG0xNVBHcXRDUVFWVHR2eHB2V3VlTmhwRDZSd2IyOVVhaWNkK21WZ05WUlJzTGZQaVFoSTBsRmtuOHlpVzN2enl1WEp1S1FBa0p6SFg3L3psYkgwaVJOSjZib1RrSEhhQTArRzljN3dzTHlnQzhVSFV4a2YzQkZidFFGemRkUngxU3UyWDRoRGpNSHBjbUYxbUFsUUZ4UEppdVBSbmRtcTRmSDVJOUFaYkJpQ0tud2pIZzRQc0pOSU12ZGRsVVgzMEFpNko5UWl5eklPWnpBbHdpV2s2QmR6K3l0OXVIUEJCRkJCZ3ZnREtza01ManVCUWZtVXlOVVFaQ1FzNGRpNTA4SDEvb29ZTXgzbzBkYkE4VkZHbnJsbEk3S3M0c0tCcFRnZHNOOW9va0MrZ21qTkdoNGZ0SXp4WFp3TWluY1JFeWl4djl5QjVGSmhreE13Vk80Z051MEFHcDBkbmNHTVdsTk5iWG5peWVacEh4VnJ2dklxNE1wYUExK3Q2a1pjUkMzNVpRRThzWEEwaGlnamhxQXF3c1V0bEJrRjlCb1grVFVDZitTcHFiV3JDRkFkbzdZNmxxbzlZUWdxRi9xZ0d2YXVtb0twTWhGWnJxZTQ5WUM5S3FmMStlL2Q2Tm1oMHAweXpva21WTndGTW1UWHFpZzBpZVRVaUJRWTNXMGtDbGJJT2xwbjZTMVU1aWNoUzJva2wrZzdTYnlqaGVFcytxMHJBN3FVVUYzY0VidFp6NHplZHNMMEo5SkNha0ZtY0x3RFUzazR0V1h4N25HNk1veWl3LzE4TTJ2NTY2WTA3cnAwTzhFNko4ZTJES2ZHcXVLU0xqWjNLa3lHNi92WTZCb0JlWHZPdzZCMWN0dEZ1OENjak9SVSt5WndwVW5INkFHbGZQdkN6OWlOTWJ6MzlYbXNPNlpoUktxTDZYMmRiTTNUOHN3SDQ3RFZSckxvc2FXOE5Hc2puUlBMRysvb2VCdXdWcFQ0ZmswU1g2em9oYzJoeHBiVGcrVy9CVkZ0MllBb0NmeXhhaVMxbFFrQXpQMTBNTEs4R2JYSzJmaGNYSHU3bG8xM1FjM0lrb2pMcVd2cXJXZWVUUE5tY2RvRFVLUVpVaytscHcrYWYrQ2lncCs2WGxMd1h3Umt2d0NNUElXeG5wWE8weWNHM256ZUlpNGYrU043UTNyNFpRczNPQ3l0aXhyRm1QUFg4WERmVjZuUVJ2Zy9NSUFrcUZpWWVqdURMOWpHZ3JTWk9BVzFmd1AvS1ZXYU1CN3A4ekpqejEvTDJ1alIvZzk4UE9RSTZjN2xJMzdreGlIL0lUdWdnLzhEL3lrL3gxL0NzQW1iZWI3SFB6Q3BBLzBmR01DbTB2RkcxOW1jTjJFclh5VmZqWXpnTThEMWFuckpBem5tbjQ2RUdKcGF5TEJ1SW0vZWJtQndaOUg3QUFWQjhIaTB0T0dBaS9NZU1uTHIyeGFLcW1UL1Ura3p5VWUvMitsNmR5MnZmRy9EN3Z3TEFBUFVXbVFlL3NSS3IzdHIrV21MRTFuMlptQVAxdTVnb2NTVUYweGM5SnlKL2ZtUzc3ZHdlRkRqTFBPdjI1MzB2cStXQno2eVVtV1NmUmY0OFdrNndnSWJCKzEwd1JzLzJ1aDZkeTBmTExmamtud01XQkRncWhFYXBneHVtbjlkV2lNejgxMExneDh5c25hdnMvMkJLekl5S3hwelU1OE9JaDJpVlV3ZHFtbldoMjQvNG1MMEV5YW1EZjZRM1FGSlZBaENxMTBlYWVITGg3aGJkdElBRFlINjVudFozeVpONDd3Slcza2wvUkdzb3I3dFBhM2hJMy9PK3lOcVJMMDk0clZxZU9WbUExZVAwQ0FJb0JJZ05GRGd6K2MzakZiNWVKOHNxWmE1L2cwem13ODJmWEZ2a2lXUFp6T2Y1Tkw4SHp5YWJUbHJ4cU1oc1R2aDd3c3R6RjFpSXlKSUlDcmtCQ3hBa0Y0Z05FQmdYNTdFdUgrWW1nVUxrR2RJNHRiQkgzUFp5Si9JRE8zVk5uMVlGb1FHdjFwWmhqZC9zakhxY1NQNTVhZWIyUGQrdFRQbUNTTjU1UzAzdnpySmlsWnl0QnB3azh6c3hpd1hlL01rRWlQcks4YVNEWTRXdTVKcHhzTzhrUGs0RnhRdGE5VUVZcE9NVmtpQXdOaGU3dS9vU0xGMHZPOWVkcDZtMlJVSWNocDVOdk5KMXE4WXhvVkZ2N1Y2dHJSSndCUDdxZEdJOE9IdmRucmZaMlIwblJwZlBrVGQ1TFhsQWpMWFozL0tsdVVEdU9mUTIyZ2x1L2ZGdy9QdU5MQXh5OFhISzA1VUxqSllZTkY5QVR6NXVaWHRSeHBuc0Vha3UrUG5nWjFhUDM0K05SNXVVaDkrN212YmFVYXJ2RlpteWdzbTRzTFByU3hKa1NwZXZrblBqSkdhVm4vYXdDTkdLLzhNVmxpU29hRGl6QlphcjRHSHI5RHg4Qlc2RmprcWJRN2NISmsrUXNQTE4rbnBFTzBkVTlIcTFvcUgrM1lVZWZOMlBXTjZlbGNDMytPMWlRb1JlT0U2UGJkTjBDSjY0V05nOVlCYjByNXFFZjUya1k2bnIyNThuT3l6TFR5eHY1bzNialhRUGNuN24reXIxeFREUnYyU3V5RnllSkszdVlPZWpKYWExY0pCVGlNUDczK0pPNDdNYnpNUHFWMVVXa0RtdXV6LzhPVGU1NGkybGVDTDBtamdJZVVibWJ2N1VmcFc3Y0NYNVp6QUNaWUM1dXg1aXFsNVMveGkzY2NaZ1hVdUsvY2VmSk43RDc1SmdNdU12MGlEd0pmbmY4ZWNQVStSYk03RjM2UWVjSHJOZ2FySDlyMlFOS0pzUFlyNGlaenFBOHIrenFqc2VxZ0Erek93OXE4R2ZCaTQreThDL3FlSmxtV1FjMEcrRzJUdDhVY3JmUG82TjdDZmdUY2UyRS9BbXc3czQrRE5CL1pSOEpZRCt4aTQ1NEI5QlB6TWpyWGN3dURCR1JGaHI3enBwdnlxVzI0cGxyUmFyd2hFMHRQVGgzdThoVSs3a3BKaytaMTNaTmxtazl0YldrV2x2Um04YllHOUFMeDlnTnNSdkgyQjJ3SGNPNERiRVB3dm53QlFWRm94V3Nxd3BEZ2VQdVZhZW5RVmp5VWkyTDd6K3JINTIyOGFWK0xTU2pKWjg3MTdHcUs1MFZKZU9NeWRCQXRHZ3QzYm5xdWU1WUUxSGo0QjJwVDVZWDhFYlJhd0w0TTJDZGdmUUJzRjdFK2dad1gyUjlBR2dmMFp0RUhnVHMvN0wyaUQ4YkMvdy80bEV3QUtzQ0orSnZVWHBzM0U0NXNBZHFwaDQ2RXZHTnFPakVzRXVGTHB3d3F3QXF3QUs4QUtzQUtzQVBzaHNPUmR6eFcwU2dROE5oWEdkNElZQS9TUFo5Q2V5eUdzQ1BSYklYZ0o2S3grMHNKRGsrRHI2K0NOeTBCMndzb3NjRWc0QTllQkt4OXFwMExKU3FpODBROWFlRVkvZUdHU2djVWJ0ZnpmMTJCeHVOWDVxaTVJVVJ0bElnNkJORittWmpSWVowdVllNXRJZk1UOUhwOXI0Y3ZTNEluUllQN3FjcVptYU1uY0dVSFJpaGdLMThiUWJhVTJJQ0k0Z3FEWVdFTGk0ckIxQ2tUMzM5R1U5b0xEei9sZ0MzY0xnM2R2Z0dvajZGeEdpbU5MaVpKTDBSd0VsdzRxb2lGVVhVcjRRWkFGcUlvRlhlVXhISHZCZEJIc04wRDZBejRFUEdjYzFOUkFXQmpvTkRxaVh3U0dqOGV4N2hrRVFTYXB1cFNnb1lFNDV3VGdXTG1DUHE4OGpXdG9ETmFrZllnN1FaME9UdHB1cy9vV3EzUlFFT3d2QUkwYVRDYUJvQ3BRaDBTakd6NGMzZkNSakhuYnd1OVNaM1FqUjZKTzcwNWdGV2pzSXFsL2grVGJRWk1HbG80KzBvZTFNcVRId3ZzYllmazJVS3NsOGk4RktkaDIvRDJ6YitqTnlINXh4Ly9Pbnd5MktDdDVqMEh0WldEWkNZN0pQcUxTbDNVSHV3TXVTWWN0dWRCTHNsRitQcVJWRmpONzducEc5b3RsNVpaQ0VxT0NXUHpiSWVaMGNsQjJBY1JYbEtIUGdab0JJSFNCTWhraTN2T0JGbGJMYnVCZ0hRUnJ3V25WMGY4VENEc1doMHVXQ1F4UVk3TzdpSXMwVUZGakpkeWdvditIRUxzOUZuc0lDRUZnTW9KTjloR1ZYcklmUW9KaFFRWVUyc0VlNkNKa0IraHlLcGozNkhDdUdKdktSU09TaVluVXMvTDlLVVJVRlJPV0NhcXdjSVJJQ0ZrTklUbVF1TTVIZ08wQzdNMkhqakV3ZnpQTU0xY2hxVUFxM1lBMTAzMTQ4MXVMOTNBNHJ4YTd6WWIwKzMrUUE4SFZMNURnSzl3N0tHb0hnbmFaRHcxTEdYbHd5eENZMUExaUFqWlFYVFdLN041clNabDdDZHc0bitYL0drZU1zUVR6ZFg4bmU4SVdraElqS08yL2w2UkVNUDBMbklkQWY5Q0hnTC9KaEJsOXdXeUVUemJiV0pSWXc1eTF5UVN2eUVYNzVjVm9CUUcxTEJNQTFCU0dVSDd4V0RUQjMzSW9EOUxTb1BadzJ4NFlVMytQdG9FMCtjeTBVak5VMU1LTW9lQzB3TkFleFZnSGh4Rm9tSXhvVmlOV1Z1SklUc1p5NFVpTTkwYWc3dkVyeHNNUW5BaGwreUQ5cWxabjNQY01lUGJNdE1WNzRLV1ZNSGtnYk11RjhRdHpTS240Z2tIajk3TnhWYm85WjNRdDl1MC9FWFhWYXRUUFFsZ0gwRzJFWG0wNC9ubzhXcHEvQVE0V3d5UG53NGJac0h3UEhDeTJvaEozU3VwZ01FMEY1M21nNlFMQm4wRDRhMzZRQUZoNUJGWWRoY3ZUWVZ3WG1OUWRkQ0phODBRSUxZZVFWUkJ5SzJpci9TampJY3Z3M1Q3M0JaQldRY2JCYnhqaUxjbXpWcStIb0ViMnBreWhrclZVZ0JWZ0JWZ0JWb0FWWUFWWWtWYnovRTcrNDZJbGU3NEJZWnAvSWNwTGZwbldVMW1ZcGdBcndBcXdBcXdBZTZPMFNnNWNFQ1Q2Qlcya1orQTJZblQ1eEdyenNVbDZpdTJKRk5tVDJWZzFqbnhiUjk4SDFxcXNYQnI5R1pNanZ5Sk9kK2FkaTI5TmVKV2R4aUg4V0hJREc2dkgrU1p3a3Y0b2o2WGVUMGQ5VnFQZTN6ZG9FMzJETnJHc2ZDcno4cDdFSnVsOXB3OFBERm5IbTEydmJEVHN5WEpoNUxlODNtMEdvZW9LM3dCTzBPWHdTTWZaNkVWTHM4dm9xTS9pNFk0UG9oSmMzZzJzVmRsNFBQVStBc1hhRmxla1gvQkdyb3Q3eDd1QlI0WDlTcXJoZ01jcU15MzJRNExWMWQ0TGZGSFVseDZ0akVhd016NzhlKzhFanRQbGtoN28rVE1meGtYODZKM0FDYnJzVnFsUWdqN0hPNEdqTlVXdFVpR0R5dVFSSStoeDRDQjFUYXRWS2tpczhUN2dDbnRNcTFXcXdoSHRmY0NsanJoV3FWQ1ZNd0tIclBVKzRHeHJGNXl5eHVNVk9tenVRV3RLczRGcm5hR3NxNXJvOFFvdExiL2FleDJQWDhvOFc3bHlleXlicThaNkwvQWU0MENXbFhzbWJ5OGo4RmJ1czdnUXZSY1k0TDI4SnozUzd4WVgzczJXbWxIZUh4N2FKUjNQSEgySHZhWUJ6UzVqU2ZHdExDNiswM2NTQU9YMldCNDcrREZmRjkvUlpNTTM1L0I3ZkZqd0lKSXN0Z213eDFJOFRsbk54d1gzczZ4OEtwT2p2dUtDaUcvUEdPcGxXN3Z3YytrTVZsWk13U3dGMFpiaThheGxnYTBEQy9NZjR0UENlMG5TSFNWV2wwOU1YZGF5eEo1SWtTMlpRbHN5TXUxejNHZXJMVlcyU3pxT1dOSTVZa25IbTBTWmVWQ0FGV0FGV0FGV2dCVmdSZHBNNnZsM2UzcW1lSHpITkMrUUpUMzM1Q2dMMHhSZ0JWZ0JWb0FWWUFWWUFWYUFGV0FGdUlWU0wwMmI4T3pMaFpMVnV0R3ZXbFN2TDJUYWpJYWpKVm1XV3oxYU1wdk4yR3p1M1poME9oMEJBUUd0SGkwSmduQmxneTNjbXVKME9pa3NMRVNsVWlFSUFuYTdIWTFHUTNsNU9Ra0pDWWlpajgwdG5RczJQejhmVVJUWnNXTUh4NDRkUXhBRSt2ZnZUMFJFQkxtNXVTUW5KN2NKZEpzQUZ4WVdvdGZyV2Y3N2NpeTlnbkFrUlRJbFpTU1N5OG1hSDM2blI0OGVpS0pJY25LeTcxdHBzOW1NSUFnc1dyU0lud0l5K2RlMmI3aXE2L2wwQ2s5a2MrVUI0c2QwNWNDQkF3aUNnTmxzOW4xZ204MkdJQWpFeHNieXYveWRmREw1VWNLTnl6Q1gvb2ZMVTBlenNYSS9PcDBPV1phUEd6T2ZINGRWS2hWNnZaNkl3QkFPVmVVanF5S1FWUkVjcU01R0sycXdXcTI0WEs0Mk1WcXREcXpUNlpBa2llenNiRjRmZWpkMy8vNGFMK1htczEvdXpOdDd2bVZLN0RCY0xoZHF0UnE5dnZXZmUyaVRjVGczTnhlejJVeGlZaUxGOWtxK3oxbE5wRDZjaWZHRENkZUZVRnhjakVxbGFpMmoxZmJqY0VKQ0FybTV1YmhjTHVMMWtjenFmUGx4VmYrejN5WWtKUGpQT1B6bmtGTlFVSUFnQ0tqVjZ1UGpzeXpMSkNVbCtaZmpjVEswMld6R2JyY2p5ektob2FFWURJYjJDeDcreUN3cmlRclZaYlFCdnZ1SDBRblV0dW9ubFZYYlNzNElQT0tPMzJPQXdYNFdFZVlvQ1FBRldBRldnQlZnQlZnQlZvQVZZQVZZQVZha3lWSXZ4Wk83WVh0ZTB0QitpVTBwd0dWM2tKK3htK3pWR1dTdnphQWs4NkI3QzJMdmtTV3o4OWQ2THNVamFqV2tqQmhBeW9nQmpHSVdsdklxc3RkdWNWK3JNekFXbFhwVkMzczg0MkdJRENQOXN2RkVkdWxBUktjVWRuNzZQVFc1UmY0SGJDd3VJMmZORnJMWFpKQzlkZ3Ztc2txdjdNTXRCcmJWbXNoNCt6OXMvL2hiSENZTDNpNHRCdFlGQnpMeXNWa01lL0JXQ3JmdTRkaXF6V1N2eWFCNGQ1YTNHUy9QcXJTbzBaQTB0QjlKUS9zeDh0R1pXQ3FxT2Z6Yk9qYSsrUWsxZVg3WWh3R1FaVXIySEhMMzR6VVo1Ry9laGN2dThMOCtmUGpYdFJ4YnZabnN0VnV3bEZmNWZ4K09IOWdUdTlHTTNXUWhiOE4yN0Vhei93SURoS2NsRTU2V1RMOWJwaUk1blJSdTNVdjIyZ3l5VjJkUXRITS9zaVQ1YVI4R1ZHbzFNYjI2WUtzMVlxc3hZU3d1bzdhZ3hMK0FaVW1pZUhjVzJhczNrNzFtQ3dWYk1wR2NUdjkxUExhOHQ1ajkzeStuT3Fmd3IrRjRqSGo0ZGtZOGZEdFYyZmxrcjlyTXNUVVo1SzdmNXBYR3k2TjlPS3hESW1FM1hVSGZtNjVBY3JvNDhOOFZyUC9uQi83cmVOaU5adkkyYkNkN3pSYU9yY21nOG5DT2YvYmhuWXUrNTlpS2pSUnMzZU8xeHNxamZianZqWmNUMFNtRnlHN3VzYmNxTzkrL0hROWRjQ0NkSjQyaTh5VDMxakxWT1FWa3I5bEM5dXJONUt6YmlxM1c1RFhBclplMWxHVnZqQTQ5MDhLMldoTzU2N2R5YkxWYnBhdHpDdnhYcFcyMUpuWjkrajFIVjJ6eWFnL0xvMFpyOE4zWE1manU2M0NZTE9SdTNIRThaVnR4TU5zL1ZmcFAwUVFhU0JzL2pMVHh3NUNjTHJKK1dzbjZsei93S3BmVG84QlZ4L0xKWHUzbnJxV3Qxc1NXZHo5bi93Ly8rK3NFRDhNZnVvM09rMGNkdDlKK0hSNENDQ29Wc1gzU2llMlR6cEQvdTZHZThUcTBkRFcxaGQ0ejNlSnh4ME55T2luT3pLSnc2eDRLdDJaaUxDNzN2eGF1UEp6RHNUVnVkYzdkc04yclp5QmEzTUsyV2hPRjIvZFN0RzB2UlR2MmVmMTBpMGVNVm84cko5SGp5a2tneTVUdVBYUThIczdmdE5QL0V2SDFyWmRBZE04dVJQZnNRcy9wa3ptOGJMMy9Uclc0SEE0S3RtUWV6Mmw1NFVvQXp6a2VmOG5wMHY2M1hWazNpYmFGN0xVWm1FdjlkRUw4VHdtTWlheHZ2UFlkSm50MUJqc1dmZWVmU3g3K0ZITlpKVG5ydHJwYmUzVUd4dUl5LzJwaGw5MUIvdVpkeCtlRVMvWWM4a3BqOVplVmVndlR4bHovVWQ3cXpjY1NXMXBvN3VvSFNJb0xhVkVaY21FeHBnR1RXZ3dvRGh1UUgvRGRoMG10Rmp4NHV5akFDckFDckFBcndBcXdBcXdBSzhBS3NBS3NBQ3ZBQ3JBQ3JBQXJ3QXF3QXF3QUs4QUtzQUtzQUN2QUNyQUNyQUFyd0Fxd0Fxd0FLOEFLc0FLc1NCdEwvYVBhK3kvd3lLYjR6cTluRm9rcUthNUZaUlNyaW5LdkRZbnpBT09TdEtOVnlsR2VDckFDckFBcndBcXdBcXdBSzhBS3NBS3NBQ3ZBQ3JBQ3JBQXJ3QXF3QXF3QUs4QUtzQUtzQUN2QUNyQUNyQUFyd0Fxd0Fxd0FLOEFLc0FLc0FDdlNSbEp2WWRvZjU0MzB1ODNzaG05ZUp5aDlXQUZ1b2RnMUVxNUk1MThIdUR6S1JVV3lkNW9EaisxY0ttazFPT1Bqa0FKMDdCUWNWQ054UmU4QTFCWVg1R1NqOHBKOXBsc01iSThJeHpFa0dsM25SRXc3TnlEV1ZqRzhjeURCMFpHWTF4ekdGbUZBUEw4bmNyVkV3SlphaENQWnZnc3NEVWpEMWMyQjJyd1gwV1VuZEswVmxheUhicURWQ0FpWldzQ0ZzK05CdE1GQkdQdmFDT3pXQzNscHBtLzJZWmZhaGNaY2dMZ0JYS0lGUzNjTE1sQmRhNmFtb2dTWEFMWW9CNnFFVUJ3WnVlakxpcEJFbSs4YUxkWFdQTXBOVG15Qk1WUWRPSWdyV3NJNHNETnFodzE3aFJINzhFU2NxWGFxczdLd0dPT28wbXF4cmNuelhaVVdYUzZFVEFlVmFlVm83U0FibkdnRHRvTlRRQ2RMMklMMmdRTmtwd3BqWERYV1kzWWlhaXkrYmJSaWlyU1lldGFnajVWUnF3UlVLaGxKQnBkTElraWxRa0pHNDNJaTZhcFFid2oxajNINFNHRTQrdWd3WkpPTVM2T21ScWNqMnhtRUdLcERyaGFKVEF3aHF6d010UmNNemZVYzY4bWpibXQwbFhwRzZ1a3RHOTFxb25JUkdteEQwS2tSSFhaVUtuZkJMa2xHMGhyQWFxZldvc1ZpVnlNQU9XSWdmNVMyamZGYXVuYWhjRWFWWGl0R05ycWdXSldMTGdXN1NianZIaXlIRG1GeGZvTzF3ekJTaDkxTDZaTHZjQldYa2pqclZnNGZXazVJL3NlWU53OGs2YTRieVg1K0xrY0NPelRwczd4R3BZUEdqaWJ4eXFtWTl4K2tjcmNhMDg0dG1Hc1BFamxvQUlGZE82T0pEY2U0OFJ1SzFtaXg3ajlJeEpCQlJGMS9qVy8yWVZtV2laNTJCUmFMaGNCaFF6RGs2VERzVnVQYVhVajQ4R0dFRGgrQzVjQXg5RnNrREVkMWhKdzNDTHNzRTNQSlJTREl2Z2NzcUVEZnFRTTJzNW1FR1ZkaDZOMExsVmxOWUZvM1ZGbzE0VDE3b291T1JIUUZvNG9JSiswZmoyR3VxY0VoaWtTbEp2bmVzS1RWYWNqZG4wVnNVaElsMVZXa3pYMk9IUjk5UkVGWkNmbS9MRVd0MVNGWnJLaW1Ya3JLdVBNeFdxMVlMR2JzeFNXb1JNSDNnSzBXRzBFYUxaWDVCZGhGS0xMWnNXM1pScGhUUWg4YlMyaVh6aFJzeWtCOUxKZWM5SFFpb3gwNHJWWlVvZ3E3eWVhREtpMEFMaWVCSWNFWWdrUEFac2RodHlNSDZSRkVFUVFRd3NPd1NoTG0ybHBDWXFJSUNnNEJaRlJxbGU4Qkk2dW9zdHR3cUZYSW9ocFpKYUJQU0VDcjFtR0lqVVliSG81T3BTWTBOUVdOMDRuTjZVSUlOaUNydFJpcmpiNm4wb0lnb0E4S1JoQkZFdUlTS05pYVFleTFWOU9oWnkrMGdRR0lvb2crS1FsSmNwRzVmRGtHclJhcnlZeGFwME9RSk4vMHBiVldHd0Z4c2U0dndDVno5SlhYY0E0YmdqNDJqcEJPYVJTdVhJSHJhQTd5dU5GZ2R4QVlGSVJLRkxFWnJZRE85eHdQWjM0K2dxakdVbHRMeWJidGFDTWpJTWlBU2hTUkJSRER3eWtYWkF4V0d5NkhBNHZWZ213MnRldFpMczBHZGlMZ3JLb0NsNHZhL0h6Q09uVWlmT0o0SE5rRkNDNFhva3JFZGVnWVlZTUhZZWpkRzB0aEFXb1pYRlUxdEo5Q242TFNsNDN1M2VnYnUwdTFhR1d3RnBkUThPTXZCQTN2UWtoOEoycU1Kc3dhRlphU0l1eTl1aEhWdXhkT3dVTHAyazNFVFppSTJtWW5QaldaeThJNnRnbmdaNnZPRWkzSmN1TjF6VmxieTg1Ly9oTnpXUWxxWVRzMUFUb0M4enNRTUhZMG9SZE1RRURDbkp0UDlhdi93cGt1bzlQbUk1ZjFSWWhQcE5kVlZ4UFVxMmZiaElPQzRKbXBGblZ3TUFGcUY0Wk9td2lPY1JKVmFVZDFOSWZRd1FQUmF0Vm90VHBDa2hKeGxaWmpLQ2xHYXhZSTZMY0ZiZGtPQXJ1bisyWUNJUEhLNjdIc00xQ2JxeUZzcEEwcFJZVSt6RDMrcWdVVm9scU5ZV0FLWVFQdE9NMEMxb01hRWliZTRuWk1mQkU0cEZkUDBzYjhEYWxZNU9oUk1DUW1ZNnVveEZKZWpxV2lBa2RsTmJxMEx1U1h5VGpNTWhFaFU0aTc1RExmVHZFazNuQXRDZU91SWpUWFFOakFDd2hRaTJnbEY2ckthclJBMUpBSkJPWG9pZWg2RVdtUFBneXE5cDIvYTdiUk9sV3FNN2FTOTkvL1lwZGtkRkZSSUFoSXRkVUlMb2diTllMSXNhUGJCZlpVbytVeDRPUFd1Nm9hYTM0K0NBSzZtQmcwVVpIdDI2S3REZXh0NHJGaHlWZEZBVmFBRldCRmZNdHFueklzZVdUSE5DK1RKWUlnS0R1bUtjQUtzQUtzQUN2QUNyQUNyQUFyd0Fwd0M2WGUzTkxzZjIvdm1sMW84aXZBRHZHQlhjOEl2SFZmUmNUcUhTVitCVHltWDB5RTBvY1ZZQVZZQVZhQUZXQUZXQUZXZ0JYZzFnNGVPbGNmME9vY2VYNEZtRnlkcEYxOUp1QUw4bjRMNm0zWjRWZkF1L1A2QlMxVStyQUNyQUFyd0Fxd0Fxd0FLOEFLc0FLc0FDdlNWS20zTUczRUY1K1kxOXRHR2Z3SmNJUnVyV1g5akpzQ2xENnNBQ3ZBN1cxczNJOWpHQVFMb2FwcUFQU0N0Y25scUgwRlZvMlRFTEdXQ0ZVRmF0bEpyUlJNc2pxUGFpbUVFbGVNZndFSHFzd0VDQ1k2cXc4akN3SUdMQVNMUnFwY29jU0x4V2h3VXVLS3hvSEc5NEVOZ29VZ29aWXdzUnBSa0VoWEh5QmRtMFc1SzVJOFZ3TEhIQjBvSnBvWXNaUmlWeXhPUk44RlZ0VTlXdTFBUzFmMVFkTFVSeG11MjBTd3lvaWdobkk1Z3RYQ0NQUXFLMnVzSTlFSWRweXl3WGVObG9RS3JXQW5WVHlHaU1SQTNYWkN4QnE2YWJKSTBXUVRLWmJUVTdzUGplQ2dtK1lnTWtJanZrUXZGZzBPd29RcWRJSU50ZURrc0RPVkdMRVVuV0FqVkZXREFTdUZ6amkwZ2dPOVlDVmNWWVdJeTNlQkhXZ3d5NEhZWkIxT1dVMG44UmdsemhpTVVpQmxVaVJXdEtTbzg3RExHcXl5SHJOc3dPWExmVmhBcGx5S1FPMXlFcXN1NFEvYkVNN1Ria1ZDd0lWSW1SVEZKdHNnbkxLYWJHY3lKaWtJQWZtc3F1M1Z3RElDT3NHR1dUYVE2MHlpekJtSlVRb2tYWGVRR2xjSU9jNGtEanZUS0hiRm9NWUZnb3dzQzc0OUxGbGxQU0lTT2M0a3Vtb09jZERaaFd4WEN0VlNHQlpKVDZES2hFVTJVQ01INDVUUGplTVRqb2RKRGtDTmxuMk9ia1NyeXRBS0RySWNuVWxWSHlQSGxVS2xLNnhSRnRwbmdBR2NzcHBhT1JpYnJFT0RBd2tWZWE1RWJMTHVuUDNXSjRIL0ZMdXN4WTRXQUp1c085N1hsZkJRQVc1QXBWOE91YTlpY0ZKMW9qOEJadVNGVm94UVZGb0JWb0FWWUFWWUFWYUFGZUIyOTdTdS82cjNSdG5QdHJVUVlDT3NWVlJhQVZhQUZXQUZXQUZXZ0JWZ1JkckM4em9oOFF2eHU0MDhDMjlEMmNoVEFWYUFGV0FGV0FGV2dMMUVXalFocmhjTmlDb1JoK1ErYXRlZ0RzRGtxTVVwdVE5YkR0UUU0WkpjUkJ0aXlUVWVvMk53SndJMXdSU2JDd2pWaGVHU0pYSnFqeUFnb0JKVWdJQkRzbnN2c0tnU0dSRS9qbUZ4WTloV3VwSEV3QTVFR2FMNW8zQVZLL0tXY25QNjNlUVpjeWkxRmpFcVlRSzE5bW9tZHJpTUExVjdTQXJxeUpTT1Y3STZmemx6TnQvUFJSMm4wVEc0RTNuR2JMNDgrREhodWdqR0prNGtLYWdEVHRuSi9NeC8wVE9pRDF0S05tQjFXZHBIcFNQMTBReUxHMFBQeUg3OHZkOC9DTlFFRXE2TFpFRE1VS0lOc2FRRXB4R3VqNkRTV3M2Y0lhK3pzM3dMb2lDeU52OS9GSm55K096QUJ5UUVKakVoK1JKK09iYUVvWEdqU1EvdnhkUk8xMUpoTFdQMmdEbE1TWjFPcEQ2YWUvcyt4b1NVUzdnK2ZXYjc5ZUdMT2t3bE1TaUZja3NKR3BXR1BSVTdzYnZzbEpxTEdKTjRJU3Z5Zm1GSFdRWnZqL2tQaTdNV2NsdVBlK2tSMFpkcnU5M09GWjJ1SmQrVVMxeGdJa2xCSFpqWjh3SHlqTmxrMXg0aDM1aURWdFR4K1lFUDBLc043QzdieG82eURHcnNWVmljNXZZREhoWTNoZ0pUTGhkM3ZCS3RTc2ZjWWUreXIzSVhLY0ZwZkhQb1Uwb3R4ZXl0Mk1rVEcvK1BqVVZyVUF0cTdsbzFnd09WbVh5MDkyMytLRnpKd3IzLzVwTFVxM2crNDJGRVFlUkE1UjQ2aG5UbXljSC9wTkNVejdHYXd3eUxIME9NSVk3OWxaa2tCWFZvdno1ODYrOVhvQkcxaUlKSWhiVU1oK1NnMEpUSGJUM3VaWDNoQ2tZbWpHZEkzQ2lHeFkwbFhCZkp0YjlONU1idWQ3R3BhQTBMeGkxaGZQTEZQSmZ4RUplbFhzMjB6dGRUYWltbTBsYk9tTVFMbWIzdWRrWW5YTUNXa2o4WUdqY0t0YUJoYStZR0x1b3d0ZjFhT0QyOE42K1BYTWp1OHUwWTFJRmMwKzFXUHJuZ3YwUVpZcmkvMzFPRWFjUDU3dkRubUowbVZ1VDlRditZSVZUWktuaGk4RDhSQkJWZlpIMUlvU21mWE9NeGJrcS9pM0pyS1RhWGxmakFSQWJIakdCUTdIREtiYVY4c204ZW94TXZvTlpSUTdRaHR2MWF1TXhhekQycnJ1T0Ivayt6cDN3N3U4cTJNRFpwSXFJZ01pL3pOYXB0VlRnbEorRzZDTEpyai9EeThQZUpDWWhERkVSMmxtM2h0cDczMGl1eVB3SUNueDU0bjVIeDQ5R0tPalFxTFp1TDExRnFMZWFxempkeXpIR0ljbXNwOS9WOUFnR2gvVnJZN3JJekpYVTZJeFBHb1JHMTNKQStDN1BEaEVOeWtGVzVYYUJYTndBQUlBQkpSRUZVbDNGSmsvbis0clVzM1B0dlVrTTZVMmpPWStBWGlSeXMzSWRhcFNHcmNpK3I4bjlERkVTK1ByaUlYT014d25VUlZOc3FtWkk2bmR0NzNJdEcwT0NVbmV3dTM0clphYUxDVnRZK3dCcVZocEVKNCtnVzNwTk5SV3NabHpTWmcxWDdHSnMwa2NVSEZqSzl5ODNNR2ZJNmIreDRqa0JORUNQaXg3R2xaQU9mWHZBTDY0dFdjc1hQby9rNWV3bVo1VHZZWHJhWm1JQTQra1lOSXNZUXgzZEhQbWRVZ3J1MUwwNjlrdHphb3p5eDRmK1l2K2NOekE1VCs2aTBTM1p4VGRmYmVHYnpiQlpQL0EyREdNREc0alU4dkg0V0l4TEdVV3V2NWw4N251ZmxFZSt6T244WnQ2K1lSb1cxakF0U3BuQis0aVFTQTFPSUQwZ2lOYVNjdlJVNytmN2lkZHkvOWhhT1ZHZng1YVQvTVhmcjR5ekwrUkdBMmYyZkpydjJDTGYxdUpmSE45elQvamt0bGFCQ0ZOUU51b1dpSU9LU3o3NHNYeWZxVWF2VW1CekdPdTNSMWl0TFFDQXR0Q3VGcGp6TXpxYTE4S2s1TFk4c0xwVmtDVW0ybjFFVHppVTJseFhiU1c4NzlZdVRrVGxjZlVDSmxoUmdCVmdCVm9DOVF2cEdEZkxPak1lcGNtWG5HN2luOXlNNFpRYzJsdzFSRURHb0E0NWZldEdBUzNKaWsyellYRmJzTGx2ZGtGVC83ODVoNldRVS80SEZaYWJDV3NZcjI1N3lXQjA5UHBrV3Fnc25OYmd6YXBXbURzWmFEOG9wT1ZDcFJEU0NCclZLZzBaMStzOW56bnVEd3VvY0RPb0FMdXgwT1YwL0RjSG9xRzFXZlU1MVBMeHk5akF4S0FWWmxsR3IxQ1FIZFdSOTRjcG1sOVVxbnBhbkpkK1ljL3ozbk5xamlwVldnQlZnQlZnQlZvQVZZRVY4VTA3SmF1LzVCb1I2enp6b2RBSTJXL004VHIxZXdHcHRiMisxUjlNV3BrMmZIa0t2WHJwbWZkVE1tZUdrcEdoOHF3L1BtQkhDakJraHpTcjgybXREbUQ0OXhLdUFUd3NlQk1FTk9XWk1BSUlnY09HRmdRd1lvQ2NxeXIwRHl1ZWYxN0JtVGNOenRJSUF0OTBXeHFCQmV0UnFnU0ZERE1USHErbmMyZDNLQ3hkV2s1Rmg4YTRXbG1YNDhzc2FzckxzM0hSVEtHcTFRRnljbXFsVFExaTJ6SFJHMkQvdi9lU1Rhb3FLWE54OGN4Z0FLU2thTHJra21PKy9ON1k3N0JsVldwTGc5ZGNyMkxqeFJBVS8vN3lhYjc4OWR4RHVjTWpNbVZOS1p1YUo3ZHNXTEtqaTExK04zdDJIRXhMVTlPbWo0OVpiQzVrenA1UXJyZ2hHYkdCZm40YU1VbnE2bHNSRURUTm01UFBhYXhWTW54Nk1JSGhISHo3anNEUm9rSjZTRWhjNU9lNGxTUU1INmlrcmM1R2Q3VGorYnExVzRNY2ZrNWswS2FkZUtTTkdHRGg4MkVGUmtYdjUwc2lSQVdSbDJTa3BjYmI3c0hUT2NmaHNjdkhGUWZ6MFV6S2RPeC9tOEdFNzNpazlXclpBUEM1T3pYZmZKWkdYMTRYRmk5MDdZR1JrZENRdnJ3dnZ2Qk5IWUtCM2U2dE5ybDFSa1pQcDAvUDUrT01xZ29QZHQ0ZUZpZnpqSDZYODdXOUZtRXlTL3dVUERvZk16cDAyQUdwcUpBUUJNaklzeUY3MnhNVGdIcGxOQng0M0xwRFkyTk9UbTVkZkhzeTk5eFlURjVmRnE2K1djOVZWSVEzMjhUKzFvSzFCZjM3elRqWXZtbjV1VCt0VXVlR0dVTFpzc2ZET081WDFQS29ubmlqaDJERzN4WDdvb1JJNmREaDllTHJsbGpEQ3drUSsrNnk2elVEbnpIcWJpMGFzYVpwck9YWnNBS0doSW9JQVU2Y0cwN3UzN3Zod2xKZm5aTWNPNjNIWVB5VTcyNEVnd0lRSmdRUUdxaEJGZHd0SFI0dFVWN3VuOTQ4ZWRiQm5qNjFkUU04NkxDVW5hL2p3dzNnbVRBaXM5K3FISDFieHdBUEZWRmVmMlRCMTdxeGwwYUlFaGcycnY2SG12Lzlkd1dPUGxYclVxQTNxa2NtY21lOXc4Y2pWRGI1dWRZRmhTQ09lVzhyTmRYRGhoVG1zWEhuQ2IzNzc3VXB1dTYzd3JMQUFodzdaR1RYcUdEdDNubkF0bjMrK2pIdnZMZllZN0tBZW1mejByN3ZJV0RTOVFWaXJDOTdhQ1dtTGFId2YxdXNGQmcvVzgvWFhOU1FsYVJneG92RTdxWWVGaWZUc3FXUFJvbXA2OTlZeFlrU0FSMEFIZHQvRG5KbnZjTW1vVldkczBmbVo4TkkyT05PcHdtY0VIallzZ0R2dUtPU0xMMm9RUlhqb29VaFNVelVjUGVvNFo4VkdqQWhnMnJSOGZ2eXhGcTFXNFBISG80aUpVVGZidGZRRTZEbGRTMEhndEhHMW9mODdVMXpjM0h0UGxnSHBlNWt6OHgybWpGN1pmTkNQR3psNzJGRGxHbHZobHR6ck1WQ2FxTkx0SVkwQmZUOFQvdGtNVUs4Qzd0OXRIM05tdmMybHJRanFGY0J0Q2RxdXdQMjY3bWZPckxlNWJNeUtOZ050RitBL1FTOGR2UkpCa05zVXRFMkJ2UUcwVFlEN2RqM0FuSmx1MVcxdjBGWUY5a2JRVmdIdTIvVUFUOS94RHBlUC9kM3JRRDBLM0tmTEFlYk05RzVRandEMzZYS0FwKzk0bHl2Ty81L1hnN1lJMkJkQm13WGN1M01XYzJhKzQ1T2dUUUx1M1RtTHAyZSt5OVR6bC9zc2FLT0EvUW4wck1DOU9oM2s2Wm52TUcyYy80QTJDRHk4NzQ2USs2Lzl4QzlCRzB6eHJKby9PRy9NZ0l4RXZ3STlXNHFuUTN4Qk5wRG9UeTM2bDVkNnpUMkcyWG1yNmRxcXh4NU03Yk9kSlZ2bnRXNmNaZ1B1QVJhQ1FEcys4NkFXWFN4YThGSHJmdXBSNEVwZ1c4TXZ0K2xjNWpmM3ZVL2dZRnZyZmNEUHdNQXp3N1lwOEpoT1dWejIvTTdXS1Z3R25nUXVCU3E5SU1VakNETGZ6cDhIclhIUWJ4bHdMYkRjQzFJOGY4ckNXeFlSTWE0VnhyVk53RlZBYnVOdmFYV1Y3aE9meDgydmIvQjh3ZThBbzVzRzJ5WXQvTXZiLzBZSTllQnFGek13RS9pc0hWTThaNUtYcHkwaGNXcVY1d3JNd3IxbGYyYnppMmcxbGU0UVhzN3N0Ly9udVFLL0JRYTNETFpWZ1plOStpYXFPQThzY1hBQkQ5WTVFelZ0bk9KcHJEdzRZUmxkYnkxdWVVRkZ3TlhBR3MvVnplTXRIQlZvNHNYNTM3ZThvTFhBQU0vQ3RncndyOCs5aVNiVjFiSkNYZ1hHQTRXdG5QRm9xZHgwM2dZRzNwZmQvQUpxZ1Z1QUphMFl3SGlxb0FDdG5Ya0xQMnUrem1UV0RUbFpyZXNYZUV5bC8vdm9PK2g3T1pwMzgrZkEwTmFIOVJqd3hUMTJNKzdKL1UyLzBWRVhxRjhQK01wMHFWcDBzWGpoQW1qcUEyaDVkV1BySnRwVVd0ekNpKzlaUVBCUWE5TnUrbC9ka05QR3NDMEdIdDd4TU5OZTNOYTBtNTRISmdHbHRJczBXNlVGUWVhSDk5OUZDR3prRFZWMWZmWG5OcVRUYU1EaDhFd0x6N3ZoTTZJdWJPVFRadHZyVkxndFlFVVJ4bzJEK2ZPaHFNZ3pMZHdqdG9BNy9yV3VrZWtPNEcrQXRSVWhCUUdHRG9VWk0yRDZkSWlMODZ4S0wzM3Izd2poNXdqcVQ4b050eHBrdjM1dXlLdXZoZzRkV3FjUFAzL1pENlJNcnpqN200N1dlVTNiV3dHMGUzYzM1SXdaMExWcjZ4cXR4TkJLSG4zMzE3Ty82V2ZnQnM2WkxtMlNwS1c1VzNIR0RPalRwKzJzOVBLWDMwUk1PRU5RTHdIL0FGNnErNzJsa3BqbzdvOHpac0I1NTdYOXNIVHYyQlYwbjNtR2VLME11S2JPb1dpSlJFZkRsVmU2SVVlTm9qV2V3VzBVY0pqQndxc2ZmTlB3aTgzSURkY3ZQQXl1dU1JTk9YNDhEVDZrM05iQXY4NTVFMDNuQm9MNnQ0SFpRRk9mcEEwS2dpbFQzSkNUSm9GVzJ6cDBEVHgzY0U3Z2F3ZHVac2lEcCt4YVpnYnVxQXZyR2l0NlBVeWU3SWFjTWdVTW5wMTNjUlhrVVhFa2syTkZtZXlvem1TMUxaT2w0cjZtQWVzMURoWXNYRlRmSDhzQ3BnSjdHdW5halI4UDExd0RsMThPSVMzZjRrS3FLS2ZtMEc1eUNqTFpYWm5KT21zbVA2djJrQ3RVTllyc3JNQS9QUFF1aHI0bithSkxnRnM1ZTdwVUZOMEdaOFlNdHdHS2pHeWVOaHFOR0E5bWtwK2Z5ZDd5VERhWU0xbEtKbnZGRXVTVDl5b1VQZFNITCt5Mmx3dWYybHVuTDhERHdCdlE0TDZJZ2dCRGhweHc3ZUxqRzE4RG13M0xvWDBVNW1aeW9DeVRUYVpNbGttWmJGTG5Jc2xTczhHYUJLeFN5WHkxWUQ3b2NPZUdwM1B5RWI0bklQdjJQZUgxbk11MWt5VHNSN0lveWM3a1lFa21XMm96K2QyWnlVck5ZZXp5U1Urc0NYVndjaHRhNmMvdVhFam9TSXM3SjN4MUhmU2ZrcDUrQXJKYnR3WUxkZVptVTNFc2t5TkZtV3lyM3MwcWV5YS9pUWVvRWF5bmYzb2JQMVYrR3ZDUWxLTmMvVktHT3pmOGVGM2VLVFgxaEd2WHQrK0pSaXNwcHVwSUp0a0ZtZXlxeW1TdExaTmZWSHNwRkdvOG5FaHFKV0JCZ0NVdnpVTzRHZGlVQ1BkY0JUTm1JS2Qzby9iUUh2S3lON0puK3dMV1d6SlpLdXdoUzNWSzJrTEU2NldlNy9iNXVLRjd6dXRxN0ZHWU5JaktwQWcyV2ZieW01ekpWakcvdm1YMEpabUZnQ0oxTXZONjl1Nk5SNWI1Zi9iT096eXFvbXZndjd1OXBQZE9RZ205UzBkUVVjQ0dEVVZRd1M2VzcxWHN2ZnVxci9WVnhDNWdlVUdxQ0NpSTBnazl0SVJRUWtKNjc1dnRlKy8zUjJpQkJCSkkyK1dlNTlrSGR2ZnUzUHp1T1hObTVzek1HYzk1blRWcWVUQU1ud0V2d285RFBGZXBad1R4cXJVdzVSNjQ1MjR3YXk0QzRPTXlheWdNZkJGU3dpOFNZSURrQ0Jqd0lzd2VjcEVBSHpmeHUrK3BlWG1DaVRjNEVEOTdpR2VZZUtObUhqekJ4QnM5MWVMdUpuN2VjMHV6aDhDQWwyQi8rRVVDRERXd0ExNXlMeE8vNEFseHM4YTlUTHpKRnJXNGk0blhHZy9iNHR0YkllMkNUTHovNnlyeGZjZTRvLzl5WEZyY0pnaW5UYXQvUER4eTZjanNkWG5ybW1RYno1VDRLY3dZTmdPRHl0Q3F2SUlnQ00xaTBtZVkrS0haRFBodEFQdkw5bnRtSGE3VHhNdjJNK0MzQWN3K05QdmlBQVl3TzgzY3ZlNXU3bDUzTitZTFBEdllMWURibW9tMzZNNjA0eVkrNjlDc2l3UDRaTlBRZW9IRUZnMlJkL2Z2enJ4Ujgram0zODN6Tlh4My9OMXN1M0ZicThLMmlJWU5LZ016aHMxZ1N2eVV0dGUxOUVRVGJqR1RiaXNtZkZZTmwxU1dYUENLU0sxQ0t6N2I0ZG4wS1ZGVGl2SXk4bWhyVXJ0OWVKcHM0am4vd1VNdThEWE5zdjJtcVJpYnJnNG5VTE9xcDYwZUJ0Qmt3SFpxdHJadXhpM2t3b0RicGdrM0U3Q2JtUENGQTl1T2dXN0dMVVhsNlNaOC9zQnVhc0tOQjNaekUyNGNzQWVZY01PQk53RnozTitFenczc1lTWjhkdUI4S3ZtRlNFOHk0WXRlYW8wa05BL1BYWUFnM1hJK0JWbnZuWGpXNzNVL3pHa2RRa2xZYVAveTl2SE5IZ0JvcXlJRHk4QXlzQXdzQTh2QU1yQU1MQVBMd0RLd0RDd0RuM004dkhaWjErd1JZU21SbmdTNFByOXJ6bVhYcFVUSkppMER5OEF5c0F3c0E3ZEJxVFh6TUhyNWExczhNQzY5Qlc2WFRWb0dsb0ZsWUJsWUJwYUJaV0FaV0FhV2dXVmdHVmdHdnFpbFZpQStIWGROZkZlL3hKM0dLTmRoR2ZpWWFQcjFJL0NMTHdoUFNDQXFLd3YvLy93SFJVQ0Eyd0dmY3d1QW9OVVNNSDA2M3ZmZkQ0RGo0RUVLeG83RmtYd3kzN0ttVnkvc2UvZDZnSVlGZ2NDdnZ6NEJhOXUyamJ4aHcwN0NDZ0xHaVJNSm1qMGIzeGRmUk9Idjc5N0F2azg5aGRlVW1vM09rc05COFIxM0lKYVVuTHhBa3JEdjJJR3FRd2NFcFJLeHJNeDlnUlcrdnZpKzl0cUo5MVZmZklFak5SVUEzZVdYbjhqUUx6a2NaRWRIWTE2eTVNUzF1c3N2ZHo5Zy9kaXhLTHk4VHJ3M0wxb0VnTmZreVFSKzh3MUIzMzJITWlRRTU5R2ppQlVWMlBmdVJWQ3I4WDMrZVlKKy9CRy9OOTVBMEdyZEIxaHpTbHBsQVB1eGVtdGV2aHhFRVZkeE1hN0N3bHJYU0E0SDlzUkVwS29xSE1uSlNEWmJtd091MTBzTE90MUpFS2NUc2JMeW1KOFN5TzNWQzBVOXVkL3RTVW5rZE8rTzhpd240clJKRFR1elRwNVVJYWhVcUk4ZEJPTXFMa2F5MlhEbDVxSThMUmU4b0ZhRDB3bVNoQ3N2ejcyQXJldlcxWHF2UGVXOEZHVjRPTWFKRXduNDhFTzBRNGNDb083VUNaK25uc0wzNVpmUjlPbmpmazdMbnBpSWJmUEozVnErTDd5QWNPekVEVmRoSWNieDR6R01INDhyTzd2R0lqSXlNRngvUFlhYmJzS1psdVord0FBbFU2Y2lXV3NTUDZqajQvRjU4c21hTDF3dVRETm5rbi81NVVqSHppU1Q3SGJLMzM2YjRpbFRrT3h0ZC8vZU9ZZUgrcXV2Sm1UK2ZBUmp6V2x3WlMrL1RNVy8vMTNuT1NnZU1UeTAvUGtuT2IxN1U3MWdBWWdpL20rL1RlaWZmMklZTnc1VUt0eE5HaFVBVUFZSG94azRFR1ZnSUdKRkJiWk5tM0FWRjd1Vmh1V0l4MFVWMDVJa3llTTAzR0o1TGVXWWxnd3NBOHZBTXJBTUxBUEx3REt3REN3RHk4QXlzQXdzQTh2QU1yQXN6U1MxQWx4YjducXFxdXZrY1Y0K1Y0NEFZTUdDUktaTm0wZDJkdDFMR1hyMGlDQng1VU1rOVJnSmdMNUhGMnlmZjBHZlBtL1ZlOE5ycnVuQlo4K1BnTStuVTdWaEM2R1BQOEMwN1VwK1hkUnNpMklXd2pkMVoweVRBZ0pjYVJPbmtqNzVNZXc1ZVl3ZjM0OERCOTdncWFldVFxMitzTE4yWTJJQ1dQenJmWHcvUXNCMDIxMUlEaWRkTnk0ai9QbC80VktvV3FjT2Yxc1ZsUnc0LzBjY2hjV2tETHFhZ3MrK3c2QlI4dUdINDBsTWZKbmh3enMyK2dacXRaSm5uaG5OanEvR0VQK2ZseW1lTlplWUdlL1JjZkZNdEIzYXNYcjFBYlp1VFc4ZDRCOSsySlRYNDRhZitIUHMvVVMrK3hLRm4zM0xnWkUzWWtyWVRvOGVFV3pZOEF3elowNGhKTVM3UVlXUEdOR0pYYXVtOG5EaE9uSW1QNExQVlNQcHVtMEYvamRkUTM1K0paTW1mY2VWVjM1S1ZsWlo2d0FEVkZaYWVXTGFmSzc2K0NEVk03N0JlRWx2RG8rYlRNYkR6K0lzS3VIdXU0ZHk4T0NiVEowNkFxV3liaWNmRXVMTjdCK21NSDlDSU02NzdzYWVuVWY4My9PSmV2Y2xCS09Seno1YlRaY3Vyekpuem5aYU92Wi8ycUVwRHk0QVRteW5WU2dFN3J0dk9HOU82RUQ1Nis5aXo4NGo0dVZwQk4xek95Z1VwS2NYRTZWMTFuSmE0VXZuWXQyeGk3TFgzNnU1L3RVbkNab3lBUlFLdG14SjQ1Rkgvc2V1WFZrdHlWakxhZFVDWHJKa2Qxci8vdTNpVHYrRmw1Y1dIeThOem9LYU04TlZnUUVJMnByVkFJN2MvRnJBWGRZdndaRmZDS0tJMHRjSGhmSGtFV0o1ZVJXSTRwa2FmZWlobjFtK2ZGK0xBTmR5ajhIclYvbTcvajZ6UGxVY2U5VWxvdGx5NHYvMjdGd3kvL1ZTby8raTlvNldXODlWQzFpMWQ0KzJaTWUyOHk3TVZWNUp5YzhMR3YwNzM1N1h5MTNMRnRHd3BGRkxDb08rY1NXSUVxTDE1SWtueCt0MlkwUnFMV0RMTTgrWERSd1ozNmlEQ3V0eVdvMlZkMjc5R2toc2VlQm5ubG1ZcEZRcWFtVmJpbzcyNTczM2JxWjkreUFBcXRZbGtQL3hWeWk5akVTODhpUktuL283SWJhaldlUysvZ0dPZ2lKQ0hybUhOWTRnUHZsME5RNkhxOVoxaHc4WHRFNGQzcjc5cUduTGxqUzJiRWxqNTg0TWhnL3Z5TXlaVTJqZlBnaEhmaUZINzMyQzFGdnVROWVwUFprVDcyZnlxMnZPS0RBeE1aUEprMmRTV0ZpRk5qYWFkbCs4aDNGZ1A0N2U5d1M5NW4zTmw2OWVqbHF0NVBoOXRteEpvNlNrK3R3ZEJrSEExMWRQYkd3ZzBkSCtCQVY1MWR2eGFiQ0dqOHV3WVIzNDZxczc2ZEVqQXNubG92RExXZVM5K3htNlRuRUV6WjNGOHpPVG1EUHVXN3AzUC9Oa1ZrbVMrT21uTFN4ZHVwZTMzNzZCUng0WlNlUWJ6eEI0KzQxa1BmMDZ6c24zTXYvWlIxazU1VTZlZm1FSlJVVlZaNVRSb1lNdk45L3NRMnlzZy9Cd005N2VOZ3dHRjNwOUlYcDlDYUtveE9Fd1VsMGRRRW1KanR4Y0kzdjJhUG50dHlyeThxb2FEaHdWRmFCOTQ0M3J1UGZlWVFCVWI5OUYxbE92WTgvS0plTFZwNWhqQ3VYVjhYT29xTENjODBtV2w1dDU3TEU1ekp5WndKZGZUbUxBZ0U1MFd2WXpwWE1Xay9QYWZ4Z1FGTWllbjU3bjlVVVpmUGZkUmtSUjRwcHJ3cmo3Ymd1OWUrOG5QdjRmb01ZWnBxVEFQLy8wcENDM0UxZU5TbVhFcUxRNkhyUWZVNmRlenVIREhWaTN6cC9QUDg4NHQwbi85Tk05ZmU2OWR4ak8wbkl5Ly9VU2g2NmVoTDU3Wjh3enZtYjBGK2s4UG0xK2cyQlBsWjA3TXhneTVIMm1UdjJGc25JTEFaTnVwdXZXRlhnTjdrLytIUS95b2pxWmlkZDJBYUJQSHoyMzN2b0I4ZkhMVDhBQ2RPMEtQajVHcmh2ZGx3MHJlMksxMW1YeTVmVHF0WmhiYnZtUW5qMnREYXZEQXBKUTh0TjhVZ2FPb1hySEhrSi8vb2EzSEQwWWR0MDM3TjU5L3YxZmwwdms2Ni9YMDduenE4eWNtWUFxd0kvb1Q5NGtmc1VjTEh2M0UxZFJzMEJWZVpZaGQxemNJZlN1alhRWjVNYzMzenpFMnJWR2ppM2hQaE5LSVRYTXBIOTZlMzVXdUtNODBoVTlraU9CN2ZubnpzVm5kU2haV1dWTStiOEZkRGpXVTdLcE5DUSt0NmplNjR1S3FyajMzdGw4OGNWYTR1SnFGcGdyUXE0bWFjdWhZMXFxSDNqUW9GS2VlNnlJd2NNMFZGWDFZTTZjd1R6NVpCcHo1Nlp6YkNuM0tkcHVJUEQzLzJUbG5IeTM2NXlhcTZpd01HZlI2WjMra2dhWitjNmRHWTNTakVZRER6eStpMFVMVkZTWVNuam9vYjFFUmc1aTI3WUxBRzcxRU9wWldwa0RCK0R6NlJKWFhybU5wQ1RvMXcvNjlmdW5uaWJNVFlEVmFnV2dxOGNQU0V5WUlCRVFJT0J5aVpTV0txbHZKNkJHbzNRUFlKVTJrcG56dnF2M2U2YzlEMVZoT0tYRkpYdzFzd2hmL3hpVXlsSzArcWphUFR5TENCUzJmZUNqbVJLaWJ5Q2kxb0F1YmlRT2N3VnFnMjhOYk1FKy9OUjZ5cVZZRkoxaUNGYWtVbDdwZzQrVWdsWFRHWk0rRnJXK1pwOVZXY0tmN2pFOExNekxKM0xGcmVnMlBsWVRhWm5WSDh1Mkh3QXdTd2JLYk5XWVJBTllTMUNheXZIUnExRDcrK1AwaWpvQkMrQ3dPZHdEdUtTb2hOeXlhbExhSjJIL2RqQ2R4Q08wMzFxenp5SWkySmZPY1hIRWhQbGhGUlhrVmxXUVZWSk5TVkVSVldXRnVGejJCZ0czS1pPdXFOQlI1cVZoOGhFN21lVmJxUXFHRFZHVlJGVVdZYkdVWVhjY3hTNm9DWW5waFRhZ2lDcXhIWUVLRTRMR2oweXJCTXJqd0hiMzBQRGh3MlVVS0NJNFdnQjZOZXpWUWE0Z1ViTC9ad1JqS0U2akJrZFFMNG95RGxKZGtJZTVKSnVNbkd3T1paZFNuSk5HZVA1ZXdqUW0wZy9udXdkd1phVVZaVmduWE8xQXA0QXlGZmlYd3NHY1YxQ1ZKbVBQTFNhd2VoK1pPZGxJQVg2azU1WmdxcXlrdkRBYlovb09CaTc1RVdudlduWnN6WE1Qa3daUTZPSUlNTUhXRU9oMEZES3FZRmRrTlZtNVIzQmFNaW4xSG9WQ1hZMUNWUk5FU051MUIrbm9iSFJLZ2MrOWdvZ1V4cEdiVytFK1FieWtReUZzUDZyRHBZQllOZVJjQlRZbHJGM3dLbFdsSmV4ZVBRK2R3WnZpekhReXBsOE5tNzZpcTNrejZVa0pITm4zTnptSDh4b2ZBR2hOMmJ5NUNOOEJVVVFIcCtKWENsRmJROWs3K0JwS2xFWTJ6UHNlcmNGQ3pvWlhFUUV2SUwwTTFBSVlOQUs2anBlemFFNmlld0dMb2tTSk1CaGRjVHFyakM0dXRSYVFka0RGbmc0RFVkd3hBS25jakVXcndGYVNRNVZlaGQzYnlob2hDS2VyQXNPQlhXUWNMWGUvdVBUV0xRWk1XL29RWGdpYlM3d0lMczlFVSs2RjZBMlNWb2t5eEEvcGlrajhBNGVqNmhtRHE3c1JwU1dkd3EweDV4ZlRhZ3V5WVU5L2lnaW0rcVk3MEdaNjRUTFlLT3VaaThxcUkvQlFHRXFIbWJMNEkyZ3JmQkMyYkVUYzVVVjUrYmszZWJiWm1RZUxCYktQeEtGWitnYzJTbEVKUHZqdUNrU1ZwNkRLUHh1VlRZdkNyRUs1Y2cyR1ZBMUhEam5QUDJyWlZxU295RVZabVRlWGFCTW9xWXpGTlR3Q2g3OERzYXdjc2J5Q29MK1R5VTcycHJqSWZHRmgycllrVGlkcytVZEpoL2hzZ25MU0tQSFJvdkt6NEhWQXkrNnRSaVRKZGVGeDZiWW9SdzVKY0VoTldKaWFnZ0xwMk1xQnhzOUt1ZDBHNFB4OEc3STBRazdmWGZvcmNKdUhNUzRVQkVFK3lsTUdsb0ZsWVBlVVJyWERGWGtWTFAvdlJqYXRLYUNzMG94TlpXYlA0Umo2ZDgxQWFmY20yTS9BOE5HUmpIMWtDTjdCWHU0TlhMbHdJYkhqMVpUakE3UW5KcUtRL2owUGNpUXBqQUhSKzFtOU9aNkMvZjU4bGdEUmJ5d2w1YTlnakZkZTZjWWFsaVM4cUQ0R0RKbTVJZVFVQk5HeFhRN3psbCtHS0o2c0hUNVNKU2hDM2JzT3E0S0Q4VDl0QWFLQXhIV2pOcDl4clQ4VnFJS0QzUUs0M2lscFpWRFFHY0JPbDVMRi85eFpTN3NBQVpTamRCUGdla1Y1aW9ZRkFlTGpEVVJIYTBsSTZFdEFnSnJPblEyMU5LeXNKNFdjK3dBSEJCQkF6VXJiNTU2TFljdVdmdno4YzFjaUlyVE1uZHVOeE1UK1BQUlFCQURCZWt0TnVyaTI3cVdmZlRhdFUyWm0vU3RnNHJXbFRMdzVoSGZlaVVPaEVCZ3h3ZytBcTY2cXlWajYyV2NkeWN5MEVyQ3htdHR2Mzk4bUFHTmlkSjNxQmQ2K3ZUSm83ZHI2dzV3djR1VE9PME5SS09xdTZocU5ndkhqZ3puMHA4U3Z2eGEyQ2VDUkkvMEN6N3Zqc1k4dUhKMituOExDVGdRRXFCQkZNSmxjK1Bnb0VVV29xSEN5OHRzZEZORFBNN3FXZnpDS3NEKy81TkFoTTRJZ25GaG1kUHovZTNkWEViN2xWOVl6eURPQVhTajRqb2tJSDd4QXlxNWl4bzRONE00N1E3bmlDajkycnN0Ri85OFgrSnE3a0JBOG95OE5VSWszSHpydlorSnJuL1BjZEQzcTBkZmlXTGFJd2dvRjgzZ1lGMHJhc3B4WEVNK09tdG1NUjFka28rOHZPOW5CT0J4dUVnOVVuZFpkYnBSWTBiS1ovdko0V0FhV2dXVmdHYmhGdlBRbElZVlczOEdlQmRncHBOQzZyajdnL3l2OHQ2NTZ5enFQQWpacVIrbytrdXZ3UlF3c3lCcVdnV1ZnR1ZnR2xvRmxZQmxZQnBibC9LUldWN0tzZTQ4RklOeHlYcU9TVHo1R2ZkV1ZKQjNPcGVlNDJoblR1bmNNSjJucHF3QlVQL2tVanI5V3RTQ2l0TkEvT1VsZW1DWUR5OEF5c0F3c0E4dkFNckFNTEFQTHdES3dESHhXcVRXWjVqVnoxbURWZ09aZHMySDgrS01XQlhSdTN6bVlnWmZJR2diZzUwMnArcU5iTCt5ZzVNTFNxam8vZTMzNnNsWUJqSFZXNitzRlhyZ3RUYjlzVjJhVDM3U28xTVFiWHl4dkZlRHIrc2JvWlM4dEExOHNUdXVXZ2UwdC9ZZjIxRjlJZ1lXbFZYdzVaMzJ0ejRJRHZIaGs0c2pXY2xxV1pYUHFBYjV6V0VmTGhiYkRTWWR6endBT0NmRG05Y2V1YXhWZzUvYWRsbnRra3o0bXBudnUzbktoZ2ZoelNTc0U0cmZJWGxvR2xvRmxZQmxZQnBhQlpXQVpXQWFXZ1dWZ0dWaVdzMGxDd2lHejVHR1NrSERJTE5kaEdWZ0dsb0ZsWUJsWUJwYUJXMFV1S050SVdmdnU0RGp6WEJSRldDaUttR2lRUkp6YjY4N0tyMy8rS1hTUFB1UkdHaGJGT21FQmxOMjc0cjN3ZitoZk84dlJ2SGE3ZTVtMFpLcy96N09ZZnJUV3YzWC8zdDc2SmoxdjNtYlRGK3Z6R2pRLy9OYU5IZkE3VmF1ZE9xSzU0VnFjZS9ZaFZWU2VlQ2lxd1FOUnRvOUZNQnF4Zmp1ejFnUDdZSDRTZTlKS214VXdPUCtvcVY3Z3ZYc3o3VnZUR3JaSi9PVlJ0WS94RlB4ODBEMythSzNQdEJQR281MVFzNFBHc1NFQlRnSEdabVBYa1JKKzM1elpyTUNEVEpuMkpuRmFlcW4yTVFPU3FScmJEei9pM0p1RVZGYUcxN2RmWUZ1MEJPZWE5U2lpSWtGWCsvQTN5V3BERjZoc1haTnVqR2hPQlZZb2NCMDRoUG0xdDA4Q09WMklxV25ZLzFoWjZ6cEU4WVNHOVZvM0F0YUpKejIwSWlRWW43K1g0VXBPd1pXWkJRNG5na2FEK3VyUktPSmlFWHk4VVhidGpIUHJEc3pQdjNLaURtdlZiZ1NzRnAyY1FIYUpDTDYrcUlZT1J0bXRLNUxWQ2lvbHl2aU9LTnBGSTNoN0kyaTFPSGVjMGliYjdPNmxZVHVLRXhzWHBXb1RWVGZmaml2bEVKS3B4aW42SGR5RDliOHpzSDc5UFNnVUtLS2pFSXlubk5hdFZtR3h1ZHdIdUVqbFJjaHhZTE9sM2g3VjhVNkttRkhiR3l0Q2dza3ZzN1E0OEhsM1BGSWRPZ1F2WTczZnU4U3o1NXRUdEk4ajdSeW5RYmNwNEpWNzhsR1BHRjduZHgrSGp5VHl6bmxjdmtWSHVxN3VBMGJMK2cwbU9hUE1mWUNYYjh0R01mNFdKQVMrQ0J2R0RaM3Y0Zk93NGN3UDdNVW40U09vbHBRa0tRT1kwbjRpS2ZvUXBuU1l5UDBkYmlORkg0S3FYeDhXNXdxTlRqcllxblc0b016Q1RFc296a3R1NWoyeEd3Q0p4cWhhelJWQXVpNkFjWjN2eGFxb3lVYTh4eERCdG1sOStIaFdzdnVOaDkrZnY0L2hUMHpDMzNVeVkvRnhzRlBsMU05dWpwVDRiNmErVlJ6V0dScnVYWjFmR3VBWHVWRi9BQUFnQUVsRVFWUTBSemI0MStXd2VINFpzMjd2eU8zek1yRUlaemVZSzdWbDNIcm5GWHp3K2h5dUZsdkducU50bGFXclQrM3oxM0lrVVowV1NORG9wWWVxd1FOSnZ1dGhidnQyUDZXS3VnOU1uaFJrNXROcndyRTkrMktMam9VRldPaWZmYmhwY3dBNHQyeWoyOGR2c3ZuWnZveFhGZFQ2THN4cDRvZmhHajdyNWNRMjdabFdHL2czZVV6TGRTUWQ0Lzg5eGpjVDRsaDJTeWpkeFhJZUNha2c4ZTBSWEhONEE1WVAvMHVydU9XbWpHbWRFY1VvS2FYNnFSZm8xNnNIRzU5L0d1Zm1MZGh1bTRqTGF2V01JRjY5MnQ2YmhHblMzYlJGa2VQU01yQU1MQVBMd0RLd0RDeExTdzRtVHBHZExPQThSa3R0WEJiU0h6bGptZ3dzQTh2QU1yQU1MQVBMd0RLd0RDd0RYNkRVQ3RPK0cvbHVUcldyZXFNbkFScVZ4cHdYZUtIdTBaSWtTUjQ1V2hJRVFSNHR5Y0F5c0F3c0E4dkFNckFNTEFQTHdNMDZlRWhNTk9jSEJLaTJlUkpnYWFrenYxN2cvdjBQaEFFRFBVeXBXWElkbG9GbFlCbFlCcGFCWldBWldBYVdnV1ZnV1JvdDhsU0xYSWRsWUJsWUJwYUJMM1pnU1JJdkx1QzgxQSt3bUZKYkJWalZFamR4dVZ5SW9vZ2dDRWlTaEpGVllJM0NxWXRGa2lRRVFVQ3BWQ0lJZ3ZzRHUxd3VqcWJ0UTZjOGdnSUpwYUlTbGVZNkhMWnF5alBuSUVwYVhLSUtsWEV3RVJFUjdnOWNVcHhMaUc4NlhvRlhZOWwvQU92MmxaU29xekNXcGFNUEdZZlA5YU5SYXNySnlkcU5KSVUzdTVhYkhWaXI4NkVpSlovU3lkZWkzSk9NVWxtRTlxN1JTTHQyWVZvN2w2b3V2VkRkT2dqenVQR2VVWWRGcFloWjNRRjFlQVlPUlJHQ0Z6akxOcUtPc2lCZEMxVHRSWXdjU21EMEFDUWtyQTRiZXJYT1BZRS9Ydmt4eGFYRlBESDJjVXFteENJNGJLalVnWGpwZ2dFYnB1b2luQzRUeHVnK0xDcGFSVlZKRmVWV0U2OTBmUlNWUXVVK3dCdjJiMENqMVBEcXlsZnA3Tk9abTBPVE1PU3RRZEJBbVNhWHltcC9xczFtSW9Oc09IS2d1dkJKSWk1NWo2L0trM0JKSXN0elZ0UERMNTRPM3JGdEh6aTdLSnQvTC84M09vTU9sOVZGenpnSXRTN2xRTWdZUkhxeFZUV1lJRXF3K0VUaWJkMUFYRVFWN1kwcjZIVGdXYTdzOGlFclNuWXhLKzAzUm9RTjRQSDR1MUUwc1JOclVtQlJFckZJRmhMekVobm84dVhhM21ONU1YUWpoUUg5T2VJMW42dkRGZnlScXVlbVdEdXBKb21kNWFPNXZidkVuRDNqdU1GdkROZVVicVE0MTVjdFBpYVN5dzZ4TEdzMTQySkd0ZDJlMW9JdEN6QmJ6R2k5dFZUNkJkTExwek11ZXdtN3JkZmhFSFNrVzFUWUpBVW9sT3d0VitKMFFrRzFpejJXZmxScnd6QVY3NllxSmdJdmpTL0Z6bElzcnFaUFg5T2t3TU02RGVPK24rNmpSM0JIZW1oTDJGdXlGNlZLb3RJVmhsb2hVWmgrRUVHUzJMOTdCenFsQzRWQ0pDczFCUlFLS2wyaEtKUWl1ZW9LSW5TQkdGUmVxRkNTWnk1c1BwT08rTFA4Z2dxenBxL0M1VDJKUStrZjRvanlJZEhTa3lySFJneFNJVW9rdW5icXdOcWpFdDE3OWFLZ0VDeVNRSHk3VHVpVEtsRGJTa213ZFNXdk1nVEh3U09VeFBnelU3R0U1dzVHWUpZMGJWUERxb0JPVkdkTlIyTWNpcUQzd1ZaZFJKTFltVGdwQWJXOWd2MDdOb0Vva3BXeUd6L0JqbEVKaDNadncwdk1SMmZLWm9QMmVreGlPOG82Qm1BTXJxS2dhZ2htcVYzYk5XbVZUeGNDQnN6R3BDaWlZN1UvUnMxaFBpcnNRMGorV3NwTlc4Z3FTVUtnaXBUc1BWUVVicVhLVWNTT3REMTBycDVPbGptY1EybzF5b3BDMUxvcWNzcXZKc2Mrcm0wM1M2NnFITXdILzRka2Q3RlJIODJJZ0RTV3BoM21RRWc4NGFWZlVoV2d4RWt4WGtIN0VDMCtCSWpCZUlWazA2WGlMOTRPZUEwLzdSNWlqbWpZcWh1S1NtVkZLZGx3Q2JxMnEyR2xUd3crL2Q1RUczSTVLUm5ycVJEVVhCcGk0eVBkNTNSd2JjYXFEQ0w2NkE2Y1dpVjZheWxCUmZzSnRGU3gwVEFLazFjSmZaMWw1TVNHb0ZHWk1hcVBFcXorcSswSEFLeEhsMkVyV0l2Z2dIWDdDd2tQaVdGNDJSOThvdjJZOW83ZFdMejFhRTBPeWlPTWFLdlVPRlhGL09SNmpFc3RoMGhSUitMd0tTZkFlQkJSaEJMYjhMWVBMQ2oxQ0hZMURzZGg3SzdkL0x4NUtha0ZDWFJRSDJhbGNCMUd6R2dxN0NncURGUUVXSm1oZlpkeDlwL1k0SXJCcVNwSHF5cEhxNmxFcVZIZ1ZQaTIzVHFzdHB0eHFMUm9Jb1p6U1d4L09pakxjRlVkNVE5TE5IMDdSakRNWU9IUWpyOHdHMjVoN0toUkZGYmtzR2xiS3MrR1NOaTdmTURhSTZWNG16UHBhWVJDSzJTWU95SkpBb2dPVkFvRlRrSFp0b0RqVkRhRzZpc29kQW1NQ2Rad1RhZnVKQmRHTXFURXdrZUpHUXdmR0VyQWdKdnh0eDlselQ4SlZKaUw2WDc1R0lwTldtd2xoVnpwbytlVFBkNzhOTGtYZHJ1ZGYyM0tvaytJd0Q4WkZSUVpROGhHMzdhQWxTNDd1NjBhNGxSMkVzdGR2UEIzS2Q0dUs5ZUg2eGpkT1lhLzg4dFlaeFlaNkpmSW1OamZNQ29OdkpuYWozWjJQMEwwU3RUZUdtN3RIRXkzbFNYWXpDYSs3K1BGZllsVmRES28wU3NCVnhzejZSVEJINDBFUGJ4c3JLNVNZOWJvTU9QTmR5YzZiMzZNOGYyZFNFMHVqMWJOSVZxVndWMSszekdqNGltS1hLRlFEdUFGT2hDMFh2eGVZbUp3WkNCYkxWcXdTOUJFaVlwcmpiM0MveWhyMGVsU0pTNGtCTVRtalJZdnpMdkdmM3lMaG1ucjdhalE4dm1sNWFrV0dWZ0dsb0ZsWUJsWWx0YVRXajB0dzVPZEZ3aElGOXpUcXZqZ1VMNVNRZGdGamFzenlOOFVlMkZsSE85cFhZbWNNVTBHbG9GbFlCbFlCcGFCWldBWldBYjJER0M3U3lDOVJIM3hBSzlQTmJCa3I5ZkZBN3gwbnhjclU0eXRBdHppY1dtWENFdVR2Q2l0VmxCcFZlQ2pFejFidzlzejlCUldLWEdLQW1zT0dUemZwSmZzTzFsM1c4T3NtODJrMDB2VVBMMDRoQXByN1dlYW5LYzlHWXJZN2MyaG90cExrcFFDdkRTbWhJRnFzM3NCeHdVNitPREdRaWJOaWlEcEZNaFRwZHF1WUV2NnlYbmZZQzhYcysvS1kwUkhNOVlNTnpUcDlrRU9Wdjhya3pzSFZKN3oyaUZ4RmhLZXltQkVSN043MTJHRFJ1TExDZmxNdjYwQVpUMTNlM1JFR1g4OG5FMjRqOU16bkpZZ3dOaXUxYmpxYVlGR2RUYWpWcmJNZVdvdDVxWC8zRisvUi80anVlVzhkWXNCTDArcWFZNVVDb20zcml2bTV5bDVlQi9yZEt6WTc5VmlCK2ExU0UrcjJxNWd6V0VEc1FFT1p0NlZ4NENZbWxQeWVrYll1R05XT0VsNVd2YmxhdWtWYWZNTURmOXowTUIxUFV3a1BKVnhBaGFnUTVEOWhCYy9tOG03blliN1JsbTV2b2VKdXJZdkhQZmlpZGs2endHTzluZWUwNHYzajI2Wnd5RGxpSWNNTEFQTHdES3dEQ3dEeThBeXNBd3N5L2xKcmZITFpmOXJBK2ZXTjdHc25WUjdqQ2JYWVJsWUJwYUJaV0FaV0FhV2dXVmdqd0pXQ0JjWjhQVWR3VnR6RVFGZjJ3RXVqN2xJZ052NVFpZC9HQk4za1FCZmRTeTFUcmNnaVBMMmNHQkJnQ3RqVDc1dkRTMjNLSERQSUFnOVpScDRkQndJTGV5eG0zUzZOTmdBc2I0MVQxRVFhcG9mUVRqNS9uU05oaGhnWWxmSXI2NTVmenplY2p6czRoUmhTMjdOdjIwU3VOUUNvOXJCdmIxQTNVRGJlYUIzM1orbmxzRjdXNW9XdHNtQlhSTE1UWUdFSEhoMkVIUVBPcjh5Zms2dWVUbEZONm5EbVpYd3I3OWhSaUxZR3BGaEphMGNIbDRKcy9ZMUQyeVRhL2hVRVNXWWZ4QTI1OEl6ZzZCWGNQM1hTaEw4bEZ6emNqYno4dWxtOTlMWlZmQm4yamtlRHJEb1VQUER0bGl6Tk9vY2VmeVVBbHpXUWwzTlpnZjIwMEcvME5xZlpWUkF0ZU8wSGxpc2h3Q1BqRDQ1SEhTS01ITWYzTDhDcGl5SGpka25yK3NlQk9GZUhnQjh4VEZ6UGxRS0Q2MkVINU5xd0VzczhPb0dlSDBqbEIxYm9uVmx1K1lIYnRhRmFTRUc2QklBMys2QlgxTnEydGhhM2hsWWx3V0pCZkJJWHhnVlc5UCtTdTRLSE80RkQ2NkFqSE1zaUsreXcvdGI0Wkl3OE5kQnFkVk5nZmMwTW8vdWpud1BqWGkwcHNqQU1yQU1MQVBMd0RLd0RDeExpMG10cVBDZ1Z5K2JDOUlFejBLVUZtNTljNzJjTVUwR2xvRmxZQmxZQm03enNpTXRNVVB5TUVrOHVqdGJObWtaMklPbFZwaTI3UEhQZ3BiL3M3UDVPL0NLbWxDN0pEYi9BZy9kNVgwRFdsM0RYajFkZVBWd3RiNkdXMG9DTDdValNRSlZlMVdlWDRjRkJRUmM2aVJ3aEFPaEZleXJ4VzlwN09KRUV5eWlDUll4ZG5aNlBuRGdDTWNwLzNkNlRoM1dSb2pFM0c5QnFUdGw4bE1ROEJ0MEVqaDhnaFY5ckl0VEUvRTRMUUpaMyt1eDVTcmNDOWlXcXlCcnBvNzRWOHdZT3RidmtVOTlBT1pVSlVmZmFqN1laamRwYTVhU2ZZOTZremRmZTg1cmMrZHIyZmVvTjlZc3BYdWE5SEdSSEpEeHBaNktSQlZkM3EydTg1b0R6eHNwMzlZeXFWdGJ6R25aQytxL2xhMmc1UTZhYWpIZ2dCR09zM2h1dStjQit4OER0dVVxU0hyRW02Ukh2RTg0Si8relBBeTNCTlpGdVRDMmQxRzhTczNlQjd3eEhWQmlPcUJrN3dQZUZQK3R3ZGpCaFM2eVpYTFV0a2huMXJlL2s5Ui9HeWordS9iZUhaZEZJUFhmQnNxM3EvRzl4SUUxUitzWndJVi9hcEhPVWsyTFY2a1JXbU1ma3h6VGtrTThNckRiU1MybjllaXNKemVERk9OWmlOSVcyYVJsWUJsWUJwYUJaV0JaMnFEb2V6MXhVQjA2UkFKQm9tWnppU2U4RnRScjBncGRrTkhRNTFtTUE5NUU2UjE3OGRSaFZVQVB2SVo4akw3YlZBU056MFhpdEFRQlRmUVl2Qy85RW0yNzYwRlFlamp3Y1c2VkFWMlhlL0VlOWw5VVFmMHVubVpKWVl6RTJQOFZqUDFlUm1HTTlJemhZWU4rRU53Zjc2QSsyREtXWXpzeUQ4bFpmUkYwUEFRbDJ0aHhlRjg2QTAzVWFGcGxacnMxZWxxQ3hnZDk5NGZ4R3ZJUnFvRHVGMC9YVXVrZGkzSEEyeGg2UDROQ0gzTHg5S1hWWVVQeEhqNGRYY2RKQ0VxZDV3UFhsS2hHMitGV3ZJWlBSeDArZ3RPMlZiUXQ0SkVqUmpaZHdicEFETDJtY2RVVGE5bDVzQlJKa2xydDFhTER3MjBwcFZ6eHIzVTg4bEVpK2FYV1Z0ZHdyWFpZbmJ3N0FLTE8rb01RbndvR2RUakkwbDBERzNXai82M0taUEhLdzl5YnU0S0orYXZSU2kyemdrYy9kTWpnQzlLd0FIeDZ4N2RFQlJRMyt1WVdoWll2b201Z1FzOVhXT2ZYRzZrVjZ2ZDVtYlNmb1pwdjd2a0NwYUptVGxlcEVMbTBjekwzalZqVm9OL25hSU40dXRPRFBOcjUvemlpajJqYlhjdmpNcWpEUVZZKzh5ckpPZTI0dXZjT2pCb3JvOTUvcDFGbGJQZnB6S1R1TDNKTDRRWWV5bDJHYnd0MFV4c0ZyRk03dUxyWGpoUHYrN1pMbzIrN21zeEN6ODY5aHdPNVVZMytBMFJCWUg3b0NGWUdYc0tET2N1NXBXZzlLa2xzUFdDRDFzcm9IcnU1dnM4MnJ1cXhHNlAyVEUrNytYQlh2bDkvMVFYOUlaVXFBeCsydTVWRkljT1pscm1Rd1pVcHJWZUhKVWs0cTRNUmhLYk5yU0kwWTY2V2MyclliTk94SkhFUVN4SUhvVk03bURCb0F4OVArcTdXTllNN0h1QytFYXN1U01zK1RqTVA1U3pqbHFLTktLWG1XenplS0M5dGRhaFpzYmYvaWZlSlJ6dncwNmJMS2FuMjVzMWJmcVpMUkhiakJ4NlN5SzJGNjFtMDczVnVLMXpYckxBWDVLVzNIdW5NOVorOGdrdFU4TlNjK3hqU01ZV2hIUTgweW5FTnFEeklVNWtMNkdESmJkdk5Vcm5aeUlNekg4VWwxaGlJUzFTdzhWQjNOaDVxMkpnNDBsYk10TXlGakNqZjE2ejF0VW1BSmVDSlh4NGd1N1R4T1J6MW9vMzdjbGN3c1dBMUdySGxGNGVmQWV6bzNxZVVmY1ZuamRBVlZ2bzJ1aDhOY01mb0dGNjV1eHRoQVMyKzQzN0xxZmxnbTMxaDJzQ3VBYnozY0UvNnhmdTNpZkZ3TGVBTldUdFFFTnNrQlV2YVNwd2QvMlo5U0JKRGYydkZRMzVPR3c4M3ZZWVZMcHd4bTNDMTI0U2t0TlBXcEdsejA0WWs0K3k0Q2tsWFFWdVZKZ0VXdmZOeGRscUI2SmRCVzVjTEExYWJjWFQ0QjFmNHJtTlR5bmdvc0NEaWpONktLM1lka3NxR08wbWpnY1hBd3pnNi9ZVmtLTVlkcGNIQWtxRUVSNmMvRVFPUDRNNXlUbUJKWmNNVnR3Wm41SFpRaUxpN3FNN1dhM1pGSnVKb3Z4clVaanhGNmdRVy9ZN2lqRitCNkZXQXAwa3RZRWxYV2Uzb09ROVgwQUczYVdaa09WZUxldXFibDI3dnMyZjI5YzVlWnAxSGFYZGg2UzNKZFdkTTY1SXVCSDd3c1FhRFZmQllEWjhSeE90K1JJRW5ROWNadGZSazZIckR0SjRLZmRhNHRDZENuek1RNzJuUURacDU4Q1RvQmsrMWVBcDBvK2FXUEFHNjBVc2UzQjI2MXVBaFF1OHdnckpCMFBNK2c0TnZGT0RTdCsweGNvRlRGZmRTZmNEK09vY1dHclprME91Z2prdmZEQ0x1UDRkUkdGeHRGampCYWdpOUlKTStWY3o3dlVoL3RoT2lXZW01ZGJpcG9UZnRQdjk3bjg5dm0yVHA0WVZBUC9FaGxGYzEvcDRWcHByZnRncncrVUlYbE1EdWc3QjBmZVB2OS9zNjJIV2dwb3hXQVQ0ZjZNVnJ3T21DbjVjMy9sNC9MUWVYV0ZQR2VVYzhFc2QyTnF1MmVPc3ZGTnpRelZTbjkxNnlEbDZlRGxZN0dIU1FrVmRqbW9JQVBUdUN6VjRETVhFc3ZESDE1TG1ta2dTdmZRWC9Xd0VxQmVnMHNEZTE1bk5mSTdTTEFMTzE1dk8zSDRNYlJ0Ynkwam5EaHBxam1oWDRiTkJiaytDR0o2Q2c5TXpmcUZYdzMyZGc2dmk2RDNHZE1RK21mUVQyT25JVmhRVEEwazloWUk4em1xVmF3QzIrSFdWUUQwajlIWWIwcXYyNW56Y2tMNENIYjYzL3hOcEhib09rK2VCLzJybkZ3M3BENnBJelladTlEcDlMdXljNkxZWWE4enRWN0E1b0YzN3VzbVBDd0hMYVBMdFdBOTdHVm5CYURZRTkzcVNzVHdRZkkzei9HblJ2WDFOL1Z5U2N1L3cvRTJvZVR2Y084TjJyTmFEckVxR3F1aFdBR3dJTDhOMWk2Tm9lRHYwRzk5NEFpWFBnam10ZytxL252c2NYdjhKZDE4S3VPWERmalhCd01YU0poVzhYbjhmZ29TVmdBWHJGdzk1ZlQ5WlZqUnBtdndsL2JUNzNmWjZaREtPSG5Id2ZIbFJUMWovYldoQzRNYkFBVncycSsvTlRRZXFUdXE1UktPQ3F3UzFrMG8yRmRldkJnN3ZCbm1IU1pWYTFMUmdhMVBFd2RiYXk4OVZpMXJwOG9hcnRBaFk0VlFWZ3JoczQxNkt1RGdhL2N4V1MzRUhrbVgrQnVUb1UydjcyNFhRb1BIK1RUdTRnOHN5VGR0eDFobEZ4TWNFMkN0Z1RZQnNNN0Ntd0RRTDJKTmh6QW5zYTdGbUJQUkcyWG1CUGhhMFQySk5oeitocEhZaVRTbVpmNzRqMFZOaUxVbXFGeTN6SExGNEEzT0poakFzclZ0NGtIK1VwQTh2QU1yQU1MQVBMd0RLd0RDd0R5OEJOT1R4OCs0RWU4VEdoQm84Q3pDd3d4Ly9meW5xQSs4YjdCUXpyR2RSOGQzZFZnQ1VaN0duZ2RSazRza0hiQVZUQnpYYkxUZnVLQStyVmNMT0taUys0S2tFWFQ1a3RCajlWTUlKQ0EvWk1zS1dCY1pBSDFlR3FOYUF3SXVtN2d5cUVBNGZ6TVZlYlFCVUMydmFnaXdkYnFvY0FPNHRCMTVuRlczZnczcnRyRVYwV0xvbmJoOXEwQkl1NWtuZmUyOERpaE5YZ01vRWx5UU9BN1puc3ljcEdLWm5Za2VOTDRkRy9VRlFQUkNYMnB5QjdONGZML0Nndk8weTVLd3pzelo4MG9abnJzQWoyREJhdjMwbnlObDk2UndrRWVlc1FsTjZnOUNGVVdFS3NuNE8xR3lTS2JiTjRadXhRZHdjV3dHc1lQbDZwV0IyZHVQTEt2VlFkL1lKS1Z5QVp6czRVT2lJWWRtbC8wcGJGNDZzdnJFbkxMcm1hTlQxNzh3TmJrb2dJakdSbzlHNm1IL0NocFB4aEhKSUVLS2gyR2VrU2JLVnpZQm5Sd2ZHZ2lXcjJYUFROM3l5cHcvSFJadUNLY1RCU0ZVYXZJWmVSbTJlam9zcEV1MGh2OGtxUGt1UzlrVENmZUJDdDdtN1NnRHFLYTdyNWtWVWF5dmE5ZjFHdU9zcVlIamRoZGFyWm1aN0F4bjBibUhEbGJmU05VSUk2MUFPQWxkNWc2TXNESS8wWjIzY1V6MzczS2dmM2lDaDFUa3drODkvSFBpUll0UXQwWFVIcDV3SEFBSnBZRklLR2RvcE1mbnpoZjVSWDJiRGFIVVNGK3FHMDdRZjFjRkFGdGNpZlVndDQxNkh5MHBJS2V6T2VhUkFEbkZ5enYrZElBUkFJMklIbVNRU1lXV0F1clJmNDVXK1REZ0U5UFd4RWVFZ09BTWpBTXJBTUxBUEx3REt3REN3RHk4QXlzQ3lObGxvTDA1enBtVithbm5wNWpDdmxjSnluQUFhbWJCYnFOV2xsYkhTdzc4TFpvZnFIN2s2NG1PcXdRZi80ZzBOOUZzM2FKQmowbG92R2FhbTZ4QS96My9SbnJySnJwL1NMeDB0ck5SMThGODRPTlR4OHo2YUxxVmt5NlA3dmdXRStpMy8wQ0JOdmNEdXM2dHpSSTB5OGNSMFBEekR4OCtscHViV0puM2ZYOHFTSmQwNjdlUHJTV2swSDM0VXp3OTNKeE04TCtMVFRJdlh1Wk9LS3hrRGFiUE94MjhkaUtvNmh1blFjTnRzeXR6Tng0VFNvT25lMU9LcE5aRzk5RDF2SmFxcXlBN0dXR1VHUUNPcVdqZHB2RkVIeGQrSVgyK2w0bmdxTDlmTnZFODFmemh6V0ZnY1Bad2ZPeTRPWk02RlBIK3pWRDBOeElVWFdHS1FJQmFvU0IyR3FJemhET3FEeSt3NjJib1dISGdLL21pbFA1OEhVVFZWM1BOUlBNbHYwN2dOc3MzRmt4T1dzR2RhWExpVTJYSHB2SklVQ3IvUlVxdHJIbzNBNjBKWVZZd2tPbzJ2Q1dzSVN0OWZLSENUWjdHbVZreDdDbFhLd2ZWc0JQdnY4c0ZhTE5pQ0FoVU9MaWRUdTQ1QmxDc09zY1lSMDcwQ3hmeVNhYm4wSks4a2l4emVjWHVrSHowaVRKR2cxN1gwWHpyUllQLzkyVTFzeDhYTTZyV0NEamw3dFhtRlgrU2lHeFY1UHRFR0xyMTVIbUVyQ1dsS0lGeTZFOUFQNCs5U2I3cWhOZWZGenJnRFFhalg0MlpYY0ZIYy8wVG1wak9qZkMzOS9mMHBLU2xpM0o1bWpvZTB4aFBxajBPdlAyVkh4Mi9SbnE1dDRuUm9XUlFkbTh5cEUwWUhWWXNWbU1CQ2VuMGE0VVVkNmVqcXJWcTBpTFMyTllMVkFWR2tXTnIwQlYya3BvdWlrdW5vMW9saDNOdE5qSmg2dWI4V09TcDBhcnE3ZWlVNDNHb2VqZ05MaU1pVFJSV1YxTlVjdEZ2WnQzNEtmbng4VkZaVjA3dDBYcDBhSEswS2dvS1NDRUxFUW5XNFVKdE0rZkh6cVQxLzJycXNYYjludmJDSEV6ZWNHbHFTblNVbnBRcTl3Z1RLREZ3Z0NwcndjK2cwWlRLOU9reGc4ZURCYnRteWh2THljeEgxSjBHMGc1WG9qRVdWcUVuTzdFaG56QkQ3OGZVYTVWcHZyeUxEYkZwS1lYRHlzVFdtNFN1cUpienN6bUozNDV1Y2lXQzM0aFlZaEdMd29MaW9rSXpPTG9wSlM5TDUrK0lXRVVtaXVSbGRWQ1NZVHZ1MEdZQmE4enloejkvNmlUY01uL3RhM3V0cGhhSE5lV3FNY1RyVnJNM1ovTzFFQlBsdzE0ME9pMVFheWl5cklEWWhrWlc0WmVZRlI1SmxkUkFvYXJ2em1VOXBiS25GR2E4bXpKaE9vSG5CcWNaWlhQOTI2cWUrNCtjTmFHN2Jlam9mVFdjTEd3bkgwOExiaDYvZ1Y5ZHlWc0hvMXBLWmlLU2dpbzF0UE9pVHRSdDJwSThUR1F1L2VPTysrbVZMZFhWaWtQTUoxVzlCb1FrODE0UTZ0Um5qazBZYjF0TXBOODBIMUVFcEpCK0pJSkZjUGpNWW5VVXBxV0xZTXJyNGFsd3BNcGs5eEt2YURZajFPcWxHTG54RGdmVWViTWVFR0F3TlUyL2FRVy8wOWtmclpPT3lWNlBWZWxGZ3ZRY0lmdFZDTXJ6WUppNldNSTVadStHdUdFMmE0RjcxdWtPWFZUN2NtdmpWOVo1dm9XWjBPZk5hT2gxSGJtMDdhejZpc3ZCYUY0bmRFY1ROT0tZZDhTeEdSQmd1Q0VJTk9ONUY0NWZWNGVZM0Zhbk1kNlgvRHZGYjF3aGZjMHdMdzhSa0RqQUVnV2dmUnZtZDB1ZHVPQ1RkcmlLY05ldUVtMFhCOTBoWTZFaTBHN0M0bTNCUW1iWDdsRS9jeDRRdlNzTlhtT2pKay9BSmhkMHJKTU54VVZKNXV3dWRqMG01dHdvM1NzQ2VZY0lPQmQrOHYzamg4NHVKK25xRFZjNW4wTVJPZU45elRZTS9RY0dwR1JlR3RqNjNJOXlRVGxxWFc4QkFXU0RYblJYalNhMEZURHg0OHJoMldnV1ZnR1ZnR2xvRmxZQmxZQnBhQlplQkdCd0MrK3k0UGkyV0xSeEhxOVhuY2YvK0p0dzFhaWVmbXNsQVFoS2JOTHkzUk1pbldtK0krVFFJOE4zVXVMcW41ejF6Nlgrci8yZ2J3OU9UcGJNemYyS3l3YVpWcHZMRHRCVVRwd2c1NFBxKzVKVkVTMlZPeUJ4R1JDbnNGQ1FVSmZKUHlEVnFsRm9Cb1l6U1J4Z3RQK0ZKcUsrVm8xVkZFU1dSZTJqeXlURm44a3ZvTG5YdzdBZEEzc08rSmU1NWZIWkdrQlZJRFpYbkdjaWxvZHBERTE5UjYzYlg2THNua01FbE5JVGFYVFhwcTgxTm4zTVA0dlZINitmRFBEUzFtUVpNQVM1SWs1VlRuU0JFL1JaejRRMTdiOFpva1NxTFUxUExqb1I5UDNFUDlyVnBLS1V0cHpNK2JMcVpsVkJrcHNoWVI2eDJMVWxCUzdhaEdvT2xQajdjNGE5YWtkdlRwaUVOMFlIVlpXOGRwL1pINUIvZDB2b2ZrVzVOWlAyNDlpY1dKemRKRXJjbGR3N3dyNTNGZ3dnSGVIdkEyU3pPV05sRTdkeDRtZmFxVVdrc2xpOVBTNUNaOStuMXlxM1BQMjZRdmFNbERoQ0dpMW50L3JYK3pORW1uM3lmY0VONDZKdTMyZzRmdnYvOCt6K0poZ3dlOVhwOTN0dThYQUpLSHZlU3BGaGxZQnBhQlpXQVpXQWFXZ1dWZ0dWZ0dscVh4VWlzQU5XTHlTbzg3cFhYOWoyTUV1UTdMd0RLd0RDd0R1Mld6bExNbDNPT2FwY2pCZWZWdnA0M3d6NU5OMnRPa2xvWi83Ky9sZ1lpbStvR2JVNm8xR2xMajRpalc2ZEQ1K25KOXYzN1lpNHV4RlJaaTJyRURiV2xweTJ1NHFVVUNEc1RGOFpkS3plWURLVmgyN2dSZzE2NWQ5T25UNThSMU5xdVZJMnZXa0RWL1BxWWxTMURiN1MzanBaZDRlVFdabDg0SkRlVVhMeStTQzBVaXU0ekZVcFZQL3VIVnhFYjZrcHljWE8vdk12ZnNZZmViYnlMOTlWZVRUSzNmWURJMTcrQkJBdjdwMlpPbjgvTFlsVkZDLzJHUEVoemVrK0ZlSVl5NDlQL0l6S3Vnc0xDdzN0L0g5TzdOZGZQbkUvTGVlemdNVGI4eHJ0SEFEc0FpU1hXK1RJTEFqejE2OE5ubXpaak5abnlDT2hGU25nbEFtVzhrcFE0ckVrcWVlT0lKOHZMcWJ3SVZDZ1ZESG4yVWRsOStTYm0zZDczM3ExSXFFVWFPeFB1QkI3QzFhOWVndFFlTnJzT0dJVTcwM2M1Y2hHWnlhZm52N2s3OHZYRUxlcjBlVVJTeFZPYVFwVEVTVVpKR2ZrZzhSbnMxZ21obHpwdzU3TnUzanpWcjF1RG41NGZUNlVTU0pOUnFOWklrNFhRNlVTZ1U5THZ4UmtRL2dmeWxqK0VqRmRXNlg0a0ZoSkJvdWw3N011SGR1bkdnYjErU1B2b0kveU5IbXFZT0N6MWRLUFIxTHdxclVIanhVWDRJaVVrcEFDeGJ0b3pVMUZUKy92dHZvdU82WWJJRVlUdGFScmE2Z3NmdXVwUkpreVlDTUhYcVZNYU1HY095WmNzb0xpNW04dVRKVkZaV3NtREJBcnAwNmNMVXFWUHAyTEVqRy85Y1F2YU14L0EyRjFHR0d0K1lTNGdZT1FXQTNLVkxLZHU2RmIrS2lxYXR3NElJaU1JWnJ5ckJ5SWVud0o3UnRRdjE0YVpyT3FFSkw4UG95a09qVVovNHpuNmFOejR0UWVnSkdYNzFEY1ErK2prV3RSK1NTMEJ5aVRoc05weDJPN2hjNkN5V0MvVFNBaWlIT1ZENVFJRmRTN0RHaGdJSnhXbHVzMHJTOCs3QlNIYnMyVi9yOCs3ZHUyT3hXQ2d2TDhmYjJ4dWowVWhaV1JsMnU1MlFrQkJTVW1vZXp0Q2hRNWsxYTFhTmIzQTRDQWtKd2VWeVVWeGNqTUZnSUN3c0RQMHBxZWYyckY1RTl2ZjNvWEdaejJ6blhSb3NEcEVnblJNQTYyNFZVbzdpREEzWFc0Y2xoWUtsMWhFa0trZWpjemlSRkJJVHBjL29vQzgrYVI0WDJJaUpvb2hHb3ptaGFVRVF6dGtHS0pTYzhlQnpIUUVzNEVGS0RYR0VPL1p5aGZBYlVVSkJuVTVNVlYvYnNucHZSN0w3WG9HM3lndi9paHdLL0tMSlc2MGt6S281cFQ2NGVFSmZ4TWRkdTVLWWN0S2szMy8vL1JOMWVQRGd3ZlRvMFlNVksxYVFuNS9QblhmZXlmanhOY3VYUjR3WXdhNWR1ODVaaHdFMi8vWWJXWTg5anE3Q2lRTk5yV2J3OTM2M1V0NnVDMXFIbFZKVlR4Ym1DenlXL1UyZDdYaTlkZGdxS0RDcDlPaXRGVGlWR3V3S0pYSFdNeDJEdDhYQ3ROSlMrblhyMWlqdGpodzVFbjkvL3pNMFhtZmtjZkZpamp6NUpMbzZIRk81UW9Yb3NoTmNrbzVDZENJS0NuU1cwc1o3NlFwQnlkS29nYmphWDA2RmR5aWFuSWxEZ0trQUFDQUFTVVJCVk4zY3Mzc1cybm9jaTFtajRkdTRPRmJ2M0htaVdYSzVYQ2lWU2hRS1JhMm1CeUF6TXhNZkg1OHp2anUxV1ZLcjFXejk3VGZTcGszRCt5eDk3VC9hanlJL3BEc09uM0FzU2pVOWR2ekFsVVg3Ni9UU1oyMlc3SUtDUlIxR1k5SDVjTVhCWmJSem1NK3FOWmRDd2YrNmRXUEJsbk92ZklxSmllRS8vL2tQRXlaTXFQZWFIUXNXY09UeHg5RlhWcDYxckVxRkNwdGF6KytYM0U5aytub3V6MHM4b1poR0FSOFhKd0txQnE2aGxJQy9lL1RnaDcxN01adnJma0JkdTNibGtVY2U0WW9ycnFCYkhWVkJraVEyZmY0NStlKzhnOFpzYm5BMUtWTHJDWEpZYWtHZFZ6dXNhc1NDVVFHNEtpbUpqOExER1g3S2lPaFVTVTFOSlNVbEJUKy9NdzluemQ2M2oyVzMza3JKU3k4MUNoWWcrRFRZRmgwdG5UbzhYS1hSa0xCL1A1YlRPZ2c2blk2dnYvNmFDUk1ta0xaMkxaa0xGbUJhdEtoSmg0Zm5aZEpORWdEUWFqblV2ajJsV2kzbGdvQkNFUEFUQklKRmtRN1oyZWlMaXBybHZnM3VlRFMxR0cwMitxYWt0SzB3clhRUWp3dlRDcDI1dUdjUGE1bDBibG00QnlMbTFRODhjY1lzRHdRZXcwVnQwakt3REN3RHk4Q3l0T21lMTZsdjF0MDAyZEhub1VrcW56RmpFRVdKR1RQVzh0Skx2MUZaV2YvbXh0OStlNFNlYzk2bDdOZGZBWWo2NEFPK3F1N0M2Ni9Ydno4d05qYVFHZTlkUzdmVlAxTDgzWGNFM1hjZlB4Z3Y1YzFQbTJYVDlVTDRwdTRjQUM3L1lDbjEybXRKbnpnUlYyRUJqejEyT1NrcGJ6QitmTDhtdWJOYXJlUzVaMGV6K2JVdVJQenJacW9URXVpOGZqM3R2dmtHdTg2cjVldncrem5SRmQ1TC9zR1duazV5bHk0VWZma2xFV0UrekovL0VNdVgveCt4c1lIbmZhTWhROXF6WS9FZDNKZjRGWG1QVENYMHlTZnBtcGlJMTdCaEpDUWNZZEdpWFMwUHZITGxmbHZ2VytlejZMcFhDSHZyYlhLZWY1NERRNGRpMmJPSGE2N3BRWEx5Nnp6MzNCaFVxb2I3T245L0E5OStNWUdGVjl0eDNqSUtRYU9oVzNJeVljODlSN25Kd1lNUC9zeWxsMzdBb1VNRnJlT2xMUllITDczeU82TytLcVpxMXA5b1ltTko2ZCtmN0tlZlJpZmFlZSs5bTltMTZ4V0dEajM3U1FhQ0lEQnAwa0IyL3pDYUlaOC9TdEZYWHhIMzg4OTBYTFlNYlZ3Y1AvMjBoUzVkWHVYYmJ6Y2dpaTAzS3ExWFZmdjM1ekh5bGg5NTIzQTFJWE1XVXI1b0VjbmR1bEcrWkFrOWVrU3djZU16ZlBQTm5halZ5ak4rR3hCZ1pOWDh5YnlqMlVqeCtPdnhHVDJhN2lrcCtJOGZ6NkhEaFl3YTlRbVRKOCtrc0xDcWRiMzBBdy84V05xNWM5Z1ptNEQxZWpVakIwVVRzbjBWb3NtRTd6WFhvRHNsMnBoMisrMjF2SFRJRTA5USt2UFBPSXVMOGI3c01neVhYSUxMSmJKMWF6cmJ0eC9GNlR3ejRMNTgrVDdXckRuWTdGNjYxdkR3NXA1Nnc5Q3VkY1g5bkZDV0RzZW1QZXk1dWRoemMwOThXL1gzeVlOb0t2LytHMzJmUHFpam9sQkhSZUVzTDZmeTJQYzlnQjdkejNqT0FKaVBlTEZtVFFzSEFMem5mS1U2dlBtZkN5cXdjdVZLS2xldWJQVHZZaTY3RXpDMFhoMlcrOUtlR05PeTlSNGtSbldMVlRhMmtPTHZ2Ni8xUHVpKyt4cjloNVJYaFFPRkxRdWNNM1NjdmZ2b3J1cTZMdFJvVlBqNDZGQXFGWWdXQzY2S0NoQUUxQ0VodUV5bVdsNDY5T21uVDdxN29pSWtsd3VYUmsrMXBLelRRd09rdnYxSHl3TlBudnhET1ZEclBMK3dNQjgrK2VRMmJyOTlBRWdTcFhQbmtqMXRHa3AvZjR4dmYwaFJkRGRPNzNDdVdwWEMwS0h0TVJxMTJITnl5Snc2RmV2Ky9ZUysrUmF6cWp2eTFqdC9ZckU0MmxZZFZpZ0VIbjU0SkFjT3ZNbnR0dy9BbHBySzRiRmp5YmpuSG9JZmU0eTFELzZYM3Zlc0pEZjN6RW5xaElRamRPdjJPa3VYN3NYUXB3K2ROMjBpOGovL29lRDExN2p4dDlmWjgrdk5qQm5UdmUwQTkrNGRSVUxDYzh5WU1Ra2ZuWUs4dDk4bXVVY1BFQVNrWC85aTNHOENqMDFiY05aaFkyWm1LZVBHZmNGTk4zMUpUbDRsd1ZPbjB2M0FBWFR4OFZUZWVCWGZka25qMTVsM0VCYm0wM3JBM3Q0NjRjTVB4N056NTBzTUdoUkgxZHExN08vVGg2SXZ2aUQ4bSsrWjBlVWVCdDN5UDNic3lHandEWDc3YlRkZHU3N0dwNS8rZ3lJNGhMaGZmcUhUaWhWVUxGOU9sNWNuc2ZPRC9qejZ5RWdVQ3FIbHZmVE1tVlA4YnJtbEg4NmlJbzQrOHd3bFAvMUU4TU1Qa3poNEF0ZStzSnpzN0xMenVvbkpaR1BhdEhuOCtPTm12djc2VGdaY2RSWGQ5dTBqLzkxM3liOXZDaytNSG8zdlBkZnc3KzkzQTlDdlh3d1JFWDRYQkxablR4WlpXV1ZuQjlhcUZVTHg5OStUOCt5emFHSmk4RnU4Z2tlL1BjU3lMMzV1a3FlN2ExY1dnd2UveHlPUFhNWTc3OXhJeEJ0dkVEQnhJcGtQUDB5OEtlRkVUK3ZGNXk3bDVqNC9OTGhjVVpTUVJGQ3FqbG1KTm9aN1grL0tyRmtKWndkZThOR0NvenVkUlYyZDNTZVNHdGFUcFpPV1VsMXRPK3ZOUHZ6d0x3YnE0dkFaK2lBQWhXdXRyTS9ZZWRZL2J2cjBOU3hjbU1qSWtmRTFJNWl3U2FUdlBBalVqSjZVZ2gycGNEWldxeEo3YVFqZTRYbFlLb0xSK3hhZE9BRFg2UVNuVThEbEZEaDZWSTNURHIzNzJhaXNFdkFKNndWTU83ZEp6MTVmdEIvb1dyTm1OckZCVDNmanhsUnFSNkt5R3ZTN3ZMd0s1czdkZnRacjdCWWRRbEVjSmxHSldIZ3JoR3pBRUxXalpzQlNwYVNxUkkyNVRJM05JcUFRNE1BMk5mNHhWaFFtbC90MUxTVUpCSWNPbFJLMGxYRUlZaWpLd3N0eDJIUTE4VGVuZ0wxS1RXV1Z4S0c5T2c3djErSnlDVmhOU3BBRTl3TVdCRkFKU25ScUJaSTlESzFnUkhENTRpcXJHYUtxVkJKT2w0VEZva0dyRmxBTEFpNlhBb2REUUtOdG9KZHVhK0txOHNmaGtxaTBDUGpvZkFFYmtpV281b0VvSk1LajdLaU5Ua3F5L0ZIcm5NUjB0S0wxcytOMHV0bG82WGlJeTlEdUlGTHdFZno4czNFNE1uRUtvQWc0QklDdnI0aFNKUkhieVlwRmRHTHdkYUJTaWVoMUVnYURzdDVsakcxU3crV1ZRQVFvbEtBTnpzY3FpTmlxa3RFRUZXSno1clAzdlNDOG94eEVYMmRHcVFLTjNvVSt3SWx3bkVicFhXOHZzRTFxdUtESURvcVRGVkViV0loUDczbDR4L3pERDE5cENmazdoRGUvRTdDV0s4bkwxS0JWS2lqUFZTTTZhcHlWb0E2Z3RMVGFmWUJUVWdwQTM2V1dBMU5yYXBxYWtndzEwckUvM0Y2b0lqekd6dENyeTduMHVncjB2azVjRGdYb081T1NrdTgrSnAyWW1JbmcxUitwZWsrdHp5MmlRTUxWdnBneUhDZ1ZRYnltcitZYlRBUUYxL1pTcGZiT0ZCVnRkUi9nL2Z2ektIU09JSmphM2N2dksvM0k3YTZnS3E2YWZVWXZKTFVQVDFoTDZLWTdaYW1pb09hM05XSHU1YVVsU1dMbVlsOVFoOWI2Zks3Rm13RFJoVllqb0ZEWGVQUDU1dHJEU3lIb0ZuNzRNY245T2g0ZmY3b1JaK2pKL25DcFE4RWhzeHFOVXFKRXFVTGpGRUdDVmRaVFE3c0NpUVYza0pCd3hQMkFpNHFxZVAzcjl1QlZNMVc3dzZFbjJPRWdWMURoVUNocXhzOUsyR25WWVhQVmVHY3A0bWtlZW5Ldis0WnAvL1BCYW5aVXZBdnFZRW9kQ2lvVlN0UmlUZnRzVXdnZ2dRT0JTcWNBdmlONDU4ZEI3TnlaNGI3QUxwZkltQnYvNUxENkoyNzExL0JVUUJsK0toRzl5MFdrNEdTc3NvcVZ3VmtFQnc5bTV1WVhlUDNOVlkyTGVMVEpYbGU1bWVGai9tTEp2UGs4RWZjOFQxUnRxKzJrd2gvbW80WFg4TndMdjlXN3M4MXROSHhjaW90TmpMaHFIdi8rL1FYRWRwK0FLZ0NNUFNtUFhNd04wN3J6ekhOTEd6ekhyTUpOeE9VU2VlWFZQNWsxTzVnUDNsdkUvZ05WdlBmK1g1aE10dk1QNHJtREhEbFN4TTIzbnY5NUQvTENORStYMDRJL0R5NEE0WUlQcDdGWXZrdlY2VndkTDZnUUs2bm82ZGdFakFzRkdIL1JtclFNTEFQTHdES3dEQ3dEeThBeXNBd3NBOHZBTXJBTUxBUEx3REt3REN3RHk4QXlzQXdzQTh2QU1yQU1MQVBMd0RLd0RDd0R5OEF5c0F3c0E4dkFzclN3MUZxWU52UzJSZWFFblhuNitpNmVQMzBNNDhmV24yWEo5TVNMMlA5YVcrLzM2UTgveVNYL0xXeGhRbUVocVkvSUM5TmtZQmxZQnBhQlpXQVpXQWFXZ1dWZ0dWZ0dsb0ZsNEZPbDF0N0Q5bEhlTzN0MURoaGUzOFgvSkdUelQwSjIvYVg1aklIeFkrcjlPbWRmZGRzQy92bjN3d1ZJMHNXajRiWWtHcldDbWUrUHd0ZGIwNkRyajJSVzhQaGJHOTBYMk80UTJid3JuODlmdTdSQjE0KzlaNWw3YXRqSFMwT2xxU1lSeVl4ZmtpZ29OcU5VMXZqV2p1MThlV3ZhUUFBZWZHa3RWZFUxeVVDcnF1MnMzSkJaWnhsdDNrdS84OVFnVk1jQVJWRmkvcDlIbUx2c01IT1hIZWJ2VFZtMW9QeDhOTGhjSXN2WG5NenNFT1N2NDVrSCtyVDlac25icU9iWHowYnoyRjA5Y1J5Y1N1ZjJaMC96K09FTFEvbnl6Wkg0ZUoyczQ0TjZoMUswL1Y1ZWZ2UVMzbjkyQ0JxMW91MENWMVU3K0dWSlRYS3c2VC90NDJCYU9RQTlPd2N5cE8rWnVYVm0vSkxFcTU5dW82elNSbkJBVFdSNTY1NENWcXl2TWUyZmx4ekM3aERiZGgzZXVxY1FvZU1NUWdKckFCUUtnVy9ldVF3Zkx3MTlyLysxMXJXdmZib05RUkJJK1dzaUs5WmxjdWRUTlduWjczNTJOWVVsNWhNUG9VM1g0WUxpbXBNc0MwdHFEb1NjT3JFN2wvUU1wbjIwRHk4KzNQK002ejk5ZVRoYWpaSTdib2huOVBEb0UyVkkwc2t5M0taWmlnZ3g4dTR6Zy9sbTduNHFxdXk4OEhCL012Tk1KNzYvZW1RN0pvM3J4SDB2ckdIQ3RSMzU4cTJSOUxoNkxoYXI4NnpsMXM0QjBISEdBaVRwbHJZQXZHRDZHRzRaMitHYzExbXNUdjZmdmZNTWs2TFlHdkRiM1pNMjU3ekFraFpZY2c2aVJFWHdvcGhBeElDaWNvMFlNQ0NZQ2ZkNjhWUE1Yc0dMS0dKQUJCU1VIQVVrNXh5WHpUbE5udTcrZmd6dU1zS3lDMnlhdGMvenpEUGROZDNWL2M0NWRhcE9kWFdWajhtdHQzOTl1cE1KMC8reU11NWZIclhVU1EzL28zOEN0OS9ZbEJQSmhYejZ6UUVBSGgzVmhpWU5QT2ZPV3I3eExDczJ1cXVxaVk5MTVybUhPakIzOFZIMkg4M3pMZzBIQlJqd01lbkl6ck1peSs2MnZTUUo3RnQ2RjYyYXV0ZmQrRzE5TW9NZkxHdGRHUTBTSVVGR1NzeE9TaXpPY2pWY0o4UER3bUlIR2RrV1pGbkZaSFRQMFMvTEtzLy9hMVBwOXZocFpUTUxtNHdTZG9kTVJyYkZFOVliNCtGSmozY3AzVjZ5NWd5ck5xWHd2eDhQY2VCWTNrV1A4ZHJnb1dHc1AydS9HVWJqK0VEYXR3emovaGRXa1ZkZzU1a3B2NU9kWjcza01WNnA0ZVMwRXI1ZjRwN2I3cnNseDB0QjloM0pKU1BiY3NsanZOYWsvL3Z0QWNUbUg3TnBaOW1rbkIxYWhYdTBvaTUyak5jQ256eGJoS3E2dndVQlJ0elVqRDhXM01INmVjTVkzS2ZoQmNmVXEwNDhWWVdWdjZkZzBJdTBiQnJDdXExcDlhdUw1MkppTWtyYytjUXlRb09OVjd6c21GY0JwMmFhbWYvYmlhdktReHVZVnQvRm95MzlReWZNTGZkVzN6cGVMOTRIVzV2WExHRE9CRTlHanpJc0tRaDZWelY2V2dYa1d1N24xeDZtYWNBYThQbG5pMzhqWUVraWVPell2dyt3Yjc5K2hEejVwTmNCZTFSTEhZM2syOEduTWljRzNuTVBobGF0TUNRbDRUaDRzRklYbTkwSGpOZlZMR0R3eTVjQWxnUXFWVXVLdnI0RTNPN3U2d3NjUHB6Y3FWTlJYUzRvWjMyVVA4VlBCMzRHTHpCcFhWd2NEVmF2cGxsZUhzMkxpMm1XbjQvbzcxN3pPK3kxMTBpMDIya2h5N1NRWmNJbVRhclR6cXhTZCtaS1RTVjE2RkJLRmk1RTlQZEhNRnlvSmprN201UWJieVIzOHVRS05lMFZUa3N4bThsNDhFRXlIbjc0Z3Qvc0J3NXd1bU5IekN0VzFIbW5kZG0yNTBwUHZ6QUNNUnB4cGFYaERYTFp3SUhEaDd0Tk9DK1A0dSsvQjhEUXJCbW1MbDNxSDdCZ05PSi95eTJZbHkzamROdTJwSTBZUWRydHR5UG41eE00YXBUMzFjTkhIQVEwdU1UQlB0ZGNRODZrU2VSLzlCRi9qdWNxWHJBQTY3WnRSRTZmRHBJRWN2bEw4TDI1QzQ2NmFoZllJemhlMEFGTDB1NUxORHd1QlNSSkNEb2RxcjM4enZCblJzT1d4Sm9GekgvNUVoMEFGY29sdEljc28xN3FkeTA4MUlBMVlBMVlBNzdLYW1uangyeVZMWFN0cm9zNWtrQU9xVm5BRzN0ZW9scTZaaWpKVUgzQW1rbHJ3QnF3QnF3QlgwMTRhSFc1RjR6ODJ3RGZ1WnB1bXpJMWs5YUFOV0FOV0FQV2dEVmdUV3FnQTJEWkxRK2s1R3pkSFZlZkFNTzdkVWdkdE9oLzhWb1oxb0ExWUEzWSs4TkRmWENRM1RjdXVsNEI2b09EN09WV1MyYXpiYjRLdDljbllBRis5UE16YVJONWFzQWFzQVpjRDZxbHhZdFd4aFFWbStzVllHQ0FYMHk1d0w4dVhkdG8xODZEOVFxNFk2ZWtSbG9aMW9BMVlBMVlBOWFBTldBTldBUFdnS3M3ZUFnTURMREh4RVRVcitBaE1FRHIwOUxLc0Fhc0FXdkEzbGt0N1pzNkk5R1NWcitHNHZuR1JpV1dDMXk0LzNCb3p0YmQ5UW80dkZ1SFVLME1hOEFhc0Fhc2lSY0ZFMlh5Ujc5ZUZtbk5KcC82QkNqMzYyWHR2bWFUcjFhR05XQU5XQVBXZ0RWZ0RWZ0Qxb0NyV3p4NlBKeDMzR1JKdUcxa3ZXcGFIaE9MTEt6WmRIRmcxOEJyYkpHSmZhcjlKbFNIZXdKN3dWRDlRNVVQSFYxbksxZkQxUWJveW5VRDZzTEFWWWhqcTN1c21MRkhBZWlDd0hWdWtRcGRhTTJhZExXSXF4REh0c1lnaUJpN25BRmRFTG9tNzdrRE5WMFF5RVhZLy95OTZ4bVFBcjBjV0JlRUZQdDA2VGFBRkR1dTdIY3BFQ251NmRKdDc5V3dYSUxxekVBd05VUFg2TTFMMzBURE44ck0zM1ljd1JBTFl2Vk1aRjQ5MVpKaXdiR2pCWTd0elZHZDJYLzVJNHFRVTZZaHAwd0QyWE14Q3RXWmcyTjdjeHc3V29CaTlTSU5pNzVJRGQ4QVp4YUMzdk1CdXl2MVAwZ1JvMHEzZFEzZkt2MU4wSWVqUzVnSytpZ1FmYnpMcEtYb2h5NmVIbkV2U3U0Q1FFV0t1UGZDMytNbmVGOFp2bFE5Sy9na0l2aDNLZDIrNlBuT3pITWFqL0lDNEl2VnN4ZHhhSlEzMGJGY2hPTVA5eDlsN0ZsWTVaNjc2b0gvV3MrV2VUSzNqMVJsbEt5dkFCVXhkQ2dJT2xCbEVLVFNxa25YWkliNy9HcW9wcXJGcE4zMWJOa014SExXVnlqWmN4Rk1UVkZLdGlNR1h3K29PUGIwUWd6b2dtbzlnUmg1RDFLa3UweExNWStYL1FIZTRyUlUyeGxjeDhhQVluRnJMZUZmS0lWcmtRSjZJdnAzQk1XTTROTVNuRmxJVVEvaE92MENjdnFIQ0tJUHV1Yi9RekExOWk1Z3dkUVlmYXNGcUk0VTBJWGkzSHNOdWlZZklJYmVoT3ZNYTZEYTBDWDhHNlZnQmM1RHQ2RnZ2eEdjK1FqR2VOQlYzenh5MWR1MDFBV0Rha2N0Mm9JVTh5UksvbS9JNlIrajJwTkJsWEdhRHlDWW1pREZQb1Zhc2hNaG9IdTF3dFpJVzFySlhZUmFzZ1BCMUFReHFBOUMxSU1JcHFhQWdtbzdXZnBSOG41QmNHWWpSWTJwT2VDVmgxZG03ay9iWHcyVEhyUTc5NTExN3JQNUw3LzdBKzBCR3h6NnFFcXZuRkdVa1ZrdThPUWxrMDhCbmVwWnI4NnB2M1dmbGdhc0FXdkFHckFHckFGcndCcXdKdFVXdG5yc05YdGxQdlhzTlI3Z1I0Ni9wYjNHb3dGcndCcXdCbHcvZ2FNai9Hdi9wa1VWWDZPeitvR2JKNFR4N1h2RGVlTGU3clV5bWJ4T1ZCaDEzVDVldXZWM0hNNHJlekp4V2QyMHg4L2tjU0k1ajd3Q0s0cFNjMnRqbXd3dUh1aTNoL0hETnVGcmNOTHl5Y2R4S1dMMUF3T01tYkFRUWFnWjdRb0NET3QybU9talY5QTRzc0I5L1krR1VtZ3hYcm1WWE03QjZybVY4UDc4cms1cDJ5aUxkeDlZUnYrMnAwdlRuTExJZDcrM3ZycGlVVlUzR0Jic1MyNkI1ZXJ6Q2JEeStvaTFQRHBvQjZMbytjZitjVFFPaTExZis5WFNrTDZKelA5d0JHSEJWejd5UmhKVm5oaXlqYU1mZnNqamc3ZGZBQXV3OTh6Vmp3aTRxSWI5ZlEzY09iZzE4MzdaaDgxZThjcU1KNVB6K1BDclA2NVl3MjBiWmZINVl6L1RyZG1sMXorVkZhRjZnSis4cndjdlAzb2RHM2NrYyt4MGJvV1pIRDZadytHVE9aZDljYU5lWnVJZEczanB0dC9SaVJVdjRhdFNUY0EvTFQvSUwydU9jRGE5c05xY1V1OVdaL252bzcvUU1xN3lmMVREc01McUFiNFNiVlZXQW4zc1RMMW5OWS9kdVAyeXoyM2ZPTE42Z0t0THJrdEs1cXR4UDlFZ3ZPaUt6bThjV1VCNGdJV2M0aXQzampVU1BFaWl5cXQzcm1mMUczT3VHUFpQdWIzSDRib2RMY1dHRkxQOHRhOTUvYTUxRjYxcUxsZEc5ZGxiZDRFSGR6ck83bmYvUzc4MnA2dlUyYlZwbUZXM2dJMTZtZi9jdjRJbEUrY1JIbUNwOHZ6ZnZHdHQzWEZhU2ZIWnpIM21KOW9uVk45OElNTzZINkZic3pTMkhvK3RmZzNmUGlnSm5TUmVOTEo1WXNnMnR2OW5aclhDL2ltZlAvWXpKb09yZW9FSDlHckN4MjhNNWF2cHR4UGdWeGFpUlFXYitYbkNQTjRmODlzVjNjU1ZOa2ZmR3JtbWVrMTZ4LzQwNXZ5MG05T3BCUlNiM1JPUi9hUHpNV1k5c1ppSVFBczFMYy9kdklYdHgyTXZLMlM4TE9DQ0lodlAvM3VaTzhBd09YajcvcFg4ODRZZDFLWjg5ZlJDU3F3R2x1eHNYbjFldWsvck0reDU5N05haHdWM1A5ZjhGMzdnNlgvOGdWU0pldjZ5dlhSaWJDNUR1eDVsOGJaRVJFRkZFbFZFVVVYazNMZW9JZ25udHMvN2xrVGxndU5FVkNUcDNIRi9QVmJ3UEU0VThVd1hQSy8xMUQrMjByZk5hYllkanlNajM0K05oeHB5SkMzczZvQzdOa3ZqeHhkK1FGRUVGQVFVUlVCV0JCVFZ2YTJvQXJJc2x2Nm1LS0J3TGswdE82NzBuSFA3RGtVNmQzeFp1dnpYL2IvbThlYzEvM0l2Z2I0MlVuSURPSm9lZHZVYTNuNGlsaUdUUnlLSmJpMjR2OC9mVmtyL2RVbFNMdndXeTdSWGVwNzBsK1BQNVNYKytidWdJcDUzN3ZuZjdtc3BHUDV5TGQrbWFTemUxb0w4RXRQVmR1TEIvdVJJdkZtMFJ5MGFzQWFzQVd2QUdyQW10U2NlWGZtUDk5VG4zdXhyREExYkw2RTY2d2RnVndxRmNrMzZSTEhxYyt2dkplejhwNTNRVzFRRS9kK2dERnRzOE1nSE50NXlXV240UDRYUW0rc1hlTGxPYS9ZU0ovMWZOV08rMDBXTHVmVUgvSkplZXY5SmhaNFBXL2x4cjVPNFp4VmFmTzM5NEJWV1MyYWJ5dWpKTnA3NFB6dHlpRm9HUHRRN3dTdGREODljN0tUUFl4Wk9wQ3JvbzFUaW5qc0gvZy92QXIrc2hzZWU0d285SHJieTQxcDNWNncrU2lWdXZFTGlWekloTjZrSXVub0dERkJzVVJuMXVvMm5aOWl4bjZ1ckRkRVEvN3hDNHRkMUgveUttNWFmL3VTazMrTVdUcVdWRFZYd0J2Q3Jha3Z2UE9vMjhVVWJQSjgybElKL0pSTXlwRzZCWDNYd1VHaFdHZkdLamZFZjJuSDhwVGxxaUlINEZ4UVM1OGlFREs0YjRGVVdMWDA0MzhtQXA2eWN5Ymh3Tkk0aEZ1SmZQQWQrbzFwZE0xYlVmSGk0N1pCTTk0ZXMvUEw3eFIrb0dXSWgvcVZ6cGw1TDRKVUNidCsrUGUzYXRhdFVoZ1VsS25kTXRQSFNKM2FjNVR4SVBCODgrRWFsUnNFckJTeUtJc3VXTGFOcDA2WVgvTmF1WFR0TXBnczd2Ti83enNuQWNWWlNzc3AvM21PSWhRWXZxU1RPa1FrZVZEUGdsUUl1S2lvaU9qcWFGU3RXRUJzYml5QUlEQnc0a0dYTGxqRnAwaVJzTnR0RnovdmpnRXkzaHl6OHRrVytaUDZHT0dnd1FhWDVsekxCTjFTdnFYc0V4emUyMFZsKzIrKzZZT2F1aUlnSXNyTGNBMGtPSFRxRXpXYWpZOGVPeUxKTVVsSVNSNDhlcmZCQzQrODI4UG9ZQTdwS3dOalBRdFlja2NMVkFxcGNqUjBBNVltUFQ5bC8wS3BWS3pwMjdBakE1NTkvWGlsWWdPbmZPTGpoYVN0cE9SVS8walEyZ0FZVEZaclBsZ20rWGtVUWE4aWtXN1pzeWN5Wk16bDI3TmhGZjU4MmJkcGxYV3pUUHBtdVl5eXMyRlk1dFpXQ2Z5a1RVa1hnRjgzQ1pETHg5dHR2YytEQUFjYU1HWVBCWUxqb3lhKzg4c3Bsdnc1Z3RxcWtaaW1YZFk0VUJQcElFQXpWWElaRFEwUHAxcTBiM2J0MzUrNjc3eVl4OGNJcDNWNTg4VVhlZnZ2dFNsMHNzWUhJTjIrWWFOT2tjcXFTaXlEN1c1RzhoUUt5cFdyS3NJY0xhUllwVGp5ZXBaUkd0MWFybGVQSGo3TnUzVHJDdzhQcDI3Y3ZkcnVkTVdQR2NQandZV1JaWnVUSWtSdzllcFJEaHc1ZDhzSWpyOWZ4NDFRVDhaRmlwVUN6dmhSSm1TeFNzbE80cWg3VXo3Ry9jZjUrcFZ1M2YzcnA2ZE9uTTJmT25MSU1kRHFhTkdsUzdua21BOHg0MnNoOWcvVlVaUDF5SVdSL0o1TDdrMUJkMDFwV0hqZzdPNXVVbEpRTEhKWEw1U3JYVTdkb0tETDM5WXBOV0M1MG0yN3V3dW9EdlNMZzhlUEhZemFiSzNYOHlPdDFmUENzRVg4ZjRkS2c4MFJ5RjFVLzZHVURiOSsrdlZLd1BrWjRiOXlsVFZndWdPeDVBcm1MUkJSYnpRWVBsUVl1S1NtcDhKZ1dEZDFldUhYamk1dXduQTlaM3dyazFRTG9aUU5YSkhmZm9PUDlaeTV1d25VQnRNcUFmWXh1TDN6dmpSZWFzSndQV2ZNRThoWUxLRGFCdWlCWEJWeWVDYnZ5SWZzYmdieWY2dzdvVlFPUEdxUmp4dE9lSnV6S093ZjZTOTBEdldKZ0h5TzgvNHpiaEM4QS9WbEFzZGROMENzQ2J0bkliY0pKQ1c0VGR1VzZxeGR2QUwxczRIdHVkSnV3bjBuQWxRdFozNGprLzRMWGdGWWErSHdUZHVWQzJuOUY4cGQ0SDJpbGdGc2x1TnZDaWY0U2FUTUU4cGNJS0E2OFdzb0Z2dmRHUGRQdk5XS2VMM0trSG9DV0MreHJndjk3eU1RTnFRWlNIcWcvb0JjRmJob2dXSis1eHQ4bjdET0pYQ2VhMUFmeGNMV1B2amRjSGJjdEhXZXhoRFh6MHVNWTlQNHl2bkVPVmtlRU1PT2FtRG9MZVBpMi93cmxtblN1YkVCMUNsZ3o5YmdFRUFNQ0NHclhHdDlJUHdUckFXeXB4OGsvWmtLMkMxQWlZY3ZXNHdvVHZiY01CNHBPek9rR1ZDQm0xSjJZL0JXRUlCWHpwcFhNdjdZekE3c0dFM284Qy8vOEU1eFlFZ1I1T2dSVXJ3TDJVRStSb2tkeENDaStQZ1RFK3VJNHNwSUZQeTNqVUdnU1BVOUl6UHM5bHpmYXRNVVZra2hnWTdmN0xySmRhUHBHU1UrendMSTNQdzJpRGxFUTZoN3duNkk2aTNHZC9wNkZOMTdEeHRiK1pBWHJDQ3kwRWx3aTg5S25hekNHZG9lb0h1WDNWYWtLd1FhLzBuMm5Jak1vdGpNQ1F0MENEcEpjNkFOa2RFNGQ1bE1aM0x4bERSTVNmRWx2RzRCUHpuWWU2TnVOc0JzSFEwQXppcmJzUkJBaHpOOStRYVl1UmVaSVlRb21TYy93aEd0UlViSEpEdTVJNkYyM3luQ1JyTU1uMm9sc0VjbmNGb2k0cnhqL3VEenVqajZMcmtrM2JJY0ZjalpzUVM1YWhVRVU4WXV6WTNHVXpialFLN0lWeDRyU01MdHM5SWx1eTVLejIxaVE3RjZSYmsvK0tYN29PNEdma2pmaFV1UzZBUnlqdDZGWUJYeGluQ2dwQnJEcHNKelFZVG5oQWphVjFtTTZ3QlR1UkZVRVFuM0xtbUo3OGs0aHF6STIyY21LdEYyb3FLVndlbEVpMWplTUtGTXdxWmJjdW1IUytiSWVmWkNNczhTemFBc0dCY21vb0p6bmtSMUZPb3loVGdxdFpVN0w3TEpoazUzRSs0WnpUV1NTUng3ZHdsdTQvMkZScWp0bDJLbUsyUE4wT0FyY2lsZUJUVjBqTVE5MEVIOXJIdXQ3eFZDc2QxZEVpa09nNkxqcG9xK3dwbGh5V0oyK3AzUS96QmpJRTYyR2Nyd29qZVNTN0xvRGJCUVZMQmtHekFhQm5XMkNhWEpyRGtjU2pRUWVncnpkdmppQ1pYUURIQnpwNkVlUkhseFdDYnZUTS80d1NYcDhkY1pTYlE2Tzc4STNmVjdBUnpJd2FkZFhxTFZjYjN2Y3JVVVdRUVZGSjdBblJxTDl6eUhjYkRwTHdoMkZsS2g2K3E3SlFFa1RLR2lxME55aGdpQmdrejNOM3k2NzZCdmRsbjR4N2VnWTJoU0xiR2RGMms1bUgxOUpqcTJvYm5scGYxSEdFQ3dqV1FRNnB5azB2YW1RRi8wNkVyYmVqbzhnczd4REhQMWFKUk9aSzJJMUNBUW9LaEYrbmozcktpcHJNdmF5Sm1NdmRWRThOYXpxOEkyMW81d1VhSE1nanhQN1EyalRwUVJyRzVVbXdXYjhEcnR3N2RTVDRDeEJGQVFDbXRteE9uM3hKdkVBanRMWmNPVHBNSWE2Y0tVWlFJQnJkK1RpMnEzbkJHSDBrYk1SRVVBQVU0UVRaNUZFVUVPbjl3TG51QXdZUTEyVW5IRVBORHVRZW95QzRseGNCZ0ZVRUdUd1VmVzBiZFVKY25TRUNNOVZJZ0FBSUFCSlJFRlVKRmtwc2daNkw3QWtxRml6RERqTklydlBIR0IvcTBqT2RtNUxndE9Jb0lKTmNYSFFZTVArNFdwNmRMcU93aU0rR0hzcFhnWHM0V0pkcW9BdFIwZGFxSjZTekhUTTEwUXdkbytMeDR4dCtJZXVoQWYzbEdCcEZvaTVld01PSi9paXVBVHlMUWJ2QmY1VEZNa2QxUmdFRlVGUnlWWTI0dWZUSHRIb1I2RE5nWWlDUTE4UCtxVjFnb29wM0Vsc0RxUUVoVkIwMU15dkRVSm9sZVlQSE1VZXJsS2M3OEt3TFowMnJxWklCcFVnSHk5MldpNVZ3Q2ZTaVd5VjZOR2lNOUtLWFpqdEplVC8yZnhWNEk0U0d6MTZEc1NnUW1CekcxWm5nUGNDUitnYzJISU5HSUpjT00wR3VqYnZpS3lxV0V3aUFxQjNxUmhsTjdodnRBTkx1cDdRS0x2M2x1Rk1sd2xqcUFON25nNFZzQ2t5ZGtXbUtGd2dKMVpBZHNqWUZCa0ZGVXVHQVZPRWk0S3JtQW00MWpYc0s3aXdwQnVSN1FKbld3anNUQWlsMkNDUlpTOUViM1BoMHptU2tDS1pCSnVGTGxzY0ZKOHc0ZFBMNmIwYUxsRWtIQVVTMWxDQlNjTVMyTklpZ002eEJaenFHTXVwbmcxb0Uyem1XRXRmM3U4WngvYTJQaWd1Z2R3U0w5WndvQ1NqODFXUUxDS0RUdVpUNHRUelFmTjQ0ZzVtWVhJNjJlMGJTbFNxQTc5NEIvR1o3ckliN092RlhycFExdUViN2NCMXlzakk3L001bm1TZ3g5RUMwaHRLb05jVGZhUVFCSUdrdFhZTVZ2Q0pjT0p3ZVhId0VLMjNveW9DdnRFdUxPbDZtaDF5NEZKVVdoMDRGL3Fwb0JjRlJBUU13UzUwZmpLQjNsd1BGeXM2UktPQ3M5aGQ4ZVpIK3hEMTlBMUlrZ09ydzBxdzdTeEhmeTBnZW5zZWlsMUFIeUJUYk5ON0w3QkZsbkNaSmZLc1J1VHhIZW5SSWdxOU9CQkJLc0NTdFJCMTZ6YjZqK3pObm4rMElPK3JmUWhuUUdqanhZOWFBa1FubGpRREJiMWk2TjcySG5SQ0h5VGRDWEorV1UzZVFna2EzSWw2YWlPSkoxWVNlbnMwemlMM1RHZGVxK0VpUlkrcWdpTEx5R2Rub2pvVml2WGhLQTVmZEFFaVpxZUFYNy8vb3N2S1I4bmJqY2h4ekE2ZDkyb1l3QmppSXNDZWp5eGFNRVhFRVppL25PQU9lUmk3bXZBTGlrRW5wNkx6TDZEb2RBWkJpVmE4VFM0QUZrU1Y1bkkyZTk4OHlSL0hrcEVkT3ZUS1lmemF0TUtlWnVWNGJpNGIzL2lHMkdYYjBmbklYZ2Q4Z1QycUNwZ2luUVNLQ3E0WlI5aHFrc2p6dHdJejhMSExSSCt0RWdiNDk3RGpzb3JlRCt3b2REL2s5b2x5VUh6S1JKQk5JTWptV2RmcUEyU01JVTRzcVg0UTRlVW1yY29DUlNkOENFaXdveS9IWkFNUzdLZ09FWE9hd2Z2TE1FRGhNUjhFU1NXdzFZWEQxd09iMlBDSnNaRjN3QmRWRnJ6ZnBBRVVwNEFsM1loZnZKM0lyc1dZSWx5b3NsdjdMcXVJWXBPdzUrbndSaW4zcnZNUCt1QXNGcEh0SXNWblZFQkFzWXNZSTV5WVU0eklEdS9zeFB2YmlZZWEwZ2xUNnh0Z0RMbVgvOEowZlJJTldBUFdnRFZnRFZnRC9yc0RDMzYrQ0FHMXMraHJqVVFBUW9BL1B2Y094M1RyVGVpN2RVSUlkRDlpVmMwV25MdjNZVis0Rk92c2IxRnlxbjhNWnZVMkxRVUIzNGZ1d1gvS0pNU0lzRXNlcWhZVlV6TDFYY3pUUHdLNTZycU8vdHEwckRaZ3dXQWc4TE4zOEJrOThyTE9zLyt5bklLN0gwRXRMdkVpWUVFZ2FPWjcrRHc0eWlOWlBwdUs3ZnRGdVBic1IzVTYwU1cxd09mQlVVaHhubS9GMkpldUpQL21VVldpNlJvSkhud2V1TnNUVmxXeGZEcWJuQmJkS1I3L0t2WmxxOUcxYUk3eHhnRUlmaGMrakRNT0dZai95ODk0UnhrV2ZIMklPTDRkTWFac1lkWENoNS9CT3ZNck44d04vUWo2NWpQRXNGQlVod09obkltTlZMT0Y3S2FkVVRLejY3YUdUY09IZWNEYWYxNVdDcXRybFVqd1QzTVF3MElCS0prMEZSU2wzS3JMOTZGNzYzNDliQm8yNUx4Q0sxUDArQXVsdS81dnZJamdXellabVgzeGIxZysvc0t0VWJzRHg0WXQ0Q3FiT2RCNDYwMTFIMWpYdVgzcHRuUHJUdVN6cVFCSThiR1liaC9xVWE3VkVqUEZMN3hPL2sxM2tSWGFGTmVlL2FBcmF4cm9PN1FCU2FyRHdLS0lGRjIyV28vcitLbXlQNkpqV3hBRUhDdldVdlRFaTJRMzY0S2NtbzVxdFdGZnVoTFQ3VVB4Zlh5TVozNlNWR0g5WGZ0TnkvUFhGei92YlRUQllBQkJRTmV4TGJyRXBvaEJucU53OVYwN2N0SEplNnA0dmZLcUJWWVU1SXl5WlRaMXpjdm0yWElkZHMrcko0YUg0ZnZVSTRSdFgrWGVEdzVDakkybStLVTNrVStlOGN4UGxsR3ljK3UyaHAzYmQ1ZHByVXNIcElTR2J1QURoM0ZzM0ZLbU9KdmQzVUQ1YmlhUnlYc0lXZmdWanJVYlBmUGFzYWRjTDE1bmdPMC9MZkVvZzRHZlRpL2RMWms0Qlp6dUIzT3ExVXJBbElrWWIrZ0hrb1RoK3I0WHRNeHNDNWQ2UWNQRHgwVDQwYTFJOFdWdmx4WTkrUktXRDJlV1ZsdUJzMllnQmdhNFBYQTViNTJxeFNYdWhzZFZtblMxTnp4VXE0MlNseWQ3cEFXK1A0MmdPUjhqQlBoalc3aVVuT2JkS0o3d0ZvNTFtMUFMTC81cVQ4blVkNnU4L0ZacjhCRDR5WFI4eDk3djZkT3ljN0hOWDR4cjl6NVVwd3RkcTBSTWQ5MksxQ0RPczFqOHZJejhZZmRXU2ZtdHNmQVF2WjZnajkvRzV6S2JoL1pGdjFKd3p6OVJTOHhWY2hzMTk2akY2YVR3a1djcGZPanBTZ1VBYW1HUnU5VjEyLzFWQmx2elBSN25CUUkrbys3QU9Hd0krdTZkRVVORDNDWmVVSWhyendGc1B5M0I5dFgzS0huNVZYN3RtalBwUy8wQlJnT0lJcXExK2lmSSt5dHdyVHpHVisyMU45K04xaSt0QVd2QUdyQUdyQUZyd0pyVW1IZzB1L0xYcmswSjd0TW5yaW92c0tOdFc4ejc5OWNtNDQ5OTRJNi9yVWxmVmx0YXNWaklQRzhGZ0xCYmI4VVFGVlYvZ1YxRlJSeDc5TkhTZmI4T0hid09XS3VXL3RabDJGVlFRTW51c281MVYxNmV4KzhsTzNlaW5MZTRsRytMRmhoaVlyd1h1R1QzYnZiMjYxZnU3OGNmZjl4alAvSHp6NGwrNkNITnBEWGd1bXJTUWRkY1E4L3NzaTVXUjFZV08xcTNMdDF2OCt1dkJIVHBVcm92K2Z0N043Q2cxNk1QRHkvZFYxMmVDeG5xZ29NOWZ0ZE1XZ1Ayc3FhbFBqU1U5aHMybERVdGs1THFON0JnTUJEVXUzZjkwWERKN3QzNWNrRkJsY2JEY25GeDNRVSsrZlRUUjRBMm10UFNnRFZnRFZnRDFvQTFZQTFZQTlhQU5XQU5XQVBXZ0RWZ0RWZ0Qxb0ExWUExWUE5YWttc1JqWU5wWjMrajVvTjVlenhCL2JHREp1RU1yd3hxd0Jxd0JhOEFhc0Fhc0FkZTRWUHZMbG9LZkwvcldyWkFpSTBDU2tETXljUjAraGxKWVdMK0FqZGRkUThDVFl6SDI3NE5nK3N1S1BiS01mZE1mbEh3K0crdFB2MVQ1MUJVMUNpeUdoUkk2ODBOTU4vUy80RGNsTHgvbi9vTW8yYmtJUVFFRXZmVUtBZU1lSTIvMFAzR2RQTzE5d0xxbWpZbjQ1UWVraHZFZTZZN05XeW1hK2c2MmRSc3ZtQVZObjlTU2dLY2Z4VHozQnh4L2JQY2VweVVHQlJIKzQ5ZWVzTEpNNGFTM3lCcDRNN2JWNnk0NjVadno0R0h5bjNvUndXQkFkMjVXRjY4QURwcjZLcnJtVFQzU0NsNTRoZUozUDZyVStmWU5teENNeG5Jbk1xbFR3UHFXaWZqZDV6bTdvWFh4VWtvKy9lS3k4bkVlT1lhdWNhUFNmYjhIN3FtYndMNmpob040WGxhcVN1R3JVNjRvTDllWnM2WGIvbU1md0RUa2hycm50RXlEci9mVTFMNER1STZkdUxMTVpCbEJwM09QelRZWUNQMzQvOGpxTXhoZFluTk1BL3JnU2ttbDVNUC8xaUt3SUtCcjB0alRLMi9mZFhWWm1vem9HalpEREFwRWpBZ24rdUMyYytWOE00V3ZUSzVkRFl2Ky91NTVPYzVYVW1iV2xZRWFEUVNNZndxL2grNTN0OHpPenpNNWhkeTdIMFIxT211M0RDdG04d1hWalJnY2ZFVjVxWFlIUlZPbWt6L21NVXIrTzlzRFRnd05ScXlDR1l1djNta3BDbkpxK2w4YUV5MnVLa3Y3NzM5UThNeEw3amw1WEM2c0MzNUdWVlZDUHB0eDFkVldsWGhwMjZxMUh2dUdYdDBSUTRLdk9MOC9aM0lSOURvS25wOUU3cjBQazU3UWhwSlB2MENmMUxMMmdTM3pGM21XUmIyZWdQRlBYWmxUT2E4ZUx2bmlhMHIrTzl2OUo5anNXQmYrZ3ZQQW9kb0h0cS9iaUgyZDV3Uisvbzg5alBHYTdwZVZqeFFXaXB5V1VicGZPT210T3RxMFZGWHluMzRKNWJ6aC9vSkJUOWgzWDFZYVdvcUpSdGUwQ2FyZDdsRW4xOW0ydE92b2NmTHVlUVRWY1o1bkRRa20vSmY1QkwwK0FUR2duSldvUlJHLysrL0dPS0FQOXEzVkh5MVYrYk1sUTlkT2hNMzdBaWttMnRNSUxGWnNhOWJqM0wwUEpUc0hJU2dRWGZPbW1IcjNwR0RDNjFnWEw2MHVSSTluUzlYeU1FM3c5eWZneWJINFAvNXd1ZDVhdGRvd2YvMHR4ZFArNzRvYktuVUd1TXpsNmpEMjZJS2hjeWZFNkVnRW5RNDVJeFBuZ1VQWTEyMnNrUm5UL2dwY3ZaMTRMaGYyalZ1d256ZEZhMjJMMWkrdEFXdkFHckFHckFGcndKclVtSGcwTFF1bVROa2VPSDU4NS95U0VnWU9ITWpldlhzdmVYSjhmRHhyMTY0bElTR0J3c21US1hqbGxTcTZLNkhLampQMjZaTVNzMlpOZzR1YXRHMzU4dWljRVNNSURRemt0OTkrbzNuejVzaXlYTzduekprejlPdlhqN05uenhJMGFSSkJFeWRXRGJDcVZ1NmpLQlYrQkVXNTlJVGFsb1VMeWJubkhpTER3bGkxYWhYTm1qVzc1TDJkUG4yYWZ2MzZrWnFhU3ZEa3lRUSs5NXozT1MzemQ5K1I4K0NEeE1iRXNIcjFhaElTRWk2WnlZa1RKeGd3WUFBWkdSbUVUSjlPd0Y5bVlmSUtMMjJlTTRmY3NXTnBFQi9QNnRXcmlZK1B2MlJHUjQ0Y1ljQ0FBV1JuWnhQNndRZjQxOUZwcGk1WkxaVjgvamw1NDhiUnVIRmpWcTFhUlhSMDlDVXpPM2p3SUFNSERpUTNMNCt3eno3RDc1NTd2QXNZb1BpREQ4aC8vbmtTRXhOWnRXb1Y0UlZNTnJSMzcxNnV2LzU2OGdzTENaODlHOTg3Ny9TK2hrZlI5T2tVdlBvcVNVbEpyRnk1a3BDUWtFc2V2MnZYTGdZTkdrUmhTUWtSMzN5RDd5MjNlRjlMcS9DdHR5aWNPcFgyN2R1emZQbHlBZ01ETDNuOHRtM2JHREprQ01WV0srSGZmNC9QNE1IZTE3UXNtRGlSb3YvN1A3cDA2Y0p2di8yR2Z3VVRobTNhdEltYmJyb0ppOU5KeElJRm1QcjM5NzYyZFA1enoxSDg4Y2YwN05tVEpVdVc0T1BqYzhuak4yell3TkNoUTdFcUNwR0xGMk9zNWNtTHJpaDR5SHZpQ1VwbXplSzY2NjVqOGVMRkdJM0dTeDYvWnMwYWJyMzFWdXlTUk9UU3BSaTdkL2N1WUZTVjNFY2V3VHgzTGdNSERtVEJnZ1hvOWZwTG5ySjgrWEp1di8xMm5BWURrYi85aHFGalJ5OExEeFdGblB2dnh6Si9Qa09HRE9INzc3OUhxbUFGdTZWTGx6Sml4QWhrUHoraVZxeEEzNmFORndFRHlESTVkOStOZGZGaWhnMGJ4dHk1Y3hIRlMyZTVhTkVpN3I3N2JwU2dJS0pXcmtUZm9vVVhBUU9xMDBuMm5YZGkvZTAzUm93WXdlelpzeEVxQ052bXo1L1BmZmZkQitIaFJLMWVqYTVwVSsvcThWQWREckp2dXczYm1qWGNlKys5ZlBiWlp4V2VNMi9lUEI1ODhFR0U2R2lpVnExQzE3Q2g5d0NEZTlHM3JLRkRzZi8rT3c4Ly9EQWZmUEJCaGVmTW1UT0hzV1BISWpab1FOVHExVWh4Y2Q0RERLQ2F6V1FOR1lKOTYxYWVlT0lKcGsrZlh1RTVNMmZPNUlrbm5rQnEwb1NvVmF1UXFubUM3aXJ2eEZPS2lzZ2FOQWpIcmwwODk5eHpUSjVjOFVDeVR6NzVoR2VlZVFaZFlpSlJLMWNpaG9WNUR6Q0FVbEJBNWcwMzROeS9uNGtUSnpKcDBxUUt6NWt4WXdZdnZQQUN1dGF0aVZxeDRvckhldFVLTUlDU2swUG13SUU0anh6aHpUZmZaUHo0OFJXZU0zMzZkQ1pObW9TK1F3Y2lseTByZjVoRVhRUUdrRE16eVJ3d0FQblVLZDUrKzIyZWZQTEpDcytaT25VcWI3NzVKc1p1M1loY3VoVEJ6ODk3Z0FIazFGUXkrL2RIUG51V0dUTm04TWdqajFSNHp1dXZ2ODdVcVZNeDl1NU41T0xGQ0NhVDl3QUR1TTZjSWJOL2Y1VDBkRDc1NUJQdXYvLytDcytaT0hFaTA2ZFB4OVMvUHhFLy9WVHVXdU4xRWhqQWRlSUVtZjM3bzJabk0ydldMTzY2NjY0S3ozbisrZWQ1Ly8zMzhibnhSaUorK0FHaGdnQ2xUZ0VET0k4Y0lYUGdRSVNDQXViTW1jT3R0OTVhNFRuanhvM2prMDgrd2VmbW13bWZPL2VxbDlpdThZZHB6djM3eWJ6aEJpU3ptVysvL1phYmJxcDRZZlRISG51TVdiTm00WHZubllUUG51MzV1a0ZkQndadzdOeEoxbzAzb3JQYm1UOS9QZ01IRHF6d25JY2ZmcGc1YytiZ2Q4ODloSDMyMlJVUEk2NjF4NlgyUC80Z2E4Z1FqTExNb2tXTHVPNjY2eXJvYzFCNTRJRUhtRGR2SHY0UFBVUm9KZHJxZFFvWXdMNXhJMWszMzR5UEtQTExMNy9RczJmUEN2b2NGTzY5OTE3bXo1OVB3T09QRS9MT085NEZER0JidlpyczIyN0QzMmprMTE5L3BjdDV5eWhjdk05Qlp1VElrU3hhdElqQVo1OGxlTW9VN3dJR3NQNzZLem5EaHhQazU4ZXlaY3RvMzc3OXBhczRsNHM3Nzd5VEpVdVdFUFR5eXdSVm9xMWVwNEFCTElzV2tUMXFGS0ZCUWF4WXNZS2tDaWJjZHpxZDNIYmJiU3hidG96Z3Q5NGlzQkp0OVRvRkRHRDUvbnR5Um84bTR0eXo2Y1RFeEV0N2U0ZURZY09Hc1hyMWFrTCs4eDhDbm5qQ3U0QUJ6RjkvVGU3WXNVUkhSYkZxMVNvYU4yNThhUjlnc3pGMDZGRFdyMTlQNlB2djQvL3d3OTRGREZBeWN5WjVUejFGL0xsbjB3MGFOTGkwWlZnc0RCa3loRTJiTnhQMjZhZjQzWGVmZHdFREZILzRJZm5qeDVPUWtNRHExYXVKcVdEaEtyUFp6T0RCZzltNmZUdmhYM3lCNy9EaDNnVU1VUFRPT3hSTW1rU3paczFZdlhvMWtaR1JsejYrcUloQmd3YXhjODhlSXViT3hYZllzRXNEcTZLb0lrbFUrQkhGeW4wRW9YS2ZTMGpobENrVVRwbEN5NVl0V2JseUpiR3hzZmo1K1pYN2NUcWQzSHJyclJ3K2Zwenc3NzdEZE1NTkdmeWR4ZVB2WGZYUDE1dzluaHlsODAxcVRtcEdBYU9lL29MMVc0OWZjTkwvL25NZnQvZzdPSEpYV1pkTjhBM1gwdUs3RHdsczh3d2xGcnZIOFUwYWh2UHRsT0VFZmp5VC9GL1hFdmY4SXpTSTZWcFRqRC95UUxlTHo1Z21aV1lMQi9xUEl1dC9QeEFYRmNUcWI1NWgwaE9Ea2FRckwrcDNETzdJNzIvZGpQVFA4WlJzMjBQTEJaOFNQK0d4V3RPd0I4blpCMGJiUW04YnhLbG5KM1BzZ2VkUmkwdDQ4OW1oL1BibGswUkhCRjVXeGlham5vL2VHTTZNRm5yTzNQWUlwa1p4dEZuL1BVRjllM0EyUGI5dUFELzAvckxDbnpyMm9jbEhiMUt3ZkFQN3JyMlRrdTE3R2RDckJidVhUbVRnTlpWN3M3TjVRaVNiWm8ybC95L3pTWDd0WFdLZWVvQ1dDLytMSVRxQ24xZnRvK05OVStzR3NNT2xxQzlNVzhDRHExS0pYL1FGb3E4UEJ3ZVBKdTI5TDRnTThXUFpuQ2Q1NjdtYkVTL2hXZThjMG9rTnJ3NUJmV2djSmR2MzBXTCt4elI0NVVsa1FlQzV5Zk1aOXNpbjVCV1lhdzM0b3U4dExWbXpuKzZIVXZqbW5TbkVmdnNkWjkrWVFkR0dyVFQ5WkFvVEg3K1JyTnhpS09jOS84a05WVTdmTVJiL0x1MW85c1hiR0dLak9KT2F4MTFQenVTUDNhZHIzVXQ3QUYvYnRxRWhLcW1zUmZQaHQ1c1pmdE90REx4cktGbGZMdURzNUErSkhqdVN5TmFKRkpRWDZoMDZUcE9QSnhOMis0MElrc1RXUGFmNTVPdjFOSWdKb1VGTTJmaXVIK29DOFBpUnZmeUg5cng0aEJKNFRaZEtaZGprb3pjOTlydTFUNkJiKzRRTDY4UFoyMm9mT1BEdDl3emJ0dTZzMUltS3hlcXhYN0I4QTl2aWVsVCt5bE0rcUhLWUVIMEo4YjVaN0N0c1VqbGd3ZUc4QU9SeTVHck9yUXE1dmNGNm12bWw4dEsrSnBmbnRMeE5ib3I1Z3dtdHZpSFJQd1dUWktkdnhCNW1uaDdDckpPRFVUMGJrL1VEZUVsNmR4UlZZT20xRXdENDltdy9acDRjVXJHR2kxNTh5akc0YzFPZnlseWtZTmw2am85NTBjT3BKWDUzR2VYeWh3TlZDdDNFTDQwRnFkZVNaZzJqc1g5NjVVejZQL04zbE16NWJvc0g4TFZkbS9QSXlONFlqVHFjR2Rta2YvUVZEVjU5Q3NuUDE3TUY0K2VENU9lTHE2Q0l6RS9tWWoxMmlyQTdockFuSklaWlAyekNidmRjNkpXdUhhNEl6Q0E2Y1NqNmM1R1BpbDUwNFZEMHJNM3V3TWNuYmtGRm9IWGc2Y29CYjlpWDdPQ01PM3owOVRFdzQ3WGhqQm5lQzREYytVczU5ZlJiK0xSc1FuRkJTZmtaQmdjUys4SlkwdDc1bktQM1BrTk12NTVNZVBFcDduN3RSL1llVHIxcTRDNGhSN2tsN25jK1BYRXpVOXZPWXN6MjhUZ1VPRkJVVnZXZHYxMnBIbytrNWpIOHNmQkZ4Z3p2aFdLMWNXcmNHeHgvZUFJUjk5L09vYWZHc1dUenNYSXpIUGZHOXpoa2hiZ1h4cEwwODB3c0I0OWh1K2R4Vmo3YmwwZEc5cTV3ME5xZllwUWM2TVN5YVMxOGRlNlFjMHRlSys1dnRKeVRRMFloQ2dvV2wvSEsyOUtDSVBEQUhUM1p0dWdsV2plUHdYcjBKUHNIakNKMzBRcWFmRG1kdDhWNFJqenpKUTVuK2ZOci9PK0h6WFFmOW0rT25zb2lvRmRuMm03OEFmOU9yVGt4L0hFbStlUXg3OTNSQkFWVTdDWmtWZUxIbnEvVEx1Z2s3M2I0bUI2aEI0a3dGdkJ0ajhsRW1kelIxbTJ4RzNpdDlaZm9SZGVWQVU5N3VIL2dyTGZ2eGNla0oyZmVZdmIzSFlua2F5SnczcWZjK1BsMlBwbTdIbFZWSzh4MDcrRlV1Z3lkeHRjTHQ2SUxEU2J4bXhrMG12WUNhUi9NcHMzSEg3THQ4ekVWNXVGU0pITHNRZXk1NFdFZWJQd3JHM0xhNGxSMFBMdm5VVzVZL3paNWpnQ2EvZllWczA0TlFTZklWd2JjS2lGQ3AxaXNuSGpzRlU0ODlncVJEOXpKZ1NlZW90dllMOWgxNE96bGRiVmE3TnovM0pjODlPTFhXTzB1b3NmZVRldmxYK0hNeWFOd3hOZ0tIZE1icmIvay9vUmw3aHBBWjJGcDc1Y0oxRnRJc1VTd01yTVQvejQ4a2pQbUtGSXNFVmhsNDVVQjYwNmZFZmYzdTV2OHBXdG9QSHM2L3hMaUdQbmNISXBLcm16NkNWVlYrZUtIVFhTNzVWOGNQSmFPWC90V3RGbjdMY0dES25nMGlzQzdSMjhuWXRGUEpGc2lHYlQrYmU3Yy9DbzVqcURTMzk4NWVtVnZ5M2g2a1A5dG5RL1VxVlVBSG0rNmtFOU8zb3lpVnE2YlNSSVVaTTlqeSsvVHFvdHlPYkF0QTVJWkV2UEg1WGNBMUNXcERHeUVzUUJKVUhpZzhXOGsrR1d5TGM4OTZEelRGbEkvMjlLTi9UTDRzdHUvYVJtUURFQ2Y4RDA4dk9NNWZrN3JXYm1HaHpkSXFLRnM3cTZ0ZVMyNWIrdExaUjBaZS85NVVkZzZBVHkyNmMvNDZXekUrdVJ3VjRQVmxUb25XRi9DdExZelBkTDZSZXhtMUI4VDZiLzJIVHFISEsyN1pUaEVYOEsrRzhZUWJDaGg1SlpMdjFLZkZIaUdicUdINlJ4eWxMc2FybVpMWGlzY3NwNEZxYjE1Ly9pdDJHVDM4TVROZVVtWDE1YXVLUWt6Rk5FajlCQ04vVElJMFpjd01ISUhSc2xSN3ZHSGl4c1FZaWhtYkpOZkNOUlplS0hGZHh3dWJvaFZOcGJDQWg3YmRRWllRR1ZnMUE3V1pyZm5ZRkVqVm1SMkp0VWF6alZoQnk3cHNiODZjejBxQXNkTDR0aGIySVFkK2MydnZCT3ZKa1ZGNEx1ei9VcTNkK1UzWTMxT3V3clA2eGg4bkFIci9zTWZlYTE0cHZtUEdDVUhkdGxROTRIUGw2L1BEQ1RmNmZtbXFvOWs1NldXM3pMdDhFZ0dSTzdDcWVoWW50bVpGWm1kUzQ5NSs4aUlxK3VtclEwSjFwZVE2d2dzM1M0NEIyNlZqYlFLUE1PcElhTUkxcGNRdGZqSEtybGVqWmJoaXpta2FXMW5NckxoYWw1cU9ZOHhqWDh0VGU4VHNZZHVJWWVKTnVXaEUyU2ViUDZUUjRkQW5RZjIxZGw1c2NXM0Y2UnZ6Mi9CTjkybk1LM3RUTlprZHlnOU50eFF5UE43eDFMczh1RS9SMFp3cERpZUpyN3BWMzBmMVc3U2pmd3lpVEFXY20zNFhoNU0rSTNGYWIzT1ZURU5HWjJ3akxmYmxiMjJ0NlQzeXp5MGZUeEwwcnZ6WTZvN2hPd2J1WWNwaDBkaGRsWE5ldy9WSGg2RzZFdDRyK09IM05kb2hic3owQkhJWXp2RzhYMUszN0xMZG4yYkEwVUpURDl5NFZDalFKMkZJcGZ2MWR4Q3pZYUgrVTUvbnR6NUZIYlpnRTAyOE4zWmZoNndBUE9TQi9EOTJiNFhQZjhxWVd1bkRQZUwyc1UvZHo1Tm95WHpFRkF2Y0Q0ck1qdVJiSW1zRVY5U0k5WFN6Mms5UytQYXgzYytoU0NvRnpSQ2FrcHFCUGo4SUY1RlFGVnJEdkJ2THg1L2RSK2VTVmxIczdpYXZvbXBMT0lsbGxkTDN1SmZHTFZaRDY5VTdyaWphZjBHSGp5NElkSFI3am95SXNLSEdUTjZJMGx1NjJuZlBwd2VQYUxxRjdEVHFiQjU4KzIwYUJITXNHR05pWTMxbzNmdkdQcjJqV1A5K21Ha3BwcnJGL0QyN2RtRWhocTUvdm9HTEZwMGlpWk52dWI0OFNLR0RXdU0yZXdpSmFYc0diSlFoMnFoeTZxSDQrUDkrZkREYTBsT0x1SFhYNU5KU1BpS3ZuM2orUFRUUGpSdUhNaisvWG04Kys0ZVB2eHdINk5IdDZSLy8zaE1Kb2t4WTlaUVZPVHdQdUNVbEJLbVRObkJ5cFUzTTN2MllTWk42c0t6ejVhOVZOV2hRemgzMzkyYysrNWJoVTRuMHJkdkxEMTYvRmhuWUsrb3BiVnRXeFo5K2l3a01ORGdBVnRhUmtUaG5NYS9ZdE9takRwWGxpc043T2VuNTZhYkduSEhIVTNadWpXVGlJanluK0w3Kyt2cDNUdUc0Y09ib2RPSnpKOS9naVZMem1BMk83M0hhZWwwQW5xOWlGNHZJc3RjRWhnZ010SUhWVlVwTExSVFVHREg0WkM5UzhPRmhRN216ajNLM0xsSGFkczJETHZkeFFNUGxEOWdmTWVPYkRadnptVGZ2bHp2cnBiYXR3OW56WnBiMkxJbGt4TW5McjdnNnVMRnAwbEtDbUgxNmx0SVRBejJYdUNZR0YvZWZMTWIzMzkvbkxBd0l6ZmZ2SlIxNjlKS2Y1ZGxsZG16RHpOdTNBYk1aaGZmZkhPVVYxL3RRa2lJMGZ1Y0ZrQjZ1b1ZiYmxsYTZwaU9IeC9GYzg5dDR0RkgxeE1YNTh2eDQ0V01IdDJTTFZ0dUp6YjJTeFlzT0ZsL1dscWRPa1hnZENyczJwVk5wMDdockZoeE00bUp3Zno4ODJrRVFhaHpwbnpWUFI0K1BqcDY5bHhBU2tvSktTbG0wdE10ckZtVGl0T3AwTFBuajZXQlJiMEJYcllzdVhTN3FNakJvNCt1dytsMEw1eDg4bVFSSjA4VzFlOTRlTkdpVTMrdkRnQ3Y3Tk5Tb000TlRLc0NqV3A5V2hxd0Jxd0JhOEFhc0Fhc0FXdkFHckFHckFGcndCcXdCcXdCYThDYWVMVjRqcjc0RExXdTMzRG5jSmg5RGJRNU4wakk2WVMzM29KLy9jdTlYUkdqMTd4N2FKUmdVbnVZMEFuK25NQnQxeTRZUFJvcVdHSVZyd08rQXExNko3QlJna2tkWUVMSHE5T3FWd0IzRG9mWnZhRk41TlZydFU0REd5V1kxQkVtZEtnNnJkWlo0TTdoTVB0YWFCTlJ0VnF0YzhBR0VWN3BWSDFhclZQQW5jNXB0ZTA1cmJwY2JxMU9tMVoxV3EwVFRVdURDRzkxZ2EzRHltQjM3NFl1WGVETk42OGUxbUNBTjk2b0l5MnQ2dFpxaHc0d2V6YTBidytDVUlzdHJZdVYxZDI3M1dWMXo1NHF5TjhBRXlmQ3l5K0RUbGZMWmJoVE9NeStEdHFHVjc5V0FWeUtqaW03SmdKdjFDeHdiV2gxVDI1N1JxK2R6ZTdjRGpVTFhQTmFsWml5YXhKVGQ3Mk1RekhVbkVuWGhGWmZmdG10Mll0cnRRYnI0VTdoTUxzUHRBMnJPMXF0Rm1DRENKTTZ3Y3MxcU5XOXVXMjVmKzJjQ3JWYTVjQVgwK3JreVRCMWF2VnBkZXJ1aVV6Wk9iRlNXcTB5NE5yUzZ1aDFYN0lyNThwV3FOYjlIYlI2VmNDMW85VTJqRjQzNTRxMWVzWEFuY0poZGw5b0crcGRXcjFzWUlNSUU4OXBWVmRUV3MxcHcrajFWYVBWeXdMdWVLNnN0Z3Z6WHExV0NyZ210RHBoQWt5YWRMNVdXek42L1ZkVnJ0VUtnY3ZUNnJScDRIQjRuMWJMQmI2WVZ2ZnNjV3QxOSs1cTBtcDJFcU0zZkYydFdpMFhlTnR0MEM2MC9tbTFYT0EvWWV1YlZzc0ZybmF0eWlKVDkweXFjYTJXQzl5MWE5Vm9WYTkzMTZzZVdzMXF4ZWlOYzJ0RnErVUNWd1ZzKy9adXJYWTRGN0hKaXNqVTNST1p2SE5TcldtMVd1TGhpMmwxWDFZTFJtLzhocDA1bmFnclVpWEFGOWZxeTB6ZStVcWQwR3FWQVY5Y3E0bU0zaml2VG1tMVNvQXZxdFZkRTVpODY5VTZwOVdyQXI2b1ZqT2JNL3IzYit1c1ZxOFkrRUt0Q2t6ZE9ZSEp1MStyMDFxOWJPQ0xhaldqS2FNM2ZlOFZXdjFiaStlTWFSUGVTVm1YM0M2dVBnSDJhYmczZGQyMDUrTC8zTmM0LytHV0FBQWdBRWxFUVZRR2wyckFHckFHckFGcndCcXdCcXdCYThBYXNBYXNBV3ZBR3JBR3JBRjd2WGowYWFrSDZ0K01hY0NQUW12dTBFeGFBOWFBTldBTldBUFdnRFZnRFZnRDFvQTFZQTFZQTlhQU5XQU5XQk52bGIrdVY2ZldkMGF0REd2QUdyQUc3RlhpTVVDOGFRSmI2aHZnaWRPWGNObHFldjJybG9RWXJWclNnRFZnRGJpK1ZFdDVzM1dicS9OaXNnSU9LVkRuREdocTBra2dGSnl3R1pRaWwxU3RTMjY3eWdjdVhLenJXVjJYZFFSSEVqajJMY3o0NERKK2lYL2N6UVRIM0k3NTkxL0krL1FWRElYWk5RSmNJeWF0ZHVoSDNLek54QXk5aitLSU9PNlptTXFtNzNmaTR4OUF6TkQ3aWZ0aUMycUhmdldqRER1Q0k0bDhaU2IrVWJHNFhDNTJyVmtHaWt6ZlIxOUhiM0MvcitnZkZVdmtwTTl4QkVWNE43QUxDQnI3RnY1UnNRQklrc1NodkJMYXR1OUlaR1NreDdIKzBYRUUvbk15c2pjREswWmYvSzhkV3JwLzhPQkJNdkl5RUhRQ3lTbkp5TEluWHNDMVE1R052dDRMTEVRMVF1OVRCbUN6MmRpNmFTdkpaNU5KejBwbitlcGxuTmxSRnEvb2ZYd1JZaHJYYURXbFZ1VW5LU2xKdFZsc3FpcXJxaXFycXVKUzFQSFBqVmViTkd1aTN2dmd2ZW92Ynp5bjdyZzJUajM5MFJSVmxWWFZackdwYmRxMFVhdjRQbW9PMk0vUFQ4M0x5U3NGL3ZNejkrdTVxazZuVSs4ZE9VTGRNcWlsdXI5WHBHcTMydFc4bkR6Vno4K3ZXb0dyMWFUTlpqTS9MZnlwZEwrNHVKZ2xTNWVnS0FvMzNYUVQxMXpYRDk4K3c5QzM2WVlrU2Z5MDhDZk1aclAzbWpTZ1JrVkZxU25KS2FvcXErcXNtYlBVdVYvUFZVK2RPS1ZPbVR4RnRWbHM2b0Y1WDZnbHg0K295YWVUMWNqSVNMVWE3cUZtZ1FGMVFQOEJwZEJPdTFQZHMydVBPbTNxTk5YbGNLbXlVMWFUVHllckEvb1BVS3ZwK2pVUERLaVJrWkhxRjdPK1VJOGRPYWErTXVrVmRjblBTOVRUSjArcnMyYk9xaTdOWGhSWStFdWYxdWJxTGpNQkFjSDZoSVJFSThEcDAwZnR4Y1VGenVxODNvblQ5TlQ2dExRT0FBMVlBOWFBdmJKUEsrVkp3K2I2aCtnb0g5aVpLdmJVVEZvRDFvQTFZQTFZazFvTUpzN2Y2ZGRwUk1waDJSQW5DQUtxNmhrNGxaY0dWUHJZOHRKYTZ4eE04TTJ0RnNBQkcxWmVPbG95R1EwOGNOZEFPcmRyVmdxazErdTRhOWgxOU9uWkJsRjBwK2traWFIWGQrTWZBN3NpaWU1c1JGR2czelh0R0hITHRlaDFVaWxVbC9iTkdUMWlJRWFqdnZRNmJWbzI0cEY3QnVIdlo2cmRNbXl6TzJqV09KYWt4QWFsR25FNlhUUk5pS0ZsczNnVXhaM21rbVdhTjRtbFdlTVlaRVVCUUZGVUVwdkUwcXh4TEU2WFhLcjlWczNqYWQ0a0ZydTlMTlp2MFRTT3BNU0dtQzMyMmpQcFcrNS84OHpXM2NjYTZpUzNkb3hHUGIyNnRtTERsZ080emdFWUREcDZkMi9OaGkzN2NUcmxjeFlnY1cyUE5tejg0d0FPaC90cG5VNG5jVzJQMW16YWRxZ1VWTktKWE5lakRadTNIOEptYzViK2NUMjd0SEwrK1BsTHhkVUNLSXBoNVdwWWt0eWtMbG5HSmN1MFQyck12eWVPeHQvUFZKcldxRUVrLy9mNkdFS0RBMHJUd2tNRGVlK05oMmtVSDFtYTV1OW40dDhUUjlPbVphUFNOS05CejJ2UGpxUlgxNlRTTlBkMVJUMkNFRm90bjB0cCtMWUhwNlJzM25FNHJtV3plRTZjVHNkbzFDUExDazZuVEh4c09EbDVoU2lLV21yQ3dZSCtvS29VRkpzUkVCQkZBWjBrRVJvU1FHcDZEanFkaENTSjJCMHVtalNNNHRpcE5IeDlqQUJZckhaYU5XL0FnU1BKOU83ZW11OC9lN0Y2VFBoUFIzU3g0Q0gvOEZHbnlXamd6UmZ1WWR2dVkwei9aQUdxcXFMWDYzaGovTjBrcDJiejJ2UzVLSXFLVHBKNDlkbTdjRGhkakg5OUZyS2lJSW9DYjcxNEx6R1JJWXg5NFNPc05nZUNJUERDNDdmVHVXMVQ3bnZxWFVyTU5nQWV2WDhJLzdpK0d5UEcvb3ZjQTRlc1d4OFltMUZyMVZKY3ROdnNVek55aVk4Skp5VTloN2pvTUZSVTBqTHlhQkFienRtMEhHS2pReEVRU00zSXJYVGFuL25GUm9jaUNpSXA2VG0xV3kzOUNacWFrVXYzVGkzNDV1UG5pWThKSnpVamw3U01QTnEwYk1UMy8zMkpKbzJpU2N2SUl6VWpsNllKTWZ6dytRVGF0R3hVbWhZZkU4NDNIejlQOTA0dFN0TWl3NFA0Y3NZekRPamRuclNNUEZMU2MycTM0WEhUeUZkTzdEeDR1a2x3a0IrRlJSWWl3NE5wMlN5T1Rkc080V015WXJiWUNBcjBvMTFTQWx0M0hTMnRvaVJKcEd1SDV1dzVjSXJpRWl1K1BrYXNOanU5dXJiaThQRlVzbklLQ0F6d3BiakVRcSt1U1p3NW04blp0QnlDQXYwb0xETFR1VTNUa2dXZlBIZXFPZ0FOZ1FIdHlpM0RSaCtUMFdRME1QV2wrL2hqMTFIbS9MQ2F6T3g4OUhvZGs1NFpRVXA2TGg5KzhUTnJOKzFESjBtOFBHNDRpcUl3N2YwZldMdHBINklvOE9TRFE0bU5EbVBTdjc5aTNlYjlDSUxBL1hmMnAydkhSSjU3ZlJZYi96amdkcEJEZW5IekRkMTRZdUtuK1BpWi9QVUIvbTFydkl2bno0Ykg0dVZieVM4c1FWVlZqRVk5ZHJ1VDVXdDNZYkhhVVpTeXRIV2I5d0VnSzBwcDJ2WTl4L0E5bW96VDZTcE5PM0EwbWN5Y0FteDJSMm5hcWVRTUZpemRYT3JFYXFWUHErQjBzZzNndHpVN0FPalF1Z24vdkc4d2s5LzdqcFViM0dzaXRFcHN3Tk1QMzhLL1A1elB1czM3QVdqU0tKb1huN2lEOXo1ZnhPL2JEZ0VRSHhQT3BLZEg4TmxYdjdKdDl6RUFJc0tDZVBQNVVYejV3eXEyN0RqQ3J2MG5BY2c5ZWJybzBIL2VQVnpqd0dwQmdRa01TS0tJckNqa0ZSU1RrcEZMWm5aK2FWcDJUaUVaV2Zsa1pPV1h0cXN6c3d2SU92Y0JrRVNSek94OFVqSnl5YzB2TGszTHpTL2kxTmxNOGd0S1N0TmtSVUhNenc5TS8zbHB0MXFwbGs3ci9PTWVHejJFbmZ0T3NHN3ovdEo2ZU16STYwbE56MlhKcW0ybDlmQmR3NjVEVlZXK1hiaSt0QjcreC9YZGlJMEtaZGE4RlRpZExnUkJvRS9QTm5ScTI1U1BaeS9GWm5mM0luYnYxSUsrdmRyeTBmOStvWkc5cU1hcUpjL2xoeG8yc3RwT3BXUFE2d2dQRGZRSUhreEdBMEdCZmg3Qmc1K3YwYVBscFNncWdmNittSXdHbkU1WGFmQVFGaEtBMGFBdmhRVUlDd25BejhkSWlkbUcxS3hKUWRjcGIrNnZGdUtXTFNwdVd2N1pHb3NNQzZMdk5lMVl0bllIaFVXVzBoc2RlRjBIbHEvZFJYNmgyelJEZ3Z5NW9XOUhWcTdmWFdyQ1FZRytET3JibVRXLzd5RTd0d2lBQUQ4ZkJnL293cnJOKzhnOFovNnFxdFpvMC9LaURROVZWVkZWbGRqb1VCNGJQUVRacFpTbUJRYjRNdTZobTVFa3NUUk5weE41NXBGaEJQajdscWJKTG9YSFJnOXh0OURPcFRtY0xrYVBHRUNMcG5HbGFiWGE4Qmc0ZU55eEEybDV6ZG9uTmViUThiTUlnb0RzY3B0cjA0Um9NckxkVll2VDZVS1NKQ0xDQWhFUXlNb3RSSkVWSkoySW40K0ppTEFnVHA3SktBMEpCUVFTbThheS8vQVpkRG9KUVJCd09XVTZ0R25DanIzSGFkMGdJbi9PWTRQMlZnZGc3SkJCZmNzdHczSm1oby9KNk0rcno0MWs1OTdqVEgzL2gxS25OZkhwRWFSbDVQSHl0QzlSRkJVQmhZbmpSaUFBVDA3OERGbFJVRjBxRTU2Nms2andZQjRhL3dGT3B3dFpVWmo0OUFqYUp6WG0zaWZlS1MzSDR4NjZtVUg5T2pIOGtYOUJlbXJJb1duLzZWTnJ3VU5ZU0lDN2Zzd3Y5bkF5MVpWV2s4R0RoNFo3OVdoeklOSHFMQ3RZamNNdnpLRWEwaHFHQlZwYVhkY3F2VnFJTjZ3c1g4T3FxdGE3T2ZFcTVhWHJzM2kycFhmdFNaVUNBMzcvMndEdkdEYytUb0JydEdkTDlWWERzUVA3WmFoNnc3WjZSYWg1NmIrelNkc3lNL01rUDcrRGZ4dmczKys4SjFTQUpNMUwxMWNOK3pkT0tCSkU4VlM5SXR5QTVxWC92aWF0T0p3MlVhL0wrOXNBcnhrNHhDUkFxT2FsTldCTnZNZHJuNy96anhuSDVxdENQYXVXVkg3OFpWeHpiZGtERFZnRDFvQTFZQTFZQTlhQWF6bGFxbW94U0FJTzJmMHdNalpZajU5QlJGSEIzK2orbjUyeWlrTldNZHNWMGd2ZDQ2ZjFrb0JUVnIxTHc0SUFkM2NQSlNuV0I1MG9rQlJqb3RpbWNDekxUcUZWUmhRRjRrSU1tQjBLeDdQc1dCd0tTVEVtRERyM3NmZjBDRVh3RnVCMjhUNDgyVDhTblNod0tOMUt6NlorSEV5M0VlUWowVHpLaUV0V09adm5ZUGRaQzNwSm9ITWpYOGIwRGllbnhFWDN4bjRjelhLL0V2RGtnRWpheGZ2VWJXQi9vMGpmRmdFazV6bEl5WGZRT056SXJtUUxnMW9IVW15VHlTNXkwVGpjU0dLVWlhaEFQVWFkUUpGTklUSkF4eHUzeExMN3JKV21FVVpTOHB3azV6bm9reGlBcjBHc3U4QTltL29UNGEramNaaVIwN2tPVHVjNkNQWFRzZnVzbFhieFB2Z2FSWGFmdFhBazAwWnlub01EYVRZY0xvWE1ZaGNtbmNpbzdxRWN6YkNSV3Vpa1lhaUJjSDhkdlpyNjEwMWdvMDZnZmJ3UERsbmxqMU5tUk1IdGxQU1NnS3k0elRqTVQwZUxhQk94UVhyaWd2VWt4WmdJOGRXeGRGOGhyeTVPSTlBa0lZZ0NBckQxbEJtWG90STJ6Z2VUWHF4N1h0cWdFL0UxaUFnQ25NNjFJd29DamNJTW5NeXgweVRjU0ZxQmsyNk4vVGlkNDZCSmhJSElBQjBnb0pjRVZoNHFva1dVRDlOWFpOQXcxSURGb1dCeEtPaEVBVCtqaUY0U3NEbnJHSEJTakFtSHJGSmtsUkVGeUNweUVoOXFRRlZCRk9EVm9URzBqWE03b1hkV1pHQ1FSSVozRFFIZ3VrUi92dDJXajZxQ1RoUkl6WGNRRzZRbnZkQkppSjlFcXhnVFcwK1o2NVpKZDJqZ3k1bGNCOHE1bTI0UWFpQXVXRS9UQ0NPZEd2cVJVK0xDS2F2c1Q3WFNNTlRJN3lkTFNzL05NOHRrRkRwcEhHNGtKa2hQdzFBRE9rbkFwYWljeVhYUW9ZRlAzVFBwNUR3SE1VRjZRdjBrc290ZCtKc2tNZ3FkSkVhWnVLbGRJSzhzVEdmNWdTSVNvMHprV3B6YzBTa0VwNndpQUh0VHJSVGJaVTVtMnhHQmZJdjdmYVlJZngyWlJTNVM4cDExRC9oUXVwWCtMUU00ayt0QUp3a01haDFJNzJiKytKdEVBazBTd1Q0aTRZRTZ0cDAyRXh1a0k4eFA0a2ltaldZUlJoYnRLa0FuQ1lUNFNoUmFaY0w5SmJLS1hCVGJGRnJHbUZoOXVLanVlZW1XTVNhMm5uYVhzeFpSSnZhbFd2bmZwaHg4em5uWXU3cUhzdldVQlplaWNuT0hFRUw4ZE1RSEd5aTJLZHpXS1pnVFdUYmlRdzNrbExpUUJJSEVLQk9DQU50UG0ya1Y0MVAzZ05jZUthRjNNMzl5U2x4MGJleExWckdMOUVJWHovMlF3bzR6Rm14T2hmZ1FQV0grT2tMOUpBSk1Fc0crRWhFQk92TE5NZzljRTg2eFREc0o0VWJ5TERKZEcvdVNXZVRrbW1iK3JEbFNYUGVBYlU2Rnp6ZmswQ3JHaElEQTBIWkI3Z0hqSm9uUDFtZnp3NDU4VG1UYk9aQmlaY2JLTE41Ym1VV2UyVDJJWEJSaHliNUNXc1dZY01vcXQzY0tSaFFFV3NmNk1HdGpEamFuVWplakpiTmRJYTNBU1dxQmc1YlJKa1FCOHN3dTlKTEF3VFFiQ1dGdTcyc3lpTmhkQ3ZPMjV0RWt3c2dYditjU0U2UW4zK3hDSjRLL1VlSmd1aFdIeXgxSjFkbnc4RlNPblEzSGlubWlmeVJuY2gzYzFpbUU1RHdIS3c3K1Azdm5HUjVIZFRYZ2QyYTJyN1RhVlcrMnV0eDd4dzFzZ3dzWUczQWdZQ0NFSGdnQkFoOGxsTkFTSVBRU0lQUVNTdWhnQTdZQkcvZmV1MlRKc3F6ZXBlMWxacjRmYXd2THVNbFZrdWM4ang1cFpsZXo4KzQ1OTl4eno3MXpidGc3Ti9sa0ttb0RPQ3poeDNYWEZudElpdEtURTIra29qSEltRzZScE1jWUVRU1kxQ3VLbCtkV1VWQjlmSjh2UHU2anBhM2xQdDVkVWt0Rll4RC9uc1hsVnc2TG9iSXBpTXNua3gxdkpNR21KOEdtSnp2ZVNKTlBwclFoeVBTaDRlY1RmY0h3MlBqZEpiVnNLVC8renpRZDl3U0FTdGl6T2l3U294TWo2Unh0SUwvU3p5V0RIT2hFZ1ZxM2pGNENWUTNYbTNaWUpVS3lpamVnTWlqZGdxekNnanduSzR0T1RMbkhFNUx4VUZTWXM3bUowb1lnNDdwRk1pVFRTbFZUaUlYNUxsSWNlajVjSHA1enYzU3dnOEpxUHlOeklraXc2ZGxjNXVXbnJVNDJsWHJiWDRwSEJUYVZldGxjNmtXU0JGUVZMaDdvNE4wbHRjaDdIZ1Y2ZjJrZHZ4dmc0S0Z2dzJ2RFE4cUpmK2hEZDZJL1FBVkNlM0pVSDY5b3VacENWbFErV1hseVYxaG9hVm9OV0FQV2dEVmdEVmdEMW9BMU9WSFM0U3VtSGRha3RZcHBhQlhUMmxYRnRFTnF1RU5XVE52dnA4TlhURHRrQWtDcm1OWUJLcVlkVWFTbFZVeHJ4eFhURHRtR3RZcHBIYkJpV2d1VEhqUG1oaDFiYXoxWmU0LzNyWmkydDczdFd6RnRiNzJkZlN1bWJjM2JEYlNzbUxhM010citGZFAyU3JjNGE5UEw1K1JxRmROT1NyZlUwU3FtSFZMREhiSmkycUUwM0JFcnBoMVI0S0ZWVEtQOVZrdzdaQnZXS3FaMWdJcHBod1MrNzZaSFo5ZDRneWU5amtmbkdKdm5qeWVxWXRxaGdEdGlsWWZUUGhGLzJsVk1hMkhTUDQwYzk3bWdtWFFITnVrT1dURk44OUtuczBsckZkTTBrKzVnR3U2UUZkTTBMMzA2bTdSV01VMHphUTFZRTYxYk92WHloU0FJV3NVMERYaC9DUWFEN0NyYUFZRGY3K2ZUajE0RVFKWkRiTit5K3BSTW14eHpQM3d3VUwxZWo5UHBaT09TVjBoTGZ4YS8zNDh4c0FLZno4ZjhiMitqMTdEYm10ZGx5ckxNbnZWdHpUSnJXVG16bGxXY0VzQUVoeW05VmNCVmxhVzRtMHJKNmpLVUJFY3RteGJjUTBMWFc3Q3dpcHJxTWlUUGJFeVdSd0JZdjJvMm5iTUc0bkMwMkIrVlpadHFlZUYvZWFjRWVIUy91TVJXQWFla3B2UGo1ODhTYkZ4S1l1NlZsSy80SGFXaUhhdXVpb290enhBZEtlUDNlVm41NDEwRWxDZ2NBOGUzWDVQZWE1NW5USGlFclQ5UFFHNmFoeVFKK0dwbll6SUtHSDJmMENBTW9IYlRWZWlVQ0xxTi9JaWQrY3R3ZXhSNjlqbWpmUUg3ZkY2KytlUSswcE1NbUV3aXh0aUwwZGMvaGNFaVVPOHFSaEdnemhWRlFzeG01SkNJWVBzalcrWmVSbEF4WWtuNVU0dHIyYXg2VXVMTXB3UXdLa0lmT09MQXcrZHBvSER6ZjVGci80ZnMyWXBIN1luZzI0QmVMOUMzaTQ2bDY0TUlBa2lTUU1BUDlrN24wL1BNVjVGMHByYWsxQ01MUE1yTHl5Z3EyQVJFNEpNR0VwQmp3TGVKbEFTSlRma2hnaUVvS0paSlRaS1FqQ2xFSmd3RFF5ZTJyL3VjYlp1V1VsMWQzYjVNMnRsUVJrMzVNdkR2eEN5VklCa2tSQVZzVm9GeHd3eXMyaHhrNmxnandaQ0tFQ3dCd1VzUUk4Nm1SakRVWUkxMEFISHRCemkzMjBCeXV3MUVWV1hXenJzUG4zTVZicGVSWGVVK01sSWxlbWJyRUFRb3FWUnBDcVNSWUNyRnIwc2hzK3ZWSktiMlFoVEY5dWVsaTRwMlVySDVFZlRCTmVoc28wbUptSThPZ1MwRk9xSWlBamc5Qm1JaUExZ2lWWnFrNllpK0hXeGNlQitiSTBkeTl2bS9yc3I1OU9mZGZQcHo4U2tCVEV1MDVCNGhzTXFPelhOSVRoeE5Zc1pUN0Y1MVBTRWxtcVpRQWhiVFdocWRZSWpJcE1HekM0UFJoY0hxcDlzNVh5Q0tJaTVuQXo2ZkQ1TXA3THkyN0d6a2kza2xweXJ3aUQ3Q1dGcGczTGszMEgzQVZleFk5eGErb0JWVDFsdVlsRTM0RENOQVVESGEraU1yQ3JhdUgrTnNLR0hIeHMvUjZYVFlIYkhOc08xdThGQmVWb3dpSlRCbzRudVlUU29OM2doaWN4N0U3WThrcGMvOWhLUjBQSFh6R1h6ZVoxUlUxZFBZV04rK0J3OTJSeHhKbzYvYU01Q1E4ZW5PSkNZaG04MzB3MlMyMGVlY2IxbjQvVDJrOTFZWU0vRm1nc0hmMXI1S2piY3dwRWZNS1FITVNJNXd6VDlvcTFYVno5V0RpQ3pMNnRLRlg2dWhvRmYxZXIzcUorODlxc3F5cktxcXFpNWQvSlBhaHVWempnWjRmNm12cjFYYmlYeCtYREllZG52N1RGK2YzbE10ZjN4c1JjK3RSVTBkQ3JCYnVxM25RWUYzbHJraWxtK3U3VkRBSm9NWW9XVXRUOXMyUEtDcm95N1dia3pwU0lCcGlaYTYrVWVhOGVnZ29rMjFhTUNuamRPYWN0ZkMvcXUzMVhjb3dBRmRIZjBQQ3R6b0NocEtxNzBkQ2pnN05jS2d0ZUhUdGcyUEg1SlUwVGZYMGFFQ2p3U0hxV0wrcTFyZ29iVmhEVmlUZGlvdHR6WDZ6M2NkMG1seHc3bEg3N1Qwb2tDL1dCdS95MHdrMTI1QmZ3U3poTkg3VkVxTE5ob1E5OW5sT3Naa2FMdHQrTXprR0RaY05KSnpPOGZ6NWM1SzhobzhCSlZERjYzLzErQnUvRERwMTRvVjM0N3Z6NHZEdXdFZ0NRSkxwNTdCN3pJVFQwM2djU2daRW0vbjUzTUhjOFBDVGJ5NWJmY1JmOERUR3d0NVptTmg4L0dGUDY1dGJrZXlxakxxMjJYSXF0TDJnTjhZMVl1bGxRMnRnZ1dvOHZvUGVWemg4YlU5azA0d0cra1ZIY25QWlVkV0RpckhabW4rV3hJRU1pSi9YY0dUSG1uQnNFKzd6NDJ5dGozZ3ZUZGMySFQ0b2VPMDlBUittRFFZM1I3SDlNeVFibnd5cmwvejYvODlxdzh2bnRHOStjdVlPV0VRVitTa3RpMlQzcktuZGs3UDZNUHZYL1p0Y1RYZjdxNG10R2V4NlYwcnRyWG8vTWJNWE41OExLc3FQVDlid0FuYjgrOW9OZHdVQ0RHN3BKckpuUk5hbU9PQkpLQW9CR1RscUkvYlRMZDAvWUpOeEpzTi9HTndpelVpbUhVUzUzV093eWlGTHhXaDF6R3BVeHpTSHBOT01Cc1pteEw3YTllV0ZFMksxZGhzMHVkMmpzT20xN1U5NEdLWGwxNmZMeVRIWnVYVHMvdVJ0Y2N4SlpxTnZEQzhCOElldXh5VEVzMi9oblJGMldQU3QvZEs1LzUrMmMzWHVhOWZEdi9YTzF5eVMxRlZIaC9jbFVtZDQ5dDJhR2tRUlRKc1pvcWMzbVp6VlBlNzRORWVuK2pRc29VdGRTa3JzVXF0MkUwanF4MEUwcklvV0xjZnpFdC9XclV6MmJHbnNtaEhrWHF2UDduUHdWNTBMbDVlb25Zd2NTNWVYcUpsUERSZ0RWZ0Qxb0ExWUExWUE5YUFOZUFUbmVMWitlSEh0Zll2dnU5UTg4TU52c2JhZ3dMZjBtTkptYVRRdXlNQnl5SmxCOWR3dXM3ZEFhM1lyVGt0RFZnRDFvQTFZQTFZQTlhQU5XQU5XSk5qbDVhcmFZczRlUXZUMGs1YU9TcHROYTBHckFGcndCcXdCcXdCSDdYSUVQejY5QUZXVlJHdlAvbjBBRlpWbFZBb2hNazZpRkFvMUxHQlpkbUgyMVdCSkJUamIzb2VsSjBFZzNVb1N1Q1lycXRydStvTklhb0xDWHBsZ29Fb0VKZWlxQ0tpWlFxSWhvNm40VkN3SHIwK0U2UXU2SFVGQ0ZKM2RGSWFpdUp1L3hwVzVRSUVLWXY2dWtJQ1FTTUdnd1dqM29zcWIwVlJRVkZ6RUFQcmtYUWhCTktwcWFrQlpBejZFTGFvRkx4ZUQzcTlBWjFPMXo2QXF5dDNVbDJ6aE5qWVRHeDdIdWoyK3lTc2xtRklxZ3ZGOXluR3lNdnhlQlE4cmlCbWN6UStudyszY3d0VkZUK2l3MDlxMWpYdHg2UWRjYVB4K05QWnVYTW53VUFUcXFvaUNGWmNaWE9wV3oyYnB0VW02dFo4amV5ZWowN3ZRQlJGSEE0YnJzWlZSRnUvSVM1cDZCRnB0MDBBdTkxdVZxOWVUU2lrSXlnbnMyM1Qvd2o0M2VqMGtmalgyWEhPOFZBOW80N0tyOTE0VnNlaDE1c0pCYjNrYjc0UGsyNFZvYUFaMVhNUFB1ZVBiYjhORnhRVVVGOWZqOGZqSVRrNUdiMCtucG9hUGNIQWRwcWFZb2c1NTJ3TVowaElwbkhJL29XRTZJZlBXNEVjYWlUS1hJVFpkZ2FoVUN3aCtVT2NOVjhnTk93bXNkUFZiVmZEc2JHeGhFSWh6R1l6c2l3VENnWHBrbTJodnNHSzM3dUZvc0oxV0tMR1liUFowQm43WVJBVzRXMzZuSUMvQ0tQamJ2eGVIeEdtT1FUa1lSaU1VZGp0aDM4STVaVG50RHdlRDZXbHBRaUNRRUpDQWcwTjlSaU5KcUtpb3NqUHo2ZTh2SncrdlhvaCttL0hvUE1pUlA0YlJZMGc0TnVKeFJwSHdEMGJpM0ViaXY1bXpOYTB0cC9Uc2xnc1pHZG40L2Y3RVFRQnU5M1JYS0s5VTZkT0dEejF6THRpTUJXTE4rSG1mbHh1RVovUEIySUtraFNGUVYrR0lmSzJnOEcyelc1SkVBUjY5T2l4eDZ4RGlLS0kxV3BGOXMybFYrOS9VNlFUS0F6ZGlkNFZTV3FxTGF3cFVRUkJ3QnA5Zi9zTUxWVlZJZWpmZ1VnOU9pbU5oc3AzTVFxZmdqOGVXMXhuWWcxR3lzdkxxYSt2bzFmUGJMemVjT0Y5U1pMUTYvWHRDM2p6cHFYRVdoOEYyWVhUNHlNcXlvTEwzUldqK1J6cTU5dlJHZFlTSXdpbzBUWmtaUlpMbGpweE9zTlB5MW10WmpJNjdTQXo1dy9vOUxiMkFSeHZldzJkdmd0UkNVOFJMNGpJb1NyVXNpdnhWM2Nqcm5kL0NsYXVKZXVDQzlqMHdRZFVwUFNqYjkvZUpDYUduemt1THk5bnpScUY5T3dqcTRYYkppS3R4cnF0aU1aekVVVWRnaUNpMHlmaWJyS2graFlTUDJ3WVNpaUV6bUJBbDVsSlkxMTlNeXhBVWxJU2JyZWJ5c3JLOWdNYzVlaU14SzgzWEwxbUZZYVFGMFBua2VGMmFnZ1BCN09HRGlVNnhzTEdqejdDNzNJMVIyb09oNTNvNk9qMjA0WXJtbTRsVlBFT1NiRnZVYnZOaCtpdW9TYjJVam81enQrYkRRREFvUGVTbGpTWGZPY1ExbDkrT1k3cnJzTmtxS2R6MGxhczFuUGFEM0JPemlBVXBSOXFhQ09pdUlQNnhmVWsxNmNnYk5yTXJrMmI4UllYVS9qTk42Q3E2RU9qeUpVazlJOC9qaTR5a3Vqb0tBejZDZTNMUy85YWZIc1lWdHN3NGpOYXZyN3VpeS9JbkRMbEVGZUk3RGhaUzUvYlRkWEtsWlJ2M254Y3JxZHI2OEFtcTVYck5tMDZidGZUWmg0MFlBMVlBOWFBTldCTlRtRjJaZCtERVE4OFhMSW92OXNSUDdmVUxYazNLLzkreDBtOTRVbXpJTC94eU44L09KN1NiNmFTcXJWaERWZ0Qxb0ExWUExWUE5YUFPeDV3cUJYbDdtUzFBd0MvdWdWbUhjR1doNThXd0FmNUp4NzRoQ2J4OGhyaDFhMFFiNEl6RThGMGtFK3I4c0lUNjhOL241OEcwY1oycUdGRmhiK3RnS0FDcFI1NFk5dkIzL3YzMWVBTWhuK2UzdEJPVGZyZFBGaGY5K3Z4Njl2RDRQdkw5N3ZocDlKZmo3L1lDUnZyMmhsd3NSdWUzOWp5bkM4RWo2OXRlYTR4QUkrcythMWxQTHIyeEZWQlBDSEFqNndHci96Yjg3TkxZR1hWcjhkUHJZZmFBeFFmWGxzRDN4VzNJK0ErQjltMTA2cUR0SDJtZ2ZvZTVIMDZFWEpzN1FqNGhxN1ErUUJMcHY3Y0ErTDMyVHY5b2t6b0YvdmI5MDNQaGk3MmRnUnNrT0NCL2kzUFpkbmdEM3ZLMm42UUQwdXJ3dm1saHdhQXRFK2lLZFlFdC9ac2gxNzZ6Q1FZdDA5MjdNSCtvQmZEbnZycDlmRFltbkFVMXQwT2wrNVRBdlhPM2hDcGI0ZkFBUGYzRHdjYkUxTGhqSVE5NTFhQ1J3NEhKUi90Q0ovN2EyK0lNWVhOKzhLTWRoeHBwVmpnOXA0d3NmT3ZmZXlpaWw5ZmYzNFRURTREaHhIdTZRTzU5aE5mVy91RXg5SlhkNEVrTTlUNDRKL3JXcjdtRE1JemV5S3JxZWxoOCs0d3c4TkgxMERUQVI1SStXd25iRDZKMjdTZE5PQjl1Nk45UlJMQy9YT0hBNzYxNTRHaHIrb0M2WkVkRURoQ0gzWk0rMHFDQmY3Y3ZRT25lQ2Fud1pDNFg0L3Y2UU1XWFFjR1prOWtwUk5oY0R5YzE1bVRMaWQ5MlZKMkZGeWRHODVzbkFvNUpldTA3dXh6VWpmdk9MVW1EYWNPOXBRQm93RnJ3QnF3QnF3QmE4Q2EvQ1lHV1BCYW1tZmt3RjNtamdTNGNGV2FkOVNOdXl4YUc5YUFOV0FOV0FQV2dEVmdEVmdEMW9BMTRHT1RGbW5hRDc3dDQzcHg0YUFPTlhodzFBZGNzT3ZBd0dzMkp3ZFc2K05PMkllbkp0b29xV2c2N0xuaktRT0MxWUZUWXRJWnFRNW12WFVsTTkrNG5KUUVHeWtKTm1hK2VRV3ozcjZTakZUSHFUSHA0eTEvdmZvTXF1czhmRHh6STBhalJIWjZEQWx4RVpSV2hqVTZ0SGNLRVZZalJxTU9uVTdrOStmMkpENG1nbWZmWHRMK2dBZjNUdVh4Tzg4R0ZmNzMzVWEyRmRRdzdaWlAyTFM5RW1uUDl0c0RMM2lObnJrSmJDdW94bWpROGRiakZ3Q3dhRlV4S3phVXRCOWdxOW5BaWcwbFBQL09Vb3JMRzBsTGppSi9WeDB6NTI1djhiNmkwZ2FLU2hzQVNFdU80czRuWnBNVUg4bktqYVZZelFiYzNrRGJCaDdZSzRYSDd6aWJ0VnZMdU92Sk9UejA0ank4L3VBUi9XOWVVUzE1UmJXWWpYcFVWZVhoVzgraWQ3ZEUvdmJVVDZ6YVZObzIrMkZCZ0RIRE1yajAzRjUwVHJZZk1leSs0dlVINlp4czU1SnplekYyYU1aeG4zazdyaG91S0s2ais4U1h5T29VVFhGWncxRmZwN2lzZ1J2dS80YkNrZ2FxYWx4dE05STY5Nnd1MURWNDJWNVl3L2Z6ODQ3NWV0L1B6MmRiUVRWMWpWN09QVE8zYlFGZmUrcGNDN1FBQUNBQVNVUkJWUEVBdm5uMVVoWjhmRFVPbSttNDNaekRabUxCeDlmdzlXdVhjZTNGQTlvTzhLd0ZPMmh5K2RteHE1NzZKdDl4QTY1djhsR3dxNDRtbC8rNFdBM3M1eElHcE4xWXNsb2YxK3FkTFMwbVBSNWZFTHZOUk1OeEJBYWFyN24zTTQ0aXRDeGR2ZXUxMUFNNnJXNXlZNTJkUU91Mzh0eDdIN1Vub0ZPdjNlOHpXaWxKc3JkdTljRzg5SjNlRFhtcVFLK09ORm9TVlBMK3F5VUFOR0FOV0FQV2dEVmdEVmdEMW9BMVlBMVlrMk1hRDg4Lzc5Smd0NGtqZExIWFhJTlhGbmoxMWZuODYxK3pxYXB5SHZDZkgzdHNDbitvbjB2bE04OEFrUDdPTy94NWRvaFBQbGw1d1BmbjVpYnc4RTBER0xadE5nMWZmRTdjVFRmeHJyOGI5ejB4OXdRaXZpNGMxS1R6ZTQwTk9ILzVoVTA1T2JqZmVZUGJieDdKenAzLzVPbW5weEVmZi9SUFUrWG1KdkR4ODVPWU02YUdidis0RG4xQ1BEM3o4a2g4OE84VVZQbFBYUnUrOXZFVjlWZVVEcVQ2Z1pkeHpwL1A1dHpjWXdJL0ZPakhNN2ZUdmZ2ZmVmdnR4YWZXYVMxWlVzRFk2Ny9qOHBJQlZOMy9VaGc4SndmWDI2OGZNZmlSZ0Y1eHhkdHMzMTU1YXR0d2N2TC9sVnNzeHNSOXovWHIxNGxiejBzbGFlYTdCQ3NyU2JyM1htemp4K1AxaFNndXJzWDZ4dE10MnZEdXJtZVF1SGdHZGUrK2kvMmlpMGk0N1RZRVd4VGZmcnVlVjE3NWhaMDdXK2FCNnVyYzFOVzVUMW9iYm5IdzNWdXp2V2NOVG01Vm5yWGt6anRwbWowYmdJUTc3aURtcXF0YWRUc3Z2TCtlZTU5YWNHcUFGdzBiR3pJdC9WazZtU2FXZCthbFhQWkw1S254MHFlRHRNaGFCanRscVhHRzFtMm82SncvdjhWeDVPalJyZnAvcnowQjhKd2E0SVU5ei9jTXZqcjlOelZTckZZam1abXhKQ1haVVJycWNTOWZqbUEwRWpGeUpLWDMzTlBDYWUxdHcyb29oR3ZoUW1TdmovcVVYSXJxUWdRQ3YvMHk1LzEzT2JEODFBQS8rT0MzVHNDMmIvZHkvLzJUbUQ2OU8ycGpBK1VQL1ozcTExN0RQdTEzTE00NWg4WnRpNW04M3dVZmVPQWJoZy9QWnNLRUhoaHpjcWg0NGdtYVB2MERtZGRjeHpmV2dmempwY1VIamR4TzJlQWhOemVCOTkvL0kxdTNQc3hsNTNXaDR1R0gyTlNsQzhHYVdqYmQ4enBuLytoZyt1M2ZIYkE3MmJHam1va1RYMlRvMENlWXU2bVJ6aSsvVExjMWF4Q2NqWXgrNlVaV1hHUGloVWNuSEZQa2R0dzAzSzFib3U3ZWV5Y3lmZm9RMU1ZR0t2WnE5SGUvWTlPOWIvRHdxNnZJZitYN0k3cnc4dVU3bVRqeFJRWVBUdWVoaHlZejhlV1hTYnpuSGlxZWVJTFJiOTNJbEd1dTR4dkw4R2FONi9VU3FhbFJDRUo0dzZud2IvWTVEcDhERUVWaG4vY0lMZDRqaWdKYnRsVGg5UVlQRC96a2t4ZlpKZzVQL1JWMDJqUTIzL3M2ZjM5bE5UdU9FSFIvV2JHaWlFbVRYam9vdUhITWRkejRpWk9VbENpbTNHTmhVM2srcWdxeUtvTUFxcUtpcUNvcUtvcWlvcWd5SUtDb0NpcWdxQW8wdjZiU0xTRUQ1eHRSNU9YVkhCNTQ1YmVMNnRSL0wwa0JLTHJ1T1Y3NmRCczdYdjNob0RETGx1MGtNOW1PYmRSVUFEWnQ5cEtYVjNkWThNc3VHNHl1MnpRTWZ4bk4ydStXaGdNQ1FXVnp4UTRXNTY5Z1luRVROY01Nckc4MDBSajR0ZFdkTGF1YzRhNWtoczdNR2tzVVp4VzUySjVzSURNMXhOSmFDN0lLa1NZTFlEMHlrMzcwemZYTHdCcmVGVy8yNGFPZm1UTTNNQk9BK1BDSkJldU9TT01yVmhUOU5zWVZCQlJGeGE4VHlZcjMweS9aVDdiTlIyT1R5aGRWTVNCQXo1d3pHQ0dCZTlsSHJERkhZYklxbkpQb0pDRmVJZFBrWldOdHVIcWdxcmFEakljZ0NHR3pGZUhUV0R2cFJpOHVqOENNdXVqbWVIQzdxNGFVOUY2czA5dEFnQjlpYlNnV2xjRlJUdGJXbTFubmlkZ0RyQjZaaGsrMXFLcUt3eHVpZTVHZjF5SmlXZDlrSVNDSGFVVkJZUHlnODlEM0hNSmRHYjFaK1BydG5KZGZ6UXdwbWwwZUV4dWRsbjJ1UTlzSEZnUlFVRkgwSXIwVHZCaFNCSEtpQWxRMndnKzEwVnlRTVpEekI1NU50Q09hUnErTGlTbGQwVlZXTXpXNW5yU1lFTG1SZmhaV1d0cFBFazhRQkZSVnBWRW5Nak0ya201V04vVmVrYmtORGhDZ1QxeG56Q1l6UHArUHdzSXRUT3FVeS8vaTdlZ2tsVFNEbDFtbEVXenptZHVQU1F0QytDWmpYU0hTaW9LOGFvNW5iWU1adnlJUVo3QXl4aEZMSUJCQUZFVkNrWkdrdUcxY3VLMmVyMHdPTmpuTjdBNFpXelNOZHRPR0JSUDBUdlVSbVFwZG8zeVUxQXBjMUdVYXIrU3Y0NFd4MDlIcGRBU2FuSlI2R3JBN1pDWWtOcEVXR2FKM3BKZHZ5bXp0eTBzcnFrSzFUc2RNUnlUSk9pKzdHblhZSWtieVh1RXFRcEUyRElid3R0bVpPb2tIMTgzaC9ZUm8wb3hlT3BzOGZGa1NSVVhRME43YWNQanZUVTRMZDh4UHBXeXJnVXlkeXFiYUVwS3NzWGk5WGdLdUpsU2d3dS9tL0x3bVhzMVA0TCtGY2RRbyt2Wmwwb0lBNmo0RldtTlVtV0U2RDJYcUluckhHZWlYRU52YzU0UWlIS0NDeHlad1huSWptVEZCdWxpOUxLNnh0QitUWms5Y0xPNjUyYXBvUGY1ZUtuL3RXVTFYdlJlSEl4MnoyWXhnc3BDUjNSZVRwR2RXVWhRNlNTSFQ3R1ZPWlFSYnZZZC9QcVhOYlJKMy9vNEc4dEpNeE1XSCtLd2lodmQzeG9BSU55UjBRcExDNlRhejBVVHY1QzVrekZuSTE2S0RBbytKM1VGak96UnBWYVVxU1dKcWJnTmRVME9jVWVWbVZsa0U2NTBSSk5oaUNBUUNTSktFd1dDZ1Qwb1hLaHlMdUNDbGtheVlBRDBqZlB4VVlUMHNjSnR5V2dnQ1N5SWkrYVUra29KYWtWZnlZbGpyc3FLb0NodUt0NkhYNjdGYXJRaUN3SVMrSTVtUmFFZFVGZUowZmo3ZmJXTzd6N3puaXhQYXZvYkx5OTJNc1NWZ1diNkN5bWlKQmFZby9KSUVlOG8yQzJJNEVwTWtDYlBaeklqc2ZseWE1K0l6SEt4M1dhaFN3bDFTa2pXT2plNVEyOWR3WTZPWCtJWmVHR05NVE14d2NsN25KcTVMcjJhWTFZV0FRSW85RWIvZmp5ekxpS0tJb0lDYVlHQmE1MFl1ekdqaXhzNDFESS9VMDAwYzBmYmJjRXlNbFpudmhaREViY3p0OURDYnFoNGpXOTdGbkZJSDIzMG1CQUcyYnYyV3pRb1liVDFJRVl2NElyK003K01kWENnMzRSRDlmTkhValN2NzNzV1FsT1ZNKzY0ejA2NXBPT0RjMVNrSHpzaUk1YTEvMWRMSDhSOEVBU3c1RitDdHY1dDE4bloyZVdlQUVFSVY0SW52MzJhVEh3S0t5RlZwZnQ0dk5xSUE3KytLSVdTL25PdDdqMmRROGhma1d0OUFWZ1ErZXZsdXBsMGZ5ODZkKy9tS2xvZlhmdzVjZERLQmYvNjZFMUh1QitqU0dYUVNmRHNmK2c4Y3lhZExyMFZ5R0ZuaS9KbHZ0eTFzV1lRYUlLVFFKejZiQzlLbkVTMUhNU1R0MzBRcFA1T1dCSUVnYkNtRWVzUHRUSnIrbk5DbU5Cd0lHREhwQmRhWG4wbHU3REkyRjNycGtyNlFTVGticVJFdngxTjFKcVBIak9MRExaK3hwakw4R0VBWGV5Y3V5cDJNdVNhRzBha3IwTGsrWXRHQ2FsTGpvZFpwUnJRT0pNS3lFTC81dCtYSlQ3bUdrNVB0M0hCTlp6NzdxcHE3L3BMTXdLUm55SWpKNDVFMzRMWkxZZldPSktLU0oyQ05HOFRpSFFVSStCbWFsb1F4dUJFN2MxbTBxb3FRREZQUGhJL21wcUtMZTRCM1AybGd3dGwyWHZsUElidDNQeW0wS2VEOSsrTGJieDNNRlJNV1VwcjNDVVdsUHNZTmhwQU1zNWZDNUZHd2JDUDhiaHo4dkFLOGZqaHZKTHozblo3Ulk2ZnoxUHNEZVB2ZC9mWmJhTXV6aDZxcTh1enp5em4zNm5pS2hYY1pOT29HMWhWRW9TalE0SVRvS0NpcGhJSVNNSnZBRTdDd3JlbGFhZ3ovNXF6TFlnOEFTOXN6NlVOSlpLU0pNV015bUhxT1JHcGNDV2FERTdmSGl5QkZVVnlWd3B3RmVuNll0Uk9uODFCUDByd3V0QnZnNHlPdkM1ek9JdXpYaGpxZ2h2bENFSVJwYmRKcG5RelJnRFhnMHczWTR6bitLMnhrV1NZWURCNzM2NFpDSWZ4Ky85RW44YXBLMXVMTmY0NmdxUWUyVGhPdzJMTXdtODNOeWJSV1p5VVZoY3JTUEZ3RnJ5TUtRYUp6LzRnanFmOHhRZnI5ZnZ3K04wM2xpd25WTEVCUlZUb05mUnk5WHQ5NjRFaEhaNnFjRGNRcE0xQzJmME9EbUVDVm9TZFNWRzhpNGdkanRNUVFFUkZ4cExqa0xYcVlpc0psMkkxMVdDMENycTI3MFVXOFIyUmtWQ3RHVndIOGZqK2UranpjbGN1UmZKc3grTGVpSjRBU1VQQkhUVVduMHgyZGhzM1dHS1RvMGRSWGZib25uMVNHeVZpQnp2MHpuaEtCTXE4RndaSkRkUFlsUk1iM3hXeTJIdlREYXF0Mlk3TDNKRG5YUnVQdUg0aTIrWkhWYW54TnV3OEw3UFA1OERpcmFTeGRpTHY0RXd5aUM2dmVod253QnhVYUFpcUNBRUUxa3JSQms4TUp3YU5OOGFRUCtCUGJaLzJNVmFvRFFjWHJVMUJWbGFBTWt0aUlRMXlIV0xTZXBpSWJOYVkrQ0xhQjJGTkdFQmtWMThMMG8rTTZFeE9mUnNISzErbWFFa0FVQlVCaWQrRzN4S1g4ZGtjcHI5ZUxzellQWjlsQzlONTFHSUxic1lvS1NESzFEU0VVczRnZ0NnaDdVcnlpQUhMVU9kaml1aDE5R3dZd215MWtudmttSlJ2ZlJxaVpnVjRuZ0FvNm5VQzlNNGdnQ09na2dWaTdDN3V3aFByU0JkVHZmcGxLNjNBeWh0eU53V1JySHZwVlZSUmhjYzFFM0djalI3K3JBbG1XVzN3NTFjV0xjQlc4Z2FkMks1MFRUWWg2cVBXRUNJVlVxdXI4V0MxNkpFa0F3dk5Sc21qSG5IMGpPZDJuSEo5dXllWklKbXZnTFlTc1ExQlVFVkVVQ0laVTdCRjZYTjRRcWdLeW9sTFhGTUpxbHZEN1BjU3E4eW5mK0JhQlFLRFpZZFVWL1VpRXZwRkFVS1hKSXhPU1ZkSWoxbEt3NFp2bTRXRkRRd1BlN1UraTgrVVRiZGZSNUE3aEQ0WTNRSFc1WlNJc2VvejZNS2drQ2FnNkI2YlVTK2pjZmNvaFRiblZLUjZqSllwdVk1K2x1bXdidTVmY2pOM2tRMVhCb0JQeEJHUk1QZ0dEVHNMbENTR0tJb29DSWRIQnJYZS9Ra3B5SE5ucHNWUnUvSXFBWDgraUxaSGtsVVhTUDdPUkVUMWNxRkhyMkZRU3g0clZlWmdNSWxjTXNXT1I2a0FCajAvR2FCRHgrVldDc29yRklDQ0lFQXlxTk9xRzBHMzB3MFMwd3VtMUtxZWwwK2xJNnR3VHZmUUN0WVhmb05iTXdtd1VxVzRJWWpLSVdLSjBlUDFoVGZrVkt4ZzdzMkhqR3I3OGZodXFxZ0FwQ0lMWVBHYjVhWU9GbjliTHFKUWo4RDRJRXVjTXQ4TzRFU2oxQlhqOU1oYVRSQ0NvME9BTVlEYnFrVVFJaVVtWU02ZVEyV1VxSmt0VXE3cXhvMHJpeGFiMEpTcStCMXZuK1RDNDUrT0lWQ21wOUtPVEJHUkZ4V3FTc0prOE5KWGNENEUwSUdvUDZJSEdhMUtMSVp2T3V3bTdlekdLWHNUdFZWQlJLYXNLSWl1ZzE0T3FqOGFjY1MzcDNjODdxbjc3b01CNXV5dW84UVRSQ1FMOU14TVJCSUVOdTZwdytZUFl6Ukk1aVRHWXVsMk4zbk11RFJzZklDNWFwZEVsbzRRVTVKQ0swU0JpTW9xQTBxb2JraVFCZzE2Z3NpNklLRUpSbVIrelVjUm0xdUV4OUNYampIL2ljQng0aDhoMU8wcnd5Q29KRVFheVVoSmE1N1QwZ3NLa0R6YnpuNlVGNkhRNkpFbmlwKzNsakgxblBVb3dITUxkOHRYZCtBeXhtUHErVEVTM2h6QVpKSFJHRWJ2TmlOc2pVMVVmSUNWT0lTdEJvbWV1Zyt4RUF6MXpvOGxPMU5NangwNU9rb0VlMlZIa3Bwam9ubWtqTXo1RVZJUkVXYlVmazFFa0VJUll1d0haMkkzNFllL1RZOXlMT0J3eGVQMkJabWU0cnl3dnFtYjRtK3NRT1lyWnc4NUpDVXpJaWlUUEtlRDMrMUVVaFkxVlhrYW1SMkhVZWZsczJSZWtSM1ppenFaNWZMcHVCaGs5eHFQWXh4SnIwMVBiNkNja3F4ajBBbmZkT29YcFpmazhjZHQ0TGxxN2hHZnVuOHEwOWN0NS9PWnhYRmF5blljdkhjd2YzS1g4Ylh3WGJvNFV1T3pDUVFnaTFOUUhpYlpMaEJTUnRQNS9Bbk1Tb2loUzNlamkvczhXSGZDZUhaRldFSFU0cktiV0EwdVN4T1N1c1N3dDgxSmMwNGpUNVdiMkxnL25aa2VSMVNtYmVidVdFSElIV0pHL0VyMHFrcmVyZ002OS80RFAwSVBvS0IwNm5ZQ2lnS3JJV0VROWtkWkl6T2lJdEVWaEZuWFlJaVBENXlNaXNPaU5SRmlzV1BSR1pIOGRPcDFJakYxSGc5dUVJWEV5dHNSK1BQcnRTbW9iblV6N1lBMTZTd1FHZytHUWsyWkgxUStmMHlVQnExNWt4cVl5RmhaVVVlY05NYlZYTWpwSjR1YWgxeklnclM4VnJtcFFSRllWclNVaUpvdlVNMTVBeVh3U05YWUtQdk5vNUlDN3hkcU5RNDZpbFBEY3FNOThGcVQrbFlRaHI1RTk3RzdtYkMxbHp1NEEvNWkxa1FXVk1rTTZSMU5TVmN1bXdwTGo1N1FBSExZSXhuVzJNS3V3aVMyVlRReFB0WklhRTRVZ0NNVEh4ZkhwZDkrUUZkV1puUlU3RVZTVnl0cEtrdU9UNlpROUVqbmpEQ1JKWXRtc2Y0RndaSW5EVU5CRlFvK2I2SnpSc3ptSWNIczhQRFMzaUtET1JJUVE0b1pNaGFxNlJzNmZ1NE01MXc4N3Zoclc2WFNjbCt0Zy9tNDNQK3owTUNrenZGWUtJTm1leEpOVEhtWkV6akJDQnBVTmRWdlp1R056OHpoWGtpUks4Mytpc3pnVDgwZ0xnZUNoeDZsTkxpZUpaOVlUS253Q24rZlhhbXNoRmZwRXlveU1jSkpmSHlUS3BPZkdSUzRtNXNRUWE0ODZ2c0FBazdvbm9kUHJxUWpxdUtCUGN2TjVrOUhFajF2bThmT3VSVlE3cThteVpmRE91bzhvTHQyTnFxclVWdTJtY2ZOak9OMSt6cnFrZ2liUHJrUE9PRmd6eXVnOXRBRm5iUjRsYTU0bUZBclA0bHNNZWxSUndCNFZ5YzFuZHFYZUcyS1kxY21OdzdOT1RNWWp3bUtpazg1TEhCNmlyYjh1Q3hKRmtRazl4MkVUSTRpMXhyQzFZaXZwMWxUK3UreFRRcUVRcnZLNXhObENDS0pBUmEwUHE3b0JJYzF4Z0N5RlREQkdoMDFjVFVtbEg2dFpoOVcvRkZkVGVMdExyOCtIMisyaDBoMWlZWDQ1L2RJVG1IdjdPYVRHL2ZaYTVmV05vQVFwcjNjZlBiQk9wK09IYTRldzlPYWhtSXd0bC9aMVQrdkt1RzZqeVhCMG9nazNlcjJCa0J6Z3A5WHpLTit4a09LcUVEYXJoQ2x0T29wb3B2TzFkUlJ2ZUhmUGN3cmdrd1BVdWI0azZieFM3TjN1SURhNU8yNVBrTElxSDQzVnF3RFlYdDVBY2IyYm5vazJHbjB5ZnhyVEM1UEJjTUNCd3BRKzZlVGROcFNvUTNSTGh3MHRqWG85R1VueEIzek5ZcmJnbGYxVSthdXhDNUhNM0Q2SEh0Wk9uQmtkZ1VPM2cxMDFJWUxtb1NUR09wQkxQOElXSlJOby9CbmI5RWhxcXBhUmNMRVBYOU02c3BNbDNOdi9SVVNYZTZuYThSd09Rekd1blIrelMzVHc3bys3a1lGTkZVNCt1RzdNb2NmdVNZY3ZKSHpNTXc4dXQ0c252MzRPbDZlZWM0MXI2WmtjSUtRWThObW1FcE05RForN2xOcVZmOEZrZ0VCUXdldFhxYTRMSU9uQXFCZUpkK2lSRlRBYVJZSzZIQktIdmtDZ0tSL1ByZzhSWFN2NVpYY2NxMXhuOE0rYmJpZlNiRHoxTXc4UjFnZ2V2UGdlYmpsakVycEFBeWFEU0lQaExMS0gzb285SnBtRzhtMFlkS0FvS3BJb1lEV0ptTXdXRW1PTm1FMGlLdUZuamVTUVN0QlRocUFHU1VnYmdyM0hmZVEzeHZGOWNUS1RiTCtnYTJWTWZrTHowbnE5bnN3ZTQwZ2Q5QUJmNzhyaXY2VXVaRmxHRUFSeUIvNmVCbWt3d1JBb2F0aW1JaXdpMFpFNkpER2NMZEhyQkx3aEk2YU1tN0JIaDRQK3AzN2N6SGtMTDZSQjZzS3dxYTlpTnB2YkR2QmV5ZTV6SVZPbVBNK1d4bUkrWHZoWnVEL1dHZWcxNWhGY1pHTFFoK0VNZWdGUkFJdEpCNmk0dlRLbVRwZVQyei9jbXU3KzN4SWUzeWpqdHpqd1JPWmlpemwrMjJBZTk1a0hoODNPSXhQdXBWTk1DcklzNzhsKzJ1azI5Z1VhMWE0WWRTSTZTVUNTQlB5S0NhOXN4WnAyRlYySFhnL0FCMHUyOGRTV0VCZ2pRQTVoMG9zb2luTGM3dStFck9McG05bm5BSG14ZUxxTyt6Y0ZpeDVCRURlQTBJUkg2a2xTNW1qU2VvVjl5cXE4WGR6MzQwNVV5WTdZVkltQ3lxanNoRVBtbWR2MDNKTEZZcVhyV1k5aDcvSm5pcDFaREp6NEpKMTdYdFRjcC9iTlRHSGhOWDNvSmxRVDZTNG53aExCcU16WUUzZERxcXArcnA0a0NRYURCenp2OVhyVnJidkwxZXI2QnZXdHVldlUrb2JHWS8yb3owKzRTUjlwUXZCQVlqS1o2Sm9hcnF4eDlWbDl0T2xTRFZnRDFvQlBiK0RUVGxvTUQydUlVenNhWUN6Vmd0YUdOV0FOV0FQV2dEWGd3NGlVSlo4K3dHS0tndmxCeitrRGJEamZqK0Y4UCtoUEYrQ3BBUVM3aW41MG9PTURDM1lWL1pnd3FPSEMwd0RZTURIUW5GZ3lUUFdmOURzNCtjQlRmNTBZRjVNVWRJT0RIUmRZTUtyb0o3VTBZOE1GSjllc2oxL1dVZ0RCcklhL1FtblBWeW1xQ1BzYzYwY0hFU0phamtBTkYvbnh2N0hQZks3YThyZXFndG9nb3RZTGJReFlEZCs4OVRVWGd1WEloOVZTbG93OXYrNmdyd2RtR25CZGFXdWJKdTMvd0VUallEdnkxdU5RejFjQnozMVduRk9panB0MlQwZ2JsamZyYUJ6c3dQK2g4ZWhacTBXYXpvbkMrMDhMS08zQWFha3VBZGNWTnR3M1JLTDZXNmVkMEZJOWpmMGRCSDgybkJDbmRlSzh0QXErMTAwMG5XRkhMand5RS9lOWFLYnhURHRLeVltN3JSUGVMWVhXNkhCTk83elRDYTNRNGI0MUFrNXdMM1ZTK21IZG1ZY1BMblFEUWdqUkp6NXBlbEtBRFpPUFlDOEhDUXpuK3RzL3NPQlEwWS9hVDhPQnNIUDZ6UmN6SmREK2dRMFRBdUZJYTIrWHMxT2ljYmlEeHVGMjNIZEV3RDZGa2ZRVEFnZ210WDBENi9jeDU4RFhSaHI2T3dpdDBvVzkrTE5tR29jN1VJckMzNGhnVmRHUERiWmpZUDJlNFdBSTNMZEg0THpRaHRvZy9NWTdOL1J6RVBqUytKdlJWTnNlUEJ5SWQzZ1F0VW1nYVdJVW9XVUh6K2VvRFFMT2FUWk1OM2t4MytVSnEwRTVRVDVsMzRQalBabW1QenRBYUxVZXRlN0lveTFkdnhCS3RYamNnby85SjlPMDJjT09MaHF3QnF3QmE4QWFzQWFzQVd0eTBxUkYyTlVYL3ZNMERJNkd2aDBGc1A5K2pDMU1PbTBLdWVNbCtyNE9TMVJvN1BCdCtQYmJ5Vm0rSEpiMzQ0enhvQlRCaWc3dnRBWU1nQlVyNFArZXhESGR6T0Mvdy9vUVZIWlVEVytjUFJ0ME9yanJMdGk0RWR4ajZITVdSSzJDWllEYW9ZRFhyc1U5WVFKY2ZER1VsVUZXRnZ6OE03ejhEcVo3b2hsNkV4VDZvS2pEOWNPZmZRWmR1OEtMTDRJc3cxVlh3ZGF0a1A1N3NrWkQya3hZeVFtZkl6akpnWWZUQ2JmZUNvTUdoZHQwZkR4OC9ERjhOUlBoalU0TXVnVHE2MkY3aDR1MDFxNkZZY1BncHB1Z29RSE9QUmUyYklFSnQ1QXdYcVRMRzdCQkJWZUhDaTBWQlY1OU5Xem1IMzRJRVJGaGMxKzRHQmIycFBlNXdDN1kyR0dBOTBwbEpWeCtPWXdkQzl1M3c5Q2hzR1lOM1B3b0ViODMwdXNSMkJHQzJnNDNlSmc3RjNyM2hnY2ZERHUxKysrSGRldWdkaVRaNHlCcURXem9jS09sUUFBZWZSUjY5b1RaczhQbVBuOCsvT3MxZEhkRTBmc1dLUE5DV1ljYkhoWVV3TjYrdTd3Y2JyZ2g3TlRpTHlCNURDVC9BSnRvTVdYV1FjYkQrL2JkQ1FudzVaZnc4WmZ3Y2hJOXA0Tzd2bzBFTFB2UGdSeXdyRVZNREl3WkE5MjdnOGNUZGxUejVvVzk5NEdrWHo5NDdUVVlQQmdhRytIdXUrSE4xK0VtbGZ5cklGVUE4OGtDUE9UdzhFQXlhVklZcmtzWDJMQWhISEplY2ttNDNTWW5INzd2VnRVdy9MejVNS2NMT1ZOQTNBVTcycVNHTzNXQ1diTmc5R2p3K2NJL0NRbFFXZ29USjhLZGQ4TFpaeDljMHhCKy96UFB3UFRwNFBmRFk0L0JrMC9DdVVHYUpvSHVSRmVzdis1UVc5WHVBVmIzL3R4L1ArcnR0NGYvSGprUzlaMTNmajBHMUMrL1JCMHg0dGZqUS8yTUdZTzZiUnVxcXFKdTNJZzZaTWlSL2Q5eCtHa2hoNXdmenNtQlR6OE4vNzExSzR3ZkgrNTY5c3FhTmVIK2VOR2lJKys3Nzc0Yi92WTNXTEtFMyt5VWN5SWtPN3NWWG5ybnpuRGJCVEFZd29HR3lmU3JxU1ltUW1GaEs5dFFHOXQxb1lWSjkrcUZXbHlNbXBIUjBreis5Q2ZVUG4xUUN3dFJZMk9QekxUR2prWGR2cjJObS9UR2pXRVRuRGN2Yk1yVjFXQ3p3ZWVmaDg4Ly9UVFUxQno2RzB4SWdHZWZoY3N1Q3p1dEJ4NkFKLzhGTWNNVG0vbzhrSERDcTB5c2YzUjk2L3RobXczNjl3OUhWSTJOY1A3NTRiSHhTeThkZkJkSlVZUWJiNFIvL0FQc2RsaXdBSzYvSG5iVm0veTk3K3U5eTVKa3lUMFpKdnZMeGIrMGZnVkFVeE1zWEJnT09yWnZEd08vK09MQllmdjNoMlhMNE4vL0RyZlpHMitFczhZSUJQcGw1QTE1YVloeXNtQVBKRWRzVXJJTWp6eHk2UGZZYk9FQnhjMDNneVRCVjEvQm4vOE1UbU5rdzdEWGV0ZnJvL1M1cDlwSkhiYzJkUEhGOE54ejRlaXJ2RHdNK3ZWTWtTNDNkTm1ZT3pLaE8yQnZDMTc1bUlHenNzS21PMzU4Mk1SZmZ6MmM0cFV5b3N0R3ZOVlRGWTFpcjdiVURSMDFzTUVBOTl3RDk5NGI3cHUzYnc4N3BTV3JkYUdlLzlkenM3Mjd2UTl0VUk1cWVEaDJiTGpMZXZqaGNGdjl4eitnVDEvSTF5ZmxEMzl6ZUdOYmhXMjFodmZ0VXdHV0w0ZnJyb084Y3FPcjc1TjlkNXFUekwxbzQzSkVHaGJGOEZCdjI3WXdyTXNGdDkwR3c0Y0x1THBuckIvMjcyRzBCOWdqMG5ELy91SHg3S0JCNGVQdnY0Yy8vUW5xaElqS0lhLzFyamRFR2ZyUWprUThWSi82d2d2aFdZZEJnOEpoNWZUcE1IbXFxRnJQNzdaaTRGTURvdzFSaHE2ME05RWRyazhGZVA5OStPdGZRVWwyRkl4NHA1Y2tHc1RCdEZQUjdaZUxzajcrZUxoUDNUczh2T0VHbUxkSTUrdDFkNjkxVWQyamh0TE9wWVZKUC9jY3ZjYVBENGVSenp3VHpqbHZDaVd0SC83MjhNYU9BSHRBazE2M0RxNjlGamJ1Tk5UMy9XZmZIWlpreXlBNmtMVFE4SXN2c21QUVlLak5UbDh5N05WaFVrZUQvWTJHNTIxMTVBMTV0YnREYjlPZmdTWWRRMXBrQTBaZi9rN0ovQlZGS2NkNjBkM3ovMHBxNHJFOTFhMldWK0x1UCtHWUFhVmgvVXN0WDcyZGVreURodzdqdERSZ0RWZ0Qxb0ExWUExWUE5YUFOV0FOV0FQV2dEVmdEVmdEMW9BMVlBMVlBOWFBTldBTldBUFdnRFZnRFZnRDFvQTFZQTFZQTlhQU5XQU5XQVBXNU1STGk0VnAvWFArVkxMR0VOK3FoV21pS0tBb3JTL0N0S2JzNDVORHFBcGY5Ry9ZUHUyNG1mVGQxNHpBb0pmYWpZYVArcm1sckU3UlhEZXRQemRjUEpEdVdYRjgrZU5XdnZwNWE4ZDFXb1VsOWVna0VYdWtpV0Y5VWxtOHRyaGplMmxWVlhGNkFyeisyV3BLSzUxVTFiazdsa2tMZ29DNjMvT3p6NzIvbENhWEgzdWs2VGV2anh5UXhyYkNHcXJyM2UxVHc3ZGM5dHNIV1pwYzRZcjlEVTVmTTZ4T0V2bmpCZjE0N0pZeFBIL1BCTTRibmR1K05Od3RNNDRMeG5ibHZodEdrUndmeWZjTDgxbXdhdGRCM3grU0ZZckxHeGsxTUkyNlJpLzN2emkzZldsNGUxRU5HYWtPTENZOVEvdWtzbkxqNFFzb05UVDVlT1B6MVN4WnQ1dUtHbGY3MHJDaXFOVFVlL2puR3d0SlQ3Ymo5UjkrcDQwTmVaVmMvOUFNQkVGQUo0bnR6Mm45NC9VRnVEd0JyT1pENzNKMTFkUysvSGZHQm9JaHVkbVQ3LzI3WFRrdGx5ZGMwZEh0UFhobHg1RUQwbmp6a2ZONTY5RXBpR0licTA1eVBDS3QzOFRHVzhxNTg2azViQzJzT2FyWXV0MEFtNDE2dlA0Z2JtK0E1ejlZMXZISHc0L2ZQcmJOT2FianJtRkJFQmcxSUkxWWg0WHJwZzJnb3NiRmhyeEtGcS9aVGFQTDEvRTByS29xUm9QRUd3OVB4bUxTOC9odDQralRKWkVtdDcvam12U2NKUVY4dHlBZmdQSnFKMCs4dWVnM3NYYUhBaFlFQVg4Z1JPYjRGL2pvdTQza3BzVjA3QVFBd1BVUHpVQlJWTzU4ZWs2Yjduc1BDdnhtOWR4bENPcEZkR0RSOHRJYXNBYXNBV3ZBR3JBR3JBRnJ3QnF3QnF3QmE4QWFzQWFzQVd2QW1yUTNhWkZxeko3MDRRRnJ4TGR6K1dMSDk5T25hVzFZQTlhQU5XQU4rSEF5dEhmQ2I4NE42NVBRL29FanJYb0dkSTlyUHU2ZTVlREt5Ymw4OFBoWXpoNldTcHpEUkZ5MG1iT0hwZkwrUDhkeTVlUmNlbVJGTjc5L1lJOTRiRlpEMndVVzk5bFRhT3lRVkY1N1lEVHYvM01zVThka1lOQ0w3SzV3OGNDTkF3RVkwRDJPNm5vZk5mVmVCdldNQitDQkd3ZFNYT0hFYUpDNFlHd0dIL3h6REs4OE1KSnhRMU9iUEtEU3hnQUFFMUpKUkVGVXR5c1NqOU8rUmNlOHFDWEdibUpJcjNpK1h4aGVQcndodjViQnZjSWdoU1ZOQklJS2dhRENKN04yRUFncUZKVTZnZkFtR0R0TG5idy9JdytqWHNUcERqYi9qMDRuTXFSWEFuLzkxNUxtL1dER0RVMWxmVjR0bGJXZVV3TXNDRERsckF3ZXZXVXdKb05FZXNvRzN2NXlLeTUza00vbkZGRGI2Ryt4bWRSai8xbU5QeUJqTlB5NmV2NnJud3J4QldSTSs1d1RCWUhYUDk5Q1RKUUpweWVJeVNCeDlRVmR1ZjNLUHNpeXl0OWVXTTVYY3dzNTJzVUdSdzJzcXZEOXdsMDhkY2N3QUw1ZnNBdGZRRVlTQmU1OVlUa0EwajZUNVA2QTNPSTNnRy9QMzc1OXptM0lyMlh0dGhvRUlmdzhoU3lyZlB2TExtNi9zZytTSkRCelFSSEhzckxpbUV4YXI1TjQ4cTIxN05qZFNLekRSRkdaRTNtZlJXbnlBUmFvNWNUV01qQzFuRm5iczZuM21uN3p1aXlyelYvbzNyL2pvMDNjK01nQzBsTWlNUm9rQWtIbDFBQzd2VUhlL1BMSW4zTzRvdDhHSm5YZGdTQ29yQ2hPT1NEd2dXVE4xcHJqNXFWUCtCWmUrOHBubTdwelJ2cHU0cXdlSGgwL2oyWEZxWlEzUmJDNk5KbkN1cE96TzlGSkJUYnJnc1JZdzE3V0lNbU15Z2d2TkkrenVubDErVUJVVmVnWXdJS2dNaUo5TjlQN2JqeGd4ejhzdlFTZnJPZnRsWDA3Um1ocDFNbGNQWEFkc1ZiUFFUUWZvbDl5T1NsUlRlMGIyR0lJTXFSVEtlTnpDOUNKaC9hc1NaRXVYcGc4bTl0SExHdGZKcDBaM1lCUkZ5S29TRHh5OWp3TVV1dFd4SWNVc2YwQWk4RGZ6bHFJM1h6MEsycjdwNWJ6NE5qNWJLbUs0OXN0WFFDQmdDeTJUWk5XZ0Z1K25jRFdxdGlqSDJrWkF2Uk9xdUwzZlRiejhwUWZlRzd5TENSUmJidHQyQnZVWTlJZG53YzdvaTFlTnBRbklpdEMyd1VHK0doZFQ1cDh4bU8ramp1bzU5TU4zZHUrbDE1YmxzZ0hhNDk5QzdWWGxndzY0dkR6bEhkTEc4b1Q4WWVPL2tIcS9Kb1lLbHdSN2FjZnJ2T2ErR2hkTHhidDdId1VRMCtCbDVZTVlsZDlWUHNKTFZWVjRMdHRPUURNeXN2bXdYSHpqNmhQenErSjRZTTF2ZWdhWDB0WlUyVDdEQzIzVmNjd2EzdjJRZHY3VS9QUFFGWUVObFlrY04rc01XeXBpbVB1anZUMlBWcGFWcHpLK2QyM054OXZyb3pqZzdWOUtLeHhvT3l4Z3RJbUc4b0p2bytUQmx6bHN1RHlHNGd3QnZqYnJMSGsxVVMzZVAyZFZYMVB5bjJjdEVSOGc4L0UwdDNoZlo1S1RrRGJiSFBBSXBBVFU0ZWlDdGhOcCs3cHRaTm0wZ3J3M3pXOThBVDFKOFQ3dHNrVXo3cnlSRTYxYUxPSEdyQUdyQUZyMHBhbFJlN0VQWFowU1dqaC9KU09CS2diT2JyVSt2TjhiU3RQRFZnRDFvQTFZQTFZQTlhQU5XQU5XQU0rMXRoNjN3UHpleCt1VVZFNzFPQkJRRmhEYXVxQmdZV1VsSURROFpRYTBOcXdCcXdCYThBYXNBYXNBV3ZBR3JBR2ZLSUhENldscFliMlVHNjFWWU1IUVRqNFE0eWpSNDh1QWRTTzlMT0hTV3ZER3JBR3JBRnJ3QnF3QnF3QmE4QWE4QWtGM3JsejU4Nk9CdGdSbVZvM2Vtb3hXcnI4blpMNUs0cU9lVzVwOS95L2twcG9PNlpycU9XVnVQdFBPR1pBYVZqL1VzdFhiMnNMMHpSZ0RWZ0Qxb0ExWUExWUE5YUFOV0FOV0FQV2dEVmdEVmdEMW9BMVlBMVlBOWFBTldBTldBUFdnRFZnRFZnRDFvQTFZQTFZQTlhQU5XQU5XQVBXNUNSSnkwZisvOVAvY3hBT3VKV25RZFNIUGg3N2o4VVhab3daQVlSTGc1ZVVCTG55U2ozejVyVmxRT0dvVERxZ0JIVVgvWGpYNkROblhKL3ZrLzJGQUtTbTZwazdGMTU2U2NGcTdaaHRlSDc1bXE2T2Q4OUtuYjE3NlFMQ0QwUEJuLzhzc20yYmp4RWpPcWJUOHNrQnc0UWZiaGsxNGZ1L2JBNG93VjE3dEcxaTRVS1ZGMTRJWURaM1RDODl1MlJKeitqM3g4UXZLRit6c0xuSi9PVXZCdkx6WFF3ZDJ2YUI1K1h1cUxaTDhxYldYTUFkOEpwSHo3aCs1SVZ6N2x3ZlV1UXlBRkpTSWxpeVJPWDU1MTJZVEcwWCtFeGJVMXhOMy9YZHJvbXArWVg5S3B3Y1RyNHErcVZQN1B0am8xWlZiMWtVMXJVZ2NPdXRFUlFVMUROb2tOcG1UVnBDbGQ1TTMzWG1tbTViaWlNa1pVdHJMdFlZY0ZrSGZYWGxpTXZuUGJCYVZwVktBSktUSFN4ZnJ2TDg4OVVZalcwTCtJNW5LWlVWeWdENldielpkWDNXNVY3cXFQc0ZDTGJtb2gvbS96QWcvdjJ6elp2cUNwYnMwYmJJcmJmR1VWUlVTZi8rd1ZNSnZIK3RvYytqSWhnLzl6K3M2OStGNWo1bXVjdTYvYXo4WE1HcmlMbXQvWUFidWwyNDRwVVI5MlNKZ2hnRGdLckt2UFRTYnU2OE01MWc4R1FBQ29jRVpzK202ZE1uc3ZxOWgwaVJKQklCQXFvUXZHUm41dUt2Niswam15T3RJNVFFYzNUOW9pbHY1MlhiVW9jMG42eXBLZWFjYyt5c1hXczdtY0FIN1pZKy9JRUJjV2RqV1ovUFlnQ0RvT3EveWl3NDg1ZmN2RHdUYW1GclByVFNXK2ZJL2VTQ0lYY3VmMzZwaXRvQVFHeHNaOWFzTWZQS0t4dlE2VTZkU2UvVjhMNXkxV1JXdm5rL2FaSkVQSUJQRmYwWDdNaGFOcXZKTnVvQTF6aWtwRmppcXBkZThHNVJKMnZDb09hVGRYWDVqQjFyWmQyNjVGTm0wdnRMZEJTTjgvL0Q1cDdabkxIMzNCeG4xTWJKK1ZtUkFWVkliOTFOQ0R6US85ckZEdzI4dnJlQXNIY1BoQUNGaFJ1UTVlTzZlNG1RbXp2a3FJRDN5clZUV2ZHZis4Z1FCZUlBUElyb21aU2Z2V3ErSzNKVWEyOG1JektsZk1tVXR5c1NMVEg5VHBnSkM0SndUTUFBc1hicUY3N0oxcTdwdjJwN1JxTjkvVVU3TXFPRENKMWFxKzBuaC81bDRSMjlwbmNYQkVGLzNQdGRRWXc2WnVDOThxZHBMSC81THJKRWtWZ0FweXk2ejk2UnUzcTV5enFLdGlJM3JENjY4ZkNCNU5YUEdaSTBIakcvbUtVQWtaSmlYZFpsMjZqL1pSYXVrUVMxdkVQbXRLcnFpYzY5a0dGL2VZcGxpa0lkd01XTyt2NDFmZFpiKzFxOGl6cHNFdStsL3pFMFpTSnFRU25MQU95U2JGdmJiY3VJZHpLS1ZvcUNXdFhoZ0p1ZGdrcWJMbzE1M0VLY1d5NWgyZk4za0N1S0RBR29sNldtcy9LNmJGenZNUS92VU1EeER1b1d2VVZlVG1lYVV4d2ZOMFN2dnFJd1BWbFdoZUVkU3NNM1hNVHlWKzRtU3hURHNFMnk1RDQ3UDNmTkNyZGxaSWN5Nlpnb0doYTl4Wlo5QTQrdkcrenJmbGVZRlJ0U2FUWHNZd052V25SUHY2dHl4Qk1SZU53Z0hodndIODhQRHlSRU1RenJWc09oNVFKbjYwUEx6dGJFeXFWVDN5bEp0c2FOYUhNYWR0aG9XdkFHRzN0bTBkd3VaelZHYlp4U2tHVUxxRUtyWWYvVzc0K0xIeHQwVTA4QlljQ2VVLzZpb3NBNldVWTk1Y0JYVEdMVk8zK25reVNGWWIySzZKdFNrTFg4eDZNWUhpWlo0bXFXVEhtN01EMHlxZm1MY3pxVkxTTkhiak90WCs4ZGNrbzFiSS9FT2U4MTF2ZmRKOTB6enhXNVpXSitqc212Q0tOYisyRi82WG5wc3VlRzNaNHJDdUxndlVQQ0R6Nm9YZnJIUCs0YUtjdXFlRXBOK3BKeldQUGhZeVJLWWhqV3J3cUJpd3V6bG43YkVEV3l0UUZMckNtcWZzblVkN2JsMkRvUDIzdk81VksyblhYV2R0MnFWWjdSbkVUNURiRE5ndnVuMTFnenFQdXYzbmFKSzJMN3VCMDVvbGNXVzMxelYzZVpzdktOVWZlbGk0SzRGemI0eVNmMVM2NjRZdWVJVUVpVk9NblNBdmpXMzFQNjlHMDA2SFJoMktBcWhDN2ZtYjc0MC9ybzRhMzE2QTZqcmVtWHlhOXY3QjJkM2R4V3ZWNDFiOHlZN1N4YjVoN05LWklXRGtkZHplZW80Zkh3YW85bHg1bmJ1NFJjaXRpMXRSZTlOSHZDNmcvT2VpUkZFc1M5T3p1R3Z2cXFZZkVsbHhRT0R3WlYzY2xGSENnYzBxUkRxaUJmVTV5MjZQMmFtR0dBb1RXWGp0QlpQRDlQZm5YMTRMZ2V6YzNCNTFOM2pCK2ZIMXl3d0huS3RIcFE0SithYk5VWEZXUnVhNUtsVnQvYytXbWoxbjl4emxNeE9rSGFDeXQvLzMzam9nc3ZMQnptOXlzRzJvaTBBRDQ3THpzT2hCNnR1WUJGYi9MK01PSEZsYU9TK28vYzIwVDhmclZ3MHFSODM5eTViVU9yeDIzd2NIYnlrTTB6Smo0WFlaUU1leU10NWFlZm5Bc25UOTR4MU9kVGpMUkJPU3BnbzJRSWZEMyttYVVUVW9jMTk4bUJnTHByeXBTQ3BsbXpHa2ZUaHFYVndLT1MrbStkUGVrbGcwa3k3Z1ZUNTg5M0xwdzBhY2NnajBkSm80M0xFUVByUlYzb2s3SC9YSHhoeHBqbVBqa1lWSGRmZEZGQjNZd1pqYVBRcEcxS2kwNDU2Vit0UzhTM0IxSGgveXJ1NHVubWhNRHBwbUVOK0ZUYm4raUhUQmZoYmVVUE5uRWFPdngxREg2UUFvRFNrbEhYcG5oRE1Ma1NocWdnTzJHdUFBWTkvR0lEdnhSV3oxbE5jRjRqZktXSFJRbDd2SkFDdWhEMDhZQmZnSkZPaUZKaGh3amZ4clJrYkZQQW9nZzJHVXhOWU5QQmZkRlFYQVYvZE1NR1BXelh3eCtBS0N1OEVvSStMc2dPUWc4dlJQdkJEdmhEWUJYQUIrUVp3RzlxdWQ2c2JXbFlnZy9TWVcwZGpDK0JtQkJFV2FDK0NYb2JvWHNJNHVJZ1NnOFB1OERyQktzS3dTQTBCVUF5UTNva1ZMdkJEOHlKTzg2eDlJbnFLRGZGUUswT0N1dWhHOUEvRWxRWlpCVThRZkFFSU1zQ1c1M2c5NE1vZ05rRVFRSFcrR0NiRlg2Mmc4dmNIb0QzU0hrVWZCVUpQL21oa3d0eVBKQUQ5UE5CakI3eW0wQ1J3U3RDS0FnVkVzeDN3QW9iSEdvdzJtYUI5L1loVGpOc01jTVdOZXlkRSt2aGI3V3dNd0pzS2ppTnNFNkFlVEdnSHNFNjFyWU52SDlNcUljYUsyejF3MFlGTW5Yd2ZuejQvSkZteDlzUDhKNytOY01MU1FMVVNaQm5iaDFzK3dNV0lEOEdIcFhERGdvQldqdjkzcjZBOTBBSGorR3UyeFR3aER3REEzWWYrSlpXNkVOOFZucmdOZXZaYWZEWGd5eHRLNURvK2xoYkJlNVJJVEZwKzRIN0ZFOHN2TC8yd01BQkFhYjJPdkExdnhOSTBFWkxHckFHckFHZnNHQkswN0FHckFGcndCcXdCdHlHeHJ1YWhqVmdEVmdEMW9EYjd1QkIwRFNzQVd2QUdyQUd2Sy9vT29KNkJBRk5EdDcxN1NPdnYvNjYrdEJERDFHV1hBWjlnSTd3emIxNWlEb2VZOGFNWWYzNjlaeWJjQzc4QUhoT0E2Y1ZHeHZMakJremVPNy9uc013MHdDN1R3TXZMUWdDdDkxMkcwdm5MU1duTUFlV0FmSnAwQzMxNzkrZk5XdldjR1gvSzJFRzBIZ2FkRXNSRVJHODk5NTdqUHRnSExmY2RoT1pZMTJrOUcwL2dETVA1YVYzN05paFptVmxIZlNmOC9QeitmM3ZmMC9QbERXOC9EZUliQWVWSFlYZUhIMGRqNXljSEpZdVhVcE05dTBNL0wzQW1xMm5RV2hwTUJoNDl0bG5lZTZWbVV5K0xZN24vd3VxMm9HQkFWQlZKazJheEtyVjY1bXhhZ3lUYjRIcStnNE0zUERlZXdBa0pTWHg0NDgvY3NiNGZ6RGdFaDN6VnJTejBQSndUZ3RBOFhySlMvNy9kczQvSnNvNmp1T3Y0KzRJaU9TSFFJTHBpTG1zQU5FV3kwRzJ0WmJGWXZaanRuRW96VDlreDhDV1FNdHlTNXR1WGRQVldIODA1cHB1SVJHQ3NHVXdzU0U2SnhJbnBJR3NsUEFnSjNhZzNYRjNlTnlQNTlzZmx3THh1eHh5ajg5NysrNzU3cDd2ODl4ZXorZlpaNS9QOS90OVBuR3N1SHdaVGZUb2R0WG01bVkyWldmeitzTzlGQ2VEWm9HRXBYSGZvZnBmMlpLam9RR3Z4WUt0cG9ZSXZmN3U3MmxwYWZ4ODRRSmJ0MjVsUStWUjlnRngvdnhLTysxL2NLMmpCRk5EQ1FEV3Fxb0pZOExEdzZtdXJpYXZ0SlROd2NIODZNL0FOODFYOGZSL1NmQnFYeGxhUjFNVEh2UGtOWVgwZWowbmpVYStUa3hrRDc3TjJuNEh2RFRoQlRUMkpLSldTRmdEQUVuQ1Zsczc1ZmpFeEVTTVJpTVJlajFaUVBkQ2RWb0p5NWN6c0djUDFvcUtDWU9IMXY2T05oTUNyNEgxY3dpOUFZR1RPTG5RakF3ZTNiZVBnSC9LTGxkWFY3TXRONWM4aTRXTjg1eG1KMDFYOWZDdWx4WUNTM2s1L1FVRlNFTkRvNkhsUmxpL0hVS0NZTEFmTG4wR1VXZkgzQ3dvaUNYNzl4TlpVREJoM3FXM3R4ZWRUc2VGYytjSVkvNG0wNjVQOTN5N3U3dkZXTG11WGhVOTZlbWlFMFFuaVBORmlMNDZSTnRoUk84UENGY0xvbFdQdUtoRmRLOWFKWnlkbldJNnVkMXVzWFBuVGhFUUVDRHdyUWJQUjJQV3dFSUlJYm5kd3J4M3IrZ0VjZkVESDZpbkZXSFlocWcwSUhxK1I1dzBQQ1pzWnBPWXJSb2JHMFZzYk94OUFaN3h6VkpwTkN3dUxzYjFER2hUWWRnSmRXY2dJeDNpb3VIbURVaCtxNWJRNk5sL091eDBPdkY0UEF2WFN6c2FHcmk0R0ZvdmdWWURVUkcrbzFvTlVpdW9tOXBtOVdjdWw0dWlvaUl5TXpNWkdCaFltQk1BQU5ZalI0anJnWTVFS1BrV0ZvWDZMQjBXQ2duTkVOTnpaRnpVTlZVdXJkUHArSzJ0aldYejZMUk1jd1dXYnQvR2R1d1k0UTVJWEI1QWVvb2FyeW9FSkNjUGFVYjQ2d1E0VHAzQ1l6YWppWW1aOUI1bFpXVVU1K2RUYUxlellaNHRtalJYWVB2eDQwakR3OFIvdkl2NHQ3TUlDVitHVnF0RnE5VmkrZk1TcnNGNmJuMjRpNkdhR2lMejhzWmZhN2VUbjUvUCtiSXlEZ0h4L2pDbjVXeHI0L0V6WndoSlM1dHdMakkyR1FxVENYOHBBOHZCZytQT3RiZTNrNVdWeGRvclZ5aG5qaVZmN21kNktOeHVWTnFaUzlXTkhWZFNVc0tuTzNid2ljdkYvYTV4OGU5SWEwWUx6d2IyenJqQndVRzJiTm1DdWE2T1NpQm1BV1pMOTJ6MXNLbXBpWGR5TnJNcDZqcnZab042b2F4TGxkOWpZSy9YeSs3ZHV6bDh5RUNGUWVMNU5Rdk1wUGNTdUsrdmorenNiR0tDenRKZUNaRmhjcDIxQkdwcWFuZ3VkVFdiWGp6TDBTLzhBL1kvV2RqcGRGSllXTWpwRTZVMGZBV3Juc0N2TkNjTGQzVjFrWnFhaXNkY2lySEMvMkRuWk9FREJ3N3cvbzd0eEw5OEcxTVN2SEVjdjlTTXdGYXJsZHpjWEtwT1Y4RXIwUEVJZFBqeEl2bTB3QzB0TGVoME9reGhKc2hFRnB1Y0prV1FKQW1Ed2NDNjllc3dQV1dDVkdTem8ydUNoZnY3KzhuSnlhSHgxMGJZQUFRaks0MnpXMzE5UFNrcEtUVGFHaVZleFVzd1h2RDc5bUJyWEloL2ZsNCtwSmwvUFR1R2MwNnVTS1gyTlZrNXJhbWtYZ1FoVC92NncxM2dIWkk1TUFJQ0FrZjdzcmV3MXdiU3lHaGZWb0hIVkxMOUJPNUJDRXA0QUlDamRiRHlXNUNHSWZJMUNGd2lZK0RGYjhLeWo4QjlBMXo5Y0tzT2x1aGxER3czUW5jK09EcDk0QjdMcU1lV0pmRElOVkJwNEdZdGVCMndzZ3hHZW1YcXBWVmFXUG9ldU13UWt3MGh5U0E1UVJNQnFrQVFMcGtCaDY0QnJ4M00zL2phbllCMGFTR0VQQW1PWDVSWVdqNnh0T3p5WVFWWUFWYUFGV0FGV0FGV2dCVmdCVmdCVm9BVllFV0tGQ2xTcEVpUklrV0tGQ2xTTkJmOURVTHFhY0ZkcVlxR0FBQUFBRWxGVGtTdVFtQ0NcIil9LmYtYW5kLC5mLWFuZG9ycmF7YmFja2dyb3VuZC1wb3NpdGlvbjowIC00MXB4fS5mLWFlLC5mLWFyZXtiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTgycHh9LmYtYWYsLmYtYWZne2JhY2tncm91bmQtcG9zaXRpb246MCAtMTIzcHh9LmYtYWcsLmYtYXRne2JhY2tncm91bmQtcG9zaXRpb246MCAtMTY0cHh9LmYtYWksLmYtYWlhe2JhY2tncm91bmQtcG9zaXRpb246MCAtMjA1cHh9LmYtYWwsLmYtYWxie2JhY2tncm91bmQtcG9zaXRpb246MCAtMjQ2cHh9LmYtYW0sLmYtYXJte2JhY2tncm91bmQtcG9zaXRpb246MCAtMjg3cHh9LmYtYW4sLmYtYW50e2JhY2tncm91bmQtcG9zaXRpb246MCAtMzI4cHh9LmYtYWdvLC5mLWFve2JhY2tncm91bmQtcG9zaXRpb246MCAtMzY5cHh9LmYtYXEsLmYtYXRhe2JhY2tncm91bmQtcG9zaXRpb246MCAtNDEwcHh9LmYtYXIsLmYtYXJne2JhY2tncm91bmQtcG9zaXRpb246MCAtNDUxcHh9LmYtYXMsLmYtYXNte2JhY2tncm91bmQtcG9zaXRpb246MCAtNDkycHh9LmYtYXQsLmYtYXV0e2JhY2tncm91bmQtcG9zaXRpb246MCAtNTMzcHh9LmYtYXUsLmYtYXVze2JhY2tncm91bmQtcG9zaXRpb246MCAtNTc0cHh9LmYtYWJ3LC5mLWF3e2JhY2tncm91bmQtcG9zaXRpb246MCAtNjE1cHh9LmYtYWxhLC5mLWF4e2JhY2tncm91bmQtcG9zaXRpb246MCAtNjU2cHh9LmYtYXosLmYtYXple2JhY2tncm91bmQtcG9zaXRpb246MCAtNjk3cHh9LmYtYmEsLmYtYmloe2JhY2tncm91bmQtcG9zaXRpb246MCAtNzM4cHh9LmYtYmIsLmYtYnJie2JhY2tncm91bmQtcG9zaXRpb246MCAtNzc5cHh9LmYtYmQsLmYtYmdke2JhY2tncm91bmQtcG9zaXRpb246MCAtODIwcHh9LmYtYmUsLmYtYmVse2JhY2tncm91bmQtcG9zaXRpb246MCAtODYxcHh9LmYtYmYsLmYtYmZhe2JhY2tncm91bmQtcG9zaXRpb246MCAtOTAycHh9LmYtYmcsLmYtYmdye2JhY2tncm91bmQtcG9zaXRpb246MCAtOTQzcHh9LmYtYmgsLmYtYmhye2JhY2tncm91bmQtcG9zaXRpb246MCAtOTg0cHh9LmYtYmRpLC5mLWJpe2JhY2tncm91bmQtcG9zaXRpb246MCAtMTAyNXB4fS5mLWJlbiwuZi1iantiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTEwNjZweH0uZi1ibCwuZi1ibG17YmFja2dyb3VuZC1wb3NpdGlvbjowIC0xMTA3cHh9LmYtYm0sLmYtYm11e2JhY2tncm91bmQtcG9zaXRpb246MCAtMTE0OHB4fS5mLWJuLC5mLWJybntiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTExODlweH0uZi1ibywuZi1ib2x7YmFja2dyb3VuZC1wb3NpdGlvbjowIC0xMjMwcHh9LmYtYmVzLC5mLWJxe2JhY2tncm91bmQtcG9zaXRpb246MCAtMTI3MXB4fS5mLWJyLC5mLWJyYXtiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTEzMTJweH0uZi1iaHMsLmYtYnN7YmFja2dyb3VuZC1wb3NpdGlvbjowIC0xMzUzcHh9LmYtYnQsLmYtYnRue2JhY2tncm91bmQtcG9zaXRpb246MCAtMTM5NHB4fS5mLWJ2LC5mLWJ2dHtiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTE0MzVweH0uZi1idywuZi1id2F7YmFja2dyb3VuZC1wb3NpdGlvbjowIC0xNDc2cHh9LmYtYmxyLC5mLWJ5e2JhY2tncm91bmQtcG9zaXRpb246MCAtMTUxN3B4fS5mLWJseiwuZi1ientiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTE1NThweH0uZi1jYSwuZi1jYW57YmFja2dyb3VuZC1wb3NpdGlvbjowIC0xNTk5cHh9LmYtY2MsLmYtY2Nre2JhY2tncm91bmQtcG9zaXRpb246MCAtMTY0MHB4fS5mLWNkLC5mLWNvZHtiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTE2ODFweH0uZi1jYWYsLmYtY2Z7YmFja2dyb3VuZC1wb3NpdGlvbjowIC0xNzIycHh9LmYtY2csLmYtY29ne2JhY2tncm91bmQtcG9zaXRpb246MCAtMTc2M3B4fS5mLWNoLC5mLWNoZXtiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTE4MDRweH0uZi1jaSwuZi1jaXZ7YmFja2dyb3VuZC1wb3NpdGlvbjowIC0xODQ1cHh9LmYtY2ssLmYtY29re2JhY2tncm91bmQtcG9zaXRpb246MCAtMTg4NnB4fS5mLWNobCwuZi1jbHtiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTE5MjdweH0uZi1jbSwuZi1jbXJ7YmFja2dyb3VuZC1wb3NpdGlvbjowIC0xOTY4cHh9LmYtY2huLC5mLWNue2JhY2tncm91bmQtcG9zaXRpb246MCAtMjAwOXB4fS5mLWNvLC5mLWNvbHtiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTIwNTBweH0uZi1jciwuZi1jcml7YmFja2dyb3VuZC1wb3NpdGlvbjowIC0yMDkxcHh9LmYtY3UsLmYtY3Vie2JhY2tncm91bmQtcG9zaXRpb246MCAtMjEzMnB4fS5mLWNwdiwuZi1jdntiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTIxNzNweH0uZi1jdXcsLmYtY3d7YmFja2dyb3VuZC1wb3NpdGlvbjowIC0yMjE0cHh9LmYtY3gsLmYtY3hye2JhY2tncm91bmQtcG9zaXRpb246MCAtMjI1NXB4fS5mLWN5LC5mLWN5cHtiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTIyOTZweH0uZi1jeiwuZi1jemV7YmFja2dyb3VuZC1wb3NpdGlvbjowIC0yMzM3cHh9LmYtZGUsLmYtZGV1e2JhY2tncm91bmQtcG9zaXRpb246MCAtMjM3OHB4fS5mLWRqLC5mLWRqaXtiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTI0MTlweH0uZi1kaywuZi1kbmt7YmFja2dyb3VuZC1wb3NpdGlvbjowIC0yNDYwcHh9LmYtZG0sLmYtZG1he2JhY2tncm91bmQtcG9zaXRpb246MCAtMjUwMXB4fS5mLWRvLC5mLWRvbXtiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTI1NDJweH0uZi1keiwuZi1kemF7YmFja2dyb3VuZC1wb3NpdGlvbjowIC0yNTgzcHh9LmYtZWMsLmYtZWN1e2JhY2tncm91bmQtcG9zaXRpb246MCAtMjYyNHB4fS5mLWVlLC5mLWVzdHtiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTI2NjVweH0uZi1lZywuZi1lZ3l7YmFja2dyb3VuZC1wb3NpdGlvbjowIC0yNzA2cHh9LmYtZWgsLmYtZXNoe2JhY2tncm91bmQtcG9zaXRpb246MCAtMjc0N3B4fS5mLWVyLC5mLWVyaXtiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTI3ODhweH0uZi1lcy1jYXtiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTI4MjlweH0uZi1lcywuZi1lc3B7YmFja2dyb3VuZC1wb3NpdGlvbjowIC0yODcwcHh9LmYtZXQsLmYtZXRoe2JhY2tncm91bmQtcG9zaXRpb246MCAtMjkxMXB4fS5mLWV1e2JhY2tncm91bmQtcG9zaXRpb246MCAtMjk1MnB4fS5mLWZpLC5mLWZpbntiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTI5OTNweH0uZi1maiwuZi1maml7YmFja2dyb3VuZC1wb3NpdGlvbjowIC0zMDM0cHh9LmYtZmssLmYtZmxre2JhY2tncm91bmQtcG9zaXRpb246MCAtMzA3NXB4fS5mLWZtLC5mLWZzbXtiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTMxMTZweH0uZi1mbywuZi1mcm97YmFja2dyb3VuZC1wb3NpdGlvbjowIC0zMTU3cHh9LmYtZnIsLmYtZnJhe2JhY2tncm91bmQtcG9zaXRpb246MCAtMzE5OHB4fS5mLWdhLC5mLWdhYntiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTMyMzlweH0uZi1nYi1lbmd7YmFja2dyb3VuZC1wb3NpdGlvbjowIC0zMjgwcHh9LmYtZ2Itbmlye2JhY2tncm91bmQtcG9zaXRpb246MCAtMzMyMXB4fS5mLWdiLXNjdHtiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTMzNjJweH0uZi1nYi13bHN7YmFja2dyb3VuZC1wb3NpdGlvbjowIC0zNDAzcHh9LmYtZ2IsLmYtZ2Jye2JhY2tncm91bmQtcG9zaXRpb246MCAtMzQ0NHB4fS5mLWdkLC5mLWdyZHtiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTM0ODVweH0uZi1nZSwuZi1nZW97YmFja2dyb3VuZC1wb3NpdGlvbjowIC0zNTI2cHh9LmYtZ2YsLmYtZ3Vme2JhY2tncm91bmQtcG9zaXRpb246MCAtMzU2N3B4fS5mLWdnLC5mLWdneXtiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTM2MDhweH0uZi1naCwuZi1naGF7YmFja2dyb3VuZC1wb3NpdGlvbjowIC0zNjQ5cHh9LmYtZ2ksLmYtZ2lie2JhY2tncm91bmQtcG9zaXRpb246MCAtMzY5MHB4fS5mLWdsLC5mLWdybHtiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTM3MzFweH0uZi1nbSwuZi1nbWJ7YmFja2dyb3VuZC1wb3NpdGlvbjowIC0zNzcycHh9LmYtZ2luLC5mLWdue2JhY2tncm91bmQtcG9zaXRpb246MCAtMzgxM3B4fS5mLWdscCwuZi1ncHtiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTM4NTRweH0uZi1nbnEsLmYtZ3F7YmFja2dyb3VuZC1wb3NpdGlvbjowIC0zODk1cHh9LmYtZ3IsLmYtZ3Jje2JhY2tncm91bmQtcG9zaXRpb246MCAtMzkzNnB4fS5mLWdzLC5mLXNnc3tiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTM5NzdweH0uZi1ndCwuZi1ndG17YmFja2dyb3VuZC1wb3NpdGlvbjowIC00MDE4cHh9LmYtZ3UsLmYtZ3Vte2JhY2tncm91bmQtcG9zaXRpb246MCAtNDA1OXB4fS5mLWduYiwuZi1nd3tiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTQxMDBweH0uZi1ndXksLmYtZ3l7YmFja2dyb3VuZC1wb3NpdGlvbjowIC00MTQxcHh9LmYtaGssLmYtaGtne2JhY2tncm91bmQtcG9zaXRpb246MCAtNDE4MnB4fS5mLWhtLC5mLWhtZHtiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTQyMjNweH0uZi1obiwuZi1obmR7YmFja2dyb3VuZC1wb3NpdGlvbjowIC00MjY0cHh9LmYtaHIsLmYtaHJ2e2JhY2tncm91bmQtcG9zaXRpb246MCAtNDMwNXB4fS5mLWh0LC5mLWh0aXtiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTQzNDZweH0uZi1odSwuZi1odW57YmFja2dyb3VuZC1wb3NpdGlvbjowIC00Mzg3cHh9LmYtaWQsLmYtaWRue2JhY2tncm91bmQtcG9zaXRpb246MCAtNDQyOHB4fS5mLWllLC5mLWlybHtiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTQ0NjlweH0uZi1pbCwuZi1pc3J7YmFja2dyb3VuZC1wb3NpdGlvbjowIC00NTEwcHh9LmYtaW0sLmYtaW1ue2JhY2tncm91bmQtcG9zaXRpb246MCAtNDU1MXB4fS5mLWluLC5mLWluZHtiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTQ1OTJweH0uZi1pbywuZi1pb3R7YmFja2dyb3VuZC1wb3NpdGlvbjowIC00NjMzcHh9LmYtaXEsLmYtaXJxe2JhY2tncm91bmQtcG9zaXRpb246MCAtNDY3NHB4fS5mLWlyLC5mLWlybntiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTQ3MTVweH0uZi1pcywuZi1pc2x7YmFja2dyb3VuZC1wb3NpdGlvbjowIC00NzU2cHh9LmYtaXQsLmYtaXRhe2JhY2tncm91bmQtcG9zaXRpb246MCAtNDc5N3B4fS5mLWplLC5mLWpleXtiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTQ4MzhweH0uZi1qYW0sLmYtam17YmFja2dyb3VuZC1wb3NpdGlvbjowIC00ODc5cHh9LmYtam8sLmYtam9ye2JhY2tncm91bmQtcG9zaXRpb246MCAtNDkyMHB4fS5mLWpwLC5mLWpwbntiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTQ5NjFweH0uZi1rZSwuZi1rZW57YmFja2dyb3VuZC1wb3NpdGlvbjowIC01MDAycHh9LmYta2csLmYta2d6e2JhY2tncm91bmQtcG9zaXRpb246MCAtNTA0M3B4fS5mLWtoLC5mLWtobXtiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTUwODRweH0uZi1raSwuZi1raXJ7YmFja2dyb3VuZC1wb3NpdGlvbjowIC01MTI1cHh9LmYtY29tLC5mLWtte2JhY2tncm91bmQtcG9zaXRpb246MCAtNTE2NnB4fS5mLWtuLC5mLWtuYXtiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTUyMDdweH0uZi1rcCwuZi1wcmt7YmFja2dyb3VuZC1wb3NpdGlvbjowIC01MjQ4cHh9LmYta29yLC5mLWtye2JhY2tncm91bmQtcG9zaXRpb246MCAtNTI4OXB4fS5mLWt3LC5mLWt3dHtiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTUzMzBweH0uZi1jeW0sLmYta3l7YmFja2dyb3VuZC1wb3NpdGlvbjowIC01MzcxcHh9LmYta2F6LC5mLWt6e2JhY2tncm91bmQtcG9zaXRpb246MCAtNTQxMnB4fS5mLWxhLC5mLWxhb3tiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTU0NTNweH0uZi1sYiwuZi1sYm57YmFja2dyb3VuZC1wb3NpdGlvbjowIC01NDk0cHh9LmYtbGMsLmYtbGNhe2JhY2tncm91bmQtcG9zaXRpb246MCAtNTUzNXB4fS5mLWxpLC5mLWxpZXtiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTU1NzZweH0uZi1saywuZi1sa2F7YmFja2dyb3VuZC1wb3NpdGlvbjowIC01NjE3cHh9LmYtbGJyLC5mLWxye2JhY2tncm91bmQtcG9zaXRpb246MCAtNTY1OHB4fS5mLWxzLC5mLWxzb3tiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTU2OTlweH0uZi1sdCwuZi1sdHV7YmFja2dyb3VuZC1wb3NpdGlvbjowIC01NzQwcHh9LmYtbHUsLmYtbHV4e2JhY2tncm91bmQtcG9zaXRpb246MCAtNTc4MXB4fS5mLWx2LC5mLWx2YXtiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTU4MjJweH0uZi1sYnksLmYtbHl7YmFja2dyb3VuZC1wb3NpdGlvbjowIC01ODYzcHh9LmYtbWEsLmYtbWFye2JhY2tncm91bmQtcG9zaXRpb246MCAtNTkwNHB4fS5mLW1jLC5mLW1jb3tiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTU5NDVweH0uZi1tZCwuZi1tZGF7YmFja2dyb3VuZC1wb3NpdGlvbjowIC01OTg2cHh9LmYtbWUsLmYtbW5le2JhY2tncm91bmQtcG9zaXRpb246MCAtNjAyN3B4fS5mLW1hZiwuZi1tZntiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTYwNjhweH0uZi1tZGcsLmYtbWd7YmFja2dyb3VuZC1wb3NpdGlvbjowIC02MTA5cHh9LmYtbWgsLmYtbWhse2JhY2tncm91bmQtcG9zaXRpb246MCAtNjE1MHB4fS5mLW1rLC5mLW1rZHtiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTYxOTFweH0uZi1tbCwuZi1tbGl7YmFja2dyb3VuZC1wb3NpdGlvbjowIC02MjMycHh9LmYtbW0sLmYtbW1ye2JhY2tncm91bmQtcG9zaXRpb246MCAtNjI3M3B4fS5mLW1uLC5mLW1uZ3tiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTYzMTRweH0uZi1tYWMsLmYtbW97YmFja2dyb3VuZC1wb3NpdGlvbjowIC02MzU1cHh9LmYtbW5wLC5mLW1we2JhY2tncm91bmQtcG9zaXRpb246MCAtNjM5NnB4fS5mLW1xLC5mLW10cXtiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTY0MzdweH0uZi1tciwuZi1tcnR7YmFja2dyb3VuZC1wb3NpdGlvbjowIC02NDc4cHh9LmYtbXMsLmYtbXNye2JhY2tncm91bmQtcG9zaXRpb246MCAtNjUxOXB4fS5mLW1sdCwuZi1tdHtiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTY1NjBweH0uZi1tdSwuZi1tdXN7YmFja2dyb3VuZC1wb3NpdGlvbjowIC02NjAxcHh9LmYtbWR2LC5mLW12e2JhY2tncm91bmQtcG9zaXRpb246MCAtNjY0MnB4fS5mLW13LC5mLW13aXtiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTY2ODNweH0uZi1tZXgsLmYtbXh7YmFja2dyb3VuZC1wb3NpdGlvbjowIC02NzI0cHh9LmYtbXksLmYtbXlze2JhY2tncm91bmQtcG9zaXRpb246MCAtNjc2NXB4fS5mLW1veiwuZi1tentiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTY4MDZweH0uZi1uYSwuZi1uYW17YmFja2dyb3VuZC1wb3NpdGlvbjowIC02ODQ3cHh9LmYtbmMsLmYtbmNse2JhY2tncm91bmQtcG9zaXRpb246MCAtNjg4OHB4fS5mLW5lLC5mLW5lcntiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTY5MjlweH0uZi1uZiwuZi1uZmt7YmFja2dyb3VuZC1wb3NpdGlvbjowIC02OTcwcHh9LmYtbmcsLmYtbmdhe2JhY2tncm91bmQtcG9zaXRpb246MCAtNzAxMXB4fS5mLW5pLC5mLW5pY3tiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTcwNTJweH0uZi1ubCwuZi1ubGR7YmFja2dyb3VuZC1wb3NpdGlvbjowIC03MDkzcHh9LmYtbm8sLmYtbm9ye2JhY2tncm91bmQtcG9zaXRpb246MCAtNzEzNHB4fS5mLW5wLC5mLW5wbHtiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTcxNzVweH0uZi1uciwuZi1ucnV7YmFja2dyb3VuZC1wb3NpdGlvbjowIC03MjE2cHh9LmYtbml1LC5mLW51e2JhY2tncm91bmQtcG9zaXRpb246MCAtNzI1N3B4fS5mLW56LC5mLW56bHtiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTcyOThweH0uZi1vbSwuZi1vbW57YmFja2dyb3VuZC1wb3NpdGlvbjowIC03MzM5cHh9LmYtcGEsLmYtcGFue2JhY2tncm91bmQtcG9zaXRpb246MCAtNzM4MHB4fS5mLXBlLC5mLXBlcntiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTc0MjFweH0uZi1wZiwuZi1weWZ7YmFja2dyb3VuZC1wb3NpdGlvbjowIC03NDYycHh9LmYtcGcsLmYtcG5ne2JhY2tncm91bmQtcG9zaXRpb246MCAtNzUwM3B4fS5mLXBoLC5mLXBobHtiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTc1NDRweH0uZi1wYWssLmYtcGt7YmFja2dyb3VuZC1wb3NpdGlvbjowIC03NTg1cHh9LmYtcGwsLmYtcG9se2JhY2tncm91bmQtcG9zaXRpb246MCAtNzYyNnB4fS5mLXBtLC5mLXNwbXtiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTc2NjdweH0uZi1wY24sLmYtcG57YmFja2dyb3VuZC1wb3NpdGlvbjowIC03NzA4cHh9LmYtcHIsLmYtcHJpe2JhY2tncm91bmQtcG9zaXRpb246MCAtNzc0OXB4fS5mLXBzLC5mLXBzZXtiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTc3OTBweH0uZi1wcnQsLmYtcHR7YmFja2dyb3VuZC1wb3NpdGlvbjowIC03ODMxcHh9LmYtcGx3LC5mLXB3e2JhY2tncm91bmQtcG9zaXRpb246MCAtNzg3MnB4fS5mLXByeSwuZi1weXtiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTc5MTNweH0uZi1xYSwuZi1xYXR7YmFja2dyb3VuZC1wb3NpdGlvbjowIC03OTU0cHh9LmYtcmUsLmYtcmV1e2JhY2tncm91bmQtcG9zaXRpb246MCAtNzk5NXB4fS5mLXJvLC5mLXJvdXtiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTgwMzZweH0uZi1ycywuZi1zcmJ7YmFja2dyb3VuZC1wb3NpdGlvbjowIC04MDc3cHh9LmYtcnUsLmYtcnVze2JhY2tncm91bmQtcG9zaXRpb246MCAtODExOHB4fS5mLXJ3LC5mLXJ3YXtiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTgxNTlweH0uZi1zYSwuZi1zYXV7YmFja2dyb3VuZC1wb3NpdGlvbjowIC04MjAwcHh9LmYtc2IsLmYtc2xie2JhY2tncm91bmQtcG9zaXRpb246MCAtODI0MXB4fS5mLXNjLC5mLXN5Y3tiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTgyODJweH0uZi1zZCwuZi1zZG57YmFja2dyb3VuZC1wb3NpdGlvbjowIC04MzIzcHh9LmYtc2UsLmYtc3dle2JhY2tncm91bmQtcG9zaXRpb246MCAtODM2NHB4fS5mLXNnLC5mLXNncHtiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTg0MDVweH0uZi1zaCwuZi1zaG57YmFja2dyb3VuZC1wb3NpdGlvbjowIC04NDQ2cHh9LmYtc2ksLmYtc3Zue2JhY2tncm91bmQtcG9zaXRpb246MCAtODQ4N3B4fS5mLXNqLC5mLXNqbXtiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTg1MjhweH0uZi1zaywuZi1zdmt7YmFja2dyb3VuZC1wb3NpdGlvbjowIC04NTY5cHh9LmYtc2wsLmYtc2xle2JhY2tncm91bmQtcG9zaXRpb246MCAtODYxMHB4fS5mLXNtLC5mLXNtcntiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTg2NTFweH0uZi1zZW4sLmYtc257YmFja2dyb3VuZC1wb3NpdGlvbjowIC04NjkycHh9LmYtc28sLmYtc29te2JhY2tncm91bmQtcG9zaXRpb246MCAtODczM3B4fS5mLXNyLC5mLXN1cntiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTg3NzRweH0uZi1zcywuZi1zc2R7YmFja2dyb3VuZC1wb3NpdGlvbjowIC04ODE1cHh9LmYtc3QsLmYtc3Rwe2JhY2tncm91bmQtcG9zaXRpb246MCAtODg1NnB4fS5mLXNsdiwuZi1zdntiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTg4OTdweH0uZi1zeCwuZi1zeG17YmFja2dyb3VuZC1wb3NpdGlvbjowIC04OTM4cHh9LmYtc3ksLmYtc3lye2JhY2tncm91bmQtcG9zaXRpb246MCAtODk3OXB4fS5mLXN3eiwuZi1zentiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTkwMjBweH0uZi10YywuZi10Y2F7YmFja2dyb3VuZC1wb3NpdGlvbjowIC05MDYxcHh9LmYtdGNkLC5mLXRke2JhY2tncm91bmQtcG9zaXRpb246MCAtOTEwMnB4fS5mLWF0ZiwuZi10ZntiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTkxNDNweH0uZi10ZywuZi10Z297YmFja2dyb3VuZC1wb3NpdGlvbjowIC05MTg0cHh9LmYtdGgsLmYtdGhhe2JhY2tncm91bmQtcG9zaXRpb246MCAtOTIyNXB4fS5mLXRqLC5mLXRqa3tiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTkyNjZweH0uZi10aywuZi10a2x7YmFja2dyb3VuZC1wb3NpdGlvbjowIC05MzA3cHh9LmYtdGwsLmYtdGxze2JhY2tncm91bmQtcG9zaXRpb246MCAtOTM0OHB4fS5mLXRrbSwuZi10bXtiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTkzODlweH0uZi10biwuZi10dW57YmFja2dyb3VuZC1wb3NpdGlvbjowIC05NDMwcHh9LmYtdG8sLmYtdG9ue2JhY2tncm91bmQtcG9zaXRpb246MCAtOTQ3MXB4fS5mLXRyLC5mLXR1cntiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTk1MTJweH0uZi10dCwuZi10dG97YmFja2dyb3VuZC1wb3NpdGlvbjowIC05NTUzcHh9LmYtdHV2LC5mLXR2e2JhY2tncm91bmQtcG9zaXRpb246MCAtOTU5NHB4fS5mLXR3LC5mLXR3bntiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTk2MzVweH0uZi10eiwuZi10emF7YmFja2dyb3VuZC1wb3NpdGlvbjowIC05Njc2cHh9LmYtdWEsLmYtdWtye2JhY2tncm91bmQtcG9zaXRpb246MCAtOTcxN3B4fS5mLXVnLC5mLXVnYXtiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTk3NThweH0uZi11bSwuZi11bWl7YmFja2dyb3VuZC1wb3NpdGlvbjowIC05Nzk5cHh9LmYtdW57YmFja2dyb3VuZC1wb3NpdGlvbjowIC05ODQwcHh9LmYtdXMsLmYtdXNhe2JhY2tncm91bmQtcG9zaXRpb246MCAtOTg4MXB4fS5mLXVyeSwuZi11eXtiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTk5MjJweH0uZi11eiwuZi11emJ7YmFja2dyb3VuZC1wb3NpdGlvbjowIC05OTYzcHh9LmYtdmEsLmYtdmF0e2JhY2tncm91bmQtcG9zaXRpb246MCAtMTAwMDRweH0uZi12YywuZi12Y3R7YmFja2dyb3VuZC1wb3NpdGlvbjowIC0xMDA0NXB4fS5mLXZlLC5mLXZlbntiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTEwMDg2cHh9LmYtdmcsLmYtdmdie2JhY2tncm91bmQtcG9zaXRpb246MCAtMTAxMjdweH0uZi12aSwuZi12aXJ7YmFja2dyb3VuZC1wb3NpdGlvbjowIC0xMDE2OHB4fS5mLXZuLC5mLXZubXtiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTEwMjA5cHh9LmYtdnUsLmYtdnV0e2JhY2tncm91bmQtcG9zaXRpb246MCAtMTAyNTBweH0uZi13ZiwuZi13bGZ7YmFja2dyb3VuZC1wb3NpdGlvbjowIC0xMDI5MXB4fS5mLXdzLC5mLXdzbXtiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTEwMzMycHh9LmYteGt7YmFja2dyb3VuZC1wb3NpdGlvbjowIC0xMDM3M3B4fS5mLXllLC5mLXllbXtiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTEwNDE0cHh9LmYtbXl0LC5mLXl0e2JhY2tncm91bmQtcG9zaXRpb246MCAtMTA0NTVweH0uZi16YSwuZi16YWZ7YmFja2dyb3VuZC1wb3NpdGlvbjowIC0xMDQ5NnB4fS5mLXptLC5mLXptYntiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTEwNTM3cHh9LmYtencsLmYtendle2JhY2tncm91bmQtcG9zaXRpb246MCAtMTA1NzhweH0uZi1zdSwuZi1zdW57YmFja2dyb3VuZC1wb3NpdGlvbjowIC0xMDYxOXB4fScpO3ZhciBBPXtuYW1lOlwiQ291bnRyeUZsYWdcIixwcm9wczp7Y291bnRyeTp7dHlwZTpTdHJpbmcscmVxdWlyZWQ6ITB9LHJvdW5kZWQ6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiExfSxzaXplOnt0eXBlOlN0cmluZyx2YWxpZGF0b3I6ZnVuY3Rpb24oQSl7cmV0dXJuXCJzbWFsbFwiPT09QXx8XCJub3JtYWxcIj09PUF8fFwiYmlnXCI9PT1BfSxkZWZhdWx0Olwibm9ybWFsXCJ9fSxjb21wdXRlZDp7ZmxhZ0ljb25DbGFzczpmdW5jdGlvbigpe3ZhciBBO3JldHVybihBPXt9KVtcImZsYWcgXCIrdGhpcy5mbGFnSWNvbkNvdW50cnldPSEwLEEucm91bmRlZD10aGlzLnJvdW5kZWQsQVt0aGlzLmZsYWdNYXJnaW5dPSEwLEF9LGZsYWdJY29uQ291bnRyeTpmdW5jdGlvbigpe3ZhciBBPXRoaXMuY291bnRyeS50b0xvd2VyQ2FzZSgpO3JldHVyblwiZi1cIisoQT1cImFkXCI9PT1BP1wiYW5kb3JyYVwiOkEpfSxmbGFnTWFyZ2luOmZ1bmN0aW9uKCl7c3dpdGNoKHRoaXMuc2l6ZSl7Y2FzZVwic21hbGxcIjpyZXR1cm5cInNtYWxsLWZsYWdcIjtjYXNlXCJub3JtYWxcIjpyZXR1cm5cIm5vcm1hbC1mbGFnXCI7Y2FzZVwiYmlnXCI6cmV0dXJuXCJiaWctZmxhZ1wiO2RlZmF1bHQ6cmV0dXJuXCJub3JtYWwtZmxhZ1wifX19fTt2YXIgbyxmPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBuYXZpZ2F0b3ImJi9tc2llIFs2LTldXFxcXGIvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpKTt2YXIgZz17fTt2YXIgbj1mdW5jdGlvbihBLG8sZixnLG4scixzLGEsaSxkKXtcImJvb2xlYW5cIiE9dHlwZW9mIHMmJihpPWEsYT1zLHM9ITEpO3ZhciB0LHU9XCJmdW5jdGlvblwiPT10eXBlb2YgZj9mLm9wdGlvbnM6ZjtpZihBJiZBLnJlbmRlciYmKHUucmVuZGVyPUEucmVuZGVyLHUuc3RhdGljUmVuZGVyRm5zPUEuc3RhdGljUmVuZGVyRm5zLHUuX2NvbXBpbGVkPSEwLG4mJih1LmZ1bmN0aW9uYWw9ITApKSxnJiYodS5fc2NvcGVJZD1nKSxyPyh0PWZ1bmN0aW9uKEEpeyhBPUF8fHRoaXMuJHZub2RlJiZ0aGlzLiR2bm9kZS5zc3JDb250ZXh0fHx0aGlzLnBhcmVudCYmdGhpcy5wYXJlbnQuJHZub2RlJiZ0aGlzLnBhcmVudC4kdm5vZGUuc3NyQ29udGV4dCl8fFwidW5kZWZpbmVkXCI9PXR5cGVvZiBfX1ZVRV9TU1JfQ09OVEVYVF9ffHwoQT1fX1ZVRV9TU1JfQ09OVEVYVF9fKSxvJiZvLmNhbGwodGhpcyxpKEEpKSxBJiZBLl9yZWdpc3RlcmVkQ29tcG9uZW50cyYmQS5fcmVnaXN0ZXJlZENvbXBvbmVudHMuYWRkKHIpfSx1Ll9zc3JSZWdpc3Rlcj10KTpvJiYodD1zP2Z1bmN0aW9uKEEpe28uY2FsbCh0aGlzLGQoQSx0aGlzLiRyb290LiRvcHRpb25zLnNoYWRvd1Jvb3QpKX06ZnVuY3Rpb24oQSl7by5jYWxsKHRoaXMsYShBKSl9KSx0KWlmKHUuZnVuY3Rpb25hbCl7dmFyIHc9dS5yZW5kZXI7dS5yZW5kZXI9ZnVuY3Rpb24oQSxvKXtyZXR1cm4gdC5jYWxsKG8pLHcoQSxvKX19ZWxzZXt2YXIgYj11LmJlZm9yZUNyZWF0ZTt1LmJlZm9yZUNyZWF0ZT1iP1tdLmNvbmNhdChiLHQpOlt0XX1yZXR1cm4gZn0oe3JlbmRlcjpmdW5jdGlvbigpe3ZhciBBPXRoaXMuJGNyZWF0ZUVsZW1lbnQsbz10aGlzLl9zZWxmLl9jfHxBO3JldHVybiB0aGlzLmNvdW50cnk/byhcInNwYW5cIix7Y2xhc3M6dGhpcy5mbGFnSWNvbkNsYXNzfSk6dGhpcy5fZSgpfSxzdGF0aWNSZW5kZXJGbnM6W119LGZ1bmN0aW9uKEEpe0EmJkEoXCJkYXRhLXYtMGJhODAzOTNfMFwiLHtzb3VyY2U6XCIuc21hbGwtZmxhZ1tkYXRhLXYtMGJhODAzOTNde21hcmdpbjotMTVweCAtMjIuNXB4O3RyYW5zZm9ybTpzY2FsZSguMjUpOy1tcy10cmFuc2Zvcm06c2NhbGUoLjI1KTstd2Via2l0LXRyYW5zZm9ybTpzY2FsZSguMjUpOy1tb3otdHJhbnNmb3JtOnNjYWxlKC4yNSl9Lm5vcm1hbC1mbGFnW2RhdGEtdi0wYmE4MDM5M117bWFyZ2luOi0xMHB4IC0xNXB4O3RyYW5zZm9ybTpzY2FsZSguNSk7LW1zLXRyYW5zZm9ybTpzY2FsZSguNSk7LXdlYmtpdC10cmFuc2Zvcm06c2NhbGUoLjUpOy1tb3otdHJhbnNmb3JtOnNjYWxlKC41KX0uYmlnLWZsYWdbZGF0YS12LTBiYTgwMzkzXXttYXJnaW46MH0uc21hbGwtZmxhZy5yb3VuZGVkW2RhdGEtdi0wYmE4MDM5M117LW1vei1ib3JkZXItcmFkaXVzOjE1cHg7Ym9yZGVyLXJhZGl1czoxNXB4fS5ub3JtYWwtZmxhZy5yb3VuZGVkW2RhdGEtdi0wYmE4MDM5M117LW1vei1ib3JkZXItcmFkaXVzOjEwcHg7Ym9yZGVyLXJhZGl1czoxMHB4fS5iaWctZmxhZy5yb3VuZGVkW2RhdGEtdi0wYmE4MDM5M117LW1vei1ib3JkZXItcmFkaXVzOjhweDtib3JkZXItcmFkaXVzOjhweH1cIixtYXA6dm9pZCAwLG1lZGlhOnZvaWQgMH0pfSxBLFwiZGF0YS12LTBiYTgwMzkzXCIsITEsdm9pZCAwLCExLGZ1bmN0aW9uKEEpe3JldHVybiBmdW5jdGlvbihBLG4pe3JldHVybiBmdW5jdGlvbihBLG4pe3ZhciByPWY/bi5tZWRpYXx8XCJkZWZhdWx0XCI6QSxzPWdbcl18fChnW3JdPXtpZHM6bmV3IFNldCxzdHlsZXM6W119KTtpZighcy5pZHMuaGFzKEEpKXtzLmlkcy5hZGQoQSk7dmFyIGE9bi5zb3VyY2U7aWYobi5tYXAmJihhKz1cIlxcbi8qIyBzb3VyY2VVUkw9XCIrbi5tYXAuc291cmNlc1swXStcIiAqL1wiLGErPVwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIitidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShuLm1hcCkpKSkrXCIgKi9cIikscy5lbGVtZW50fHwocy5lbGVtZW50PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKSxzLmVsZW1lbnQudHlwZT1cInRleHQvY3NzXCIsbi5tZWRpYSYmcy5lbGVtZW50LnNldEF0dHJpYnV0ZShcIm1lZGlhXCIsbi5tZWRpYSksdm9pZCAwPT09byYmKG89ZG9jdW1lbnQuaGVhZHx8ZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdKSxvLmFwcGVuZENoaWxkKHMuZWxlbWVudCkpLFwic3R5bGVTaGVldFwiaW4gcy5lbGVtZW50KXMuc3R5bGVzLnB1c2goYSkscy5lbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dD1zLnN0eWxlcy5maWx0ZXIoQm9vbGVhbikuam9pbihcIlxcblwiKTtlbHNle3ZhciBpPXMuaWRzLnNpemUtMSxkPWRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGEpLHQ9cy5lbGVtZW50LmNoaWxkTm9kZXM7dFtpXSYmcy5lbGVtZW50LnJlbW92ZUNoaWxkKHRbaV0pLHQubGVuZ3RoP3MuZWxlbWVudC5pbnNlcnRCZWZvcmUoZCx0W2ldKTpzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoZCl9fX0oQSxuKX19LHZvaWQgMCx2b2lkIDApO2Z1bmN0aW9uIHIoQSl7ci5pbnN0YWxsZWR8fChyLmluc3RhbGxlZD0hMCxBLmNvbXBvbmVudChcIkNvdW50cnlGbGFnXCIsbikpfXZhciBzPXtpbnN0YWxsOnJ9LGE9bnVsbDtcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P2E9d2luZG93LlZ1ZTpcInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsJiYoYT1nbG9iYWwuVnVlKSxhJiZhLnVzZShzKSxuLmluc3RhbGw9cjtleHBvcnQgZGVmYXVsdCBuO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/vue-country-flag/dist/country-flag.esm.js\n");

/***/ })

}]);